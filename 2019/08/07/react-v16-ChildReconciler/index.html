<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Microsoft YaHei, Verdana, sans-serif:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.que01.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"AL4M83H31B","apiKey":"d30226bc78f2b15b834d9fc9993e3c42","indexName":"hexo","hits":{"per_page":10}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"bounceDownIn","post_body":"bounceDownIn","coll_header":"slideLeftIn","sidebar":"fadeInUp"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这里是V16的ChildReconciler部分。上一篇只是草草略过了它，并没有完整清晰说明整个DOM树是如何通过Fiber链表结构构建完毕的。">
<meta property="og:type" content="article">
<meta property="og:title" content="react-v16-ChildReconciler">
<meta property="og:url" content="http://www.que01.top/2019/08/07/react-v16-ChildReconciler/index.html">
<meta property="og:site_name" content="Que&#39;s Blog">
<meta property="og:description" content="这里是V16的ChildReconciler部分。上一篇只是草草略过了它，并没有完整清晰说明整个DOM树是如何通过Fiber链表结构构建完毕的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.que01.top/2019/08/07/images/image-20190726144234693.png">
<meta property="article:published_time" content="2019-08-07T09:24:19.000Z">
<meta property="article:modified_time" content="2020-12-17T13:21:55.676Z">
<meta property="article:author" content="que01">
<meta property="article:tag" content="React ChildReconciler">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.que01.top/2019/08/07/images/image-20190726144234693.png">

<link rel="canonical" href="http://www.que01.top/2019/08/07/react-v16-ChildReconciler/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>react-v16-ChildReconciler | Que's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Que's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">WebFrontEnd Development</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.que01.top/2019/08/07/react-v16-ChildReconciler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="que01">
      <meta itemprop="description" content="自己的学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Que's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          react-v16-ChildReconciler
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-07 17:24:19" itemprop="dateCreated datePublished" datetime="2019-08-07T17:24:19+08:00">2019-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-17 21:21:55" itemprop="dateModified" datetime="2020-12-17T21:21:55+08:00">2020-12-17</time>
              </span>

          
            <span id="/2019/08/07/react-v16-ChildReconciler/" class="post-meta-item leancloud_visitors" data-flag-title="react-v16-ChildReconciler" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <div class="post-description">这里是V16的ChildReconciler部分。上一篇只是草草略过了它，并没有完整清晰说明整个DOM树是如何通过Fiber链表结构构建完毕的。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="初步整理"><a href="#初步整理" class="headerlink" title="初步整理"></a>初步整理</h1><p>这里还需要回顾一下，FiberNode遍历DOM树的数据结构和遍历基础。</p>
<p>遍历理论在上一篇v16-render里面有简略伪代码可以供参考。它依托FiberNode得三个属性：<code>child,return,sibling</code>来实现。如果对这个理论不了解必须回上一篇看看理论。</p>
<h1 id="链表构建"><a href="#链表构建" class="headerlink" title="链表构建"></a>链表构建</h1><p>这里链表的构建主要就是<code>child,return,sibling</code>三个属性的构建。</p>
<p>这个构建过程在<code>reconcileChildren</code>函数及其调用函数中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextChildren: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If this is a fresh new component that hasn&#x27;t been rendered yet, we</span></span><br><span class="line">    <span class="comment">// won&#x27;t update its child set by applying minimal side-effects. Instead,</span></span><br><span class="line">    <span class="comment">// we will add them all to the child before it gets rendered. That means</span></span><br><span class="line">    <span class="comment">// we can optimize this reconciliation pass by not tracking side-effects.</span></span><br><span class="line">    <span class="comment">// 如果是一个新鲜的没有渲染过多组件 我们不会通过最小side-effects更新它的child</span></span><br><span class="line">    <span class="comment">// 相反 我们会在渲染之前将它们全部添加到子节点</span></span><br><span class="line">    <span class="comment">// 这意味着不需要对side-effects进行跟踪 以优化这个reconciliation过程</span></span><br><span class="line">    workInProgress.child = mountChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这部分是更新相关</span></span><br><span class="line">    workInProgress.child = reconcileChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      current.child,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reconcileChildFibers = ChildReconciler(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mountChildFibers = ChildReconciler(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到不管如何，最终都会调用到ChildReconciler。两者区别是初始更新和Update的区别。</p>
<p>接下来是ChildReconciler函数代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildReconciler</span>(<span class="params">shouldTrackSideEffects</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isUnkeyedTopLevelFragment =</span><br><span class="line">      <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">      newChild !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;</span><br><span class="line">      newChild.key === <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">      newChild = newChild.props.children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle object types</span></span><br><span class="line">    <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSingleElement(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              expirationTime,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSinglePortal(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              expirationTime,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果child是字符串或者数字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理文本节点逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">      <span class="keyword">return</span> reconcileChildrenArray(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        newChild,</span><br><span class="line">        expirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getIteratorFn(newChild)) &#123;</span><br><span class="line">      <span class="keyword">return</span> reconcileChildrenIterator(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        newChild,</span><br><span class="line">        expirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">      throwOnInvalidObjectType(returnFiber, newChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; !isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">		<span class="comment">// newChild如果为空 做一些初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remaining cases are all treated as empty.</span></span><br><span class="line">    <span class="keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reconcileChildFibers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对应的大场景有两个:</p>
<ul>
<li>一个父节点有单一的子节点</li>
<li>一个父节点有多个子节点</li>
</ul>
<h3 id="单一子节点构建"><a href="#单一子节点构建" class="headerlink" title="单一子节点构建"></a>单一子节点构建</h3><p>这其中不管是那种情况，都必然会有child &amp; return的设置。我们来看看调用栈。</p>
<p>首先是常规的单一的子节点。此时面对的情况是:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">            <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">                reconcileSingleElement(</span><br><span class="line">                    returnFiber,</span><br><span class="line">                    currentFirstChild,</span><br><span class="line">                    newChild,</span><br><span class="line">                    expirationTime,</span><br><span class="line">                ),</span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">            <span class="comment">// PORTAL组件略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用栈</span></span><br><span class="line">placeSingleChild(reconcileSingleElement(args))</span><br><span class="line">-&gt;reconcileSingleElement(args)</span><br></pre></td></tr></table></figure>

<p>看看这个函数的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = element.key;</span><br><span class="line">  <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line">  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 初始化渲染这里可以不管</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">    <span class="keyword">const</span> created = createFiberFromFragment(</span><br><span class="line">      element.props.children,</span><br><span class="line">      returnFiber.mode,</span><br><span class="line">      expirationTime,</span><br><span class="line">      element.key,</span><br><span class="line">    );</span><br><span class="line">    created.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> created = createFiberFromElement(</span><br><span class="line">      element,</span><br><span class="line">      returnFiber.mode,</span><br><span class="line">      expirationTime,</span><br><span class="line">    );</span><br><span class="line">    created.ref = coerceRef(returnFiber, currentFirstChild, element);</span><br><span class="line">    created.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时配合这里的<code>created.return</code>赋值语句，整个具体场景里面的return和child就做好了配对。</p>
<h3 id="多节点配对"><a href="#多节点配对" class="headerlink" title="多节点配对"></a>多节点配对</h3><p>多节点配对的核心代码是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">    <span class="keyword">return</span> reconcileChildrenArray(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        newChild,</span><br><span class="line">        expirationTime,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看关联代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildrenArray</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChildren: <span class="built_in">Array</span>&lt;*&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> resultingFirstChild: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> previousNewFiber: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> oldFiber = currentFirstChild;</span><br><span class="line">    <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="comment">// Element Diff算法实现</span></span><br><span class="line">      <span class="comment">// 这里是更新相关的Diff算法 可以参考之前的旧文章 虽然实现变了 算法思想没变</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 标记批量删除 如果新的children.length === 0 就整个标记删除 和之前算法思路一致</span></span><br><span class="line">    <span class="keyword">if</span> (newIdx === newChildren.length) &#123;</span><br><span class="line">      <span class="comment">// We&#x27;ve reached the end of the new children. We can delete the rest.</span></span><br><span class="line">      deleteRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If we don&#x27;t have any more existing children we can choose a fast path</span></span><br><span class="line">      <span class="comment">// since the rest will all be insertions.</span></span><br><span class="line">      <span class="comment">// 遍历newChildren,缓存上一次的childrenItem，标记当前newFiber为它的sibling</span></span><br><span class="line">      <span class="comment">// 并将最上方的childrenItem缓存以便遍历后返回</span></span><br><span class="line">      <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> newFiber = createChild(</span><br><span class="line">          returnFiber,</span><br><span class="line">          newChildren[newIdx],</span><br><span class="line">          expirationTime,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!newFiber) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">          resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后方代码略 初始render只到上一个return就结束了</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>关键地方的构建这里都在注释里面有写了。</p>
<p>当children是数组，那么遍历，看时机将sibling绑定到下一个同级元素。结束后将firstChild返回。此时<code>workInProgress.child</code>就被绑定到了这个firstChild上了。</p>
<p>那么新的childrenItem上的return呢？它们在createChild里面被绑定好了。买个元素的return都指定到了workInProgress节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createChild</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Text nodes don&#x27;t have keys. If the previous node is implicitly keyed</span></span><br><span class="line">    <span class="comment">// we can continue to replace it without aborting even if it is not a text</span></span><br><span class="line">    <span class="comment">// node.</span></span><br><span class="line">    <span class="keyword">const</span> created = createFiberFromText(</span><br><span class="line">      <span class="string">&#x27;&#x27;</span> + newChild,</span><br><span class="line">      returnFiber.mode,</span><br><span class="line">      expirationTime,</span><br><span class="line">    );</span><br><span class="line">    created.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">      <span class="keyword">case</span> REACT_ELEMENT_TYPE: &#123;</span><br><span class="line">        <span class="keyword">const</span> created = createFiberFromElement(</span><br><span class="line">          newChild,</span><br><span class="line">          returnFiber.mode,</span><br><span class="line">          expirationTime,</span><br><span class="line">        );</span><br><span class="line">        created.ref = coerceRef(returnFiber, <span class="literal">null</span>, newChild);</span><br><span class="line">        created.return = returnFiber;</span><br><span class="line">        <span class="keyword">return</span> created;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> REACT_PORTAL_TYPE: &#123;</span><br><span class="line">        <span class="keyword">const</span> created = createFiberFromPortal(</span><br><span class="line">          newChild,</span><br><span class="line">          returnFiber.mode,</span><br><span class="line">          expirationTime,</span><br><span class="line">        );</span><br><span class="line">        created.return = returnFiber;</span><br><span class="line">        <span class="keyword">return</span> created;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArray(newChild) || getIteratorFn(newChild)) &#123;</span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromFragment(</span><br><span class="line">        newChild,</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        expirationTime,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">      );</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throwOnInvalidObjectType(returnFiber, newChild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分支有点多，但是只需要关注return的赋值即可。</p>
<h3 id="递归-amp-串联"><a href="#递归-amp-串联" class="headerlink" title="递归&amp;串联"></a>递归&amp;串联</h3><p>我们就仅有两层的树进行了分析。那么我们如何将多个层级递归串联起来，让它们一直从顶部走到终点呢？答案当然是workLoop!</p>
<p>如果对workLoop还有陌生感觉，那么不妨重新区看看。workLoop循环结束的唯一条件是FiberNode.child===null。只要child不为null，他会按照算法涉及一路next或者child遍历下去。</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>到这里，我们的链表构建就结束了。我们清晰的看到了，这个链表是如何完整架构的。但是这里还是不太够，我们对current和workInProgress树的流程还缺乏一个整体认知。</p>
<h1 id="Fiber里面的树"><a href="#Fiber里面的树" class="headerlink" title="Fiber里面的树"></a>Fiber里面的树</h1><h2 id="workInProgress树"><a href="#workInProgress树" class="headerlink" title="workInProgress树"></a>workInProgress树</h2><p>这棵树是有迹可循的。</p>
<p>实质上，构建workInProgress树其实就是链表构建的更深入的探究。它和上一节其实密不可分。</p>
<p>换句话说，上一节其实也只是构建workInProgress过程之一。所以，两部分参考着看是很有意义的。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>第一个创建是在renderRoot函数里面:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">nextUnitOfWork = createWorkInProgress(</span><br><span class="line">    nextRoot.current,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    nextRenderExpirationTime,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createWorkInProgress</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> workInProgress = current.alternate;</span><br><span class="line">  <span class="keyword">if</span> (workInProgress === <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgress = createFiber(</span><br><span class="line">      current.tag,</span><br><span class="line">      pendingProps,</span><br><span class="line">      current.key,</span><br><span class="line">      current.mode,</span><br><span class="line">    );</span><br><span class="line">    workInProgress.elementType = current.elementType;</span><br><span class="line">    workInProgress.type = current.type;</span><br><span class="line">    workInProgress.stateNode = current.stateNode;</span><br><span class="line"></span><br><span class="line">    current.alternate = workInProgress;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 更新分支 略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  workInProgress.childExpirationTime = current.childExpirationTime;</span><br><span class="line">  workInProgress.expirationTime = current.expirationTime;</span><br><span class="line"></span><br><span class="line">  workInProgress.child = current.child;</span><br><span class="line">  workInProgress.memoizedProps = current.memoizedProps;</span><br><span class="line">  workInProgress.memoizedState = current.memoizedState;</span><br><span class="line">  workInProgress.updateQueue = current.updateQueue;</span><br><span class="line">  workInProgress.contextDependencies = current.contextDependencies;</span><br><span class="line"></span><br><span class="line">  workInProgress.sibling = current.sibling;</span><br><span class="line">  workInProgress.index = current.index;</span><br><span class="line">  workInProgress.ref = current.ref;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer) &#123;</span><br><span class="line">    workInProgress.selfBaseDuration = current.selfBaseDuration;</span><br><span class="line">    workInProgress.treeBaseDuration = current.treeBaseDuration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workInProgress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个源头我们穷根究底一下。</p>
<ul>
<li><p>ReactDom.render(App, container)首先获取到的root是一个App经过createElement函数返回的结果。举个栗子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    $$typeof: <span class="built_in">Symbol</span>(react.element)</span><br><span class="line">    key: <span class="literal">null</span></span><br><span class="line">    props: &#123;&#125;</span><br><span class="line">    ref: <span class="literal">null</span></span><br><span class="line">    type: ƒ App()</span><br><span class="line">    _owner: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后续引用到的ReactRoot构造器根据给出的container元素构造了一个Fiber节点。这事所有Fiber节点的root。前面提到的nextRoot也是它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var root &#x3D; createContainer(container, isConcurrent, hydrate);</span><br><span class="line">this._internalRoot &#x3D; root;</span><br></pre></td></tr></table></figure>

<p>这个createContainer设置了current，current由createHostRootFiber函数创建了一个FiberNode，除了tag==3之外和空的FiberNode没有什么区别</p>
</li>
<li><p>createWorkInProgress环节。</p>
<p>此时，<code>workInProgress.alternate = current.alternate = current = createHostRootFiber()</code>基本都是空Fiber，只不过设置了tag===3。</p>
</li>
</ul>
<h3 id="初始化render里的变更"><a href="#初始化render里的变更" class="headerlink" title="初始化render里的变更"></a>初始化render里的变更</h3><p>接下是workLoop+performUnitOfWork了。performUnitOfWork引用了beginWork。</p>
<h4 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h4><p>当根节点进入这个beginWork分支。触发<code>return updateHostRoot(current, workInProgress, renderExpirationTime)</code>，也就是nextUnitOfWork变量初始化后第一次获得返回值。</p>
<p>这个函数中有这样一个调用栈:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostRoot</span>(<span class="params">current, workInProgress, renderExpirationTime</span>) </span>&#123;</span><br><span class="line">  pushHostRootContext(workInProgress);</span><br><span class="line">  <span class="keyword">const</span> updateQueue = workInProgress.updateQueue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">const</span> prevState = workInProgress.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> prevChildren = prevState !== <span class="literal">null</span> ? prevState.element : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// processUpdateQueue这个函数非常重要 它可能是将FiberNode树和ReactElement联系起来的核心入口</span></span><br><span class="line">  processUpdateQueue(</span><br><span class="line">    workInProgress,</span><br><span class="line">    updateQueue,</span><br><span class="line">    nextProps,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> nextState = workInProgress.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> nextChildren = nextState.element;</span><br><span class="line">  <span class="keyword">if</span> (nextChildren === prevChildren) &#123;</span><br><span class="line">    <span class="comment">// If the state is the same as before, that&#x27;s a bailout because we had no work that expires at this time.</span></span><br><span class="line">    <span class="comment">// 如果状态与以前相同 那就是救助 因为我们此时没有工作到期。</span></span><br><span class="line">    resetHydrationState();</span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> root: FiberRoot = workInProgress.stateNode;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (current === <span class="literal">null</span> || current.child === <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">    root.hydrate &amp;&amp;</span><br><span class="line">    enterHydrationState(workInProgress)</span><br><span class="line">  ) &#123;</span><br><span class="line">    workInProgress.effectTag |= Placement;</span><br><span class="line"></span><br><span class="line">    workInProgress.child = mountChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reconcileChildren(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">    resetHydrationState();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里processcessUpdateQueue函数在上一篇render里面有相对详细的解读。这里关注点是内部引用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resultState = getStateFromUpdate(</span><br><span class="line">    workInProgress,</span><br><span class="line">    queue,</span><br><span class="line">    update,</span><br><span class="line">    resultState,</span><br><span class="line">    props,</span><br><span class="line">    instance,</span><br><span class="line">);</span><br><span class="line">workInProgress.memoizedState = resultState;</span><br></pre></td></tr></table></figure>

<p>这里getStateFromUpdate函数为空白的workInProgress注入了props数据。它更新了workInProgress.memoizedState，就这里而言，它将<code>&#123;element: reactElement&#125;</code>的数据结构赋值过去了。</p>
<p>关于这个变量，参考scheduleRootUpdate函数里面的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> update = createUpdate(expirationTime);</span><br><span class="line">update.payload = &#123;element&#125;;</span><br></pre></td></tr></table></figure>
<p>让我们把关注点继续返回updateHostRoot函数，此时这个函数结束之后，正常情况会进入以下分支:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">reconcileChildren(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    nextChildren,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">);</span><br><span class="line">resetHydrationState();</span><br><span class="line"><span class="keyword">return</span> workInProgress.child;</span><br></pre></td></tr></table></figure>

<p>因为返回的是workInProgress.child，所以这里重点关注一下reconcileChildren对workInProgress.child的处理。这里可以重新返回之前的「链表构建」来看。</p>
<h4 id="子孙节点"><a href="#子孙节点" class="headerlink" title="子孙节点"></a>子孙节点</h4><p>结合我们到链表构建这一小节。到此为止，我们可以做出这样的论断:</p>
<p>nextUnitOfWork实质上就是当前遍历过程中要处理的节点，通过我们的workLoop遍历，当这个工作到最终节点的时候，我们就完成了整个workProgeress树的构建。</p>
<p>不过这里稍微往下走走，当我们FiberRoot处理完毕，<strong>beginWork第二次运行时候应该是怎样的场景呢</strong>？此时返回的第二个FiberNode节点就是App组件对应的节点。这里关注点核心属性:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    effectTag: <span class="number">2</span></span><br><span class="line">	elementType: ƒ App()</span><br><span class="line">    type: ƒ App()</span><br><span class="line">    <span class="keyword">return</span>: FiberRoot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时走到beginWork.就会进入如下分支:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IndeterminateComponent: &#123;</span><br><span class="line">    <span class="keyword">const</span> elementType = workInProgress.elementType;</span><br><span class="line">    <span class="keyword">return</span> mountIndeterminateComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        elementType,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountIndeterminateComponent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此时核心调用如下 省略多数无关代码</span></span><br><span class="line">    <span class="comment">// 它返回了一个ReactElement,这是一颗完整的VDOM树，下级已经全部展开为ReactElement</span></span><br><span class="line">    <span class="comment">// 就常规ClassComponent初始render，它相当于return Component(props, refOrContext)</span></span><br><span class="line">    value = renderWithHooks( </span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      props,</span><br><span class="line">      context,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">    reconcileChildren(<span class="literal">null</span>, workInProgress, value, renderExpirationTime);</span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是reconcileChildren。关于这个函数可以看看上面提过的「单一子节点构建」部分。总之这里对workProgress有一些修改。最后它将child设为了下面分支返回值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> created = createFiberFromFragment(</span><br><span class="line">    element.props.children,</span><br><span class="line">    returnFiber.mode,</span><br><span class="line">    expirationTime,</span><br><span class="line">    element.key,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>最后就是返回了FiberNode。这个FiberNode根据参数设定了以下非null值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pendingProps: children 完整VDOM树</span><br><span class="line">tag: Fragment = <span class="number">7</span></span><br><span class="line">expirationTime: expirationTime</span><br><span class="line">key: element.key</span><br><span class="line">mode: returnFiber.mode</span><br></pre></td></tr></table></figure>

<p>这里贯彻一个重点，那就是这个FiberNode是下一个nextUnitOfWork变量，如果对这个概念不熟，那么上一篇需要回看一下。总之，这里脉络是reconcileChildren函数为当前FiberNode构建了child值并返回这个child。</p>
<p>这个child上的pendingProps是workLoop能够持续加下去的核心所在。假设一下，当App里面内容是这样的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;header className=<span class="string">&quot;App-header&quot;</span>&gt;</span><br><span class="line">        &lt;div&gt;Test&lt;/div&gt;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>beginWork这里分支判断主要靠fiberNode.tag判断。我们这里思考一下。这个App构建下来，会有多少个FiberNode, tag分别是？</p>
<p>答案是: 这里一共会有五个FiberNode, 组成一个workProgress链表树。对应的tag只分别是3、2、5、5、5。换成Enum值，那就是: HostRoot、IndeterminateComponent、HostComponent、HostComponent、HostComponent。很显然，ReactDomComponent都被设置为tag=HostComponent了。</p>
<p>那么问题来了，这里需要将tag和children(ReactElement)联结起来。这里是通过一系列的createFiberFromXXX函数做到的(FiberRoot除外)。而具体采用哪个函数，则取决于ReactElement.type。这里常规(ReactDomComponent)是使用createFiberFromElement函数。</p>
<p>就常规来说，如果<code>type === REACT_FRAGMENT_TYPE</code>则使用<code>createFiberFromFragment</code>,否则使用<code>createFiberFromElement</code>，后者是常规情况。</p>
<p>搞明白前面这些，现在我们可以认认真真看看，children是怎样一路层层拆包，只到遍历完毕为止的。这事workLoop和VDOM的关联脉络所在。</p>
<p>认真观察createFiberFromElement</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFiberFromElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> owner = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> type = element.type;</span><br><span class="line">  <span class="keyword">const</span> key = element.key;</span><br><span class="line">  <span class="keyword">const</span> pendingProps = element.props; <span class="comment">// 关注点1</span></span><br><span class="line">  <span class="keyword">const</span> fiber = createFiberFromTypeAndProps(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    pendingProps,</span><br><span class="line">    owner,</span><br><span class="line">    mode,</span><br><span class="line">    expirationTime,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> fiber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里补充updateHostComponent函数简略代码以加深了解</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">current, workInProgress, renderExpirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nextChildren = nextProps.children; <span class="comment">// 关注点2</span></span><br><span class="line">  reconcileChildren(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里我们通过这个函数里面这一句<code>const pendingProps = element.props</code>将整个VDOM树层层解包。最终完成了整个FiberNode树的构建&amp;链接。</p>
<p><strong>同时，VDOM和FiberNode的关系这里也有了清晰认知。</strong></p>
<h2 id="finishedWork树-amp-amp-current树"><a href="#finishedWork树-amp-amp-current树" class="headerlink" title="finishedWork树 &amp;&amp; current树"></a>finishedWork树 &amp;&amp; current树</h2><p>renderRoot函数在workLoop结束后有以下处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootWorkInProgress = root.current.alternate;</span><br><span class="line">onComplete(root, rootWorkInProgress, expirationTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onComplete</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  root.pendingCommitExpirationTime = expirationTime;</span><br><span class="line">  root.finishedWork = finishedWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>root.current.alternate</code>显然是<code>root.current</code>的一个副本。</p>
<p>关于这个root上下文逻辑。不妨在本文内搜索<code>workInProgress.alternate = current.alternate = current = createHostRootFiber()</code>看看。当renderRoot结束后，它的child指向了我们的App节点。最终的情况就是: 当初始化渲染render阶段完成后，finishedWork == current == FiberRoot。</p>
<p>就整个流程来说。React在初次完成后，都会拥有一个current树，它的内部数据对应到整个UI上。如果后续有更新rootWorkInProgress树会被重新构建。</p>
<h2 id="updateQueue树"><a href="#updateQueue树" class="headerlink" title="updateQueue树"></a>updateQueue树</h2><p>updateQueue也是一个链表，不过它和FiberNode不一样，只有next一个链接属性。</p>
<p>updateQueue的脉络还是得从render这里入手。回顾之前的render文章，看看调用栈。我们可以发现，初始render第一次处理它，是在scheduleRootUpdate函数中的<code>enqueueUpdate(current, update)</code>。</p>
<p>这里针对FiberRoot设置的updateQueue是一个初始值。里面的callback值来源于上级调用。它在ReactRoot.prototype.render函数中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> work = <span class="keyword">new</span> ReactWork();</span><br><span class="line">updateContainer(children, root, <span class="literal">null</span>, work._onCommit);</span><br></pre></td></tr></table></figure>

<p>配合processUpdateQueue函数，可以很容易知道fiberRoot上的初始updateQueue是一个callback设为work._onCommit的初始值。</p>
<h2 id="Side-Effect树"><a href="#Side-Effect树" class="headerlink" title="Side-Effect树"></a>Side-Effect树</h2><p>我们可以将 React 中的一个组件视为一个使用 state 和 props 来计算 UI 表示的函数。改变 DOM 或调用生命周期方法，被视为Side-Effect。</p>
<p>在v15版本中DOM树通过它的_owner属性是否为null来判断是否是一个自定义组件。它的更新纯粹是判断props是否有变更来处理后续生命周期&amp;渲染。v16这里则是在FiberNode上记录了一个nextEffect属性来标记下一个自定义组件——v16叫类组件，它里面有生命周期之类的Side-Effect操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enqueueSetState(inst, payload, callback) &#123;</span><br><span class="line">  &#x2F;&#x2F; 此时inst为App实例 payload&#x3D;&#123;text: &#39;Hello World&#39;&#125; callback&#x3D;undefined</span><br><span class="line">  const fiber &#x3D; getInstance(inst);</span><br><span class="line">  const currentTime &#x3D; requestCurrentTime();</span><br><span class="line">  const expirationTime &#x3D; computeExpirationForFiber(currentTime, fiber);</span><br><span class="line"></span><br><span class="line">  const update &#x3D; createUpdate(expirationTime);</span><br><span class="line">  update.payload &#x3D; payload;</span><br><span class="line">  if (callback !&#x3D;&#x3D; undefined &amp;&amp; callback !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    update.callback &#x3D; callback;</span><br><span class="line">  &#125;</span><br><span class="line">  flushPassiveEffects();</span><br><span class="line">  enqueueUpdate(fiber, update);</span><br><span class="line">  scheduleWork(fiber, expirationTime);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这里关系到update的实质上就是<code>enqueueUpdate(fiber, update)</code>，说白了，这里update主要还是设置一个expirationTime, fiber节点上的更新队列才是实质核心。</p>
<p>这里enqueueUpdate主要是调用appendUpdateToQueue。这个函数基本可以理解为向update数组push一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function appendUpdateToQueue(queue, update) &#123;</span><br><span class="line">    &#x2F;&#x2F; lastUpdate&#x3D;&#x3D;&#x3D;null说明之前是空的队列</span><br><span class="line">    if (queue.lastUpdate &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">        queue.firstUpdate &#x3D; queue.lastUpdate &#x3D; update;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 否则将update放到链表队列尾部</span><br><span class="line">        queue.lastUpdate.next &#x3D; update;</span><br><span class="line">        queue.lastUpdate &#x3D; update;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>仔细想想，在v15进行Diff阶段，实质上是进行Diff对比中的ComponentDiff环节。这个环节如果props变化不会直接生成新的替换下级所有旧的节点。这里换了链表，但是这个对比环节还是需要依据。这里想来就是nextEffect属性存在的意义了。它定位了所有ClassComponent方便进行ComponentDiff。</p>
<p>但是需要注意的是: 这个链表的顺序，它不是按层级做顺序链接的。而是基于我们的FiberNode遍历理论，在这个遍历过程中，遇到ClassComponent时候，按照先后顺序进行连接、遍历。这里偷懒偷个图。。。</p>
<p><strong>这里关于组件对比的想法仅作为猜想了，后面看Update环节时候再做确认。</strong>这里疑问是，当这个next不再以DOM层级作为依据，底部组件可能比上层组件更先遍历到，那么问题在于如果下级和上级同时变化了，如果下级先处理一些事情会不会造成浪费？</p>
<p>这里问题暂且留到Update环节分析。</p>
<p><img src="../images/image-20190726144234693.png" alt="image-20190726144234693"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/React-ChildReconciler/" rel="tag"># React ChildReconciler</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/08/07/react-v16-Update-renderPhase/" rel="prev" title="react-v16-Update renderPhase篇">
      <i class="fa fa-chevron-left"></i> react-v16-Update renderPhase篇
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/08/14/react-v16-Reconciler-Diff/" rel="next" title="react-v16-Reconciler和Diff算法">
      react-v16-Reconciler和Diff算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9D%E6%AD%A5%E6%95%B4%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">初步整理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E6%9E%84%E5%BB%BA"><span class="nav-number">2.</span> <span class="nav-text">链表构建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%80%E5%AD%90%E8%8A%82%E7%82%B9%E6%9E%84%E5%BB%BA"><span class="nav-number">2.0.1.</span> <span class="nav-text">单一子节点构建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%8A%82%E7%82%B9%E9%85%8D%E5%AF%B9"><span class="nav-number">2.0.2.</span> <span class="nav-text">多节点配对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92-amp-%E4%B8%B2%E8%81%94"><span class="nav-number">2.0.3.</span> <span class="nav-text">递归&amp;串联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="nav-number">2.0.4.</span> <span class="nav-text">小总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Fiber%E9%87%8C%E9%9D%A2%E7%9A%84%E6%A0%91"><span class="nav-number">3.</span> <span class="nav-text">Fiber里面的树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#workInProgress%E6%A0%91"><span class="nav-number">3.1.</span> <span class="nav-text">workInProgress树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA"><span class="nav-number">3.1.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96render%E9%87%8C%E7%9A%84%E5%8F%98%E6%9B%B4"><span class="nav-number">3.1.2.</span> <span class="nav-text">初始化render里的变更</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E8%8A%82%E7%82%B9"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">根节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E5%AD%99%E8%8A%82%E7%82%B9"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">子孙节点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#finishedWork%E6%A0%91-amp-amp-current%E6%A0%91"><span class="nav-number">3.2.</span> <span class="nav-text">finishedWork树 &amp;&amp; current树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#updateQueue%E6%A0%91"><span class="nav-number">3.3.</span> <span class="nav-text">updateQueue树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Side-Effect%E6%A0%91"><span class="nav-number">3.4.</span> <span class="nav-text">Side-Effect树</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">que01</p>
  <div class="site-description" itemprop="description">自己的学习记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">77</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">que01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"TXWIywcTsrMfVKtclog3CxDl-gzGzoHsz","app_key":"987dqIR4vvX2mQJjmAV86Qp0","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
