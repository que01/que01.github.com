<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>React笔记大纲导航</title>
    <url>/2019/06/17/react-table-of-react/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>这里主要是对前面一些文章进行一个归类、导航。<br>PS: 这些文章部分日期不准，跨度有些久,从18年到19年，而且时不时会有更新……在typora反复改来改去一直没上传，再传已经忘了具体哪天写的。<br>先传一部分。。。</p>
<h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><ul>
<li><a href="/2018/04/15/react-build/">React工程结构浅析</a></li>
</ul>
<h2 id="React源码分析-v15-6-2"><a href="#React源码分析-v15-6-2" class="headerlink" title="React源码分析(v15.6.2)"></a>React源码分析(v15.6.2)</h2><ul>
<li><a href="/2019/04/03/react-VirtualDom/">虚拟DOM</a></li>
<li><a href="/2018/04/20/react-render/">React render环节分析</a></li>
<li><a href="/2018/04/26/react-lifecycle/">React生命周期分析</a></li>
<li><a href="/2019/06/15/react-instantiateReactComponent/">instantiateReactComponent</a></li>
<li><a href="/2018/05/01/react-domComponent/">React ReactDOMComponent分析</a></li>
<li><a href="/2019/06/15/react-ReactCompositeComponent/">React ReactCompositeComponent分析</a></li>
<li><a href="/2019/06/28/react-ReactCurrentOwner/">ReactCurrentOwner:ReacCompositeComponent &amp; ReactDomComponent之间的胶水</a></li>
<li><a href="/2019/07/04/react-Reconciler/">React核心: ReactReconciler调度模块分析</a>(大幅更新by 2019.7.4)</li>
<li><a href="/2019/07/04/react-Reconciler/">ReactDOMComponentTree</a></li>
<li><a href="/2018/06/10/react-event/">React Event Part1</a>[更新by2019.7.1]</li>
<li><a href="/2019/07/10/react-Event-System-Design/">React Event Part2:React事件体系设计</a></li>
<li><a href="/2019/06/15/react-PooledClass/">React PooledClass</a></li>
<li><a href="/2019/06/15/react-ReactUpdates/">React更新 ReactUpdates</a></li>
<li><a href="/2019/06/25/react-diff/">React Diff算法</a></li>
<li><a href="/2019/06/15/react-Transaction/">React事务 Transaction</a></li>
</ul>
<h2 id="React源码分析-v16-8-6"><a href="#React源码分析-v16-8-6" class="headerlink" title="React源码分析(v16.8.6)"></a>React源码分析(v16.8.6)</h2><ul>
<li><a href="/2019/07/15/react-Fiber/">v16开篇 &amp;&amp; Fiber:新的数据结构</a></li>
<li><a href="/2019/08/07/react-v16-ChildReconciler/">v16 ChildReconciler 链表构建</a></li>
<li><a href="/2019/08/07/react-v16-render/">v16版本的render流程</a></li>
<li><a href="/2019/08/07/react-v16-Update-renderPhase/">v16版本的update流程 renderPhase篇</a></li>
<li><a href="/2019/08/07/react-v16-Update-commitPhase/">v16版本的update流程 commitPhase篇</a></li>
<li><a href="/2019/08/14/react-v16-Reconciler-Diff/">v16版本的Diff算法</a></li>
<li><a href="/2019/08/28/v16-Scheduling-in-React/">React的调度-v16</a></li>
</ul>
<h2 id="React17的部分分析-v17-0-2"><a href="#React17的部分分析-v17-0-2" class="headerlink" title="React17的部分分析(v17.0.2)"></a>React17的部分分析(v17.0.2)</h2><ul>
<li><a href="/2021/05/10/react-17-0-2/">大纲整理</a></li>
<li><a href="/2021/06/13/2021-6-13-react-17-0-2-hooks/">useState</a></li>
<li><a href="/2021/06/18/2021-6-18-react-17-0-2-hooks-useEffect/">useEffect</a></li>
</ul>
<h2 id="React生态"><a href="#React生态" class="headerlink" title="React生态"></a>React生态</h2><ul>
<li><a href="/2019/06/15/react-redux-saga/">React生态 react-redux|redux-saga</a></li>
<li><a href="/2019/06/15/react-route/">React生态 react-route</a></li>
</ul>
<h2 id="React项目"><a href="#React项目" class="headerlink" title="React项目"></a>React项目</h2><ul>
<li><a href="/2018/11/05/2018-11-5-typescript-redux-starter/">typescript在redux-react项目中的应用</a></li>
</ul>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react-17.0.2-hooks 之 useEffect</title>
    <url>/2021/06/18/2021-6-18-react-17-0-2-hooks-useEffect/</url>
    <content><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>这一篇主要是 useEffect的细节分析整理。因为 hooks 部分有点长也就分开了。关于 useState的部分可以看上一篇。这里入口函数的分析也在上一篇里面，如果有不明需要返回参考。</p>
<h1 id="useEffect-细节"><a href="#useEffect-细节" class="headerlink" title="useEffect 细节"></a>useEffect 细节</h1><p>在常见的hooks 函数里面useEffect使用频度和 useState 是不相上下的。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">export default () &#x3D;&gt; &#123;</span><br><span class="line">  const [text, setText] &#x3D; useState(&#39;hello&#39;);</span><br><span class="line">  </span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;Hello World&#39;);</span><br><span class="line">  &#125;, [text]); </span><br><span class="line">  </span><br><span class="line">  return &lt;div onClick&#x3D;&#123;() &#x3D;&gt; setText(&#39;Hello&#39;)&#125;&gt;click&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 以上是一个非常常见且典型的useEffect使用场景。</p>
<p>在这个使用例子中，useEffect 传入了一个函数作为第一个参数，传入一个state数组做为第二个参数。</p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>我们承袭前一片的分析，可以得知，当初次mount时候，useEffect 指向mountEffect函数，当 update 的时候，则指向updateEffect函数。</p>
<h3 id="mountEffect"><a href="#mountEffect" class="headerlink" title="mountEffect"></a>mountEffect</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: () =&gt; (() =&gt; <span class="keyword">void</span>) | <span class="keyword">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; enableDoubleInvokingEffects) &#123;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mountEffectImpl(</span><br><span class="line">      PassiveEffect | PassiveStaticEffect,</span><br><span class="line">      HookPassive,</span><br><span class="line">      create,</span><br><span class="line">      deps,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引用到的mountEffectImpl</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看出，在源码中，我们传入的函数称为 create，数组则称为 deps。</p>
<p>这里函数里面涉及到一些位运算的 flag,这里暂且略过对核心路径进行解读。</p>
<p>当这一路调用下来，通过mountWorkInProgressHook函数，它得到一个workInProgressHook，并在其memoizedState属性上挂载了一个新的空白Hook 实例。</p>
<p>接下来就是pushEffect函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushEffect</span>(<span class="params">tag, create, destroy, deps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effect: Effect = &#123;</span><br><span class="line">    tag,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    deps,</span><br><span class="line">    <span class="comment">// Circular</span></span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> componentUpdateQueue: <span class="literal">null</span> | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any);</span><br><span class="line">  <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    componentUpdateQueue = createFunctionComponentUpdateQueue();</span><br><span class="line">    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);</span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect;</span><br><span class="line">    <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">      lastEffect.next = effect;</span><br><span class="line">      effect.next = firstEffect;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果前面对 useState那篇还有印象的话，大致可以看到这里主要是对updateQueue属性的处理，而 useState 则主要是对queue属性的处理。</p>
<p>这里还是简述一下过程</p>
<ul>
<li>当 hook上updateQueue属性没有有效值时候，创建一个空 updateQueue，并将它的lastEffect属性设置为由之前传入的 create 和 deps 构成的 Effect 实例，这个 Effect 是一个循环链表，这里将首尾都链到它自己。</li>
<li>当有有效值时候将之前传入的 create 和 deps 构成的 Effect 实例，塞到firstEffect前面，并将它本身设为firstEffect。</li>
</ul>
<h3 id="updateEffect"><a href="#updateEffect" class="headerlink" title="updateEffect"></a>updateEffect</h3><p>这里看一下细节:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: () =&gt; (() =&gt; <span class="keyword">void</span>) | <span class="keyword">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> updateEffectImpl(PassiveEffect, HookPassive, create, deps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用的updateEffectImpl</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">let</span> destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevEffect = currentHook.memoizedState;</span><br><span class="line">    destroy = prevEffect.destroy;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.deps;</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        pushEffect(hookFlags, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里很显然就又回到了pushEffect，这里分支就是之前提到的</p>
<blockquote>
<p>当有有效值时候将之前传入的 create 和 deps 构成的 Effect 实例，塞到firstEffect前面，并将它本身设为firstEffect。</p>
</blockquote>
<p>这里处理的核心，归根结底，还是在于updateQueue属性。</p>
<p>PS: 当我写完这篇之后，自己再看一遍其实也还是感觉言之未尽。但是hooks这个机制呢，它本身说到底，其实还是针对函数组件中的各种状态进行一个临时的状态保存。</p>
<p>这里的保存，有闭包，也有直接的在属性上进行挂载。处理完毕这些之后在后续的更新里面对它进行读取、处理，并反馈到 View 上(说穿了其实有些兴味索然。。。)。</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>pushEffect函数处理了hook.updateQueue的赋值，并将生成的 effect 赋值给到hook.memoizedState。</p>
<p>这里没有像 useState 那里那样，还有过一次直接计算和直接触发更新。究其根本，useEffect 在 mount 之后，并不一定真的会执行这个 create 函数，他就像一个订阅器，当我们执行了 setXXX(‘new Val’)之后，通过对应的 setXXX开始更新流程，并在这个流程中对比 deps，并针对性的执行 create。</p>
<p>然而这个流程，就是更新层面的逻辑了。回头看看很久之前分析过的update 环节，实在有些怅然。</p>
<p><a href="/2019/08/07/react-v16-Update-renderPhase/">《react-v16-Update renderPhase篇》</a> </p>
<p><a href="/2019/08/07/react-v16-Update-commitPhase/">《react-v16-Update-commitPhase》</a></p>
<p>hooks 部分写到这里实在有些兴味索然，就这样做个收尾吧。这里的收获是，知道 fiber 节点上一些属性(updateQueue|memoizedState|pending之类)，是如何变化、反馈到View层面的。</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react-17.0.2-hooks 之 useState</title>
    <url>/2021/06/13/2021-6-13-react-17-0-2-hooks/</url>
    <content><![CDATA[<h1 id="全局状况"><a href="#全局状况" class="headerlink" title="全局状况"></a>全局状况</h1><p>这一篇其实是<a href="/2021/05/10/react-17-0-2/">react v17.0.2整体结构分析</a>的组成部分。太长就把它抽出来了。<br>以下实际上都是ReactHooks的组成部分。因为同属hooks范畴就单独归纳一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useCallback,</span><br><span class="line">useContext,</span><br><span class="line">useEffect,</span><br><span class="line">useImperativeHandle,</span><br><span class="line">useDebugValue,</span><br><span class="line">useLayoutEffect,</span><br><span class="line">useMemo,</span><br><span class="line">useMutableSource,</span><br><span class="line">useReducer,</span><br><span class="line">useRef,</span><br><span class="line">useState,</span><br></pre></td></tr></table></figure>

<p>关于这些useXXX系列的函数都在ReactHook.js里面。他们的结构几乎一模一样:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  initialState: (() =&gt; S) | S,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">BasicStateAction</span>&lt;<span class="title">S</span>&gt;&gt;] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// useCallback =&gt; dispatcher.useCallback(arguments);</span></span><br><span class="line"><span class="comment">// useContext =&gt; dispatcher.useContext(arguments);</span></span><br><span class="line"><span class="comment">// useEffect =&gt; dispatcher.useEffect(arguments);</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这里<code>dispatcher</code>指向<code>ReactCurrentDispatcher.current</code>。</p>
<p>关于这个变量，大致可以认为它是一个指针，会在运行过程中不断变化其指向。在当前分析的版本中，它的定义在ReactFiberHooks.new.js文件中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReactFiberHooks.new.js#line399</span></span><br><span class="line">ReactCurrentDispatcher.current =</span><br><span class="line">  current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span></span><br><span class="line">    ? HooksDispatcherOnMount</span><br><span class="line">    : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactFiberHooks.old.js#line1776</span></span><br><span class="line"><span class="comment">// ReactFiberHooks.new.js#line1817</span></span><br><span class="line"><span class="comment">// 这两个文件里面这部分定义是一致的</span></span><br><span class="line"><span class="keyword">const</span> HooksDispatcherOnMount: Dispatcher = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  useCallback: mountCallback,</span><br><span class="line">  useContext: readContext,</span><br><span class="line">  useEffect: mountEffect,</span><br><span class="line">  useImperativeHandle: mountImperativeHandle,</span><br><span class="line">  useLayoutEffect: mountLayoutEffect,</span><br><span class="line">  useMemo: mountMemo,</span><br><span class="line">  useReducer: mountReducer,</span><br><span class="line">  useRef: mountRef,</span><br><span class="line">  useState: mountState,</span><br><span class="line">  useDebugValue: mountDebugValue,</span><br><span class="line">  useDeferredValue: mountDeferredValue,</span><br><span class="line">  useTransition: mountTransition,</span><br><span class="line">  useMutableSource: mountMutableSource,</span><br><span class="line">  useOpaqueIdentifier: mountOpaqueIdentifier,</span><br><span class="line"></span><br><span class="line">  unstable_isNewReconciler: enableNewReconciler,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HooksDispatcherOnUpdate: Dispatcher = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  useCallback: updateCallback,</span><br><span class="line">  useContext: readContext,</span><br><span class="line">  useEffect: updateEffect,</span><br><span class="line">  useImperativeHandle: updateImperativeHandle,</span><br><span class="line">  useLayoutEffect: updateLayoutEffect,</span><br><span class="line">  useMemo: updateMemo,</span><br><span class="line">  useReducer: updateReducer,</span><br><span class="line">  useRef: updateRef,</span><br><span class="line">  useState: updateState,</span><br><span class="line">  useDebugValue: updateDebugValue,</span><br><span class="line">  useDeferredValue: updateDeferredValue,</span><br><span class="line">  useTransition: updateTransition,</span><br><span class="line">  useMutableSource: updateMutableSource,</span><br><span class="line">  useOpaqueIdentifier: updateOpaqueIdentifier,</span><br><span class="line"></span><br><span class="line">  unstable_isNewReconciler: enableNewReconciler,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>这里重提一下重点，本篇的重点是React核心的数据结构</strong>。</p>
<h1 id="useState的细节"><a href="#useState的细节" class="headerlink" title="useState的细节"></a>useState的细节</h1><p>我们看一看常见的useState的定义(mountState&amp;&amp;updateState):</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>&lt;<span class="title">S</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  initialState: (() =&gt; S) | S,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">BasicStateAction</span>&lt;<span class="title">S</span>&gt;&gt;] </span>&#123;</span><br><span class="line">	<span class="comment">// 细节忽略</span></span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateState</span>&lt;<span class="title">S</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  initialState: (() =&gt; S) | S,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">BasicStateAction</span>&lt;<span class="title">S</span>&gt;&gt;] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateReducer(basicStateReducer, (initialState: <span class="built_in">any</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rerenderReducer</span>&lt;<span class="title">S</span>, <span class="title">I</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  reducer: (S, A) =&gt; S,</span></span></span><br><span class="line"><span class="function"><span class="params">  initialArg: I,</span></span></span><br><span class="line"><span class="function"><span class="params">  init?: I =&gt; S,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">A</span>&gt;] </span>&#123;</span><br><span class="line">	<span class="comment">// 细节忽略</span></span><br><span class="line">  <span class="keyword">return</span> [newState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以究根结底来说，我们常见<code>const [text, setText] = useState('hello')</code>返回的就是一个state和一个dispatch。</p>
<p>关于这个hooks机制吧，因为在函数式组件里面(每次render必然会重新执行这个render，正常来讲变量赋值会被初始化)，所以个人盲猜就是用闭包原理做了一个仅仅对当前函数式组件开放访问的闭包作用域。后面爬源码来验证这个猜想吧。这里目标是mountState函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>&lt;<span class="title">S</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  initialState: (() =&gt; S) | S,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">BasicStateAction</span>&lt;<span class="title">S</span>&gt;&gt;] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// $FlowFixMe: Flow doesn&#x27;t like mixed types</span></span><br><span class="line">    initialState = initialState();</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;</span><br><span class="line">  <span class="keyword">const</span> queue = (hook.queue = &#123;</span><br><span class="line">    pending: <span class="literal">null</span>,</span><br><span class="line">    dispatch: <span class="literal">null</span>,</span><br><span class="line">    lastRenderedReducer: basicStateReducer,</span><br><span class="line">    lastRenderedState: (initialState: <span class="built_in">any</span>),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;</span><br><span class="line">    BasicStateAction&lt;S&gt;,</span><br><span class="line">  &gt; = (queue.dispatch = (dispatchAction.bind(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    currentlyRenderingFiber,</span><br><span class="line">    queue,</span><br><span class="line">  ): <span class="built_in">any</span>));</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里hooks赋值的结构是:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hook: Hook = &#123;</span><br><span class="line">  memoizedState: <span class="literal">null</span>, <span class="comment">// 保存最新的值</span></span><br><span class="line">  baseState: <span class="literal">null</span>, <span class="comment">// 初始值</span></span><br><span class="line">  baseQueue: <span class="literal">null</span>,</span><br><span class="line">  queue: &#123;</span><br><span class="line">    pending: <span class="literal">null</span>,</span><br><span class="line">    dispatch: <span class="literal">null</span>,</span><br><span class="line">    lastRenderedReducer: basicStateReducer,</span><br><span class="line">    lastRenderedState: (initialState: any),</span><br><span class="line">  &#125;,</span><br><span class="line">  next: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这很显然是一个链表的结构，第一次执行之后会返回这样的hooks结构，后续执行的时候就会把相应的hooks数据结构放到这个next属性上并返回，最终所有的hooks组成一个链表。然后它被放在当前渲染的currentlyRenderingFiber节点上(dispatchAction函数内容)。</p>
<p>另外可以看到返回dispatch的核心路径了: <code>dispatchAction.bind()</code>。这个函数如果涉及到fiber要分析还是挺麻烦的，考虑到这里fiber为null，所以我把相关代码删了，贼清晰现在：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAction</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action,</span><br><span class="line">    eagerReducer: <span class="literal">null</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: <span class="built_in">any</span>),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append the update to the end of the list.</span></span><br><span class="line">  <span class="keyword">const</span> pending = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">    update.next = update;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update.next = pending.next;</span><br><span class="line">    pending.next = update;</span><br><span class="line">  &#125;</span><br><span class="line">  queue.pending = update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几个注意点：</p>
<ol>
<li>bind函数的返回。bind函数是将函数绑定了上下文之后返回。所以dispatch是一个函数。这个函数就是指定了this指向的dispatchAction</li>
<li>dispatch这个定义的时候传入了一些参数，核心就是这个hook.queue。</li>
<li><strong>闭包的实现</strong>：通过bind函数，成功的把状态值存入了dispatchAction函数的闭包里面。</li>
</ol>
<p>当我们mount渲染完毕之后，dispatch也就被定义完毕，在这个定义过程中，巧妙的利用了bind这个函数将相关的一些值存到了一个基于dispatchAction函数构造出来的新函数里面。这个过程中因为这个闭包的存在，我们的无状态组件在更新的时候，将不会丢失内部状态。</p>
<p>这里我们继续对这个这个更新的流程分析一下，看看后续更新过程之中，它是如何在update流程里面，拿到旧的值，并如何在更新过程中使用setXXX(new)获取新的值，并触发视图更新。</p>
<p><strong>这里主要是两个要点，第一个是视图更新时候如何拿到缓存值，第二个是setXXX(newValue)过程中更新值和View。</strong></p>
<p>这里讨巧一点进行探究，如果先分析第一个那么后续的要重新分析，但是如果直接分析第二个，一方面即可以继续上面的分析思路，另一方面它本身也会触发更新和缓存值读取，这样两个分析就组成了一条线。</p>
<p>所以我们直接看看setXXX(newValue)过程发生了什么。</p>
<p>这里往上进行回顾,首先是setXXX这个函数，它的值的定义：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// useState初始最终导出：[hook.memoizedState, dispatch]</span></span><br><span class="line"><span class="keyword">const</span> dispatch: Dispatch&lt;</span><br><span class="line">  BasicStateAction&lt;S&gt;,</span><br><span class="line">&gt; = (queue.dispatch = (dispatchAction.bind(</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  currentlyRenderingFiber,</span><br><span class="line">  queue,</span><br><span class="line">): <span class="built_in">any</span>));</span><br><span class="line"><span class="comment">// dispatchAction的函数参数定义:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAction</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 那么此时, 通过dispatchAction.bind这个调用:</span></span><br><span class="line">setXXX(newValue) === dispatchAction(currentlyRenderingFiber, queue, newValue)</span><br></pre></td></tr></table></figure>

<p>此时我们就可以带着疑问去分析，当执行setXXX(newValue)时候，发生了什么。<br>此时，我们需要对dispatchAction函数做一些比较细致的分析，之前dispatchAction函数我们把Fiber节点相关东西删掉了方便理解简单的意图，但是这里需要则需要对Fiber处理部分进行细致分析(为了尽量简洁还是删除了dev部分代码)。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAction</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action, <span class="comment">// &lt;- 这里保存的是setXXX(newValue)里面的newValue值</span></span><br><span class="line">    eagerReducer: <span class="literal">null</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: <span class="built_in">any</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 提到的queue在前文中的定义</span></span><br><span class="line">  <span class="comment">// const queue = (hook.queue = &#123;</span></span><br><span class="line">  <span class="comment">//   pending: null,</span></span><br><span class="line">  <span class="comment">//   dispatch: dispatchAction.bind(</span></span><br><span class="line">  <span class="comment">//     null,</span></span><br><span class="line">  <span class="comment">//     currentlyRenderingFiber,</span></span><br><span class="line">  <span class="comment">//     queue,</span></span><br><span class="line">  <span class="comment">//   ): any),</span></span><br><span class="line">  <span class="comment">//   lastRenderedReducer: basicStateReducer,</span></span><br><span class="line">  <span class="comment">//   lastRenderedState: (initialState: any),</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line">  <span class="comment">// Append the update to the end of the list.</span></span><br><span class="line">  <span class="keyword">const</span> pending = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">    update.next = update;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update.next = pending.next;</span><br><span class="line">    pending.next = update;</span><br><span class="line">  &#125;</span><br><span class="line">  queue.pending = update;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    fiber === currentlyRenderingFiber ||</span><br><span class="line">    (alternate !== <span class="literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// This is a render phase update. Stash it in a lazily-created map of</span></span><br><span class="line">    <span class="comment">// queue -&gt; linked list of updates. After this render pass, we&#x27;ll restart</span></span><br><span class="line">    <span class="comment">// and apply the stashed updates on top of the work-in-progress hook.</span></span><br><span class="line">    <span class="comment">// 这是一个渲染阶段的更新, 将其保存在一个延迟创建的队列(更新链表)映射中。</span></span><br><span class="line">    <span class="comment">// 在这个更新结束之后，我们将会重新触发顶部的work-in-progress，将保存起来的更新进行应用。</span></span><br><span class="line">    <span class="comment">// 这里做一个标记 并在render阶段触发更新 这种对应的是已经有多个update在fiber上的情况</span></span><br><span class="line">    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 主要来说，这里是一个条件赋值行为(针对update对象)</span></span><br><span class="line">    <span class="comment">// 这里有个要点在于，当前update队列其实还是空的 所以可以直接计算下一步的state</span></span><br><span class="line">    <span class="comment">// 如果: 里面的值和当前一致就直接return退出不走下面的scheduleWork逻辑。</span></span><br><span class="line">    <span class="comment">// 反之, 则执行scheduleUpdateOnFiber进行更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下是16.8版本时候的if判断 17.0.2有更新 但是贴出来感觉也有些参考意义</span></span><br><span class="line">    <span class="comment">// currentlyRenderingFiber =&gt; workInProgress</span></span><br><span class="line">    <span class="comment">// if (</span></span><br><span class="line">    <span class="comment">//   fiber === currentlyRenderingFiber ||</span></span><br><span class="line">    <span class="comment">//   (alternate !== null &amp;&amp; alternate === currentlyRenderingFiber)</span></span><br><span class="line">    <span class="comment">// ) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      fiber.lanes === NoLanes &amp;&amp;</span><br><span class="line">      (alternate === <span class="literal">null</span> || alternate.lanes === NoLanes)</span><br><span class="line">      <span class="comment">// fiber.lanes =&gt; fiber节点优先级</span></span><br><span class="line">      <span class="comment">// fiber.lanes === NoLanes =&gt; fiber节点上没有更新需要执行</span></span><br><span class="line">      <span class="comment">// 当fiber上不存在别的update，就不需要经过多个update进行合并计算state</span></span><br><span class="line">      <span class="comment">// 那么当前的update就是唯一的计算过程，即可以立刻算出结果</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// The queue is currently empty, which means we can eagerly compute the</span></span><br><span class="line">      <span class="comment">// next state before entering the render phase. If the new state is the</span></span><br><span class="line">      <span class="comment">// same as the current state, we may be able to bail out entirely.</span></span><br><span class="line">      <span class="keyword">const</span> lastRenderedReducer = queue.lastRenderedReducer;</span><br><span class="line">      <span class="keyword">if</span> (lastRenderedReducer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> prevDispatcher;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> currentState: S = (queue.lastRenderedState: <span class="built_in">any</span>);</span><br><span class="line">          <span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);</span><br><span class="line">          <span class="comment">// Stash the eagerly computed state, and the reducer used to compute</span></span><br><span class="line">          <span class="comment">// it, on the update object. If the reducer hasn&#x27;t changed by the</span></span><br><span class="line">          <span class="comment">// time we enter the render phase, then the eager state can be used</span></span><br><span class="line">          <span class="comment">// without calling the reducer again.</span></span><br><span class="line">          update.eagerReducer = lastRenderedReducer;</span><br><span class="line">          update.eagerState = eagerState;</span><br><span class="line">          <span class="keyword">if</span> (is(eagerState, currentState)) &#123;</span><br><span class="line">            <span class="comment">// Fast path. We can bail out without scheduling React to re-render.</span></span><br><span class="line">            <span class="comment">// It&#x27;s still possible that we&#x27;ll need to rebase this update later,</span></span><br><span class="line">            <span class="comment">// if the component re-renders for a different reason and by that</span></span><br><span class="line">            <span class="comment">// time the reducer has changed.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// Suppress the error. It will throw again in the render phase.</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 16.8版本的调用 scheduleWork(fiber, expirationTime);</span></span><br><span class="line">    scheduleUpdateOnFiber(fiber, lane, eventTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑在注释里面其实比较清楚了。为了方便阅读部分关键地方我都做了中文注释，并加了一点点个人理解。</p>
<p>这里的逻辑分支大致是: </p>
<ul>
<li><p>如果是第一次update更新过程，那么立刻计算出结果，并调用scheduleUpdateOnFiber(scheduleWork)更新</p>
</li>
<li><p>如果之前已经更新过，再次更新，那么此时queue.pending保存的就是上一次缓存的 update 对象(代码块 line36),此时: <code>update.next = pending.next; pending.next = update;queue.pending = update;</code>这三条代码，就比较有趣，它完成了一个环形链表(当然其实首次更新过程也有一个环形链表):</p>
<ul>
<li>先将 update 下个节点设为pending的下个节点</li>
<li>然后pending下个节点设为 update。通过这两步骤就讲 update 塞进了环形列表</li>
<li>最后将queue.pending指向 update。</li>
<li>完毕后做一个需要批量更新的标记</li>
</ul>
</li>
</ul>
<h1 id="篇外-总结"><a href="#篇外-总结" class="headerlink" title="篇外 || 总结"></a>篇外 || 总结</h1><p>分析过上文这些数据逻辑变动之后，大致就明白这个这个 useState其实实质上还是对<code>dispatchAction</code>的细节分析。</p>
<p>这里queue的维护是这里核心逻辑。这里主要是维护的pending(当前 update 节点指针)，以及update节点所在的环形链表。</p>
<p>至于后续的更新主要是通过标记更新，或者手动执行<code>scheduleUpdateOnFiber|scheduleWork</code>函数来实现的。</p>
<p>关于这个函数，在16.8版本下的scheduleWork函数的分析，其实前面也分析, 具体可以参考看看<a href="/2019/08/07/react-v16-Update-renderPhase/">《react-v16-Update renderPhase篇》</a>。</p>
<p>这个函数是在上一篇中是setState函数的下级调用，在这里直接调用它实质上和setState触发更新原理也差不多。<br>这一篇就不再赘述。</p>
<p>但是新版本这里更新了调用方式<code>scheduleUpdateOnFiber</code>, 但是呢，查看了一下相关函数里面的原有的scheduleWork调用基本都直接替换为scheduleUpdateOnFiber，那么很显然这里scheduleUpdateOnFiber基本等同scheduleWork，只是加入了一个lane优先级参数。</p>
<p>而优先级的整理，则又是一个故事了。</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react-17.0.2</title>
    <url>/2021/05/10/react-17-0-2/</url>
    <content><![CDATA[<h1 id="react-本身"><a href="#react-本身" class="headerlink" title="react 本身"></a>react 本身</h1><p>react 不仅仅是浏览器端在用，而且服务器端和 reactNative 端其实也还是在使用。<br>纯<br>这就决定了 react 库本身只是一个很纯粹的数据结构类型的库。</p>
<p>但是前端其实很难脱离 react-dom 去看源码，在这个不断的跳转中其实已经分不清什么是 react，什么是 react-dom。</p>
<p>但是说到底，react 就是 react, 而非 react-dom。虽然常规来说，如果不看 react-dom，其实很难处乎其外去理解 react。但是这篇，还是很克制的去单的分析 react 本身。</p>
<p>时间已经到了 21 年 5 月。所以这里的版本是 17.0.2。但是 react 这个库 实质很多地方已经一年多没有修改过了。所以如果早期有理解，这里依然还是那样。</p>
<h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p><img src="/images/react17-0-2.png" alt="react17.0.2"></p>
<p>这张图比较大，可以右键打开到特定地方点击放大镜查看(chrome)。<br>这里对导出的函数和变量做一点分析。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">createMutableSource,</span><br><span class="line">createRef,</span><br><span class="line">Component,</span><br><span class="line">PureComponent,</span><br><span class="line">createElement,</span><br><span class="line">cloneElement,</span><br><span class="line">createContext,</span><br><span class="line">createFactory,</span><br><span class="line">forwardRef,</span><br><span class="line">lazy,</span><br><span class="line">memo,</span><br><span class="line">useCallback,</span><br><span class="line">useContext,</span><br><span class="line">useEffect,</span><br><span class="line">useImperativeHandle,</span><br><span class="line">useDebugValue,</span><br><span class="line">useLayoutEffect,</span><br><span class="line">useMemo,</span><br><span class="line">useMutableSource,</span><br><span class="line">useReducer,</span><br><span class="line">useRef,</span><br><span class="line">useState,</span><br><span class="line">isValidElement,</span><br><span class="line">useTransition,</span><br><span class="line">startTransition,</span><br><span class="line">useDeferredValue,</span><br><span class="line">block,</span><br><span class="line">createFundamental <span class="keyword">as</span> unstable_createFundamental,</span><br><span class="line">useOpaqueIdentifier <span class="keyword">as</span> unstable_useOpaqueIdentifier,</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Children</span><br><span class="line">REACT_FRAGMENT_TYPE <span class="keyword">as</span> Fragment,</span><br><span class="line">REACT_PROFILER_TYPE <span class="keyword">as</span> Profiler,</span><br><span class="line">REACT_STRICT_MODE_TYPE <span class="keyword">as</span> StrictMode,</span><br><span class="line">REACT_DEBUG_TRACING_MODE_TYPE <span class="keyword">as</span> unstable_DebugTracingMode,</span><br><span class="line">REACT_SUSPENSE_TYPE <span class="keyword">as</span> Suspense,</span><br><span class="line">ReactSharedInternals <span class="keyword">as</span> __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,</span><br><span class="line">REACT_SUSPENSE_LIST_TYPE <span class="keyword">as</span> SuspenseList,</span><br><span class="line">REACT_LEGACY_HIDDEN_TYPE <span class="keyword">as</span> unstable_LegacyHidden,</span><br><span class="line">REACT_SCOPE_TYPE <span class="keyword">as</span> unstable_Scope,</span><br></pre></td></tr></table></figure>

<h1 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h1><p>这篇主要分析返回的数据结构，看情况记录一下以前写过这些数据是如何使用之类。</p>
<h2 id="Fn-createMutableSource"><a href="#Fn-createMutableSource" class="headerlink" title="Fn#createMutableSource"></a>Fn#createMutableSource</h2><p>这个函数过于简单 基本直接贴也可以:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createMutableSource</span>&lt;<span class="title">Source</span>: <span class="title">$NonMaybeType</span>&lt;<span class="title">mixed</span>&gt;&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  source: Source,</span></span></span><br><span class="line"><span class="function"><span class="params">  getVersion: MutableSourceGetVersionFn,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">MutableSource</span>&lt;<span class="title">Source</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mutableSource: MutableSource&lt;Source&gt; = &#123;</span><br><span class="line">    _getVersion: getVersion,</span><br><span class="line">    _source: source,</span><br><span class="line">    _workInProgressVersionPrimary: <span class="literal">null</span>,</span><br><span class="line">    _workInProgressVersionSecondary: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> mutableSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要用于<code>useMutableSource</code>, 官方文档在这里<a href="https://github.com/reactjs/rfcs/blob/master/text/0147-use-mutable-source.md">0147-use-mutable-source.md</a>。</p>
<blockquote>
<p>useMutableSource() enables React components to safely and efficiently read from a mutable external source in Concurrent Mode. </p>
</blockquote>
<h2 id="Fn-createRef"><a href="#Fn-createRef" class="headerlink" title="Fn#createRef"></a>Fn#createRef</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRef</span>(<span class="params"></span>): <span class="title">RefObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> refObject = &#123;</span><br><span class="line">    current: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> refObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里超级常见了， 常常会用到的ref.current就是这里。</p>
<h2 id="Fn-Component"><a href="#Fn-Component" class="headerlink" title="Fn#Component"></a>Fn#Component</h2><p>这里Component说是一个函数其实不太合适，日常来说，我们都是把它作为一个组件使用的。它是react项目无法避开的一个知识点。</p>
<p>但是在纯粹的React库里面它是一个构造器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.props = props;</span><br><span class="line">  <span class="built_in">this</span>.context = context;</span><br><span class="line">  <span class="built_in">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="built_in">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line">Component.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.updater.enqueueSetState(<span class="built_in">this</span>, partialState, callback, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Component.prototype.forceUpdate = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.updater.enqueueForceUpdate(<span class="built_in">this</span>, callback, <span class="string">&#x27;forceUpdate&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当new一个Component时候，原型链上就自动有了setState这些东西。它们依托ReactNoopUpdateQueue进行更新。</p>
<p>当然，后面就全是细节了。这里不表。</p>
<h2 id="Fn-PureComponent"><a href="#Fn-PureComponent" class="headerlink" title="Fn#PureComponent"></a>Fn#PureComponent</h2><p>PureComponent和Component基本相同。但是它没有了Component的原型上的setState和forceUpdate这些了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PureComponent</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.props = props;</span><br><span class="line">  <span class="built_in">this</span>.context = context;</span><br><span class="line">  <span class="built_in">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="built_in">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fn-createContext"><a href="#Fn-createContext" class="headerlink" title="Fn#createContext"></a>Fn#createContext</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createContext</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  defaultValue: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  calculateChangedBits: ?(a: T, b: T) =&gt; number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactContext</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (calculateChangedBits === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    calculateChangedBits = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> context: ReactContext&lt;T&gt; = &#123;</span><br><span class="line">    $$typeof: REACT_CONTEXT_TYPE,</span><br><span class="line">    _calculateChangedBits: calculateChangedBits,</span><br><span class="line">    _currentValue: defaultValue,</span><br><span class="line">    _currentValue2: defaultValue,</span><br><span class="line">    _threadCount: <span class="number">0</span>,</span><br><span class="line">    Provider: (<span class="literal">null</span>: any),</span><br><span class="line">    Consumer: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  context.Provider = &#123;</span><br><span class="line">    $$typeof: REACT_PROVIDER_TYPE,</span><br><span class="line">    _context: context,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> hasWarnedAboutUsingNestedContextConsumers = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> hasWarnedAboutUsingConsumerProvider = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> hasWarnedAboutDisplayNameOnConsumer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">		<span class="comment">// 略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context.Consumer = context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里context是早前redux之类库必须用到的东西。这里主要关注ReactContext数据定义。</p>
<h2 id="Fn-forwardRef"><a href="#Fn-forwardRef" class="headerlink" title="Fn#forwardRef"></a>Fn#forwardRef</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">forwardRef</span>&lt;<span class="title">Props</span>, <span class="title">ElementType</span>: <span class="title">React$ElementType</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  render: (props: Props, ref: React$Ref&lt;ElementType&gt;) =&gt; React$Node,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> elementType = &#123;</span><br><span class="line">    $$typeof: REACT_FORWARD_REF_TYPE,</span><br><span class="line">    render,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> elementType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里这个函数核心还是$$typeof和render组成的这个数据结构。正常来说render是一个<code>(props)=>ReactNode</code>的函数。</p>
<p>它主要作用还是为了方便使用ref方式获取dom结构，以便一些老旧js库基于dom来工作。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规使用方式</span></span><br><span class="line"><span class="keyword">const</span> Child = React.forwardRef(<span class="function">(<span class="params">props, ref</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div ref=&#123;ref&#125;&gt;&#123;props.txt&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当要进行实例化、渲染的时候，需要执行这个render一次将ref传入。</p>
<h2 id="Fn-lazy"><a href="#Fn-lazy" class="headerlink" title="Fn#lazy"></a>Fn#lazy</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lazy</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  ctor: () =&gt; Thenable&lt;&#123;<span class="keyword">default</span>: T, ...&#125;&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">LazyComponent</span>&lt;<span class="title">T</span>, <span class="title">Payload</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> payload: Payload&lt;T&gt; = &#123;</span><br><span class="line">    <span class="comment">// We use these fields to store the result.</span></span><br><span class="line">    _status: -<span class="number">1</span>,</span><br><span class="line">    _result: ctor,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lazyType: LazyComponent&lt;T, Payload&lt;T&gt;&gt; = &#123;</span><br><span class="line">    $$typeof: REACT_LAZY_TYPE,</span><br><span class="line">    _payload: payload,</span><br><span class="line">    _init: lazyInitializer,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lazyType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规的使用</span></span><br><span class="line"><span class="keyword">const</span> SomeComponent = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./SomeComponent&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>这里lazy要求有一个&lt;React.Suspense&gt;容器 &amp;&amp; 浏览器的Promise环境支持。</p>
<p>具体的lazy更多细节在ReactLazy.js里面。它的实现上和Promise非常相似。里面有多种状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Uninitialized = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> Pending = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> Resolved = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> Rejected = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>而lazy数据结构中的lazyInitializer属性，执行之后会进行类似Promise这样的操作。</p>
<p>这个<code>_init: lazyInitializer</code>机制，大致就是为什么需要Promise(底层原理依赖它)，为什么需要&lt;React.Suspense&gt;容器(_init:lazyInitializer需要有人来执行, 返回的数据结构和内部逻辑决定了它没有自执行的可能性)。</p>
<p>关于Promise底层依赖这个，访问<a href="https://babeljs.io/repl">babel repl</a>，做一点尝试就很容易明白。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from:</span></span><br><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>));</span><br><span class="line"><span class="comment">// to:</span></span><br><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> _interopRequireWildcard(<span class="built_in">require</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>))));</span><br></pre></td></tr></table></figure>

<p>关于里面多出来的其他函数可能也无需去理解，看到转译出来的Promise.resolve()已经可以确定底层依赖的事实。</p>
<h2 id="Value-Suspense"><a href="#Value-Suspense" class="headerlink" title="Value#Suspense"></a>Value#Suspense</h2><p>上文的lazy依赖于它。但是在react内部呢，Suspense仅仅是一个Symbol符号。在代码实现上，它是这样定义的：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolFor = <span class="built_in">Symbol</span>.for;</span><br><span class="line">REACT_SUSPENSE_TYPE = symbolFor(<span class="string">&#x27;react.suspense&#x27;</span>);</span><br><span class="line"><span class="comment">// lazy返回结构对应的定义是</span></span><br><span class="line">REACT_LAZY_TYPE = symbolFor(<span class="string">&#x27;react.lazy&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用场景</span></span><br><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Suspense fallback=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Spinner</span> /&gt;</span></span>&#125;&gt;</span><br><span class="line">        &lt;OtherComponent /&gt;</span><br><span class="line">    &lt;/React.Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// babel对React.Suspense的转译:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(React.Suspense, &#123;</span><br><span class="line">    fallback: React.createElement(Spinner, <span class="literal">null</span>)</span><br><span class="line">  &#125;, React.createElement(OtherComponent, <span class="literal">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑createElement的定义，这里发生的事情大致是这样:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ReactElement(</span><br><span class="line">    type, <span class="comment">// 这里type = symbolFor(&#x27;react.suspense&#x27;) = REACT_SUSPENSE_TYPE</span></span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line">    props: &#123; <span class="comment">// 细节有忽略 大致如此</span></span><br><span class="line">    	...config, <span class="comment">// 这里基本等价 fallback 也就是那个Spinner组件</span></span><br><span class="line">	    children, <span class="comment">// 这里对应的LazyComponent</span></span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以下是ReactDom范畴:</strong></p>
<p>简单看了一下新版本的ReactDom, render一路往下到了updateContainer。在这个函数中有一点点细节:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">update=&#123;</span><br><span class="line">  callback: callback, <span class="comment">// callback返回Spinner组件</span></span><br><span class="line">  payload: &#123; element &#125; <span class="comment">// element是我们的React.Suspense容器组件</span></span><br><span class="line">&#125;</span><br><span class="line">enqueueUpdate(current, update); <span class="comment">// current是容器 Fiber形式</span></span><br><span class="line">scheduleUpdateOnFiber(current, lane, eventTime);</span><br></pre></td></tr></table></figure>

<p>enqueueUpdate将update挂载到了current这个fiber节点。scheduleUpdateOnFiber开始执行。</p>
<h2 id="Fn-memo"><a href="#Fn-memo" class="headerlink" title="Fn#memo"></a>Fn#memo</h2><p>来自ReactMemo文件。</p>
<p>返回的是这样的一个数据结构:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> elementType = &#123;</span><br><span class="line">  $$typeof: REACT_MEMO_TYPE,</span><br><span class="line">  type, <span class="comment">// type这里是组件</span></span><br><span class="line">  compare: compare === <span class="literal">undefined</span> ? <span class="literal">null</span> : compare,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>常规使用上:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* render using props */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    return true if passing nextProps to render would return</span></span><br><span class="line"><span class="comment">    the same result as passing prevProps to render,</span></span><br><span class="line"><span class="comment">    otherwise return false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(MyComponent, areEqual);</span><br></pre></td></tr></table></figure>

<p>它用于一些函数式组件的性能优化。解决shouldComponentUpdate只能用于classComponent的局限。</p>
<p>这个数据结构的设计还是很容易理解的,$$typeof用来判断类型，compare用来判断是否需要更新，type这是渲染方法。React这种数据驱动的View的模式, type作为render函数, 只要使用compare精细判别一下props变化, 一般是针对作为对象的props属性,就可以进行视图一致、业务精细化处理的刷新。</p>
<h2 id="HookS-useXXX系列"><a href="#HookS-useXXX系列" class="headerlink" title="HookS#useXXX系列"></a>HookS#useXXX系列</h2><p>这里太长, 单独拆开了说。<a href="/2021/06/13/2021-6-13-react-17-0-2-hooks/">点这里</a></p>
<p>主要分析了 useState 和 useEffect两个，写到最后其实有些兴味索然，不过还是可以看看吧。</p>
<h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><p>这是一个当前尚未发布的功能。关联<a href="https://github.com/facebook/react/issues/22152">issue</a></p>
<blockquote>
<p>“Blocks” fixture app which made by built-in API, ‘react-fetch’, Server Component combination that useful to play new features v18 later.</p>
</blockquote>
<p>简单说这是一个[内置API+远程数据获取+SSR]的混合体。</p>
<p>实际上这属于一个资料很少的功能，当前实际上也很难找到demo可以参考，当前最合适用来理解这个功能的demo应当是<code>ReactBlocks-test.js</code>。</p>
<p>我去大致看了一下这个test，大致是测试Block这个api，可以实现实现数据获取,数据缓存,带有Suspense安全边界这样的一个功能。</p>
<p>个人猜想它大致还是针对当前我们一些业务组件不得不在组件里面耦合远程api请求、以及复用组件产生的。</p>
<p>当前它还没有发布, 对它有个初步认知应该就可以了。</p>
<h2 id="useOpaqueIdentifier"><a href="#useOpaqueIdentifier" class="headerlink" title="useOpaqueIdentifier"></a>useOpaqueIdentifier</h2><p>这是工具函数, 用来生成唯一id，从前为了这个id使用过uuid-v4这个库。<br>它比uuid-v4更优越的地方可能在于它是SSR-safe的，当这样当SSR环境生成的id和客户端生成的id就不会出现冲突的可能。</p>
<blockquote>
<p>🌠 React is getting a new hook, <code>useOpaqueIdentifier</code>, which can be used to generate unique IDs (to be used for form labels, aria-labelledby, etc), in an SSR-safe way.</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useOpaqueIdentifier &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TextField = <span class="function">(<span class="params">&#123; value, onChange, label &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = useOpaqueIdentifier()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;text-field&quot;</span>&gt;</span><br><span class="line">      &lt;label htmlFor=&#123;id&#125;&gt;&#123;label&#125;&lt;/label&gt;</span><br><span class="line">      &lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> id=&#123;id&#125; value=&#123;value&#125; onChange=&#123;onChange&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TextField</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>what-are-you-doing</title>
    <url>/2021/05/09/what-are-you-doing/</url>
    <content><![CDATA[<h1 id="都是闲话"><a href="#都是闲话" class="headerlink" title="都是闲话"></a>都是闲话</h1><p>19年底到今年四五月，其实一直都很忙很忙，忙着业务代码，忙着收拾心情。</p>
<p>二月时候看着自己博客hexo版本有些老了都快跑不起来了，花了两晚把它升级了一通，最后竟也没有把它推送，就那么放在桌面一角，提示未完的事情。</p>
<p>今晚自斟自酌一点点，回顾自己写过的react笔记文章，看着它一点点过时，仿佛被整个时代一点点遗弃，心里就有那么一点点的沮丧吧。</p>
<p>所以这会我再想，你在做什么呢？</p>
<h1 id="一些反思"><a href="#一些反思" class="headerlink" title="一些反思"></a>一些反思</h1><p>工作其实还是有些年头了，各种各样的挫折，问题其实该遇到的还是遇到了，关于这些，其实解决的还算好。</p>
<p>实际上一直不是那种记忆力很拔群的人，很多事情就是那样，很快就忘了。</p>
<p>今晚开始把这块和自己的人生哲学开始做个整合，发觉其实它还是有生命的。</p>
<p>强记其实是无意义的，不是一直奉行的，记忆公式，忘记结果么？</p>
<p>任他风吹雨打，胜似闲庭信步。</p>
<p>时间一点点溜走，发现头发都变得稀疏许多。</p>
<p>决定做点更有意义的事情，把时间留下吧。</p>
<p>决定把react 17.0.2版本看一看读一读。做一个大一点的架构分析。</p>
<p>然后找点更有意思的事情做一做。(2021.05.09)</p>
]]></content>
  </entry>
  <entry>
    <title>React的调度-v16</title>
    <url>/2019/08/28/v16-Scheduling-in-React/</url>
    <content><![CDATA[<p>本来看到<a href="https://philippspiess.com/scheduling-in-react/">《Scheduling in React》</a>有想法将其翻译一下。不过既然有掘金大佬捷足先登，我就不再做这事了，转过来看看React里面的调度的使用和原理。</p>
<p>这里也就结合自己理解和原文做一些小总结和阐发。主要是归总学习性质，这篇探索性的东西不多。</p>
<blockquote>
<p>文章写到一半的时候, 因为一些疑问查资料，又看到了<a href="https://zhuanlan.zhihu.com/p/60307571">《深入剖析 React Concurrent》</a>。索性对结构有大修了。所以这里把Concurrent放在了前面。</p>
</blockquote>
<h1 id="并发-amp-调度"><a href="#并发-amp-调度" class="headerlink" title="并发 &amp; 调度"></a>并发 &amp; 调度</h1><h2 id="并发-Concurrent-React"><a href="#并发-Concurrent-React" class="headerlink" title="并发: Concurrent React"></a>并发: Concurrent React</h2><p>Concurrent React 或者叫Time Slicing，实际上对个人而言，是一个很艰难的话题。在之前文章里，面对它我都采取了略过的态度。</p>
<p>一则同步都没搞明白，更何况异步的处理？二则实际上直到16.9.0，关于它的特性也依然没有正式发布。</p>
<p>后来慢慢一步步深入之后大抵也有了继续探寻的基础。</p>
<p>不过这之前，先得说明白，为什么需要Time Slicing。</p>
<ul>
<li>动画的流畅性原理。一个动画如果想在人眼中显得『流畅』,那么起码需要24帧每秒(React这里默认是按30帧算)，现在显示屏一般技术规格是60Hz(相当于每秒60帧)，这足以保证流畅了。算下来就是1000/60≈16.67ms。<strong>但是，这里要求的是每个帧是变化运动的。</strong>如果一个帧占用多个帧的时间，看起来就是卡顿。</li>
<li>浏览器Event Loop &amp;&amp; requestAnimationFrame &amp;&amp; requestIdleCallback。<strong>这里需要重点理解，读不懂它们，就读不懂全文。</strong></li>
</ul>
<h3 id="rAF"><a href="#rAF" class="headerlink" title="rAF"></a>rAF</h3><p>首先是requestAnimationFrame(简称rAF)。在一个帧里面，它的生命周期如下，每一帧都包含了 用户交互、js执行、rAF调用，布局计算以及页面重绘 等工作。在这个过程中rAF是一个必须执行完成的过程，如果它耗时长，那么帧就会一直等它技术然后再进行 布局计算和重绘。这个过程中可能会超过理想值16.67ms。</p>
<p><img src="/images/1_ad-k5hYKQnRQJF8tv8BIqg.png" alt="1_ad-k5hYKQnRQJF8tv8BIqg"></p>
<blockquote>
<ul>
<li>这里的参考路径：<a href="https://medium.com/@paul_irish/requestanimationframe-scheduling-for-nerds-9c57f7438ef4">requestAnimationFrame Scheduling For Nerds</a>。主要提及是requestAnimationFrame的调度。文章中也提到了帧之间的调度。</li>
</ul>
<p><img src="/images/1_atEwskfs0gtIryRrgnAPkw.png" alt="1_atEwskfs0gtIryRrgnAPkw"></p>
<ul>
<li>关于rAf,这里还有一篇参考，个人认为很值得看看<a href="https://www.404forest.com/2016/08/15/%E4%BD%BF%E7%94%A8%20requestAnimationFrame%20%E5%AE%9E%E7%8E%B0%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%87%92%E6%89%A7%E8%A1%8C/">使用 requestAnimationFrame 实现性能优化与懒执行</a></li>
<li>rAF有个特点，它必须在页面TAB激活情况下才能运行，如果切换到其他页面TAB它会暂停，返回后又重新开始。</li>
</ul>
</blockquote>
<h4 id="pollyfill"><a href="#pollyfill" class="headerlink" title="pollyfill"></a>pollyfill</h4><p>因为提到的rAF会在页面切换时候进行冻结的问题，这里React做了一个pollyfill。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> requestAnimationFrameWithTimeout = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// schedule rAF and also a setTimeout</span></span><br><span class="line">  rAFID = localRequestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// cancel the setTimeout</span></span><br><span class="line">    localClearTimeout(rAFTimeoutID);</span><br><span class="line">    callback(timestamp);</span><br><span class="line">  &#125;);</span><br><span class="line">  rAFTimeoutID = localSetTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// cancel the requestAnimationFrame</span></span><br><span class="line">    localCancelAnimationFrame(rAFID);</span><br><span class="line">    callback(getCurrentTime());</span><br><span class="line">  &#125;, ANIMATION_FRAME_TIMEOUT);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>核心是rAF优先级高于setTimeout。如果页面正在显示那么和rAF没区别，因为setTimeout会被rAF取消，但是如果在页面被隐藏时候，此时rAF就不会运行了，此时setTimeout会接替它的工作。</p>
<h3 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h3><p><strong>其次是requestIdleCallback。</strong>如果说rAF是每一帧必须执行的话，那么requestIdleCallback相反。它是选择性执行的。如果一个帧执行完毕时候耗时不到16.67ms，那么此时浏览器就处于空闲状态，此时它完成了它的任务，下个任务有没有开始。</p>
<p>此时就可以执行requestIdleCallback的任务了。注意的是，requestIdleCallback执行的时候，整个帧都已经完成了，收尾了，处于可以无缝交接给下一个帧的情况。如果在这个任务里面有改变布局、处理DOM、触发Promise.resolve的情况，会导致下一个帧开头就需要重新计算，或者干脆因为Promise异步导致这个帧重新开始处理拉长耗时下个帧无法开始工作。</p>
<p>这里流程的图片是:</p>
<p><img src="/images/1566444717989.png" alt="1566444717989"></p>
<p>当然，如果多个帧一直没有空闲，那么requestIdleCallback就无法开始执行，为了保障它的执行，它有第二个参数可以设置一个timeout。规定它最迟执行的时间(当然限于浏览器eventLopp也不可能完全准)。</p>
<blockquote>
<p>这里参考<a href="https://juejin.im/post/5ad71f39f265da239f07e862">你应该知道的requestIdleCallback</a>。</p>
</blockquote>
<h4 id="pollyfill-1"><a href="#pollyfill-1" class="headerlink" title="pollyfill"></a>pollyfill</h4><p>requestIdleCallback兼容性很差。所以这里还是需要进行pollyfill。<br>这里找到的hack办法是<code>window.MessageChannel</code>。这个api可以创建一个新的消息通道，实现sub/pub模式。最关键的地方是，响应订阅的函数，执行时机是Paint之后的空余时间。</p>
<p><strong>小总结</strong></p>
<p>将这些归纳起来说，就可以明白这个Time Slicing的含义了。它的意义在于，将大量耗时js操作打碎，将通过类似rAF来实现分帧进行必须的渲染，避免阻塞UI。</p>
<p>但是这带来一个问题就是优先级问题。一个任务，究竟该如何确定是放到rAF，还是放到requestIdleCallback？——所以这里有了调度器，通过它可以对任务进行优先级划分。</p>
<h2 id="调度-调度器的意义"><a href="#调度-调度器的意义" class="headerlink" title="调度:调度器的意义"></a>调度:调度器的意义</h2><p>这里我们继续上一小结的话题继续伸延。</p>
<p>在旧版本(v16之前)的里面，render是一个递归的调用，一个组件的更新会引起下级所有组件的重新计算和渲染。</p>
<p>由于渲染会占据主线程(这是宏任务和微任务的范畴了)，当这个计算时间超过一定长度(60Hz显示器上是16.67ms)时候，用户就会有卡顿的感觉。</p>
<p>这在需要即时响应用户输入并输出到屏幕的场景特别明显。</p>
<p>针对这个问题，有两个难题需要去解决</p>
<ul>
<li>一是受制于微任务(render|update)长时间占据主线程，使得浏览器无法对页面进行重新渲染，导致页面卡顿。</li>
<li>二是优先级。微任务耗时可以通过任务分解的方式解决，但是分解之后，任务之间优先级如何安排则是一个问题。 </li>
</ul>
<h3 id="React的解决方案"><a href="#React的解决方案" class="headerlink" title="React的解决方案"></a>React的解决方案</h3><ul>
<li>**Concurrent React (或Time Slicing)**。上一小节介绍过它了。</li>
<li>**Scheduler(调度器)**。它将任务优先级设定了优先级。<ul>
<li><strong>Immediate</strong>。立刻执行</li>
<li><strong>UserBlocking</strong>。250ms timeout，响应用户界面。</li>
<li><strong>Normal</strong>。5s timeout，不是必须立刻响应用户的更新</li>
<li><strong>Low</strong>。10s timeout，可以延迟执行，但是最终必须执行的更新。</li>
<li><strong>Idle</strong>。这个任务优先级不是很好描述，它是那种视情况进行更新的那种优先级，不是所有场景下都需要执行。比如屏幕之外的内容的更新。</li>
</ul>
</li>
</ul>
<h1 id="常规调用"><a href="#常规调用" class="headerlink" title="常规调用"></a>常规调用</h1><p>我们知道这些其实远远不够。所以这里需要看看更深入一些的东西。</p>
<p>这里首当其冲的，是React在更新阶段链表的构建、更新的标记。所以这里看看事件触发之后，这一块发生的事情。</p>
<h2 id="调用入口"><a href="#调用入口" class="headerlink" title="调用入口"></a>调用入口</h2><p>我们回顾一下之前Reconciler文章提到的事件调用栈。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dispatchInteractiveEvent</span><br><span class="line">-&gt;interactiveUpdates</span><br><span class="line">--&gt;dispatchEvent</span><br><span class="line">---&gt;performSyncWork</span><br><span class="line">----&gt;performWork</span><br><span class="line">-----&gt;performWorkOnRoot -&gt; renderRoot &amp; completeRoot</span><br></pre></td></tr></table></figure>

<p>然后展开一下performWork函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">performWork () &#123;</span><br><span class="line">    findHighestPriorityRoot()</span><br><span class="line">    performWorkOnRoot -&gt; renderRoot &amp; completeRoot</span><br><span class="line">    findHighestPriorityRoot()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中findHighestPriorityRoot能确保fiberRoot在调度中(或者是null)。</p>
<p>当然，这里是对FiberRoot上的东西进行遍历然后对比差异。</p>
<p><strong>我们还需要看看如何标记一个节点有变更。</strong></p>
<h2 id="标记变更"><a href="#标记变更" class="headerlink" title="标记变更"></a>标记变更</h2><p>这里仔细思考，实际上变更大多情况下是setState引起的。</p>
<p>不管是一个粒度非常小的组件更新内部text，还是通过redux的dispatch来更新App组件的props。实际上都是通过setState标记本身变更，然后由它进行的下级children进行的变更。</p>
<p>这里归总一下<a href="/2019/08/07/react-v16-Update-renderPhase/">《react-v16-Update renderPhase篇》</a>里面提到的setState相关。这里关联的是<code>classComponentUpdater.enqueueSetState</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">enqueueSetState</span>(<span class="params">inst, payload, callback</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 此时inst为App实例 payload=&#123;text: &#x27;Hello World&#x27;&#125; callback=undefined或setState第二参数</span></span><br><span class="line">  <span class="keyword">const</span> fiber = getInstance(inst);</span><br><span class="line">  <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line">  <span class="keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, fiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> update = createUpdate(expirationTime);</span><br><span class="line">  update.payload = payload;</span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    update.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  flushPassiveEffects(); <span class="comment">// 这个例子中这个函数什么也没做</span></span><br><span class="line">  enqueueUpdate(fiber, update);</span><br><span class="line">  scheduleWork(fiber, expirationTime);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这里很容易可以观察到update对象里面会赋值新的state值(payload参数)，如果setState传入第二参数，也会赋值给updata.callback。</p>
<p>完成之后，使用enqueueUpdate将update放到对应fiberNode上。这个函数核心部分:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (queue2 === <span class="literal">null</span> || queue1 === queue2) &#123;</span><br><span class="line">  <span class="comment">// There&#x27;s only a single queue.</span></span><br><span class="line">  <span class="comment">// 此时只有一个queue</span></span><br><span class="line">  appendUpdateToQueue(queue1, update);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// There are two queues. We need to append the update to both queues,</span></span><br><span class="line">  <span class="comment">// while accounting for the persistent structure of the list — we don&#x27;t</span></span><br><span class="line">  <span class="comment">// want the same update to be added multiple times.</span></span><br><span class="line">  <span class="comment">// 此时有两个更新队列。我们需要将update操作同时添加到每个队列上</span></span><br><span class="line">  <span class="comment">// 但是考虑到更新队列的持久化结构 我们不希望相同的update被添加多次</span></span><br><span class="line">  <span class="keyword">if</span> (queue1.lastUpdate === <span class="literal">null</span> || queue2.lastUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// One of the queues is not empty. We must add the update to both queues.</span></span><br><span class="line">    <span class="comment">// 如果两个queue钟有其中一个队列是空的 那么将这个update加到两个queue队列上</span></span><br><span class="line">    appendUpdateToQueue(queue1, update);</span><br><span class="line">    appendUpdateToQueue(queue2, update);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Both queues are non-empty. The last update is the same in both lists,</span></span><br><span class="line">    <span class="comment">// because of structural sharing. So, only append to one of the lists.</span></span><br><span class="line">    <span class="comment">// 如果他们都不是空的。最后一个update在两个队列中则是相同的 因为structural sharing</span></span><br><span class="line">    <span class="comment">// 所以将update加入到其中一个队列就可以了。这里将update加入到了queue1 但是却将queue2.lastUpdate指向了update</span></span><br><span class="line">    appendUpdateToQueue(queue1, update);</span><br><span class="line">    <span class="comment">// But we still need to update the `lastUpdate` pointer of queue2.</span></span><br><span class="line">    queue2.lastUpdate = update;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说白了核心调用是appendUpdateToQueue。主要就是讲update添加到fiber.updateQueue或者fiber.alternate。updateQueue两个链表上。</p>
<p>当这些处理完毕之后，使用scheduleWork(fiber, expirationTime)进行任务调度，开始遍历fiberNode链表。</p>
<p>但是这里我们假设setState进而引发了一个新的组件的props变化。它会发生什么？这里往下走一走逻辑，观察调用栈:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scheduleWork</span><br><span class="line">-&gt;requestWork(fiberNode, rootExpirationTime)</span><br></pre></td></tr></table></figure>

<p>这里requestWork有三个调用分支</p>
<ul>
<li>performWorkOnRoot(root, Sync, false)</li>
<li>performSyncWork() === performWork(Sync, false) </li>
<li>scheduleCallbackWithExpirationTime(root, expirationTime)</li>
</ul>
<p>这里performSyncWork这个和开头提到的『调用入口一致』，最终还是到了performWorkOnRoot。前面两个都是同步的处理。</p>
<p>scheduleCallbackWithExpirationTime则是异步的处理，核心是对<code>scheduleDeferredCallback(performAsyncWork, &#123;timeout&#125;)</code>的调用。这个函数指向<code>Scheduler.unstable_scheduleWork</code>,他根据回调和超时时间生成了一个callbackNode,加入到链表并返回。</p>
<p>所以分为同步和异步两种情况来讲。</p>
<h3 id="同步路径"><a href="#同步路径" class="headerlink" title="同步路径"></a>同步路径</h3><p>这里performWorkOnRoot的宏观理解需要理解链表是如何模拟树遍历的，这必须优先理解。这块着重理解之前的render篇里面的『遍历理论』就可以了。</p>
<blockquote>
<p>但是不要忽略，performWorkOnRoot必然从fiberRoot开始。</p>
</blockquote>
<p>微观上来讲的话，就必须看<code>workLoop -&gt; beginWork + completeUnitOfWork</code>。他负责每个fiberNode节点具体处理。</p>
<p>因为这里关注点主要是调度，所以就不考虑初始渲染情况下根据全新VDOM节点构建fiberNode链表的情况。这里需要关注再更新环节它的处理。</p>
<h4 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h4><p>beginWork要操作的组件类型过多，这里仅仅就HostRoot(fiberRoot) &amp; HostComponent &amp; ClassComponent做一些共性说明。</p>
<ul>
<li><p>HostComponent处理的入口函数是updateHostComponent，它主要执行<code>reconcileChildren(args) &amp;&amp; return workInProgress.child</code>。</p>
</li>
<li><p>ClassComponent的入口函数式updateClassComponent，它在这里场景下，主要通过updateClassInstance判断是否更新，在这场判断过程中，它调用了componentWillReceiveProps，根据workInProgress上的updateQueue、props、lifecyclesHooks更新了stateNode属性，也就是组件实例 新的props之类都在这个stateNode上保存起来了。当然最重要的，是更新了updateQueue链表。</p>
</li>
</ul>
<p>完毕之后返回finishClassComponent返回值。finishClassComponent检测到变化后，主要调用则如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">nextChildren = instance.render(); <span class="comment">// 更新后的实例，render执行会返回一个VDOM树</span></span><br><span class="line">reconcileChildren( <span class="comment">// reconcileChildren等价于ChildReconciler(true)</span></span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    nextChildren,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里的reconcileChildren实际上就是和HostComponent分支这里的处理事同一个入口了。</p>
<p>这里更细致的细节，参见之前提到的文章<a href="/2019/08/07/react-v16-ChildReconciler/">《react-v16-ChildReconciler》</a>。这里不再做赘述，但是有一些基于它的细节却必须说一下。</p>
<p>reconcileChildren这里实质上只有两种处理逻辑，当它的child是单节点时候按单节点处begininWork + completeUnitOfWork，他负责单个fiberNode节点具体处理，如果有多个节点，那么它就按数组方式处理。但是无论怎样，它只处理自己VDOM树结构下一层对应fiberNode。</p>
<p>更深层次的fiberNode，自然有workLoop函数继续调用beginWork处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">workInProgress: Fiber</span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试完成当前的工作单元，然后转到下一个兄弟fiberNode。</span></span><br><span class="line">  <span class="comment">// 如果没有兄弟姐妹，请返回父fiberNode。</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = workInProgress.alternate;</span><br><span class="line">    <span class="keyword">const</span> returnFiber = workInProgress.return;</span><br><span class="line">    <span class="keyword">const</span> siblingFiber = workInProgress.sibling;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((workInProgress.effectTag &amp; Incomplete) === NoEffect) &#123;</span><br><span class="line">      <span class="comment">// 只会返回Suspense 或者 null</span></span><br><span class="line">      nextUnitOfWork = completeWork(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        nextRenderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Completing this fiber spawned new work. Work on that next.</span></span><br><span class="line">        <span class="keyword">return</span> nextUnitOfWork;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 注意此时nextUnitOfWork === null</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        returnFiber !== <span class="literal">null</span> &amp;&amp; (returnFiber.effectTag &amp; Incomplete) === NoEffect</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// 将workInProgress 挂到父节点的side-effect链表上</span></span><br><span class="line">        <span class="keyword">if</span> (returnFiber.firstEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">          returnFiber.firstEffect = workInProgress.firstEffect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (workInProgress.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (returnFiber.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;</span><br><span class="line">          &#125;</span><br><span class="line">          returnFiber.lastEffect = workInProgress.lastEffect;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 按siblingFiber、returnFiber、null顺序返回。如果returnFiber 重新开始前面任务</span></span><br><span class="line">      <span class="comment">// 这意味着: 任务在不断往上伸展，节点上的effects都挂载到父fiberNode上了。</span></span><br><span class="line">      <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If there is more work to do in this returnFiber, do that next.</span></span><br><span class="line">        <span class="keyword">return</span> siblingFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If there&#x27;s no more work in this returnFiber. Complete the returnFiber.</span></span><br><span class="line">        workInProgress = returnFiber;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We&#x27;ve reached the root.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="completeUnitOfWork-标记变更"><a href="#completeUnitOfWork-标记变更" class="headerlink" title="completeUnitOfWork: 标记变更"></a>completeUnitOfWork: 标记变更</h4><p>这个函数在beginWork强大的功能面前可能容易被忽略。但是它做的事情却并非那么容易让人忽视。<br>我们已经知道，v16的更新统一从FiberRoot起，那么问题来了，如果全部从头到尾的进行遍历，岂不是太费劲而且不必要？所以我们需要一个变更节点列表，以便进行更新时候只更新它们。<br>这就是这个函数的作用。它里面有一些核心的调用。这里做一些说明。</p>
<ul>
<li>首先是处理完毕后对fiberNode做一些属性更新，捕获boundary错误之类。</li>
<li>其次，从底部往上遍历，将子节点上的effects链到父节点上，这样，最终我们到fiberRoot节点就有一个完整的side-effects链表了。</li>
</ul>
<h4 id="变更引用"><a href="#变更引用" class="headerlink" title="变更引用"></a>变更引用</h4><p>这里直接上之前提到的代码吧：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">workInProgress: Fiber</span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 略    </span></span><br><span class="line">  next = beginWork(current, workInProgress, nextRenderExpirationTime);</span><br><span class="line">  workInProgress.memoizedProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    next = completeUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">  ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次当beginWork结束，都会执行一个<code>completeUnitOfWork(workInProgress)</code>。在这个函数中，有一个引用：</p>
<p><code>resetChildExpirationTime(workInProgress, nextRenderExpirationTime)</code>。</p>
<p>这个函数批量更新了后续所有fiberNode的child节点上的ExpirationTime。</p>
<p>再往上一点说，workLoop上面是renderRoot,renderRoot上面还有performWorkOnRoot，而在这个函数里面，renderRoot结束之后，会执行completeRoot函数。<br>这个函数就是render commitphase环节的入口级调用。<br>然后这里就到了之前Update篇之commitPhase环节了。这里直接上代码了(commitRoot)。主要是side-effects的遍历处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// commit tree中所有的side-effects。这里分两个步骤</span></span><br><span class="line"><span class="comment">// 这里是第一个步骤:执行所有host的插入、更新、删除和ref卸载(注意后面第二个步骤)</span></span><br><span class="line">nextEffect = firstEffect;</span><br><span class="line">startCommitHostEffectsTimer();</span><br><span class="line"><span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> didError = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> error;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123; &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            commitAllHostEffects();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            didError = <span class="literal">true</span>;</span><br><span class="line">            error = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (didError) &#123; <span class="comment">/* 错误捕获并将指针移动到下一个Effect */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步逻辑"><a href="#异步逻辑" class="headerlink" title="异步逻辑"></a>异步逻辑</h3><h4 id="scheduleCallbackWithExpirationTime"><a href="#scheduleCallbackWithExpirationTime" class="headerlink" title="scheduleCallbackWithExpirationTime"></a>scheduleCallbackWithExpirationTime</h4><p>这里的异步处理，实际上上面已经简单提到过了。</p>
<p>scheduleCallbackWithExpirationTime是异步的处理，核心是对<code>scheduleDeferredCallback(performAsyncWork, &#123;timeout&#125;)</code>的调用。这个函数指向<code>Scheduler.unstable_scheduleCallback</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_scheduleCallback</span>(<span class="params">callback, deprecated_options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> startTime =</span><br><span class="line">    currentEventStartTime !== -<span class="number">1</span> ? currentEventStartTime : getCurrentTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> expirationTime;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> deprecated_options === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">    deprecated_options !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> deprecated_options.timeout === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> Remove this branch once we lift expiration times out of React.</span></span><br><span class="line">    expirationTime = startTime + deprecated_options.timeout;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPriorityLevel) &#123;</span><br><span class="line">      <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">        expirationTime = startTime + USER_BLOCKING_PRIORITY;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IdlePriority:</span><br><span class="line">        expirationTime = startTime + IDLE_PRIORITY;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> LowPriority:</span><br><span class="line">        expirationTime = startTime + LOW_PRIORITY_TIMEOUT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NormalPriority:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 生成一个节点， 存储回调函数和超时时间</span></span><br><span class="line">  <span class="keyword">var</span> newNode = &#123;</span><br><span class="line">    callback,</span><br><span class="line">    priorityLevel: currentPriorityLevel,</span><br><span class="line">    expirationTime,</span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">    previous: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 排序插入</span></span><br><span class="line">  <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里核心地方就2个，第一个，根据任务优先级获取不同的expirationTime，第二个，根据expirationTime生成任务节点，排序插入链表。</p>
<p>我们这里忽略了排序细节，不过需要说的是，当我们排序完毕，会有一个<code>ensureHostCallbackIsScheduled</code>函数会被执行。这个函数用来对任务进行执行。</p>
<p>这里的调用在排序逻辑中有两种情况:</p>
<ul>
<li>原链表为空，所加入的节点为唯一节点，此时立即执行</li>
<li>新节点取代旧的firstNode节点成为新的firstNode节点时候，此时立即执行</li>
</ul>
<p>它对应着两个分支逻辑: 只有一个节点的情况，执行任务；新节点有最高优先级，需要停止继续执行任务转而重新执行任务。它的意义在于，在合适的时候，开始执行任务。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureHostCallbackIsScheduled</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isExecutingCallback) &#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t schedule work yet; wait until the next time we yield.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> expirationTime = firstCallbackNode.expirationTime;</span><br><span class="line">  <span class="keyword">if</span> (!isHostCallbackScheduled) &#123; <span class="comment">// 此时仅有一个节点</span></span><br><span class="line">    isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 新节点有最高优先级，需要停止继续执行任务</span></span><br><span class="line">    <span class="comment">// Cancel the existing host callback.</span></span><br><span class="line">    cancelHostCallback();</span><br><span class="line">  &#125;</span><br><span class="line">  requestHostCallback(flushWork, expirationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个requestHostCallback函数，源码里面做了好几个环境分支，比如jest分支，jscore分支，最后才是常规的浏览器环境分支。我们来看看里面大致细节：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line"><span class="keyword">var</span> port = channel.port2;</span><br><span class="line">channel.port1.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 细节略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animationTick = <span class="function"><span class="keyword">function</span>(<span class="params">rafTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 细节略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">requestHostCallback = <span class="function"><span class="keyword">function</span>(<span class="params">callback, absoluteTimeout</span>) </span>&#123;</span><br><span class="line">  scheduledHostCallback = callback;</span><br><span class="line">  timeoutTime = absoluteTimeout;</span><br><span class="line">  <span class="keyword">if</span> (isFlushingHostCallback || absoluteTimeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    port.postMessage(<span class="literal">undefined</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">    isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">    requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码有点长，删了细节，只保留了主干。它其实就是requestIdleCallback的的pollyfill而已。这里原理环节可参考前面。</p>
<p><strong>但是这里有一些相互的调用，还是得说明白。</strong></p>
<p>首先是<code>animationTick</code>函数。这个函数在每一帧开始的rAF里面的回调，当有任务时候，需要进行递归执行<code>requestAnimationFrameWithTimeout(animationTick)</code>。它核心的作用是对frameDeadline变量进行累加，计算出当前帧的截止时间: 截止时间 = 开始时间 + 渲染时间。</p>
<blockquote>
<p>渲染时间默认为33ms，这是为了保证每秒30帧(30Hz)的计算出来的(1000/30)。源码里面有一个对这个值进行优化的逻辑，因为不是重点，这里且就认为它是33ms。</p>
</blockquote>
<p>当<code>animationTick</code>执行到尾部，会执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// isMessageEventScheduled默认为false。进入animationTick后设为true</span></span><br><span class="line"><span class="comment">// 所以不会连续两次rAF调用port.postMessage。</span></span><br><span class="line"><span class="comment">// 后面port1.onmessage进入后其值为false，可以重新rAF进来。</span></span><br><span class="line"><span class="comment">// 保证了rAF和requestIdleCallback的间歇调用</span></span><br><span class="line"><span class="keyword">if</span> (!isMessageEventScheduled) &#123;</span><br><span class="line">    isMessageEventScheduled = <span class="literal">true</span>;</span><br><span class="line">    port.postMessage(<span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是onmessage的内容。这个函数主要是对剩余时间的利用。</p>
<ol>
<li>如果当前帧还有时间空余-&gt;当前任务已经过期-&gt;didTimeout = true立刻执行任务</li>
<li>如果当前帧还有时间空余-&gt;当前任务没过期-&gt;执行flushWork &amp;&amp; 递归调用rAF</li>
</ol>
<p>onmessage在上面两个分支处理完毕后针对这两种情况调用scheduledHostCallback函数，里面会针对这两种情况进行分支处理。</p>
<p>这个scheduledHostCallback函数呢，本质上，就是flushWork。</p>
<blockquote>
<p>isAnimationFrameScheduled变量本质上和isMessageEventScheduled变量是同一回事。</p>
</blockquote>
<h4 id="callback-flushWork"><a href="#callback-flushWork" class="headerlink" title="callback: flushWork"></a>callback: flushWork</h4><p><code>flushWork</code>函数是异步流程里面的实质上的执行者。</p>
<p>我们之前讨论了rAF-&gt;requestIdleCallback-&gt;rAF-&gt;requestIdleCallback不间断直到完成任务的流程里面，实质上就是这个这个函数在执行异步任务。</p>
<p>这个函数处理三种情况下的逻辑：</p>
<ol>
<li>任务已经超时 此时走同步逻辑，遍历执行所有已经过期任务</li>
<li>任务没过期，当前帧有时间富余 那么从队列首部以类似数组pop方法的形式挨个执行未过期的任务。</li>
<li>异步任务经过上面逻辑还有剩余，那么新开新一轮调度 &amp;&amp; 立即执行最高优先级任务</li>
</ol>
<p>逻辑一:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里明白这个队列是根据过期时间从小打大排列就可以了</span></span><br><span class="line"><span class="keyword">if</span> (didTimeout) &#123; <span class="comment">// 任务过期</span></span><br><span class="line">    <span class="comment">// Flush all the expired callbacks without yielding.</span></span><br><span class="line">    <span class="comment">// 如果任务已经过期遍历回调链表全部执行 无中断、异步</span></span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">        firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">var</span> currentTime = getCurrentTime();</span><br><span class="line">        <span class="keyword">if</span> (firstCallbackNode.expirationTime &lt;= currentTime) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                flushFirstCallback();</span><br><span class="line">            &#125; <span class="keyword">while</span> (</span><br><span class="line">                firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                firstCallbackNode.expirationTime &lt;= currentTime &amp;&amp; <span class="comment">// 要求任务已过期</span></span><br><span class="line">                !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;&#125; <span class="comment">// rAF时间富余</span></span><br></pre></td></tr></table></figure>

<p>逻辑二:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flushFirstCallback();</span><br><span class="line">    &#125; <span class="keyword">while</span> (firstCallbackNode !== <span class="literal">null</span> &amp;&amp; !shouldYieldToHost());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// shouldYieldToHost</span></span><br><span class="line">shouldYieldToHost = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> frameDeadline &lt;= getCurrentTime();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里shouldYieldToHost函数计算的，rAF deadLine时间戳是否有剩余。如果有剩余就继续执行callback链表上的节点。其他和逻辑一雷同。</p>
<p>逻辑三:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">isExecutingCallback = <span class="literal">false</span>;</span><br><span class="line">currentDidTimeout = previousDidTimeout;</span><br><span class="line"><span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// There&#x27;s still work remaining. Request another callback.</span></span><br><span class="line">  ensureHostCallbackIsScheduled();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before exiting, flush all the immediate work that was scheduled.</span></span><br><span class="line">flushImmediateWork();</span><br></pre></td></tr></table></figure>

<p>这里ensureHostCallbackIsScheduled函数在上一小节里面有，他用来唤起一个新的调度。重新走rAF-&gt;requestIdleCallback-&gt;rAF-&gt;requestIdleCallback这个流程。</p>
<p>flushImmediateWork函数则是直接把剩余的最高优先级任务一口气执行完毕。但是这里要注意到，它执行完毕之后，又开始执行ensureHostCallbackIsScheduled了。</p>
<p>考虑到函数里面这样一个调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">        ensureHostCallbackIsScheduled();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当所有的异步任务都执行完毕，<code>isHostCallbackScheduled = false</code>。</p>
<h4 id="异步的贯通"><a href="#异步的贯通" class="headerlink" title="异步的贯通"></a>异步的贯通</h4><p>和同步不同，异步本身更加复杂。前面讨论了很多很多东西，但是都没有把整个逻辑贯通成环，这样也就无法在宏观上理解这个环节。</p>
<p>所以这一小节的目标是：基于之前的诠释，贯通这个流程。</p>
<p>但是这里必须知道，脱离实际使用去讲原理是不可能的事情，我们说同步可以默认看之前都知道，但是异步这块不行，所以有后面的案例和分析。</p>
<h1 id="异步案例-amp-分析"><a href="#异步案例-amp-分析" class="headerlink" title="异步案例&amp;分析"></a>异步案例&amp;分析</h1><p>注意，这里我在使用用例上根据v16.9做了部分更新。但是实际分析暂时还是使用的16.8.6的源码。</p>
<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>首先是外部容器的处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; v16.8是这种写法 但是注意 16.9有更新</span><br><span class="line">ReactDOM.render((</span><br><span class="line">&lt;React.unstable_ConcurrentMode&gt;</span><br><span class="line">	&lt;App &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;React.unstable_ConcurrentMode&gt;</span><br><span class="line">), document.getElementById(&quot;root&quot;))</span><br><span class="line">&#x2F;&#x2F; v16.9的写法 这里废弃了unstable_ConcurrentMode</span><br><span class="line">const root &#x3D; ReactDOM.unstable_createRoot(container);</span><br><span class="line">root.render(&lt;App &#x2F;&gt;, container);</span><br></pre></td></tr></table></figure>

<p>这里是加了一个<code>React.unstable_ConcurrentMode</code>容器。</p>
<blockquote>
<p>关于v16.8这个容器，根据Fiber链表结构，它是第二个FiberNode。它是走的createFiberFromMode函数创建的。不过我看了一下v16.9的逻辑，它这里直接将第一个和第二个节点直接融合为一个了。操作办法就是将FiberRoot的mode设为 ConcurrentRoot。</p>
</blockquote>
<p>其次是api调用。</p>
<p>初步的优化，是使用unstable_next将用户交互的优先级保障起来，将后续更新优先级降低，相当于强制提升了用户交互的优先级。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; unstable_next &#125; <span class="keyword">from</span> <span class="string">&quot;scheduler&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SearchBox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [inputValue, setInputValue] = React.useState();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleChange</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = event.target.value;</span><br><span class="line"></span><br><span class="line">    setInputValue(value);</span><br><span class="line">    unstable_next(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      props.onChange(value);</span><br><span class="line">      sendAnalyticsNotification(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;inputValue&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看看这个函数是怎样做的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_next</span>(<span class="params">eventHandler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> priorityLevel;</span><br><span class="line">  <span class="keyword">switch</span> (currentPriorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">    <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">    <span class="keyword">case</span> NormalPriority:</span><br><span class="line">      <span class="comment">// Shift down to normal priority</span></span><br><span class="line">      priorityLevel = NormalPriority;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// Anything lower than normal priority should remain at the current level.</span></span><br><span class="line">      priorityLevel = currentPriorityLevel;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  <span class="keyword">var</span> previousEventStartTime = currentEventStartTime;</span><br><span class="line">  currentPriorityLevel = priorityLevel;</span><br><span class="line">  currentEventStartTime = getCurrentTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> eventHandler();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    currentEventStartTime = previousEventStartTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before exiting, flush all the immediate work that was scheduled.</span></span><br><span class="line">    flushImmediateWork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先级的处理"><a href="#优先级的处理" class="headerlink" title="优先级的处理"></a>优先级的处理</h2><p>关于currentPriorityLevel。我们彻底追踪一下调用栈。这个调用起于dispatchInteractiveEvent函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dispatchInteractiveEvent</span><br><span class="line">-&gt;dispatchEvent</span><br><span class="line">--&gt;interactiveUpdates</span><br><span class="line">---&gt;dispatchEvent</span><br><span class="line">...</span><br><span class="line">-----&gt;unstabel_next</span><br></pre></td></tr></table></figure>

<p>这里初始的定义是在interactiveUpdates函数里面(packages/react-reconciler/src/ReactFiberScheduler.js:)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interactiveUpdates</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">R</span>&gt;(<span class="params">fn: (A, B) =&gt; R, a: A, b: B</span>): <span class="title">R</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !isBatchingUpdates &amp;&amp;</span><br><span class="line">    !isRendering &amp;&amp;</span><br><span class="line">    lowestPriorityPendingInteractiveExpirationTime !== NoWork</span><br><span class="line">  ) &#123;</span><br><span class="line">    performWork(lowestPriorityPendingInteractiveExpirationTime, <span class="literal">false</span>);</span><br><span class="line">    lowestPriorityPendingInteractiveExpirationTime = NoWork;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> previousIsBatchingUpdates = isBatchingUpdates;</span><br><span class="line">  isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> runWithPriority(UserBlockingPriority, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn(a, b);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isBatchingUpdates = previousIsBatchingUpdates;</span><br><span class="line">    <span class="keyword">if</span> (!isBatchingUpdates &amp;&amp; !isRendering) &#123;</span><br><span class="line">      performSyncWork();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之，有runWithPriority这个调用在，这里事件相关的回调优先级都是UserBlockingPriority。</p>
<p>所以当我们运行到unstable_next，这里priorityLevel会被强制调整为UserBlockingPriority。这和<a href="https://philippspiess.com/scheduling-in-react/">《Scheduling in React》</a>里面提到的一样。</p>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>当我们标记完成了优先级，就要开始干活了，这里运行的是<code>flushImmediateWork()</code>。这是从unstable_next函数中try…finally的finally代码块里面来的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushImmediateWork</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// Confirm we&#x27;ve exited the outer most event handler</span></span><br><span class="line">    currentEventStartTime === -<span class="number">1</span> &amp;&amp;</span><br><span class="line">    firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    firstCallbackNode.priorityLevel === ImmediatePriority</span><br><span class="line">  ) &#123;</span><br><span class="line">    isExecutingCallback = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        flushFirstCallback(); <span class="comment">// 执行第一个回调</span></span><br><span class="line">      &#125; <span class="keyword">while</span> (</span><br><span class="line">        <span class="comment">// 如果回调链表第一个不是null 且优先级为ImmediatePriority</span></span><br><span class="line">        firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        firstCallbackNode.priorityLevel === ImmediatePriority</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isExecutingCallback = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// There&#x27;s still work remaining. Request another callback.</span></span><br><span class="line">        ensureHostCallbackIsScheduled();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行第一个回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushFirstCallback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flushedNode = firstCallbackNode;</span><br><span class="line">  <span class="comment">// 将回调节点从链表中拿出来。这样即时出错了也能保持一致。否则结束再移除会导致不一致问题</span></span><br><span class="line">  <span class="keyword">var</span> next = firstCallbackNode.next;</span><br><span class="line">  <span class="keyword">if</span> (firstCallbackNode === next) &#123;</span><br><span class="line">    firstCallbackNode = <span class="literal">null</span>;</span><br><span class="line">    next = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lastCallbackNode = firstCallbackNode.previous;</span><br><span class="line">    firstCallbackNode = lastCallbackNode.next = next;</span><br><span class="line">    next.previous = lastCallbackNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  flushedNode.next = flushedNode.previous = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以安全执行回调了</span></span><br><span class="line">  <span class="keyword">var</span> callback = flushedNode.callback;</span><br><span class="line">  <span class="keyword">var</span> expirationTime = flushedNode.expirationTime;</span><br><span class="line">  <span class="keyword">var</span> priorityLevel = flushedNode.priorityLevel;</span><br><span class="line">  <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  <span class="keyword">var</span> previousExpirationTime = currentExpirationTime;</span><br><span class="line">  currentPriorityLevel = priorityLevel;</span><br><span class="line">  currentExpirationTime = expirationTime;</span><br><span class="line">  <span class="keyword">var</span> continuationCallback;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    continuationCallback = callback();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    currentExpirationTime = previousExpirationTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回调执行后可能返回的还是一个函数，此时继续以相同优先级调用它 </span></span><br><span class="line">  <span class="comment">// 代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们必须注意，优先调用并不会引起最终结果的变化。</p>
<p>倘若我们正常的更新顺序是A-&gt;B-&gt;C-&gt;D。优化之后，我们的B变成优先级最高了之后，B会被最先执行一次。到了后面再执行时候，我们的firstUpdate会指向A，A的next指向B，所以会重复执行ABCD。</p>
<p>这也是为什么componentWillMount现在会被调用多次。</p>
<blockquote>
<p>例子: 正常流程A-&gt;B-&gt;C-&gt;D。优化后更高优先级A&amp;C。当优先执行完毕再次开始新的流程时候，firstUpdate指向B, 会执行BCD。 </p>
</blockquote>
<p>当我们将最高优先级ImmediatePriority弄完之后，我们可以开始执行低它一级的优先级任务(UserBlockingPriority)了。这个任务流的启动，由ImmediatePriority来启动。这源于之前我们已经提到的一段结论。这里直接引用一下，如果忘了可以回头看看唤起回忆。</p>
<blockquote>
<p>flushImmediateWork函数则是直接把剩余的最高优先级任务一口气执行完毕。但是这里要注意到，它执行完毕之后，又开始执行ensureHostCallbackIsScheduled了。</p>
</blockquote>
<p>结合之前提到的，我们可以明白这里就开始进行rAF-&gt;requestIdleCallback-&gt;rAF-&gt;requestIdleCallback流程了，直到callback链表为空。</p>
<h2 id="最高优先级之后"><a href="#最高优先级之后" class="headerlink" title="最高优先级之后"></a>最高优先级之后</h2><p>这里接着上面说最高优先级之后发生的事情。</p>
<p>当我们走出了这个rAF-&gt;requestIdleCallback-&gt;rAF-&gt;requestIdleCallback互相调用直至回调列表为空的流程。此时核心就是requestIdleCallback函数的执行，rAF相当于一个足够敏感的定时器。</p>
<p>这个requestIdleCallback函数主要是对剩余时间的利用(这里不明白可以继续回头看之前的小结)。</p>
<ol>
<li>如果当前帧还有时间空余-&gt;当前任务已经过期-&gt;didTimeout = true立刻执行任务</li>
<li>如果当前帧还有时间空余-&gt;当前任务没过期-&gt;执行flushWork &amp;&amp; 递归调用rAF</li>
</ol>
<p>所以这里核心还是在flushWork函数上。</p>
<p>这个函数处理三种情况下的逻辑：</p>
<ol>
<li>任务已经超时 此时走同步逻辑，遍历执行所有已经过期任务</li>
<li>任务没过期，当前帧有时间富余 那么从队列首部以类似数组pop方法的形式挨个执行未过期的任务。</li>
<li>异步任务经过上面逻辑还有剩余，那么新开新一轮调度 &amp;&amp; 立即执行最高优先级任务</li>
</ol>
<p>这里我们例子中的代码是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setInputValue(value);</span><br><span class="line">unstable_next(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    props.onChange(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>意思是对更新做了切割，先将Input里面的东西渲染好。然后开始更新ListItem高亮情况，这里的更新就是异步的更新了。当任务进入回调队列(由<code>props.onChange(value)</code>引起)，整个长耗时的渲染会被React分帧走renderPhase &amp; commitPhase,整个页面可以保持流畅帧率而不卡顿。</p>
<h2 id="更低的优先级"><a href="#更低的优先级" class="headerlink" title="更低的优先级"></a>更低的优先级</h2><p>我们上面分析时候已经有了提及。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">runWithPriority(UserBlockingPriority, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a, b);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果想要更低的优先级，则可以参考这个写法。再之前提到的文章中，它是这样操作的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendDeferredAnalyticsPing</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  unstable_runWithPriority(unstable_LowPriority, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    unstable_scheduleCallback(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      sendAnalyticsPing(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和React内部调用比较一致。不过个人感觉这个API等正式发布，可能后面会单独有个封装的API，不然这样使用相对麻烦，而且暴露内部API可能不像React的风格。</p>
<p>结合我们之前的代码(完整例子参见<a href="https://github.com/philipp-spiess/scheduletron3000">scheduletron3000</a>)。这里输入关键词之后，随后要将很多个ListItem符合关键词的全部高亮。当我们输入一个关键词，首先要将输入到关键词显示到Input中，这是一个unstable_LowPriority执行优先级任务，会被优先执行。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章:"></a>参考文章:</h1><p>这一篇从开头到结尾实在挺不容易，参考了众多的文章去弥补自己未知的地方。</p>
<p>这里至以诚挚谢意。</p>
<p><a href="https://philippspiess.com/scheduling-in-react/">Scheduling in React</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/60307571">深入剖析 React Concurrent</a></p>
<p><a href="https://www.404forest.com/2016/08/15/%E4%BD%BF%E7%94%A8%20requestAnimationFrame%20%E5%AE%9E%E7%8E%B0%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%87%92%E6%89%A7%E8%A1%8C/">使用 requestAnimationFrame 实现性能优化与懒执行</a></p>
<p><a href="https://juejin.im/post/5ad71f39f265da239f07e862">你应该知道的requestIdleCallback</a></p>
<p><a href="https://juejin.im/post/5c32c0c86fb9a049b7808665">React Scheduler 源码详解（1）</a></p>
<p><a href="https://juejin.im/post/5c61197ff265da2d9e173337">React Scheduler 源码详解（2）</a></p>
]]></content>
      <tags>
        <tag>React Scheduling</tag>
      </tags>
  </entry>
  <entry>
    <title>react-v16-Reconciler和Diff算法</title>
    <url>/2019/08/14/react-v16-Reconciler-Diff/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面几篇重点分析了Render &amp; Update, 乃至Fiber链的构建细节。这里就有余地去分析V16的Diff算法是如何实现了。根据之前的Update两篇分析，可以很容易知道这个Diff集中在了render phase, 而随后的commit phase实际上就是patch这个Diff的过程。</p>
<p>回顾之前v15的diff算法，因为其Tree结构的缘故，一旦理解了之后，对其Component Diff、Tree Diff、Element Diff算是印象深刻。这里需要循着它的思路，参考更新的render phase来深入理解这个Diff有什么变化。</p>
<p>但是之前的例子也相对简单，为了Diff分析的全面，也不能简单直接循着它的思路，总之这是一个入乎其内，又出其外的过程。相应的，<strong>这篇主要是关注Diff流程</strong>，对Update的分析，一切以它为目标。</p>
<p>所以这里每个函数的分析，都要和Diff有联系，但是又要在之前Update篇上有进一步的深度。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这里还是顺着前文的Event调用栈来说。以下是触发事件过程中的调用栈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dispatchInteractiveEvent</span><br><span class="line">-&gt;interactiveUpdates</span><br><span class="line">--&gt;dispatchEvent</span><br><span class="line">---&gt;performSyncWork</span><br><span class="line">----&gt;performWork</span><br><span class="line">-----&gt;performWorkOnRoot -&gt; renderRoot &amp; completeRoot</span><br></pre></td></tr></table></figure>

<p>这里对performWork做点扩展</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">performWork () &#123;</span><br><span class="line">    findHighestPriorityRoot()</span><br><span class="line">    performWorkOnRoot -&gt; renderRoot &amp; completeRoot</span><br><span class="line">    findHighestPriorityRoot()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="findHighestPriorityRoot"><a href="#findHighestPriorityRoot" class="headerlink" title="findHighestPriorityRoot"></a>findHighestPriorityRoot</h2><p>这个函数有两个作用，一个是无效节点从链表移除，再一个是返回最终优先节点。</p>
<blockquote>
<p>Tips: 这一小节在ReactDom环境下，其实偏废话，不愿意看可以直接拉到小结。</p>
</blockquote>
<h3 id="无效节点清除"><a href="#无效节点清除" class="headerlink" title="无效节点清除"></a>无效节点清除</h3><p>这个findHighestPriorityRoot函数需要比照之前的Update-RenderPhase来看。因为它这里涉及了firstScheduledRoot、lastScheduledRoot、root.nextScheduledRoot的赋值。所以简述一下它内部逻辑。但是这之前必须先看看另外一个函数addRootToSchedule:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addRootToSchedule</span>(<span class="params">root: FiberRoot, expirationTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查这个fiber节点是否已经是schedule的一部分: </span></span><br><span class="line">  <span class="keyword">if</span> (root.nextScheduledRoot === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// root.nextScheduledRoot === null 说明还没有加入 这里加入它</span></span><br><span class="line">    root.expirationTime = expirationTime;</span><br><span class="line">    <span class="keyword">if</span> (lastScheduledRoot === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// lastScheduledRoot为空 将这个fiber设为[first|last]ScheduledRoot</span></span><br><span class="line">      <span class="comment">// root.nextScheduledRoot也设为自身 这只在仅有一个更新fiber发生</span></span><br><span class="line">      firstScheduledRoot = lastScheduledRoot = root;</span><br><span class="line">      root.nextScheduledRoot = root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则 将lastScheduledRoot下一个链表设为这个root 然后将root设为最后一个(实质是添加一个元素到链表尾部)</span></span><br><span class="line">      <span class="comment">// 并将这个root的nextScheduledRoot设置到firstScheduledRoot</span></span><br><span class="line">      lastScheduledRoot.nextScheduledRoot = root;</span><br><span class="line">      lastScheduledRoot = root;</span><br><span class="line">      lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这个root已经在schedule里面 但是可能有属性变化</span></span><br><span class="line">    <span class="keyword">const</span> remainingExpirationTime = root.expirationTime;</span><br><span class="line">    <span class="keyword">if</span> (expirationTime &gt; remainingExpirationTime) &#123;</span><br><span class="line">      <span class="comment">// 更新时间 以便后面它能被更新</span></span><br><span class="line">      root.expirationTime = expirationTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们继续下面的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findHighestPriorityRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> highestPriorityWork = NoWork;</span><br><span class="line">  <span class="keyword">let</span> highestPriorityRoot = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 这说明之前至少已经有个更新了 所以至少有一个需要操作的fiber节点</span></span><br><span class="line">  <span class="comment">// 这里配合addRootToSchedule函数要去理解</span></span><br><span class="line">  <span class="keyword">if</span> (lastScheduledRoot !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> previousScheduledRoot = lastScheduledRoot;</span><br><span class="line">    <span class="keyword">let</span> root = firstScheduledRoot;</span><br><span class="line">    <span class="comment">// 这里是一个循环 它会遍历所有root.nextScheduledRoot</span></span><br><span class="line">    <span class="comment">// 直到nextFlushedRoot &amp; nextFlushedExpirationTime得到合理赋值</span></span><br><span class="line">    <span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> remainingExpirationTime = root.expirationTime;</span><br><span class="line">      <span class="keyword">if</span> (remainingExpirationTime === NoWork) &#123;</span><br><span class="line">        <span class="comment">// 进入这个分支 说明这个fiber节点没有事情要做了 将其从scheduler里面移除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里配合addRootToSchedule函数要去理解</span></span><br><span class="line">        <span class="keyword">if</span> (root === root.nextScheduledRoot) &#123;</span><br><span class="line">          <span class="comment">// 判断是否仅有的 第一个 初始 更新 然后跳出while</span></span><br><span class="line">          <span class="comment">// 因为只有一个更新就不需要考虑后面还有更高优先级 这个fiberNode本身就是</span></span><br><span class="line">          <span class="comment">// 因为此时是要移除 所以仅仅将其赋值null就完事了 可以break了</span></span><br><span class="line">          root.nextScheduledRoot = <span class="literal">null</span>;</span><br><span class="line">          firstScheduledRoot = lastScheduledRoot = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root === firstScheduledRoot) &#123;</span><br><span class="line">          <span class="comment">// 将第一个元素从链表顶部移除 并设定root.nextScheduledRoot = null</span></span><br><span class="line">          <span class="comment">// 这个操作会因为while继续循环 直到 lastScheduledRoot.nextScheduledRoot!== null</span></span><br><span class="line">          <span class="keyword">const</span> next = root.nextScheduledRoot;</span><br><span class="line">          firstScheduledRoot = next;</span><br><span class="line">          lastScheduledRoot.nextScheduledRoot = next;</span><br><span class="line">          root.nextScheduledRoot = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root === lastScheduledRoot) &#123;</span><br><span class="line">          <span class="comment">// 此时遍历到尾部了 而且并非唯一节点(因为没有进入第一个分支) 此时是这里最后一次进while</span></span><br><span class="line">          <span class="comment">// 将lastScheduledRoot.nextScheduledRoot重置为firstScheduledRoot完成圆形闭环</span></span><br><span class="line">          lastScheduledRoot = previousScheduledRoot;</span><br><span class="line">          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;</span><br><span class="line">          root.nextScheduledRoot = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 这是链表中间节点的操作 从链表中移除一个中间节点 </span></span><br><span class="line">          <span class="comment">// 此时给previousScheduledRoot.next赋值root.next,实质上是在为while里面</span></span><br><span class="line">          <span class="comment">// 的root赋值(root = previousScheduledRoot.nextScheduledRoot)</span></span><br><span class="line">          previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;</span><br><span class="line">          root.nextScheduledRoot = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = previousScheduledRoot.nextScheduledRoot;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (remainingExpirationTime &gt; highestPriorityWork) &#123;</span><br><span class="line">          <span class="comment">// 如果expirationTime大于之前缓存的最大值 把这个root相关数据设为最高优先级</span></span><br><span class="line">          highestPriorityWork = remainingExpirationTime;</span><br><span class="line">          highestPriorityRoot = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root === lastScheduledRoot) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (highestPriorityWork === Sync) &#123;</span><br><span class="line">          <span class="comment">// Sync is highest priority by definition so</span></span><br><span class="line">          <span class="comment">// we can stop searching.</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        previousScheduledRoot = root;</span><br><span class="line">        root = root.nextScheduledRoot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nextFlushedRoot = highestPriorityRoot;</span><br><span class="line">  nextFlushedExpirationTime = highestPriorityWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>findHighestPriorityRoot其中一个作用就是清除所有<code>fibler.expirationTime === NoWork</code>的节点。根据addRootToSchedule定义 仔细体味，我们可以知道这个链表是圆环。</p>
<p>接下来就是相对精彩的链表清空环节。这里我们还是来举例配合代码注释来理解。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+---+      +---+      +---+</span><br><span class="line">| A +-----&gt;+ B +-----&gt;+ C |</span><br><span class="line">+-+-+      +---+      +-+-+</span><br><span class="line">  ^                     |</span><br><span class="line">  |                     v</span><br><span class="line">+-+-+      +---+      +-+-+</span><br><span class="line">| F +&lt;-----+ E +&lt;---+ | D |</span><br><span class="line">+---+      +---+      +---+</span><br></pre></td></tr></table></figure>

<p>这里A为first，F为last。然后看看<code>remainingExpirationTime === NoWork</code>里面的分支。</p>
<ul>
<li><p>只有root为last才会break跳出，其他的不会</p>
</li>
<li><p>当root为A(此时A为first)，且<code>A.expirationTime === NoWork</code>。此时：</p>
<ul>
<li><code>first = A.next = B</code></li>
<li><code>last.next = B</code></li>
<li><code>A.next = null</code></li>
</ul>
</li>
<li><p>当root为中间节点时候， 比如为<code>B.expirationTime === NoWork</code>。此时:</p>
<ul>
<li><code>previousScheduledRoot = F.next === A</code> 但是F节点还是F节点(<strong>这个需要重点理解</strong>)</li>
<li>previousScheduledRoot(A.next) = B.next = C</li>
<li>上面两步实质上就是将B从链表上丢掉了，链接了上一个和下一个链表元素</li>
<li>B.next 赋值为null</li>
</ul>
</li>
<li><p>当遍历到最终的last也就是F节点，且为无效节点时候。此时:</p>
<ul>
<li>将last赋值为E(previousScheduledRoot)</li>
<li>将E.next重新赋值first 完成圆形闭环。</li>
</ul>
</li>
</ul>
<blockquote>
<p>这一步其实其实就是链表元素的的移除操作。掌握这个数据结构还是很重要。但是其实归根结底还是逆向解读相对折腾，自己写大家应该都能写出来，然而一旦复杂起来，过几个月估计就只有上帝直到写的什么了😂</p>
</blockquote>
<blockquote>
<p>这里要注意addRootToSchedule上游调用函数scheduleWork会给他传入fiberRoot参数。所以nextFlushedRoot其实一般就是fiberRoot(一些情况下是null)。</p>
</blockquote>
<h3 id="返回优先节点"><a href="#返回优先节点" class="headerlink" title="返回优先节点"></a>返回优先节点</h3><p>相比上面复杂度链表移除操作。这个返回操作就格外简单。就是找出expirationTime最大的fiber节点。然后返回，如果遇到expirationTime === Sync的停止继续比较直接返回之前计算结果。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这个函数在Scheduled列表上清掉了无效节点，关联的核心是每个节点的nextScheduledRoot属性。通过它可以快速对多个FiberRoot进行调度，它将优先级最高的FiberRoot设为nextFlushedRoot。</p>
<p>这个nextFlushedRoot，将会在下一步中被使用。</p>
<p>关于FiberRoot这点，代码里面对类型有很明显的类型限定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Linked-list of roots</span></span><br><span class="line"><span class="keyword">let</span> firstScheduledRoot: FiberRoot | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> lastScheduledRoot: FiberRoot | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> nextFlushedRoot: FiberRoot | <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>这里很容易有一个问题是，如果都是FiberRoot为什么需要一个链表(ReactDOM仅有唯一一个FiberRoot)。</p>
<p>这是因为React不仅仅服务于ReactDOM，它还会服务于ReactNative。在ReactNative中它可能会使用不同的root scheduler, 这和ReactDom仅仅使用一个root scheduler有所不同。</p>
<p>这实质上是renderer(渲染器)和 scheduler(调度器)的分离。不过这个显然超出本篇的范围了，这里不做深入了。</p>
<p>唯一可以说的，是这一小节在ReactDom里面可能其实都是废话，它这里做的就是设nextFlushedRoot为FiberRoot而已。</p>
<h2 id="performWork"><a href="#performWork" class="headerlink" title="performWork"></a>performWork</h2><p>这个函数我们暂时关注在它同步的逻辑分支里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWork</span>(<span class="params">minExpirationTime: ExpirationTime, isYieldy: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 确保nextFlushedRoot是scheduled链表中的最高优先级fiberNode</span></span><br><span class="line">  findHighestPriorityRoot();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isYieldy) &#123;</span><br><span class="line">	<span class="comment">// 异步逻辑暂时不管</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      nextFlushedRoot !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      nextFlushedExpirationTime !== NoWork &amp;&amp;</span><br><span class="line">      minExpirationTime &lt;= nextFlushedExpirationTime</span><br><span class="line">    ) &#123;</span><br><span class="line">      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, <span class="literal">false</span>);</span><br><span class="line">      findHighestPriorityRoot();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>配合上文对findHighestPriorityRoot的理解加上之前文章对performWorkOnRoot的分析。立刻就可以发现很多有意思的地方了。</p>
<ul>
<li>performWorkOnRoot会调用workLoop对nextFlushedRoot节点进行遍历</li>
<li>findHighestPriorityRoot移除完成的fiberNode，然后如果还有有效值 继续performWorkOnRoot</li>
<li>直到nextFlushedRoot再无有效值</li>
</ul>
<p><strong>所以说 这里对于performWork函数这里有进一步的认知。它是对scheduled链表完整的遍历。而performWorkOnRoot只是针对指定的root节点来进行遍历。</strong></p>
<h2 id="performWorkOnRoot"><a href="#performWorkOnRoot" class="headerlink" title="performWorkOnRoot"></a>performWorkOnRoot</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWorkOnRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  isYieldy: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  isRendering = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isYieldy) &#123;</span><br><span class="line">    <span class="keyword">let</span> finishedWork = root.finishedWork;</span><br><span class="line">    <span class="keyword">if</span> (finishedWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// finishedWork有非null值说明一切就绪可以进入commit phase</span></span><br><span class="line">      completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      root.finishedWork = <span class="literal">null</span>;</span><br><span class="line">	  <span class="comment">// 如果之前暂停了任务 需要清除root.timeoutHandle。cancelTimeout实质上是clearTimeout</span></span><br><span class="line">      <span class="comment">// 这里单独包装一个是因为一些环境 比如ssr下没有clearTimeout</span></span><br><span class="line">      <span class="comment">// 这里暂时没看到异步暂停这块 可以忽略 不是必经路径</span></span><br><span class="line">      <span class="keyword">const</span> timeoutHandle = root.timeoutHandle;</span><br><span class="line">      <span class="keyword">if</span> (timeoutHandle !== noTimeout) &#123;</span><br><span class="line">        root.timeoutHandle = noTimeout;</span><br><span class="line">        cancelTimeout(timeoutHandle);</span><br><span class="line">      &#125;</span><br><span class="line">      renderRoot(root, isYieldy);</span><br><span class="line">      finishedWork = root.finishedWork;</span><br><span class="line">      <span class="keyword">if</span> (finishedWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;ve completed the root. Commit it.</span></span><br><span class="line">        completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Flush async work. 异步任务 暂时略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isRendering = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里核心路径是:</p>
<ul>
<li>如果root.finishedWork有非空值 进入commit phase</li>
<li>否则执行renderRoot</li>
<li>renderRoot会更新root.finishedWork值，接下来进入commit phase(completeRoot)</li>
</ul>
<h2 id="renderRoot"><a href="#renderRoot" class="headerlink" title="renderRoot"></a>renderRoot</h2><p>renderRoot是一个很复杂的函数。但是随着相关细节理解深入。可以做很多精简了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRoot</span>(<span class="params">root: FiberRoot, isYieldy: boolean</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  flushPassiveEffects(); <span class="comment">// 这个函数暂时没搞懂 和effect有关 但是不一定会进去 故可略过</span></span><br><span class="line"></span><br><span class="line">  isWorking = <span class="literal">true</span>; <span class="comment">// 作为禁止被递归调用的Flag</span></span><br><span class="line">  <span class="keyword">const</span> previousDispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">  ReactCurrentDispatcher.current = ContextOnlyDispatcher;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> expirationTime = root.nextExpirationTimeToWorkOn;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是一个新的stack开始，还是从之前被中断的地方开始 这里不理会</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    expirationTime !== nextRenderExpirationTime ||</span><br><span class="line">    root !== nextRoot ||</span><br><span class="line">    nextUnitOfWork === <span class="literal">null</span></span><br><span class="line">  ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulerTracing) &#123; &#125; <span class="comment">// 给开发工具用的 略</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> didFatal = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  startWorkLoopTimer(nextUnitOfWork);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      workLoop(isYieldy);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (thrownValue) &#123;&#125; <span class="comment">// 错误捕获用的 这里也不管</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulerTracing) &#123; &#125; <span class="comment">// 给开发工具用的 略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// We&#x27;re done performing work. Time to clean up.</span></span><br><span class="line">  isWorking = <span class="literal">false</span>;</span><br><span class="line">  ReactCurrentDispatcher.current = previousDispatcher;</span><br><span class="line">  resetContextDependences();</span><br><span class="line">  resetHooks();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Yield back to main thread.</span></span><br><span class="line">  <span class="keyword">if</span> (didFatal) &#123;&#125; <span class="comment">// workLoop的catch里面会定义为true 这里忽略</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// tree里面仍有异步任务 但是没时间继续完成任务了 先返回渲染主线程 代码略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We completed the whole tree.</span></span><br><span class="line">  <span class="keyword">const</span> didCompleteRoot = <span class="literal">true</span>;</span><br><span class="line">  stopWorkLoopTimer(interruptedBy, didCompleteRoot);</span><br><span class="line">  <span class="keyword">const</span> rootWorkInProgress = root.current.alternate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `nextRoot`指向正在进行的根。非空值意味着我们正处于异步渲染的过程中</span></span><br><span class="line">  <span class="comment">// 将其设置为null则表示 在当前批次中没有更多的工作要做。</span></span><br><span class="line">  nextRoot = <span class="literal">null</span>;</span><br><span class="line">  interruptedBy = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextRenderDidError) &#123;&#125; <span class="comment">// workLoop的catch里面会调用throwException()</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isYieldy &amp;&amp; nextLatestAbsoluteTimeoutMs !== -<span class="number">1</span>) &#123;&#125; <span class="comment">// 异步相关 不管</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ready to commit.</span></span><br><span class="line">  onComplete(root, rootWorkInProgress, expirationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里认真分析了一下，清除了大部分干扰代码，最终还是确认移除了异步处理、错误处理、追踪(开发工具)处理之后。它核心地方是workLoop &amp; onComplete。onComplete相关到commit Phase,我们再update的commit phase里面确认了Diff和它无关。所以核心就是workLoop了。</p>
<h2 id="workLoop"><a href="#workLoop" class="headerlink" title="workLoop"></a>workLoop</h2><p>这个函数的核心是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">workInProgress: Fiber</span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> current = workInProgress.alternate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if beginning this work spawns more work.</span></span><br><span class="line">  startWorkTimer(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> next;</span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer) &#123;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next = beginWork(current, workInProgress, nextRenderExpirationTime);</span><br><span class="line">    workInProgress.memoizedProps = workInProgress.pendingProps;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If this doesn&#x27;t spawn new work, complete the current work.</span></span><br><span class="line">    next = completeUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">  ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是Diff算法核心入口了，因为fiberNode遍历在这里得到提现。</p>
<p>beginWork返回fiber的child，performUnitOfWork返回fiber的next，而completeUnitOfWork返回fiber的return。</p>
<p>所谓大胆推测，小心求证。这里我们可以做一些推测，然后小心验证它。</p>
<p>这里大胆又保守的推测，我们在v15里面的用到的CompoentDiff、Tree Diff、Element Diff依然存在。因为所有的Diff实质上都是和child相关，所以可以大胆猜测，Diff相关逻辑，实质上都存在于beginWork——这也比较符合beginWork的命名。</p>
<h2 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h2><p>这里略去大多数干扰代码，仅仅保留常见的IndeterminateComponent、FunctionComponent、ClassComponent之类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> updateExpirationTime = workInProgress.expirationTime;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldProps = current.memoizedProps;</span><br><span class="line">    <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldProps !== newProps || hasLegacyContextChanged()) &#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) &#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// 这里和diff无关 先不管了</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before entering the begin phase, clear the expiration time.</span></span><br><span class="line">  workInProgress.expirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> elementType = workInProgress.elementType;</span><br><span class="line">      <span class="keyword">return</span> mountIndeterminateComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        elementType,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LazyComponent: : &#123; &#125;</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateFunctionComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">      <span class="keyword">return</span> updateHostRoot(current, workInProgress, renderExpirationTime);</span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123; </span><br><span class="line">      <span class="keyword">return</span> updateHostComponent(current$$1, workInProgress, renderExpirationTime)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostText: &#123; &#125;</span><br><span class="line">    <span class="keyword">case</span> SuspenseComponent: &#123; &#125;</span><br><span class="line">    <span class="keyword">case</span> HostPortal: &#123; &#125;</span><br><span class="line">    <span class="keyword">case</span> ForwardRef: &#123; &#125;</span><br><span class="line">    <span class="keyword">case</span> Fragment: &#123; &#125;</span><br><span class="line">    <span class="keyword">case</span> Mode: &#123; &#125;</span><br><span class="line">    <span class="keyword">case</span> Profiler: &#123; &#125;</span><br><span class="line">    <span class="keyword">case</span> ContextProvider: &#123; &#125;</span><br><span class="line">    <span class="keyword">case</span> ContextConsumer: &#123; &#125;</span><br><span class="line">    <span class="keyword">case</span> MemoComponent: &#123; &#125;</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123; &#125;</span><br><span class="line">    <span class="keyword">case</span> IncompleteClassComponent: &#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> DehydratedSuspenseComponent: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ClassComponent"><a href="#ClassComponent" class="headerlink" title="ClassComponent"></a>ClassComponent</h3><p>这里重点关注ClassComponent，毕竟v15还是以它为主的分析，方便参照。</p>
<p>这里updateClassComponent函数正常更新的话，主要是两个调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个函数根据workInProgress上的updateQueue、props、lifecyclesHooks更新了stateNode属性</span></span><br><span class="line"><span class="comment">// 也就是组件实例 新的props之类都在这个stateNode上保存起来了</span></span><br><span class="line">shouldUpdate = updateClassInstance(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    nextProps,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> nextUnitOfWork = finishClassComponent( <span class="comment">// 看下面 单独分析</span></span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    shouldUpdate,</span><br><span class="line">    hasContext,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> nextUnitOfWork;</span><br></pre></td></tr></table></figure>

<p>finishClassComponent检测到变化后，主要调用则如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">nextChildren = instance.render(); <span class="comment">// 更新后的实例，render执行会返回一个VDOM树</span></span><br><span class="line">reconcileChildren( <span class="comment">// reconcileChildren等价于ChildReconciler(true)</span></span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    nextChildren,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>ChildReconciler在React中的注释说到这个函数以后可能单独抽出进行手动或者编译器自动优化。这个函数里面helpers辅助函数太多。总之它执行后返回的是内部函数reconcileChildFibers。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理&lt;React.Fragment&gt;&lt;/React.Fragment&gt;语法 对其采用数组一样的处理逻辑</span></span><br><span class="line">  <span class="keyword">const</span> isUnkeyedTopLevelFragment =</span><br><span class="line">    <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">    newChild !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;</span><br><span class="line">    newChild.key === <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">    newChild = newChild.props.children;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle object types</span></span><br><span class="line">  <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isObject) &#123; <span class="comment">// 正常的VDOM处理流程</span></span><br><span class="line">    <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">      <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">        <span class="keyword">return</span> placeSingleChild( <span class="comment">// ★ 这里是我们的核心关注点</span></span><br><span class="line">          reconcileSingleElement(</span><br><span class="line">            returnFiber,</span><br><span class="line">            currentFirstChild,</span><br><span class="line">            newChild,</span><br><span class="line">            expirationTime,</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      <span class="keyword">case</span> REACT_PORTAL_TYPE: &#123;&#125; <span class="comment">// 略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&#x27;number&#x27;</span>) &#123; <span class="comment">// 处理文本 &amp; 数字</span></span><br><span class="line">    <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">      reconcileSingleTextNode(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        <span class="string">&#x27;&#x27;</span> + newChild,</span><br><span class="line">        expirationTime,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">    <span class="keyword">return</span> reconcileChildrenArray(</span><br><span class="line">      returnFiber,</span><br><span class="line">      currentFirstChild,</span><br><span class="line">      newChild,</span><br><span class="line">      expirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代器处理 暂时还没听过render里面可以返回一个generator函数得。是否有一天我们可以这样做？</span></span><br><span class="line">  <span class="comment">// 还是有其他考虑？</span></span><br><span class="line">  <span class="keyword">if</span> (getIteratorFn(newChild)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isObject) &#123; &#125; <span class="comment">// 针对上级节点是textarea的抛错</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; !isUnkeyedTopLevelFragment) &#123; &#125; <span class="comment">// 抛出错误</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remaining cases are all treated as empty.</span></span><br><span class="line">  <span class="keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单节点Children"><a href="#单节点Children" class="headerlink" title="单节点Children"></a>单节点Children</h4><p>单节点的children个人实质上就是ComponentDiff的践行。但是这里也对Tree Diff有了部分实践，因为它同时承担了一部分的删除操作，维护了FiberNode的siblings。</p>
<p>这里看看placeSingleChild函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">placeSingleChild</span>(<span class="params">newFiber: Fiber</span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This is simpler for the single child case. We only need to do a</span></span><br><span class="line">    <span class="comment">// placement for inserting new children.</span></span><br><span class="line">    <span class="comment">// 对于单root节点的VDOM树。我们只需要使用新的children替换即可</span></span><br><span class="line">    <span class="comment">// shouldTrackSideEffects = true -&gt; reconcileChildren等价于ChildReconciler(true)</span></span><br><span class="line">    <span class="comment">// 这个shouldTrackSideEffects就是传入的写死的true参数</span></span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects &amp;&amp; newFiber.alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">        newFiber.effectTag = Placement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newFiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面注释很明了，我们的Component Diff就这样轻描淡写的做好了标记，有些措不及防。。。</p>
<p>另外就是，既然这里说了: 如果是single child case，那么自然就会有multiple child case。那么，可以很自然的做出推测，这里的multiple child case，其实质就是ElementDiff或者TreeDiff——我们继续分析验证reconcileSingleElement函数。</p>
<p>但是这之前，根据placeSingleChild传参类型和返回类型，我们可以确认reconcileSingleElement返回的是一个FiberNode。另外要额外对它的alternate属性追踪和关注，以完成Component Diff分析闭环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = element.key;</span><br><span class="line">  <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line">  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.key === key) &#123; <span class="comment">// 如果是单节点 这里相等，那么需要进行后续对比</span></span><br><span class="line">      <span class="comment">// 判断Fragment还是常规HostComponent、ClassComponent的合法性</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        child.tag === Fragment</span><br><span class="line">          ? element.type === REACT_FRAGMENT_TYPE</span><br><span class="line">          : child.elementType === element.type</span><br><span class="line">      ) &#123;</span><br><span class="line">        deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line">        <span class="keyword">const</span> existing = useFiber(</span><br><span class="line">          child,</span><br><span class="line">          element.type === REACT_FRAGMENT_TYPE</span><br><span class="line">            ? element.props.children</span><br><span class="line">            : element.props,</span><br><span class="line">          expirationTime,</span><br><span class="line">        );</span><br><span class="line">        existing.ref = coerceRef(returnFiber, child, element);</span><br><span class="line">        existing.return = returnFiber;</span><br><span class="line">        <span class="keyword">return</span> existing;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deleteRemainingChildren(returnFiber, child);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则直接标记删除 并将child放到nextEffect上以备递归删除下级节点</span></span><br><span class="line">      deleteChild(returnFiber, child); </span><br><span class="line">    &#125;</span><br><span class="line">    child = child.sibling;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) &#123; <span class="comment">// 保持简洁和关注 这里分支不理会了</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 正常VDOM逻辑</span></span><br><span class="line">    <span class="keyword">const</span> created = createFiberFromElement(</span><br><span class="line">      element,</span><br><span class="line">      returnFiber.mode,</span><br><span class="line">      expirationTime,</span><br><span class="line">    );</span><br><span class="line">    created.ref = coerceRef(returnFiber, currentFirstChild, element);</span><br><span class="line">    created.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里由一个while循环。但是分析这个循环之前，草草扫过这个代码，基本已经可以确认它是Tree Diff的核心了。言归正传，返回这个while的分析。</p>
<p>这个while实质上是做的fiberNode链表和VDOM树的对比。它从给定的一个FiberNode遍历到它后面所有的FiberNode节点。</p>
<p>这个循环，实质是上单层的循环，它只是针对同一层级的VDOM对应的FiberNode进行了标记。<code>child = child.sibling</code>说明了这一点。</p>
<p>这里主要是删除的逻辑。分析一下相关函数:</p>
<p>deleteChild函数直接标记删除(effectTag = Deletion) 并将child放到nextEffect上以备递归删除下级节点。</p>
<p>而deleteRemainingChildren则是做一些遍历然后调用deleteChild标记删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteRemainingChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrackSideEffects) &#123;</span><br><span class="line">    <span class="comment">// Noop.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> For the shouldClone case, this could be micro-optimized a bit by</span></span><br><span class="line">  <span class="comment">// assuming that after the first child we&#x27;ve already added everything.</span></span><br><span class="line">  <span class="keyword">let</span> childToDelete = currentFirstChild;</span><br><span class="line">  <span class="keyword">while</span> (childToDelete !== <span class="literal">null</span>) &#123;</span><br><span class="line">    deleteChild(returnFiber, childToDelete);</span><br><span class="line">    childToDelete = childToDelete.sibling;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综合deleteChild、deleteRemainingChildren、reconcileSingleElement成一个整体来看。</p>
<ul>
<li>当children为一个单独的VDOM，此时FiberNode此时可能存在多个同级的FiberNode(通过sibling进行链接)，所以要对这些多出来的FiberNode进行删除</li>
<li>当key对应完毕。直接使用deleteRemainingChildren标记删除剩余后面所有fiber.sibling及其子节点</li>
<li>关于第二条的key对应。当key在中间时候，key前面的使用deleteChild当个删除。找到key之后，批量deleteChild删除。</li>
</ul>
<p>所以，总的来讲，这里是Tree Diff没错，但是更多的同时ComponentDiff的替换行为，一旦ClassComponent&amp;HostComponent这些做了修改，那么直接用新的替换它(这里它是FiberNode)。</p>
<p>这里再看看key对应完毕后创建新的fiber的函数useFiber。这个函数主要是创建一个workInProgress节点。当current.alternate有值，直接修改更新它，如果没值的话则创建一个，并将创建的fiber的alternate设为current。</p>
<h4 id="多节点children"><a href="#多节点children" class="headerlink" title="多节点children"></a>多节点children</h4><p>如果说单节点是其他两种Diff算法多一些。那么多节点children则是侧重了ElementDiff。同级多节点的更新，必然会伴随着节点的删除、移动、插入，ElementDiff算法在这里将会是主角。</p>
<p>它对应的<code>reconcileChildrenArray</code>函数。如果对ElementDiff实现没有了解的。可以参考之前的<a href="/2019/06/25/react-diff/#Element-Diff">&lt;<React Diff>&gt;</a>篇。当然，这是v15版本的分析。</p>
<p>对这个分析里面的ElementDiff分析做简述，就是<strong>新Index&gt;旧Index，那么需要将旧的节点移动到新的Index</strong>。理解这个非常重要，因为思路和v15版本一致，这里不再描述这个过程。</p>
<p>反过来讲,<strong>如果旧Index&gt;新Index，那么原节点可以考虑原地不动</strong>。</p>
<blockquote>
<p>Tips: 关于这个大于小于，当ABCD转换成BACD也就是0123变成1023时候，只需要对A进行删除+创建+插入。ABCD对应的是旧index，而BACD则是新index。所以考虑到大于等于和小于等于这种符号的严谨性。这里需要说明一下，它的严谨说法是: <strong>如果旧Index&gt;新Index，那么原节点可以考虑原地不动,否则旧index ≤ 新 index, 则需要进行标记移动</strong>。</p>
</blockquote>
<p>以下是源码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildrenArray</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  newChildren: <span class="built_in">Array</span>&lt;*&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> resultingFirstChild: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> previousNewFiber: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> oldFiber = currentFirstChild;</span><br><span class="line">  <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 第一道循环</span></span><br><span class="line">  <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldFiber.index &gt; newIdx) &#123;</span><br><span class="line">      <span class="comment">// 旧index &gt; 新index nextOldFiber不会变化 循环尾部有:oldFiber = nextOldFiber;</span></span><br><span class="line">      <span class="comment">// 设为null，fiberNode会走createFiberFromElement</span></span><br><span class="line">      nextOldFiber = oldFiber;</span><br><span class="line">      oldFiber = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则指向oldFiber.sibling</span></span><br><span class="line">      nextOldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> newFiber = updateSlot(</span><br><span class="line">      returnFiber,</span><br><span class="line">      oldFiber,</span><br><span class="line">      newChildren[newIdx],</span><br><span class="line">      expirationTime,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">            oldFiber = nextOldFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">    <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      resultingFirstChild = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      previousNewFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    previousNewFiber = newFiber;</span><br><span class="line">    oldFiber = nextOldFiber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newIdx === newChildren.length) &#123;</span><br><span class="line">    deleteRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 第二道循环</span></span><br><span class="line">    <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="keyword">const</span> newFiber = createChild(</span><br><span class="line">        returnFiber,</span><br><span class="line">        newChildren[newIdx],</span><br><span class="line">        expirationTime,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (!newFiber) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Keep scanning and use the map to restore deleted items as moves.</span></span><br><span class="line">  <span class="comment">// 第三道循环</span></span><br><span class="line">  <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">    <span class="keyword">const</span> newFiber = updateFromMap(</span><br><span class="line">      existingChildren,</span><br><span class="line">      returnFiber,</span><br><span class="line">      newIdx,</span><br><span class="line">      newChildren[newIdx],</span><br><span class="line">      expirationTime,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (newFiber) &#123;</span><br><span class="line">      <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newFiber.alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">          existingChildren.delete(</span><br><span class="line">            newFiber.key === <span class="literal">null</span> ? newIdx : newFiber.key,</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">    existingChildren.forEach(<span class="function"><span class="params">child</span> =&gt;</span> deleteChild(returnFiber, child));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里首先要理解的是nextOldFiber。</p>
<p>这里nextOldFiber实际上就是一个缓存作用，它的意义是将oldFiber最后赋值为<code>oldFiber || oldFiber.sibling</code>。</p>
<p>假设我们变更前元素是ABCD，变更后是BADC。</p>
<p>如果你认为这个循环是按BADC顺序，就容易走入误区。</p>
<p>这是因为这个循环实质上是以newChildren(VDOM)为长度进行自增遍历(4)，oldFiber实质上确是从ABCD的顺序遍历，如果你理解是以newChildren(BADC)来开头(不管你认为相关值也好索引也好)，那么就容易陷入逻辑陷阱——**但实质上，要理解这一段，必须以ABCD的顺序来(nextOldFiber)**，如果你能理解这一块，就能理解它的目的了。</p>
<p>而newIdx除了不得大于newChildren.length, 实质上和newChildren和一毛钱关系没有。他就是一个自增变量而已。</p>
<p>大多数情况下，我们这里</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldFiber.index &gt; newIdx) &#123;</span><br><span class="line">    nextOldFiber = oldFiber;</span><br><span class="line">    oldFiber = <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    nextOldFiber = oldFiber.sibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都不会走到第一个分支。接下来我们用案例佐证算法。</p>
<h5 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h5><p>假设我们有一个组件Test</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> text = <span class="built_in">this</span>.props.children;</span><br><span class="line">    <span class="keyword">return</span> text === <span class="string">&#x27;Text&#x27;</span> ? </span><br><span class="line">        [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>].map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;v&#125;</span>&gt;</span>&#123;v&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>) </span><br><span class="line">    	: [<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;C&#x27;</span>].map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;v&#125;</span>&gt;</span>&#123;v&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且this.props.children从’Text’变成’Number’。此时它在第一个循环里面遇到updateSlot会直接返回null，然后循环被跳出。</p>
<p>接下来路径是使用mapRemainingChildren生成Map结构, 这里key为key，而value为对应fiberNode。这个Map数据，其实和newChildren数组类似。</p>
<p><strong>然后进入第三道循环</strong>，这个循环里面，会遍历newChildren,然后挨个获取newChildrenItem,获取key然后从mapRemainingChildren找到对应的旧fiberNode。</p>
<ul>
<li>如果能找到对应key相同的。updateElement会走move逻辑，复用fiberNode</li>
<li>如果找不到。updateElement走insert逻辑，使用newChildrenItem创建新的fiberNode</li>
</ul>
<p>接下来，根据这个updateElement生成的fiberNode，查看其是否有alternate属性。如果是复用fiberNode，也就是Map里面能找到旧fiberNode的情况下，这种情况只需要做排序，此时找到了就要从原来Map里面删除它，然后使用placeChild执行排序。</p>
<p>最后，如果Map结构里面还有多余的Item，直接删除它，新的children里面没有他们，所以全部标记删除。</p>
<h5 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test extends React.Component&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    const text &#x3D; this.props.children;</span><br><span class="line">    return text &#x3D;&#x3D;&#x3D; &#39;Text&#39; ? &lt;div&gt;</span><br><span class="line">          &lt;div&gt;1&lt;&#x2F;div&gt;</span><br><span class="line">          &lt;span&gt;4&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;div&gt; : &lt;div&gt;</span><br><span class="line">          &lt;span&gt;4&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;div&gt;1&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要说它和例子又什么区别，那就是它没有key了。此时它会直接在第一道循环的完成div和span对应fiberNode的遍历(对HostComponent来说，updateSlot会返回updateElement执行结果而不是null)。这两道流程里面都是走的创建新的，替换旧的处理，完毕之后将创建出来的fiberNode使用sibling连接起来，因为其遍历到底了，所以以下分支会被执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newIdx === newChildren.length) &#123;</span><br><span class="line">  deleteRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">  <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，workInProgress.child会被赋值为resultingFirstChild。</p>
<h5 id="重要补充-placeChild"><a href="#重要补充-placeChild" class="headerlink" title="重要补充: placeChild"></a>重要补充: placeChild</h5><p>一旦我们通过updateSlot获得一个fiberNode。下一步可能就是一个重头戏了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br></pre></td></tr></table></figure>

<p>这个函数内容如下，另外lastPlacedIndex的初始值是0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">placeChild</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  newFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  lastPlacedIndex: number,</span></span></span><br><span class="line"><span class="function"><span class="params">  newIndex: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  newFiber.index = newIndex;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrackSideEffects) &#123;</span><br><span class="line">    <span class="comment">// Noop.</span></span><br><span class="line">    <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> current = newFiber.alternate;</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123; <span class="comment">// 如果newFiber.alternate有值 那么判定是移动还是不管</span></span><br><span class="line">    <span class="keyword">const</span> oldIndex = current.index;</span><br><span class="line">    <span class="keyword">if</span> (oldIndex &lt; lastPlacedIndex) &#123;</span><br><span class="line">      <span class="comment">// This is a move.</span></span><br><span class="line">      newFiber.effectTag = Placement;</span><br><span class="line">      <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 原地不动</span></span><br><span class="line">      <span class="comment">// This item can stay in place.</span></span><br><span class="line">      <span class="keyword">return</span> oldIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则这是一个插入动作</span></span><br><span class="line">    <span class="comment">// This is an insertion.</span></span><br><span class="line">    newFiber.effectTag = Placement;</span><br><span class="line">    <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个函数，有几点要明确。</p>
<ul>
<li>首先是alternate，fiberNode上的alternate实质上是newTree节点对oldTree或者叫做currentTree树的节点的链接。这里newFiber则是与前面提到的Tree相对应的workInProgress(newTree)树上的节点。</li>
<li>所以这里oldIndex就真的是oldIndex, 但是lastPlacedIndex却并不能说是新Index。我们这里没有newIndex的概念，但是可以很自然的推测它肯定也有类似逻辑，这里需要推演出来。</li>
<li>如果alternate不为空说明可以进行移动、保持、更新等处理，否则说明是一个新节点，要标记插入</li>
</ul>
<p>它这里逻辑是怎样的, 还是假设ABCD(0123-旧)到BADC(1032-新)进行变化(例子一)。因为这里是对newChildren(reconcileChildrenArray中)进行遍历，所以这个遍历对比流程顺序是: B-A-D-C。</p>
<p>第一遍:</p>
<p>​    B: 此时oldIndex = 1, lastPlacedIndex = 0; 此时B不动，lastPlacedIndex赋值为1</p>
<p>第二遍</p>
<p>​    A:此时oldIndex = 0, lastPlacedIndex = 1; 此时A标记移动，lastPlacedIndex赋值为1</p>
<p>第三遍:</p>
<p>​    D:此时oldIndex = 3 , lastPlacedIndex = 1; 此时D不动，lastPlacedIndex赋值为3</p>
<p>第四遍:</p>
<p>​    C:此时oldIndex = 2 , lastPlacedIndex = 3; 此时C标记，lastPlacedIndex赋值为3</p>
<p>原理:</p>
<p>这里有必要将alternate对新旧fiberNode的链接深入理解。这里进行处理时候将第一个元素B作为了初始基准，基准值取其旧index: 1, 此后A因为原来位置比靠前(旧index &lt; 基准值)，但是新顺序却靠后，所以按照从左往后的顺序，它必须移动，完毕后基准还是B，继续处理D，此时D.index大于基准值，在新的顺序里面也在B后面，所以它不动，改变基准值为D.index: 3。继续处理C, 它和A一样，原来位置靠前(旧index &lt; 基准值)，但是却在D后面，所以需要标记移动。</p>
<p><strong>但是这里仅仅是标记了操作办法，索引还没处理。</strong>它的索引，则是通过resultingFirstChild变量实现的。每次得到新的值，它会挂载上一个获取到的fiberNode的sibling属性上，这个sibling一路链下来，就是实质性的index。</p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>这里算法和v15有了很多变化。实现细节上已经几乎没有相同地方了。</p>
<p>针对key的tree对比这里还是有，思路一致，不过已经改用Map结构来保存了，然后移动计算上基于updateFromMap-&gt;updateElement的方式来实现了。</p>
<p>而索引，这里的调和算法上，实质已经没有这个东西了，它依托fiberNode的sibling就实现了。</p>
<p>一套遍历走下来，如果Map数据里面还有多余，就是补足了之前v15 Tree Diff过程中对Delete的标记，直接遍历Map进行删除标记即可。</p>
<p>其他情况，Fragment都是走的直接创建新的然后标记插入，最后标记移除旧的。</p>
<h3 id="HostComponent"><a href="#HostComponent" class="headerlink" title="HostComponent"></a>HostComponent</h3><p>出了常见的ClassComponent，HostComponent在浏览器环境显然是更加基础的组件表示形式，实际上所有的ClassComponent，都是对HostComponent组件的引用和扩展。</p>
<p>v16将v15里面的ReactDomComponent称之为HostComponent，常见的div、span都会转换为HostComponent。</p>
<p>在beginWork里面可以看到，面对HostComponent。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> HostComponent: &#123; </span><br><span class="line">    <span class="keyword">return</span> updateHostComponent(current$$1, workInProgress, renderExpirationTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>updateHostComponent函数里面包含了context、ref和expirationTime之类的处理。但是最核心的还是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reconcileChildren(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    nextChildren,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> workInProgress.child;</span><br></pre></td></tr></table></figure>

<p>所以事实上，我们这里又走了ClassComponent的调用栈。其中细节这里不再复述。</p>
<h3 id="FunctionComponent"><a href="#FunctionComponent" class="headerlink" title="FunctionComponent"></a>FunctionComponent</h3><p>几乎等同HostComponent情况。核心调用都是一致的。</p>
<h1 id="Diff算法小总结"><a href="#Diff算法小总结" class="headerlink" title="Diff算法小总结"></a>Diff算法小总结</h1><p>实质上在beginWork里面对算法已经有了很明显的说明了。但是这里还是要单独抽出来讲一讲。</p>
<p>我们的ComponentDiff、TreeDiff和ElementDiff实际上这里仍然适用。</p>
<h2 id="Component-Diff"><a href="#Component-Diff" class="headerlink" title="Component Diff"></a>Component Diff</h2><p>这个算法的意义在于，当ClassComponent没有变化时候，不更新，变化了，就整体替换。</p>
<p>placeSingleChild函数为所有的SingleChild做了替换标记。</p>
<ul>
<li>当判定不需要更新，且没有抛出错误的时候，那么这个SingleChild会将它自身的child全部递归做一个副本(副本之前保持fiberNode链接)，并返回child。</li>
<li>否则，适用reconcileChildren处理后面逻辑</li>
</ul>
<h2 id="Tree-Diff"><a href="#Tree-Diff" class="headerlink" title="Tree Diff"></a>Tree Diff</h2><p>这里实质是同层级的元素的key对比。核心逻辑在reconcileChildrenArray函数里面。</p>
<p>它是这样做的。如果这个ChildrenArray上Item有key props。那么newFiber = updateSlot(args) = null。然后跳出循环将旧的FiberNode全部放到Map结构里面，遍历新的children查找对应key的FiberNode。</p>
<p>没找到一个，就从Map里面删除一个，遍历完成后，还在Map里面的就全部标记删除。</p>
<h2 id="Element-Diff"><a href="#Element-Diff" class="headerlink" title="Element Diff"></a>Element Diff</h2><p>这里主要是上面reconcileChildrenArray函数里面，第三道循环里面处理的。</p>
<p>如果key存在，那么复用之前FiberNode，否则根据新的children创建fiberNode。我们遍历的是newChildrenArray，遍历过程中得到的新的FiberNode会挨个被上一个FiberNode.sibling链接起来,这样index就能对应起来了。</p>
]]></content>
      <tags>
        <tag>React v16</tag>
      </tags>
  </entry>
  <entry>
    <title>react-v16-ChildReconciler</title>
    <url>/2019/08/07/react-v16-ChildReconciler/</url>
    <content><![CDATA[<h1 id="初步整理"><a href="#初步整理" class="headerlink" title="初步整理"></a>初步整理</h1><p>这里还需要回顾一下，FiberNode遍历DOM树的数据结构和遍历基础。</p>
<p>遍历理论在上一篇v16-render里面有简略伪代码可以供参考。它依托FiberNode得三个属性：<code>child,return,sibling</code>来实现。如果对这个理论不了解必须回上一篇看看理论。</p>
<h1 id="链表构建"><a href="#链表构建" class="headerlink" title="链表构建"></a>链表构建</h1><p>这里链表的构建主要就是<code>child,return,sibling</code>三个属性的构建。</p>
<p>这个构建过程在<code>reconcileChildren</code>函数及其调用函数中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextChildren: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If this is a fresh new component that hasn&#x27;t been rendered yet, we</span></span><br><span class="line">    <span class="comment">// won&#x27;t update its child set by applying minimal side-effects. Instead,</span></span><br><span class="line">    <span class="comment">// we will add them all to the child before it gets rendered. That means</span></span><br><span class="line">    <span class="comment">// we can optimize this reconciliation pass by not tracking side-effects.</span></span><br><span class="line">    <span class="comment">// 如果是一个新鲜的没有渲染过多组件 我们不会通过最小side-effects更新它的child</span></span><br><span class="line">    <span class="comment">// 相反 我们会在渲染之前将它们全部添加到子节点</span></span><br><span class="line">    <span class="comment">// 这意味着不需要对side-effects进行跟踪 以优化这个reconciliation过程</span></span><br><span class="line">    workInProgress.child = mountChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这部分是更新相关</span></span><br><span class="line">    workInProgress.child = reconcileChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      current.child,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reconcileChildFibers = ChildReconciler(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mountChildFibers = ChildReconciler(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到不管如何，最终都会调用到ChildReconciler。两者区别是初始更新和Update的区别。</p>
<p>接下来是ChildReconciler函数代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildReconciler</span>(<span class="params">shouldTrackSideEffects</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isUnkeyedTopLevelFragment =</span><br><span class="line">      <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">      newChild !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;</span><br><span class="line">      newChild.key === <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">      newChild = newChild.props.children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle object types</span></span><br><span class="line">    <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSingleElement(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              expirationTime,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSinglePortal(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              expirationTime,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果child是字符串或者数字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理文本节点逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">      <span class="keyword">return</span> reconcileChildrenArray(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        newChild,</span><br><span class="line">        expirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getIteratorFn(newChild)) &#123;</span><br><span class="line">      <span class="keyword">return</span> reconcileChildrenIterator(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        newChild,</span><br><span class="line">        expirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">      throwOnInvalidObjectType(returnFiber, newChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; !isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">		<span class="comment">// newChild如果为空 做一些初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remaining cases are all treated as empty.</span></span><br><span class="line">    <span class="keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reconcileChildFibers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对应的大场景有两个:</p>
<ul>
<li>一个父节点有单一的子节点</li>
<li>一个父节点有多个子节点</li>
</ul>
<h3 id="单一子节点构建"><a href="#单一子节点构建" class="headerlink" title="单一子节点构建"></a>单一子节点构建</h3><p>这其中不管是那种情况，都必然会有child &amp; return的设置。我们来看看调用栈。</p>
<p>首先是常规的单一的子节点。此时面对的情况是:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">            <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">                reconcileSingleElement(</span><br><span class="line">                    returnFiber,</span><br><span class="line">                    currentFirstChild,</span><br><span class="line">                    newChild,</span><br><span class="line">                    expirationTime,</span><br><span class="line">                ),</span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">            <span class="comment">// PORTAL组件略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用栈</span></span><br><span class="line">placeSingleChild(reconcileSingleElement(args))</span><br><span class="line">-&gt;reconcileSingleElement(args)</span><br></pre></td></tr></table></figure>

<p>看看这个函数的代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = element.key;</span><br><span class="line">  <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line">  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 初始化渲染这里可以不管</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">    <span class="keyword">const</span> created = createFiberFromFragment(</span><br><span class="line">      element.props.children,</span><br><span class="line">      returnFiber.mode,</span><br><span class="line">      expirationTime,</span><br><span class="line">      element.key,</span><br><span class="line">    );</span><br><span class="line">    created.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> created = createFiberFromElement(</span><br><span class="line">      element,</span><br><span class="line">      returnFiber.mode,</span><br><span class="line">      expirationTime,</span><br><span class="line">    );</span><br><span class="line">    created.ref = coerceRef(returnFiber, currentFirstChild, element);</span><br><span class="line">    created.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时配合这里的<code>created.return</code>赋值语句，整个具体场景里面的return和child就做好了配对。</p>
<h3 id="多节点配对"><a href="#多节点配对" class="headerlink" title="多节点配对"></a>多节点配对</h3><p>多节点配对的核心代码是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">    <span class="keyword">return</span> reconcileChildrenArray(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        newChild,</span><br><span class="line">        expirationTime,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看关联代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildrenArray</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChildren: <span class="built_in">Array</span>&lt;*&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> resultingFirstChild: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> previousNewFiber: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> oldFiber = currentFirstChild;</span><br><span class="line">    <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="comment">// Element Diff算法实现</span></span><br><span class="line">      <span class="comment">// 这里是更新相关的Diff算法 可以参考之前的旧文章 虽然实现变了 算法思想没变</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 标记批量删除 如果新的children.length === 0 就整个标记删除 和之前算法思路一致</span></span><br><span class="line">    <span class="keyword">if</span> (newIdx === newChildren.length) &#123;</span><br><span class="line">      <span class="comment">// We&#x27;ve reached the end of the new children. We can delete the rest.</span></span><br><span class="line">      deleteRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If we don&#x27;t have any more existing children we can choose a fast path</span></span><br><span class="line">      <span class="comment">// since the rest will all be insertions.</span></span><br><span class="line">      <span class="comment">// 遍历newChildren,缓存上一次的childrenItem，标记当前newFiber为它的sibling</span></span><br><span class="line">      <span class="comment">// 并将最上方的childrenItem缓存以便遍历后返回</span></span><br><span class="line">      <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> newFiber = createChild(</span><br><span class="line">          returnFiber,</span><br><span class="line">          newChildren[newIdx],</span><br><span class="line">          expirationTime,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!newFiber) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">          resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后方代码略 初始render只到上一个return就结束了</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>关键地方的构建这里都在注释里面有写了。</p>
<p>当children是数组，那么遍历，看时机将sibling绑定到下一个同级元素。结束后将firstChild返回。此时<code>workInProgress.child</code>就被绑定到了这个firstChild上了。</p>
<p>那么新的childrenItem上的return呢？它们在createChild里面被绑定好了。买个元素的return都指定到了workInProgress节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createChild</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Text nodes don&#x27;t have keys. If the previous node is implicitly keyed</span></span><br><span class="line">    <span class="comment">// we can continue to replace it without aborting even if it is not a text</span></span><br><span class="line">    <span class="comment">// node.</span></span><br><span class="line">    <span class="keyword">const</span> created = createFiberFromText(</span><br><span class="line">      <span class="string">&#x27;&#x27;</span> + newChild,</span><br><span class="line">      returnFiber.mode,</span><br><span class="line">      expirationTime,</span><br><span class="line">    );</span><br><span class="line">    created.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">      <span class="keyword">case</span> REACT_ELEMENT_TYPE: &#123;</span><br><span class="line">        <span class="keyword">const</span> created = createFiberFromElement(</span><br><span class="line">          newChild,</span><br><span class="line">          returnFiber.mode,</span><br><span class="line">          expirationTime,</span><br><span class="line">        );</span><br><span class="line">        created.ref = coerceRef(returnFiber, <span class="literal">null</span>, newChild);</span><br><span class="line">        created.return = returnFiber;</span><br><span class="line">        <span class="keyword">return</span> created;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> REACT_PORTAL_TYPE: &#123;</span><br><span class="line">        <span class="keyword">const</span> created = createFiberFromPortal(</span><br><span class="line">          newChild,</span><br><span class="line">          returnFiber.mode,</span><br><span class="line">          expirationTime,</span><br><span class="line">        );</span><br><span class="line">        created.return = returnFiber;</span><br><span class="line">        <span class="keyword">return</span> created;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArray(newChild) || getIteratorFn(newChild)) &#123;</span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromFragment(</span><br><span class="line">        newChild,</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        expirationTime,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">      );</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throwOnInvalidObjectType(returnFiber, newChild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分支有点多，但是只需要关注return的赋值即可。</p>
<h3 id="递归-amp-串联"><a href="#递归-amp-串联" class="headerlink" title="递归&amp;串联"></a>递归&amp;串联</h3><p>我们就仅有两层的树进行了分析。那么我们如何将多个层级递归串联起来，让它们一直从顶部走到终点呢？答案当然是workLoop!</p>
<p>如果对workLoop还有陌生感觉，那么不妨重新区看看。workLoop循环结束的唯一条件是FiberNode.child===null。只要child不为null，他会按照算法涉及一路next或者child遍历下去。</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>到这里，我们的链表构建就结束了。我们清晰的看到了，这个链表是如何完整架构的。但是这里还是不太够，我们对current和workInProgress树的流程还缺乏一个整体认知。</p>
<h1 id="Fiber里面的树"><a href="#Fiber里面的树" class="headerlink" title="Fiber里面的树"></a>Fiber里面的树</h1><h2 id="workInProgress树"><a href="#workInProgress树" class="headerlink" title="workInProgress树"></a>workInProgress树</h2><p>这棵树是有迹可循的。</p>
<p>实质上，构建workInProgress树其实就是链表构建的更深入的探究。它和上一节其实密不可分。</p>
<p>换句话说，上一节其实也只是构建workInProgress过程之一。所以，两部分参考着看是很有意义的。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>第一个创建是在renderRoot函数里面:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nextUnitOfWork = createWorkInProgress(</span><br><span class="line">    nextRoot.current,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    nextRenderExpirationTime,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createWorkInProgress</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> workInProgress = current.alternate;</span><br><span class="line">  <span class="keyword">if</span> (workInProgress === <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgress = createFiber(</span><br><span class="line">      current.tag,</span><br><span class="line">      pendingProps,</span><br><span class="line">      current.key,</span><br><span class="line">      current.mode,</span><br><span class="line">    );</span><br><span class="line">    workInProgress.elementType = current.elementType;</span><br><span class="line">    workInProgress.type = current.type;</span><br><span class="line">    workInProgress.stateNode = current.stateNode;</span><br><span class="line"></span><br><span class="line">    current.alternate = workInProgress;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 更新分支 略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  workInProgress.childExpirationTime = current.childExpirationTime;</span><br><span class="line">  workInProgress.expirationTime = current.expirationTime;</span><br><span class="line"></span><br><span class="line">  workInProgress.child = current.child;</span><br><span class="line">  workInProgress.memoizedProps = current.memoizedProps;</span><br><span class="line">  workInProgress.memoizedState = current.memoizedState;</span><br><span class="line">  workInProgress.updateQueue = current.updateQueue;</span><br><span class="line">  workInProgress.contextDependencies = current.contextDependencies;</span><br><span class="line"></span><br><span class="line">  workInProgress.sibling = current.sibling;</span><br><span class="line">  workInProgress.index = current.index;</span><br><span class="line">  workInProgress.ref = current.ref;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer) &#123;</span><br><span class="line">    workInProgress.selfBaseDuration = current.selfBaseDuration;</span><br><span class="line">    workInProgress.treeBaseDuration = current.treeBaseDuration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workInProgress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个源头我们穷根究底一下。</p>
<ul>
<li><p>ReactDom.render(App, container)首先获取到的root是一个App经过createElement函数返回的结果。举个栗子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    $$typeof: <span class="built_in">Symbol</span>(react.element)</span><br><span class="line">    key: <span class="literal">null</span></span><br><span class="line">    props: &#123;&#125;</span><br><span class="line">    ref: <span class="literal">null</span></span><br><span class="line">    type: ƒ App()</span><br><span class="line">    _owner: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后续引用到的ReactRoot构造器根据给出的container元素构造了一个Fiber节点。这事所有Fiber节点的root。前面提到的nextRoot也是它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var root &#x3D; createContainer(container, isConcurrent, hydrate);</span><br><span class="line">this._internalRoot &#x3D; root;</span><br></pre></td></tr></table></figure>

<p>这个createContainer设置了current，current由createHostRootFiber函数创建了一个FiberNode，除了tag==3之外和空的FiberNode没有什么区别</p>
</li>
<li><p>createWorkInProgress环节。</p>
<p>此时，<code>workInProgress.alternate = current.alternate = current = createHostRootFiber()</code>基本都是空Fiber，只不过设置了tag===3。</p>
</li>
</ul>
<h3 id="初始化render里的变更"><a href="#初始化render里的变更" class="headerlink" title="初始化render里的变更"></a>初始化render里的变更</h3><p>接下是workLoop+performUnitOfWork了。performUnitOfWork引用了beginWork。</p>
<h4 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h4><p>当根节点进入这个beginWork分支。触发<code>return updateHostRoot(current, workInProgress, renderExpirationTime)</code>，也就是nextUnitOfWork变量初始化后第一次获得返回值。</p>
<p>这个函数中有这样一个调用栈:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostRoot</span>(<span class="params">current, workInProgress, renderExpirationTime</span>) </span>&#123;</span><br><span class="line">  pushHostRootContext(workInProgress);</span><br><span class="line">  <span class="keyword">const</span> updateQueue = workInProgress.updateQueue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">const</span> prevState = workInProgress.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> prevChildren = prevState !== <span class="literal">null</span> ? prevState.element : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// processUpdateQueue这个函数非常重要 它可能是将FiberNode树和ReactElement联系起来的核心入口</span></span><br><span class="line">  processUpdateQueue(</span><br><span class="line">    workInProgress,</span><br><span class="line">    updateQueue,</span><br><span class="line">    nextProps,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> nextState = workInProgress.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> nextChildren = nextState.element;</span><br><span class="line">  <span class="keyword">if</span> (nextChildren === prevChildren) &#123;</span><br><span class="line">    <span class="comment">// If the state is the same as before, that&#x27;s a bailout because we had no work that expires at this time.</span></span><br><span class="line">    <span class="comment">// 如果状态与以前相同 那就是救助 因为我们此时没有工作到期。</span></span><br><span class="line">    resetHydrationState();</span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> root: FiberRoot = workInProgress.stateNode;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (current === <span class="literal">null</span> || current.child === <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">    root.hydrate &amp;&amp;</span><br><span class="line">    enterHydrationState(workInProgress)</span><br><span class="line">  ) &#123;</span><br><span class="line">    workInProgress.effectTag |= Placement;</span><br><span class="line"></span><br><span class="line">    workInProgress.child = mountChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reconcileChildren(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">    resetHydrationState();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里processcessUpdateQueue函数在上一篇render里面有相对详细的解读。这里关注点是内部引用:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resultState = getStateFromUpdate(</span><br><span class="line">    workInProgress,</span><br><span class="line">    queue,</span><br><span class="line">    update,</span><br><span class="line">    resultState,</span><br><span class="line">    props,</span><br><span class="line">    instance,</span><br><span class="line">);</span><br><span class="line">workInProgress.memoizedState = resultState;</span><br></pre></td></tr></table></figure>

<p>这里getStateFromUpdate函数为空白的workInProgress注入了props数据。它更新了workInProgress.memoizedState，就这里而言，它将<code>&#123;element: reactElement&#125;</code>的数据结构赋值过去了。</p>
<p>关于这个变量，参考scheduleRootUpdate函数里面的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> update = createUpdate(expirationTime);</span><br><span class="line">update.payload = &#123;element&#125;;</span><br></pre></td></tr></table></figure>
<p>让我们把关注点继续返回updateHostRoot函数，此时这个函数结束之后，正常情况会进入以下分支:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reconcileChildren(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    nextChildren,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">);</span><br><span class="line">resetHydrationState();</span><br><span class="line"><span class="keyword">return</span> workInProgress.child;</span><br></pre></td></tr></table></figure>

<p>因为返回的是workInProgress.child，所以这里重点关注一下reconcileChildren对workInProgress.child的处理。这里可以重新返回之前的「链表构建」来看。</p>
<h4 id="子孙节点"><a href="#子孙节点" class="headerlink" title="子孙节点"></a>子孙节点</h4><p>结合我们到链表构建这一小节。到此为止，我们可以做出这样的论断:</p>
<p>nextUnitOfWork实质上就是当前遍历过程中要处理的节点，通过我们的workLoop遍历，当这个工作到最终节点的时候，我们就完成了整个workProgeress树的构建。</p>
<p>不过这里稍微往下走走，当我们FiberRoot处理完毕，<strong>beginWork第二次运行时候应该是怎样的场景呢</strong>？此时返回的第二个FiberNode节点就是App组件对应的节点。这里关注点核心属性:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    effectTag: <span class="number">2</span></span><br><span class="line">	elementType: ƒ App()</span><br><span class="line">    type: ƒ App()</span><br><span class="line">    <span class="keyword">return</span>: FiberRoot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时走到beginWork.就会进入如下分支:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> IndeterminateComponent: &#123;</span><br><span class="line">    <span class="keyword">const</span> elementType = workInProgress.elementType;</span><br><span class="line">    <span class="keyword">return</span> mountIndeterminateComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        elementType,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountIndeterminateComponent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此时核心调用如下 省略多数无关代码</span></span><br><span class="line">    <span class="comment">// 它返回了一个ReactElement,这是一颗完整的VDOM树，下级已经全部展开为ReactElement</span></span><br><span class="line">    <span class="comment">// 就常规ClassComponent初始render，它相当于return Component(props, refOrContext)</span></span><br><span class="line">    value = renderWithHooks( </span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      props,</span><br><span class="line">      context,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">    reconcileChildren(<span class="literal">null</span>, workInProgress, value, renderExpirationTime);</span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是reconcileChildren。关于这个函数可以看看上面提过的「单一子节点构建」部分。总之这里对workProgress有一些修改。最后它将child设为了下面分支返回值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> created = createFiberFromFragment(</span><br><span class="line">    element.props.children,</span><br><span class="line">    returnFiber.mode,</span><br><span class="line">    expirationTime,</span><br><span class="line">    element.key,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>最后就是返回了FiberNode。这个FiberNode根据参数设定了以下非null值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pendingProps: children 完整VDOM树</span><br><span class="line">tag: Fragment = <span class="number">7</span></span><br><span class="line">expirationTime: expirationTime</span><br><span class="line">key: element.key</span><br><span class="line">mode: returnFiber.mode</span><br></pre></td></tr></table></figure>

<p>这里贯彻一个重点，那就是这个FiberNode是下一个nextUnitOfWork变量，如果对这个概念不熟，那么上一篇需要回看一下。总之，这里脉络是reconcileChildren函数为当前FiberNode构建了child值并返回这个child。</p>
<p>这个child上的pendingProps是workLoop能够持续加下去的核心所在。假设一下，当App里面内容是这样的：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;header className=<span class="string">&quot;App-header&quot;</span>&gt;</span><br><span class="line">        &lt;div&gt;Test&lt;/div&gt;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>beginWork这里分支判断主要靠fiberNode.tag判断。我们这里思考一下。这个App构建下来，会有多少个FiberNode, tag分别是？</p>
<p>答案是: 这里一共会有五个FiberNode, 组成一个workProgress链表树。对应的tag只分别是3、2、5、5、5。换成Enum值，那就是: HostRoot、IndeterminateComponent、HostComponent、HostComponent、HostComponent。很显然，ReactDomComponent都被设置为tag=HostComponent了。</p>
<p>那么问题来了，这里需要将tag和children(ReactElement)联结起来。这里是通过一系列的createFiberFromXXX函数做到的(FiberRoot除外)。而具体采用哪个函数，则取决于ReactElement.type。这里常规(ReactDomComponent)是使用createFiberFromElement函数。</p>
<p>就常规来说，如果<code>type === REACT_FRAGMENT_TYPE</code>则使用<code>createFiberFromFragment</code>,否则使用<code>createFiberFromElement</code>，后者是常规情况。</p>
<p>搞明白前面这些，现在我们可以认认真真看看，children是怎样一路层层拆包，只到遍历完毕为止的。这事workLoop和VDOM的关联脉络所在。</p>
<p>认真观察createFiberFromElement</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFiberFromElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> owner = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> type = element.type;</span><br><span class="line">  <span class="keyword">const</span> key = element.key;</span><br><span class="line">  <span class="keyword">const</span> pendingProps = element.props; <span class="comment">// 关注点1</span></span><br><span class="line">  <span class="keyword">const</span> fiber = createFiberFromTypeAndProps(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    pendingProps,</span><br><span class="line">    owner,</span><br><span class="line">    mode,</span><br><span class="line">    expirationTime,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> fiber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里补充updateHostComponent函数简略代码以加深了解</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">current, workInProgress, renderExpirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nextChildren = nextProps.children; <span class="comment">// 关注点2</span></span><br><span class="line">  reconcileChildren(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里我们通过这个函数里面这一句<code>const pendingProps = element.props</code>将整个VDOM树层层解包。最终完成了整个FiberNode树的构建&amp;链接。</p>
<p><strong>同时，VDOM和FiberNode的关系这里也有了清晰认知。</strong></p>
<h2 id="finishedWork树-amp-amp-current树"><a href="#finishedWork树-amp-amp-current树" class="headerlink" title="finishedWork树 &amp;&amp; current树"></a>finishedWork树 &amp;&amp; current树</h2><p>renderRoot函数在workLoop结束后有以下处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rootWorkInProgress = root.current.alternate;</span><br><span class="line">onComplete(root, rootWorkInProgress, expirationTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onComplete</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  root.pendingCommitExpirationTime = expirationTime;</span><br><span class="line">  root.finishedWork = finishedWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>root.current.alternate</code>显然是<code>root.current</code>的一个副本。</p>
<p>关于这个root上下文逻辑。不妨在本文内搜索<code>workInProgress.alternate = current.alternate = current = createHostRootFiber()</code>看看。当renderRoot结束后，它的child指向了我们的App节点。最终的情况就是: 当初始化渲染render阶段完成后，finishedWork == current == FiberRoot。</p>
<p>就整个流程来说。React在初次完成后，都会拥有一个current树，它的内部数据对应到整个UI上。如果后续有更新rootWorkInProgress树会被重新构建。</p>
<h2 id="updateQueue树"><a href="#updateQueue树" class="headerlink" title="updateQueue树"></a>updateQueue树</h2><p>updateQueue也是一个链表，不过它和FiberNode不一样，只有next一个链接属性。</p>
<p>updateQueue的脉络还是得从render这里入手。回顾之前的render文章，看看调用栈。我们可以发现，初始render第一次处理它，是在scheduleRootUpdate函数中的<code>enqueueUpdate(current, update)</code>。</p>
<p>这里针对FiberRoot设置的updateQueue是一个初始值。里面的callback值来源于上级调用。它在ReactRoot.prototype.render函数中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> work = <span class="keyword">new</span> ReactWork();</span><br><span class="line">updateContainer(children, root, <span class="literal">null</span>, work._onCommit);</span><br></pre></td></tr></table></figure>

<p>配合processUpdateQueue函数，可以很容易知道fiberRoot上的初始updateQueue是一个callback设为work._onCommit的初始值。</p>
<h2 id="Side-Effect树"><a href="#Side-Effect树" class="headerlink" title="Side-Effect树"></a>Side-Effect树</h2><p>我们可以将 React 中的一个组件视为一个使用 state 和 props 来计算 UI 表示的函数。改变 DOM 或调用生命周期方法，被视为Side-Effect。</p>
<p>在v15版本中DOM树通过它的_owner属性是否为null来判断是否是一个自定义组件。它的更新纯粹是判断props是否有变更来处理后续生命周期&amp;渲染。v16这里则是在FiberNode上记录了一个nextEffect属性来标记下一个自定义组件——v16叫类组件，它里面有生命周期之类的Side-Effect操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enqueueSetState(inst, payload, callback) &#123;</span><br><span class="line">  &#x2F;&#x2F; 此时inst为App实例 payload&#x3D;&#123;text: &#39;Hello World&#39;&#125; callback&#x3D;undefined</span><br><span class="line">  const fiber &#x3D; getInstance(inst);</span><br><span class="line">  const currentTime &#x3D; requestCurrentTime();</span><br><span class="line">  const expirationTime &#x3D; computeExpirationForFiber(currentTime, fiber);</span><br><span class="line"></span><br><span class="line">  const update &#x3D; createUpdate(expirationTime);</span><br><span class="line">  update.payload &#x3D; payload;</span><br><span class="line">  if (callback !&#x3D;&#x3D; undefined &amp;&amp; callback !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    update.callback &#x3D; callback;</span><br><span class="line">  &#125;</span><br><span class="line">  flushPassiveEffects();</span><br><span class="line">  enqueueUpdate(fiber, update);</span><br><span class="line">  scheduleWork(fiber, expirationTime);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这里关系到update的实质上就是<code>enqueueUpdate(fiber, update)</code>，说白了，这里update主要还是设置一个expirationTime, fiber节点上的更新队列才是实质核心。</p>
<p>这里enqueueUpdate主要是调用appendUpdateToQueue。这个函数基本可以理解为向update数组push一个元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function appendUpdateToQueue(queue, update) &#123;</span><br><span class="line">    &#x2F;&#x2F; lastUpdate&#x3D;&#x3D;&#x3D;null说明之前是空的队列</span><br><span class="line">    if (queue.lastUpdate &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">        queue.firstUpdate &#x3D; queue.lastUpdate &#x3D; update;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 否则将update放到链表队列尾部</span><br><span class="line">        queue.lastUpdate.next &#x3D; update;</span><br><span class="line">        queue.lastUpdate &#x3D; update;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>仔细想想，在v15进行Diff阶段，实质上是进行Diff对比中的ComponentDiff环节。这个环节如果props变化不会直接生成新的替换下级所有旧的节点。这里换了链表，但是这个对比环节还是需要依据。这里想来就是nextEffect属性存在的意义了。它定位了所有ClassComponent方便进行ComponentDiff。</p>
<p>但是需要注意的是: 这个链表的顺序，它不是按层级做顺序链接的。而是基于我们的FiberNode遍历理论，在这个遍历过程中，遇到ClassComponent时候，按照先后顺序进行连接、遍历。这里偷懒偷个图。。。</p>
<p><strong>这里关于组件对比的想法仅作为猜想了，后面看Update环节时候再做确认。</strong>这里疑问是，当这个next不再以DOM层级作为依据，底部组件可能比上层组件更先遍历到，那么问题在于如果下级和上级同时变化了，如果下级先处理一些事情会不会造成浪费？</p>
<p>这里问题暂且留到Update环节分析。</p>
<p><img src="../images/image-20190726144234693.png" alt="image-20190726144234693"></p>
]]></content>
      <tags>
        <tag>React ChildReconciler</tag>
      </tags>
  </entry>
  <entry>
    <title>react-v16-Update renderPhase篇</title>
    <url>/2019/08/07/react-v16-Update-renderPhase/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇主要还是笔记性质，一边探索一边记录。</p>
<p>因为Fiber链表性质，Update被重新实现，这里需要重新分析一下。</p>
<h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>这一节主要是对源码的分析。</p>
<p>先预设置一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    text: <span class="string">&#x27;Text&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  changeText = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      text: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">        &lt;header className=<span class="string">&quot;App-header&quot;</span>&gt;</span><br><span class="line">          &lt;div&gt;&#123;<span class="built_in">this</span>.state.text&#125;&lt;/div&gt;</span><br><span class="line">          &lt;button onClick=&#123;<span class="built_in">this</span>.changeText&#125;&gt;change Text&lt;/button&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们忽略事件相关的东西，专注setState。</p>
<h2 id="始于setState"><a href="#始于setState" class="headerlink" title="始于setState"></a>始于setState</h2><p>基于v15的理解，不管是props更新，还是state更新，实质上归根结底，还是setState触发的更新。</p>
<p>v16的props更新呢，它会不遵循这个路线吗？思前想后的结果是：不会。所以这里就直接分析setState了。</p>
<p>这里寻找这个定义挺容易的,直接命令行输入 <code>grep -rn &#39;prototype.setState&#39; ./packages</code>就可以查出来。当然，断点更容易出来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.updater.enqueueSetState(<span class="built_in">this</span>, partialState, callback, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里涉及到了<code>this.updater</code>。不妨全局查一下:<code>grep -rn &#39;\.updater =&#39; ./packages</code>。出来的结果只有<code>./packages/react-reconciler/src/ReactFiberClassComponent.js:497</code>,也就是<code>adoptClassInstance</code>函数可能是调用，观察这个赋值的目标<code>classComponentUpdater</code>，也能基本证明这个猜测。</p>
<p>所以这里<code>this.updater.enqueueSetState</code>实质上就是<code>classComponentUpdater.enqueueSetState</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">enqueueSetState</span>(<span class="params">inst, payload, callback</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 此时inst为App实例 payload=&#123;text: &#x27;Hello World&#x27;&#125; callback=undefined</span></span><br><span class="line">  <span class="keyword">const</span> fiber = getInstance(inst);</span><br><span class="line">  <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line">  <span class="keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, fiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> update = createUpdate(expirationTime);</span><br><span class="line">  update.payload = payload;</span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    update.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  flushPassiveEffects(); <span class="comment">// 这个例子中这个函数什么也没做</span></span><br><span class="line">  enqueueUpdate(fiber, update);</span><br><span class="line">  scheduleWork(fiber, expirationTime);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这里关系到update的实质上就是<code>enqueueUpdate(fiber, update)</code>，说白了，这里update主要还是设置一个expirationTime, fiber节点上的更新队列才是实质核心。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params">fiber: Fiber, update: Update&lt;State&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Update queues are created lazily.</span></span><br><span class="line">  <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line">  <span class="keyword">let</span> queue1;</span><br><span class="line">  <span class="keyword">let</span> queue2;</span><br><span class="line">  <span class="keyword">if</span> (alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// There&#x27;s only one fiber.</span></span><br><span class="line">    <span class="comment">// 仅有一个fiber节点 此时更新是一个初始渲染 </span></span><br><span class="line">    <span class="comment">// 此时由memoizedState创建一个更新即可 此时memoizedState是&#123;element: ReactNode&#125;结构</span></span><br><span class="line">    queue1 = fiber.updateQueue;</span><br><span class="line">    queue2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (queue1 === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// createUpdateQueue返回一个空update，baseState = &#123;text: &#x27;Text&#x27;&#125;</span></span><br><span class="line">      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有进入此分支</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queue2 === <span class="literal">null</span> || queue1 === queue2) &#123;</span><br><span class="line">    <span class="comment">// There&#x27;s only a single queue.</span></span><br><span class="line">    <span class="comment">// 此时只有一个queue</span></span><br><span class="line">    appendUpdateToQueue(queue1, update);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有进入此分支</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里enqueueUpdate主要是调用appendUpdateToQueue。这个函数基本可以理解为向update数组push一个元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendUpdateToQueue</span>(<span class="params">queue, update</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// lastUpdate===null说明之前是空的队列</span></span><br><span class="line">    <span class="keyword">if</span> (queue.lastUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 此例中进入这个分支了 update是一个对象，结构如下</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//   callback: null</span></span><br><span class="line">        <span class="comment">//   expirationTime: 1073741823</span></span><br><span class="line">        <span class="comment">//   next: null</span></span><br><span class="line">        <span class="comment">//   nextEffect: null</span></span><br><span class="line">        <span class="comment">//   payload: &#123;text: &quot;Hello World&quot;&#125;</span></span><br><span class="line">        <span class="comment">//   tag: 0</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        queue.firstUpdate = queue.lastUpdate = update;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则将update放到链表队列尾部</span></span><br><span class="line">        queue.lastUpdate.next = update;</span><br><span class="line">        queue.lastUpdate = update;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>走完这一步时候，<code>fiber&lt;APP&gt;.updateQueue</code>链表加入了update，updateQueue上firstEffect指向了这个update。</p>
<p>然后<code>enqueueSetState</code>开始执行<code>scheduleWork(fiber, expirationTime)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleWork</span>(<span class="params">fiber: Fiber, expirationTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// root指向FiberRoot</span></span><br><span class="line">  <span class="keyword">const</span> root = scheduleWorkToRoot(fiber, expirationTime);</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !isWorking &amp;&amp;</span><br><span class="line">    nextRenderExpirationTime !== NoWork &amp;&amp;</span><br><span class="line">    expirationTime &gt; nextRenderExpirationTime</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// This is an interruption. (Used for performance tracking.)</span></span><br><span class="line">    interruptedBy = fiber;</span><br><span class="line">    resetStack();</span><br><span class="line">  &#125;</span><br><span class="line">  markPendingPriorityLevel(root, expirationTime);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// If we&#x27;re in the render phase, we don&#x27;t need to schedule this root</span></span><br><span class="line">    <span class="comment">// for an update, because we&#x27;ll do it before we exit...</span></span><br><span class="line">    !isWorking ||</span><br><span class="line">    isCommitting ||</span><br><span class="line">    <span class="comment">// ...unless this is a different root than the one we&#x27;re rendering.</span></span><br><span class="line">    nextRoot !== root</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> rootExpirationTime = root.expirationTime;</span><br><span class="line">    requestWork(root, rootExpirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个函数主要是从Fiber<APP>开始往上遍历，更新对应节点的childExpirationTime属性，然后返回FiberRoot节点。childExpirationTime用来判定是否要更新child，这里不做细表。然后接下来会执行<code>requestWork(root, rootExpirationTime)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestWork</span>(<span class="params">root: FiberRoot, expirationTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">  addRootToSchedule(root, expirationTime);</span><br><span class="line">  <span class="keyword">if</span> (isRendering) &#123;</span><br><span class="line">    <span class="comment">// 禁止递归调用 后面的任务在结束后再重新开始</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isBatchingUpdates) &#123; <span class="comment">// 此时isBatchingUpdates === true</span></span><br><span class="line">    <span class="comment">// 在批处理结束后开始清洗工作(针对脏组件|Fiber?)</span></span><br><span class="line">    <span class="keyword">if</span> (isUnbatchingUpdates) &#123; <span class="comment">// 此时isUnbatchingUpdates === false 里面逻辑不会进入</span></span><br><span class="line">      <span class="comment">// 除非被排除在unbatchedUpdates，否则现在需要开始进行清洗</span></span><br><span class="line">      nextFlushedRoot = root;</span><br><span class="line">      nextFlushedExpirationTime = Sync;</span><br><span class="line">      performWorkOnRoot(root, Sync, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后面因为return 都不会执行 也就不会直接进入render调用栈</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Get rid of Sync and use current time?</span></span><br><span class="line">  <span class="keyword">if</span> (expirationTime === Sync) &#123;</span><br><span class="line">    performSyncWork();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scheduleCallbackWithExpirationTime(root, expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时入注释中所标，这个函数几乎不会执行任何东西，除了开头那一句——<code>addRootToSchedule(root, expirationTime)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addRootToSchedule</span>(<span class="params">root, expirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Add the root to the schedule.</span></span><br><span class="line">  <span class="comment">// Check if this root is already part of the schedule.</span></span><br><span class="line">  <span class="keyword">if</span> (root.nextScheduledRoot === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This root is not already scheduled. Add it.</span></span><br><span class="line">    root.expirationTime = expirationTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastScheduledRoot === <span class="literal">null</span>) &#123;</span><br><span class="line">      firstScheduledRoot = lastScheduledRoot = root;</span><br><span class="line">      root.nextScheduledRoot = root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没进来 略</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 没进来 略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为一个链表，lastScheduledRoot代表的是下一个操作、读取的目标。所以这里线索基本上可以锁定到读取了lastScheduledRoot变量的函数。这里能列入候选的函数只有两个</p>
<ul>
<li>findHighestPriorityRoot</li>
<li>addRootToSchedule</li>
</ul>
<p>但是满足场景的目标只有findHighestPriorityRoot。进一步反推，findHighestPriorityRoot调用者只有performWork——所以呢，不管什么，这个场景下，最后引起DOM更新的，必定、也必须是performWork。</p>
<blockquote>
<p>Tips: 这里之所以说lastScheduledRoot代表的是下一个操作，是因为这里没有对应的nextScheduledRoot变量，这个nextScheduledRoot直接挂到root节点上了，所以lastScheduledRoot就是下一个，也是最后一个。</p>
</blockquote>
<blockquote>
<p>Tips: 关于findHighestPriorityRoot可以后面看看Reconciler部分分析，会有详细分析。这里仅仅做脉络推导。</p>
</blockquote>
<blockquote>
<p>Tips: lastScheduledRoot实际上在React-DOM里面就一个指向fiberRoot或者干脆为null，addRootToSchedule实质上只是更新了fiberRoot.expirationTime。</p>
</blockquote>
<h2 id="略过的Event"><a href="#略过的Event" class="headerlink" title="略过的Event"></a>略过的Event</h2><p>不管怎样，v16更新后更新逻辑因为基础数据结构变化，出了一些必要的变化，总之这里更新后DOM确确实实不再是setState直接引起的了。它被耦合进了事件这一块。当更新队列处理完毕之后，React只是不动声色lastScheduledRoot赋值给了fiberRoot，然后由事件机制处理了后续。</p>
<p>但是这里不打算调过头去研究新的Event了。所以还是通过断点来过去调用栈。这里产生的调用栈是:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dispatchInteractiveEvent</span><br><span class="line">-&gt;interactiveUpdates</span><br><span class="line">--&gt;dispatchEvent</span><br><span class="line">---&gt;performSyncWork</span><br><span class="line">----&gt;performWork</span><br><span class="line">-----&gt;performWorkOnRoot -&gt; renderRoot &amp; completeRoot</span><br></pre></td></tr></table></figure>

<p>这里暂时不管是如何调用下来的，但是这里能确认的是当断点走过performWorkOnRoot函数。Text在DOM上就完成了从Text到HelloWorld的过程。</p>
<h2 id="performWorkOnRoot"><a href="#performWorkOnRoot" class="headerlink" title="performWorkOnRoot"></a>performWorkOnRoot</h2><p>这个函数其实在render篇已经提到过了。不过这里重点是要把Update部分单独拎出来讲，侧重点有所不同。</p>
<p>这里基础的路径还是:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">performWorkOnRoot</span><br><span class="line">-&gt;beginWork</span><br><span class="line">--&gt;updateClassComponent</span><br><span class="line">----&gt;updateClassInstance</span><br><span class="line">-----&gt;processUpdateQueue</span><br><span class="line">------&gt;getStateFromUpdate</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStateFromUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: Update&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  prevState: State,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance: any,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (update.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> ReplaceState: &#123;</span><br><span class="line">		<span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> CaptureUpdate: &#123;</span><br><span class="line">		<span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> UpdateState: &#123;</span><br><span class="line">      <span class="keyword">const</span> payload = update.payload;</span><br><span class="line">      <span class="keyword">let</span> partialState;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> payload === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        partialState = payload.call(instance, prevState, nextProps);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        partialState = payload;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (partialState === <span class="literal">null</span> || partialState === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, prevState, partialState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ForceUpdate: &#123;</span><br><span class="line">      hasForceUpdate = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> prevState;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prevState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里场景下的核心是<code>Object.assign(&#123;&#125;, prevState, partialState)</code>。很好理解。</p>
<p>processUpdateQueue这个函数在这里需要关注点的是，更新了workInProgress.memoizedState。但是这是App这个fiber节点的事情。不妨回顾有关ChildReconciler的分析。当我们把文首的例子拆成Fiber，有几个节点呢(这里由FunctionComponent-&gt;ClassComponent了)？</p>
<p>这里答案是6个。我们添加一个button。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> FiberRoot tag = <span class="number">3</span></span><br><span class="line"><span class="number">2.</span> fiberNode&#123;elementType = App&#125; tag = <span class="number">1</span></span><br><span class="line"><span class="number">3.</span> fiberNode&#123;elementType = <span class="string">&#x27;div&#x27;</span>&#125; tag = <span class="number">5</span></span><br><span class="line"><span class="number">4.</span> fiberNode&#123;elementType = <span class="string">&#x27;header&#x27;</span>&#125; tag = <span class="number">5</span></span><br><span class="line"><span class="number">5.</span> fiberNode&#123;elementType = <span class="string">&#x27;div&#x27;</span>&#125; tag = <span class="number">5</span></span><br><span class="line"><span class="number">6.</span> fiberNode&#123;elementType = <span class="string">&#x27;button&#x27;</span>&#125; tag = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>这里完全可以做一个小结，在这个更新的的render环节，主要是两个Fiber节点变了。</p>
<ul>
<li>第二个节点memoizedState变化为{text: ‘Hello World’}</li>
<li>第五个节点里面memoizedProps和pendingProps节点里面分别保存了新旧不同的children。</li>
</ul>
<p>以v15的Diff算法。会针对第五个节点执行创建新节点对旧节点进行替换、插入第六个节点。我们后面再看看V16里面是如何实现Diff的。</p>
<p>总之，这是completeRoot环节的问题。切略过不提。</p>
<h2 id="Hook的实现"><a href="#Hook的实现" class="headerlink" title="Hook的实现"></a>Hook的实现</h2><p>原本想过如何去理解Hook，但是最后决定把它作为Update的一个小结来分析。</p>
<p>由很多人说Hook其实可以作为Redux的替代，但是Redux本身是借助setState实现，所以这里看看Hook是如何处理的。</p>
<p>这里需要一个新的例子。这里改造一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [text, setText] = useState(<span class="string">&#x27;Text&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;header className=<span class="string">&quot;App-header&quot;</span>&gt;</span><br><span class="line">        &lt;div&gt;&#123;text&#125;&lt;/div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> &#123; setText(<span class="string">&#x27;Hello World&#x27;</span>) &#125;&#125;&gt;change Text&lt;/button&gt;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看useState的定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span>&gt;(<span class="params">initialState: (() =&gt; S) | S</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveDispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ReactCurrentDispatcher = &#123;</span><br><span class="line">  current: (<span class="literal">null</span>: <span class="literal">null</span> | Dispatcher),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个逻辑埋得有点深。断点在<code>useState(&#39;Text&#39;)</code>之前，可以发现它是<code>ƒ bound dispatchAction()</code>,最终是对dispatchAction的处理。</p>
<p>再看看调试工具里面的调用栈。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">App (App.js:<span class="number">5</span>)</span><br><span class="line">renderWithHooks (react-dom.development.js:<span class="number">13449</span>)</span><br><span class="line">updateFunctionComponent (react-dom.development.js:<span class="number">15199</span>)</span><br><span class="line">beginWork (react-dom.development.js:<span class="number">16252</span>)</span><br><span class="line">performUnitOfWork (react-dom.development.js:<span class="number">20279</span>)</span><br><span class="line">workLoop (react-dom.development.js:<span class="number">20320</span>)</span><br><span class="line">renderRoot (react-dom.development.js:<span class="number">20400</span>)</span><br><span class="line">performWorkOnRoot (react-dom.development.js:<span class="number">21357</span>)</span><br><span class="line">performWork (react-dom.development.js:<span class="number">21267</span>)</span><br><span class="line">performSyncWork (react-dom.development.js:<span class="number">21241</span>)</span><br><span class="line">interactiveUpdates$<span class="number">1</span> (react-dom.development.js:<span class="number">21526</span>)</span><br><span class="line">interactiveUpdates (react-dom.development.js:<span class="number">2268</span>)</span><br><span class="line">dispatchInteractiveEvent (react-dom.development.js:<span class="number">5085</span>)</span><br></pre></td></tr></table></figure>

<p>根据renderWithHooks函数，可以做出的论断是ReactCurrentDispatcher.current 可能的值是 HooksDispatcherOnUpdate &amp;&amp; HooksDispatcherOnMount。初始渲染阶段，它是HooksDispatcherOnMount，之后它是HooksDispatcherOnUpdate。</p>
<p>这里得看看HooksDispatcherOnMount，然后才是HooksDispatcherOnUpdate。</p>
<p>为什么是这个顺序？因为setText是一个函数，后面在update环节会调用。而它里面有很多变量，必须在这里形成闭包缓存起来以备后面使用。</p>
<p>如果无法理解这个mount &amp; update。这里做个简要分析:</p>
<ul>
<li>当我们初次渲染渲染时候，App函数会运行，useState会运行第一次。这是一个初始化</li>
<li>当App里面onClick触发setText时候，useState里面会有第二次运行。但是我们的useState依然会运行第二次。</li>
<li>这里问题来了: 这两次useState运行过程中，又应当是怎样的实现的数据变更和变量传递呢？</li>
</ul>
<h3 id="Mount-amp-amp-Dispatch"><a href="#Mount-amp-amp-Dispatch" class="headerlink" title="Mount &amp;&amp; Dispatch"></a>Mount &amp;&amp; Dispatch</h3><p>第一阶段是Mount，这是初始化渲染环节里面的处理方式。</p>
<p>HooksDispatcherOnMount.useState:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>&lt;<span class="title">S</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  initialState: (() =&gt; S) | S,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">BasicStateAction</span>&lt;<span class="title">S</span>&gt;&gt;] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    initialState = initialState();</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;</span><br><span class="line">  <span class="keyword">const</span> queue = (hook.queue = &#123;</span><br><span class="line">    last: <span class="literal">null</span>,</span><br><span class="line">    dispatch: <span class="literal">null</span>,</span><br><span class="line">    lastRenderedReducer: basicStateReducer,</span><br><span class="line">    lastRenderedState: (initialState: any),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;</span><br><span class="line">    BasicStateAction&lt;S&gt;,</span><br><span class="line">  &gt; = (queue.dispatch = (dispatchAction.bind(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// Flow doesn&#x27;t know this is non-null, but we do.</span></span><br><span class="line">    ((currentlyRenderingFiber: any): Fiber),</span><br><span class="line">    queue,</span><br><span class="line">  ): any));</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mountWorkInProgressHook构建了一个空的Hook数据结构,它和Fiber很像，或者说，它是fiber的一个子集。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type Hook = &#123;</span><br><span class="line">  memoizedState: any,</span><br><span class="line">  baseState: any,</span><br><span class="line">  baseUpdate: Update&lt;any, any&gt; | <span class="literal">null</span>,</span><br><span class="line">  queue: UpdateQueue&lt;any, any&gt; | <span class="literal">null</span>,</span><br><span class="line">  next: Hook | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: Hook也被储存在链表结构中。它们使用以下变量进行储存，next连接所有Hook:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let currentHook: Hook | null &#x3D; null;</span><br><span class="line">let nextCurrentHook: Hook | null &#x3D; null;</span><br><span class="line">let firstWorkInProgressHook: Hook | null &#x3D; null;</span><br><span class="line">let workInProgressHook: Hook | null &#x3D; null;</span><br><span class="line">let nextWorkInProgressHook: Hook | null &#x3D; null;</span><br></pre></td></tr></table></figure>
<p>这里初始化渲染是将firstWorkInProgressHook,workInProgressHook都设为了这个新建的hook。</p>
</blockquote>
<p>而currentlyRenderingFiber变量在renderWithHooks函数里面有定义,它是当前渲染的Fiber节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">currentlyRenderingFiber = workInProgress;</span><br></pre></td></tr></table></figure>

<p>所以说，就这个setText函数来说，未看其内容，已经可以知道，它可以获取queue(尤其是内部的memoizedState值，这里场景是text变量)，同时也可以访问到对应的Fiber节点，它形成一个闭包。接下来看看dispatchAction函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAction</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    fiber === currentlyRenderingFiber ||</span><br><span class="line">    (alternate !== <span class="literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber)</span><br><span class="line">  ) &#123;</span><br><span class="line">	<span class="comment">// 这里没有进入此分支 暂时略过</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    flushPassiveEffects();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line">    <span class="keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, fiber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">      expirationTime,</span><br><span class="line">      action,</span><br><span class="line">      eagerReducer: <span class="literal">null</span>,</span><br><span class="line">      eagerState: <span class="literal">null</span>,</span><br><span class="line">      next: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append the update to the end of the list.</span></span><br><span class="line">    <span class="comment">// 以下逻辑是 是将update添加到链表尾部</span></span><br><span class="line">    <span class="comment">// 当queue.last===null.此时queue是空的。queue.next = queue.last = update</span></span><br><span class="line">    <span class="comment">// 否则。走下面注释的逻辑</span></span><br><span class="line">    <span class="keyword">const</span> last = queue.last;</span><br><span class="line">    <span class="keyword">if</span> (last === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">      update.next = update;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> first = last.next;</span><br><span class="line">      <span class="keyword">if</span> (first !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查queue.last 如果有值。追加到update.next上</span></span><br><span class="line">        update.next = first;</span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="comment">// queue.last.next = update。将update放到了queue链表最后一个下一个节点</span></span><br><span class="line">      last.next = update; </span><br><span class="line">    &#125;</span><br><span class="line">    queue.last = update; <span class="comment">// 正式将last指针移到update</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      fiber.expirationTime === NoWork &amp;&amp;</span><br><span class="line">      (alternate === <span class="literal">null</span> || alternate.expirationTime === NoWork)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// The queue is currently empty, which means we can eagerly compute the</span></span><br><span class="line">      <span class="comment">// next state before entering the render phase. If the new state is the</span></span><br><span class="line">      <span class="comment">// same as the current state, we may be able to bail out entirely.</span></span><br><span class="line">      <span class="comment">// 当前队列为空，这意味我们可以直接进行新的state计算 如果新的state和旧的完全一直</span></span><br><span class="line">      <span class="comment">// 那么就可以什么不做了</span></span><br><span class="line">      <span class="keyword">const</span> lastRenderedReducer = queue.lastRenderedReducer;</span><br><span class="line">      <span class="keyword">if</span> (lastRenderedReducer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> prevDispatcher;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> currentState: S = (queue.lastRenderedState: any);</span><br><span class="line">          <span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);</span><br><span class="line">          <span class="comment">// Stash the eagerly computed state, and the reducer used to compute</span></span><br><span class="line">          <span class="comment">// it, on the update object. If the reducer hasn&#x27;t changed by the</span></span><br><span class="line">          <span class="comment">// time we enter the render phase, then the eager state can be used</span></span><br><span class="line">          <span class="comment">// without calling the reducer again.</span></span><br><span class="line">          <span class="comment">// 缓存之前update对象上 计算出的state，以及用来计算这个state的reducer函数</span></span><br><span class="line">          <span class="comment">// 如果reducer函数在进入render phase时没有变化，那么可直接使用之前缓存的值而不需要重新计算</span></span><br><span class="line">          update.eagerReducer = lastRenderedReducer;</span><br><span class="line">          update.eagerState = eagerState;</span><br><span class="line">          <span class="keyword">if</span> (is(eagerState, currentState)) &#123;</span><br><span class="line">						<span class="comment">// 这是一个捷径。我们可以直接结束而不去规划re-render</span></span><br><span class="line">            <span class="comment">// 但是它还是有可能稍后重新定义update——如果后面这个组件因为其他原因被re-render</span></span><br><span class="line">            <span class="comment">// 并且此时Reducer函数被更改的话。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// Suppress the error. It will throw again in the render phase.</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scheduleWork(fiber, expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然里面逻辑很多，但是它核心的地方却只有几个:</p>
<ul>
<li>根据action参数(Hello World)创建了一个update</li>
<li>update被加入到了queue链表上</li>
<li>执行scheduleWork</li>
</ul>
<p>此时因为scheduleWork在batchedUpdates函数下游，isBatchingUpdates(这个变量在batchedUpdates更改并后续requestWork中引用)被赋值为true，所以scheduleWork并不会引发后面的commit phase阶段。</p>
<p>而是由事件系统触发了。调用栈其实和上面Event提到的一致。</p>
<p>到了这里，最后的疑问可能就是commit阶段里，后续它究竟是如何获取queue链表了，这里还是call by share相关知识了，这里不再提及，主要还是对hook变量上的queue做了修改，此时hook.queue被添加了一个update到尾部上。当setText被导出，这个hook就会因为闭包被缓存再mountState的作用域里面不会被GC。</p>
<p>由于这个hook每次运行都会重新生成新的hook，所以多个FunctionComponent里面相同的setText使用不会读取到旧的值。</p>
<p>而且因为hook没有被导出过，renderWithHook也由相关render阶段执行，所以也无法在React组件之外访问到它。</p>
<p><strong>以下是重点</strong>。前面我们提到了对hook的创建，操作，链表结构，以及firstWorkInProgressHook变量。但是它们都没有做导出。这里hook是链表，它和WorkInProgress是相同的性质，它将可以类似全局性质的获取、变更。</p>
<p>回头仔细观察renderWithHooks函数。其中两句显得尤为关键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> children = Component(props, refOrContext);</span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line"><span class="keyword">const</span> renderedWork: Fiber = (currentlyRenderingFiber: any);</span><br><span class="line">renderedWork.memoizedState = firstWorkInProgressHook;</span><br></pre></td></tr></table></figure>

<p>综上，可以知道<code>renderedWork.memoizedState</code>变量被赋值未新建的那个Hook。为什么在末尾重点提到它呢？因为它不但承上，而且启下，是整个hook和fiber结构的联结点。</p>
<blockquote>
<p>现在已知memoizedState不但会保存常规的memoizedState值，还会保存ReactElement和Hook。</p>
</blockquote>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>然后就是我们想知道的更新方面的环节。当renderWithHook再度调起App(),此时HooksDispatcherOnUpdate.useState就有了用武之地，它实质指向updateState。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateState</span>&lt;<span class="title">S</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  initialState: (() =&gt; S) | S,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">BasicStateAction</span>&lt;<span class="title">S</span>&gt;&gt;] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateReducer(basicStateReducer, (initialState: any));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>&lt;<span class="title">S</span>&gt;(<span class="params">state: S, action: BasicStateAction&lt;S&gt;</span>): <span class="title">S</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而updateReducer里面有这样的返回：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>&lt;<span class="title">S</span>, <span class="title">I</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  reducer: (S, A) =&gt; S,</span></span></span><br><span class="line"><span class="function"><span class="params">  initialArg: I,</span></span></span><br><span class="line"><span class="function"><span class="params">  init?: I =&gt; S, </span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">A</span>&gt;] </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">      <span class="keyword">const</span> queue = hook.queue;</span><br><span class="line">      <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</span><br><span class="line">      <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里hook执行后的返回值大致如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  baseState: <span class="string">&quot;Text&quot;</span></span><br><span class="line">  baseUpdate: <span class="literal">null</span></span><br><span class="line">  memoizedState: <span class="string">&quot;Text&quot;</span></span><br><span class="line">  next: <span class="literal">null</span></span><br><span class="line">  queue: &#123;</span><br><span class="line">    dispatch: ƒ ()</span><br><span class="line">    last: &#123;<span class="attr">expirationTime</span>: <span class="number">1073741823</span>, <span class="attr">action</span>: <span class="string">&quot;Hello World&quot;</span>, <span class="attr">eagerReducer</span>: ƒ, <span class="attr">eagerState</span>: <span class="string">&quot;Hello World&quot;</span>, <span class="attr">next</span>: &#123;…&#125;&#125;</span><br><span class="line">    lastRenderedReducer: ƒ basicStateReducer(state, action)</span><br><span class="line">    lastRenderedState: <span class="string">&quot;Text&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参见<code>updateWorkInProgressHook</code>,它返回的主要是nextCurrentHook的一个副本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nextWorkInProgressHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="comment">// 略 未进入此分支</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Clone from the current hook.</span></span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line">    <span class="keyword">const</span> newHook: Hook = &#123;</span><br><span class="line">      memoizedState: currentHook.memoizedState,</span><br><span class="line">      baseState: currentHook.baseState,</span><br><span class="line">      queue: currentHook.queue,</span><br><span class="line">      baseUpdate: currentHook.baseUpdate,</span><br><span class="line"></span><br><span class="line">      next: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This is the first hook in the list.</span></span><br><span class="line">      workInProgressHook = firstWorkInProgressHook = newHook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Append to the end of the list.</span></span><br><span class="line">      workInProgressHook = workInProgressHook.next = newHook;</span><br><span class="line">    &#125;</span><br><span class="line">    nextCurrentHook = currentHook.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里关键是<code>nextCurrentHook</code>变量，再回头看看renderWithHooks，里面有一句:</p>
<p><code>nextCurrentHook = current !== null ? current.memoizedState : null</code>。</p>
<p>所以一切都顺理成章了。它们都指向了之前创建的hook。</p>
<p>到这里我们就可以明白，这个遍历是如何从dispatch传递到update环节的。在Mount环节，我们初始化了一个Hook，然后再dispatch我们更新了这个Hook，并将他赋值到了当前fiberNode的memoizedState属性。最后我们更新环节则更换了一个useState函数，它在里面获取了dispatch变更后的Hook，然后执行了后续渲染。</p>
<p>在之前的ChildReconciler篇里面其实有提到renderWithHooks。但是那时候只是专注于它的结果，它返回的是一颗展开完毕的VDOM树。</p>
<p>这里我们仍然不做接下来的细节分析，但是，对于最简单的Hook更新，我们已经对其数据流变化一清二楚了。</p>
<h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p>这里还是走的Event这块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dispatchInteractiveEvent</span><br><span class="line">-&gt;interactiveUpdates</span><br><span class="line">--&gt;dispatchEvent</span><br><span class="line">---&gt;performSyncWork</span><br><span class="line">----&gt;performWork</span><br><span class="line">-----&gt;performWorkOnRoot -&gt; renderRoot &amp; completeRoot</span><br></pre></td></tr></table></figure>

<p>但是为了能更好代入Hook这块，我们做一些更细致的工作:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatchInteractiveEvent</span><br><span class="line">-&gt;interactiveUpdates</span><br><span class="line">--&gt;dispatchEvent</span><br><span class="line">---&gt;performSyncWork</span><br><span class="line">----&gt;performWork</span><br><span class="line">-----&gt;performWorkOnRoot -&gt; renderRoot() &#123;</span><br><span class="line">  workLoop</span><br><span class="line">    -&gt;performUnitOfWork</span><br><span class="line">    --&gt;beginWork</span><br><span class="line">    ----&gt;updateFunctionComponent -&gt;renderWithHooks</span><br><span class="line">&#125; &amp; completeRoot</span><br></pre></td></tr></table></figure>

<p>这样，就能将Event这块和Hook这块衔接上了。</p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react-v16-Update-commitPhase</title>
    <url>/2019/08/07/react-v16-Update-commitPhase/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们之前render篇，我们有比较简略的对commitPhase环节进行分析。这里在它的基础上对Update的commitPhase进行分析。它们实际上是同一个环节。</p>
<p>但是这里随着对Update环节的认知深入，所以这里commit环节也可以进一步深入了解。</p>
<p>总之，这里是承了之前的render篇上一篇update篇来对commit进行深入的分析。他不仅仅像是标题提到的Update环节下的commit，实质上也是render环节下的commit。</p>
<p>这里会牵扯到Diff算法。我们也一并看看，不再像前面那边简单略过。</p>
<h1 id="调用栈确认"><a href="#调用栈确认" class="headerlink" title="调用栈确认"></a>调用栈确认</h1><p>之前提到update和render里面的commit环节是同一个。但是这里依然要做一个确认。</p>
<ul>
<li><p>这里首先当然是Render环节下的调用栈。<br>回顾一下render篇，performWorkOnRoot函数里面renderRoot执行之后会执行completeRoot。这里调用栈就是之前提到的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">completeRoot</span><br><span class="line">-&gt; commitRoot () &#123;</span><br><span class="line">    commitBeforeMutationLifecycles()</span><br><span class="line">    commitAllHostEffects();</span><br><span class="line">    root.current = finishedWork;</span><br><span class="line">    commitAllLifeCycles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Update之setState部分</p>
<p>这里在之前「略过的Event」小结里面提到了<code>performWorkOnRoot -&gt; renderRoot &amp; completeRoot</code>。所以整体和前面一致</p>
</li>
<li><p>Update之useState部分</p>
<p>这里在文章最尾部的「commit」小结里面有明显分析。最终也是completeRoot函数。</p>
</li>
</ul>
<p>所以这里可以明确一下，它们都commitPhase都是走的completeRoot。</p>
<h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>实际上，必须提前说一下，completeRoot和renderRoot在workLoop过程中，往往是二选一的调用。如果root.finishedWork为空执行renderRoot，否则执行completeRoot。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">completeRoot</span><br><span class="line">-&gt; commitRoot () &#123;</span><br><span class="line">    commitBeforeMutationLifecycles()</span><br><span class="line">    commitAllHostEffects();</span><br><span class="line">    root.current = finishedWork;</span><br><span class="line">    commitAllLifeCycles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="completeRoot"><a href="#completeRoot" class="headerlink" title="completeRoot"></a>completeRoot</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查是否存在与此到期时间匹配的批次。</span></span><br><span class="line">  <span class="keyword">const</span> firstBatch = root.firstBatch;</span><br><span class="line">  <span class="keyword">if</span> (firstBatch !== <span class="literal">null</span> &amp;&amp; firstBatch._expirationTime &gt;= expirationTime) &#123;</span><br><span class="line">    <span class="keyword">if</span> (completedBatches === <span class="literal">null</span>) &#123;</span><br><span class="line">      completedBatches = [firstBatch];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      completedBatches.push(firstBatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (firstBatch._defer) &#123;</span><br><span class="line">      <span class="comment">// 这个root节点被阻止进入commitPhase. 取消它的调度直到收到其他更新。</span></span><br><span class="line">      root.finishedWork = finishedWork;</span><br><span class="line">      root.expirationTime = NoWork;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Commit the root.</span></span><br><span class="line">  <span class="comment">// 清空finishedWork 只有finishedWork!==null才会执行进这个函数</span></span><br><span class="line">  <span class="comment">// 当然 这里finishedWork作为参数传进来了 清不清空都不影响我们调用</span></span><br><span class="line">  root.finishedWork = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查这是否是一个嵌套的更新(有一个同步的更新在commit阶段被纳入更新计划)</span></span><br><span class="line">  <span class="keyword">if</span> (root === lastCommittedRootDuringThisBatch) &#123;</span><br><span class="line">    <span class="comment">// 如果新的root和旧的root相同。这事一个嵌套更新。为了防止陷入死循环。</span></span><br><span class="line">    <span class="comment">// 对nestedUpdateCount变量进行累加</span></span><br><span class="line">    nestedUpdateCount++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 切换root时候 对nestedUpdateCount变量清零</span></span><br><span class="line">    lastCommittedRootDuringThisBatch = root;</span><br><span class="line">    nestedUpdateCount = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  runWithPriority(ImmediatePriority, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    commitRoot(root, finishedWork);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里细节不算多。</p>
<p>completedBatches作为<code>Array&lt;Batch&gt;</code>数组。它主要是保存<code>root.firstBatch</code>，如果batch有阻止，这个保存也依然会进入数组保存起来。当render完毕，finishRendering函数后面会清空它的同时，遍历Batch上的_onComplete函数并执行。</p>
<p>lastCommittedRootDuringThisBatch变量用来缓存每次执行completeRoot传入的root。以便后面的scheduleWork出错捕获。</p>
<blockquote>
<p>Tips: </p>
<ul>
<li><p>lastCommittedRootDuringThisBatch会被finishRendering函数清空为null。</p>
</li>
<li><p>另外scheduleWork这里说到捕获，是因为在ReactNative中可能存在多个fiberRoot，而ReactDom中只有一个。</p>
</li>
</ul>
</blockquote>
<p>nestedUpdateCount变量用来标记相同root更新次数，如果超出50次，那么很有可能就是出现了代码错误，导致组件无限更新了——这个在scheduleWork函数中，当然，只是警告，同时它还是会将其清空为0。</p>
<p>接下来是<code>runWithPriority</code>函数这块，这块是其核心中的核心。看看源代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_runWithPriority</span>(<span class="params">priorityLevel, eventHandler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">    <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">    <span class="keyword">case</span> NormalPriority:</span><br><span class="line">    <span class="keyword">case</span> LowPriority:</span><br><span class="line">    <span class="keyword">case</span> IdlePriority:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      priorityLevel = NormalPriority;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  <span class="keyword">var</span> previousEventStartTime = currentEventStartTime;</span><br><span class="line">  currentPriorityLevel = priorityLevel;</span><br><span class="line">  currentEventStartTime = getCurrentTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> eventHandler();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    currentEventStartTime = previousEventStartTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before exiting, flush all the immediate work that was scheduled.</span></span><br><span class="line">    <span class="comment">// 退出之前，将所有规划好的立即执行任务执行完毕。</span></span><br><span class="line">    flushImmediateWork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要是设定currentPriorityLevel &amp;&amp; currentEventStartTime，然后执行eventHandler()，完毕之后将这两个值还原。并执行<code>flushImmediateWork()</code>。</p>
<p>在这里<code>eventHandler === () =&gt; (commitRoot(root, finishedWork))</code>。我们先继续这个路线。</p>
<h2 id="commitRoot"><a href="#commitRoot" class="headerlink" title="commitRoot"></a>commitRoot</h2><p>这里代码有点长，做一些精简。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">root: FiberRoot, finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  isWorking = <span class="literal">true</span>;</span><br><span class="line">  isCommitting = <span class="literal">true</span>;</span><br><span class="line">  startCommitTimer();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存并清空root.pendingCommitExpirationTime属性</span></span><br><span class="line">  <span class="keyword">const</span> committedExpirationTime = root.pendingCommitExpirationTime;</span><br><span class="line">  root.pendingCommitExpirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新优先级</span></span><br><span class="line">  <span class="comment">// 更新待处理pending优先级以考虑我们即将提交的工作。 </span></span><br><span class="line">  <span class="comment">// 这需要在调用生命周期之前进行，因为他们可能会安排其他更新。</span></span><br><span class="line">  <span class="keyword">const</span> updateExpirationTimeBeforeCommit = finishedWork.expirationTime;</span><br><span class="line">  <span class="keyword">const</span> childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;</span><br><span class="line">  <span class="comment">// childExpirationTime 和 expirationTime对比</span></span><br><span class="line">  <span class="keyword">const</span> earliestRemainingTimeBeforeCommit =</span><br><span class="line">    childExpirationTimeBeforeCommit &gt; updateExpirationTimeBeforeCommit</span><br><span class="line">      ? childExpirationTimeBeforeCommit</span><br><span class="line">      : updateExpirationTimeBeforeCommit;</span><br><span class="line">  markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> prevInteractions: <span class="built_in">Set</span>&lt;Interaction&gt; = (<span class="literal">null</span>: any);</span><br><span class="line">  <span class="keyword">if</span> (enableSchedulerTracing) &#123;<span class="comment">// 略 &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reset this to null before calling lifecycles</span></span><br><span class="line">  <span class="comment">// 重置ReactCurrentOwner.current防止生命周期函数被影响</span></span><br><span class="line">  ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据effectTag 处理Effect List链表</span></span><br><span class="line">  <span class="keyword">let</span> firstEffect;</span><br><span class="line">  <span class="keyword">if</span> (finishedWork.effectTag &gt; PerformedWork) &#123;</span><br><span class="line">    <span class="keyword">if</span> (finishedWork.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">      finishedWork.lastEffect.nextEffect = finishedWork;</span><br><span class="line">      firstEffect = finishedWork.firstEffect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      firstEffect = finishedWork;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There is no effect on the root.</span></span><br><span class="line">    firstEffect = finishedWork.firstEffect;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 预备渲染新的节点。此时禁止事件的触发，统计后面需要autofocus的节点</span></span><br><span class="line">  prepareForCommit(root.containerInfo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invoke instances of getSnapshotBeforeUpdate before mutation.</span></span><br><span class="line">  <span class="comment">// 遍历执行实例中的getSnapshotBeforeUpdate</span></span><br><span class="line">  nextEffect = firstEffect;</span><br><span class="line">  startCommitSnapshotEffectsTimer();</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> didError = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> error;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        commitBeforeMutationLifecycles();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        didError = <span class="literal">true</span>;</span><br><span class="line">        error = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (didError) &#123; <span class="comment">/* 错误捕获并将指针移动到下一个Effect */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  stopCommitSnapshotEffectsTimer();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer) &#123;<span class="comment">// 略&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// commit tree中所有的side-effects。这里分两个步骤</span></span><br><span class="line">  <span class="comment">// 这里是第一个步骤:执行所有host的插入、更新、删除和ref卸载(注意后面第二个步骤)</span></span><br><span class="line">  nextEffect = firstEffect;</span><br><span class="line">  startCommitHostEffectsTimer();</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> didError = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> error;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123; &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        commitAllHostEffects();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        didError = <span class="literal">true</span>;</span><br><span class="line">        error = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (didError) &#123; <span class="comment">/* 错误捕获并将指针移动到下一个Effect */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  stopCommitHostEffectsTimer();</span><br><span class="line">  <span class="comment">// 在已经将真实的节点挂载后触发</span></span><br><span class="line">  resetAfterCommit(root.containerInfo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此时work-in-progress tree 就是 current tree。</span></span><br><span class="line">  <span class="comment">// 这必须发生在遍历执行side-effects第一个步骤之后，这样current树仍然是the previous tree</span></span><br><span class="line">  <span class="comment">// componentWillUnmount(resetAfterCommit)此时执行</span></span><br><span class="line">  <span class="comment">// 但是又必须发生在遍历执行side-effects第二个步骤之前，这样finishedWork树是current树 </span></span><br><span class="line">  <span class="comment">// 方便执行componentDidMount/Update(commitAllLifeCycles)</span></span><br><span class="line">  root.current = finishedWork;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在commit side-effects第二步骤，我们执行所有声明周期函数和ref回调</span></span><br><span class="line">  <span class="comment">// 生命周期作为单独的阶段触发，如此整个tree上所有的替换、更新、删除都将被调用</span></span><br><span class="line">  <span class="comment">// 在这个阶段，所有的renderer-specific initial effects也会被触发</span></span><br><span class="line">  nextEffect = firstEffect;</span><br><span class="line">  startCommitLifeCyclesTimer();</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> didError = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> error;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123; &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        commitAllLifeCycles(root, committedExpirationTime);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        didError = <span class="literal">true</span>;</span><br><span class="line">        error = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (didError) &#123; <span class="comment">/* 错误捕获并将指针移动到下一个Effect */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (firstEffect !== <span class="literal">null</span> &amp;&amp; rootWithPendingPassiveEffects !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This commit included a passive effect. These do not need to fire until</span></span><br><span class="line">    <span class="comment">// after the next paint. Schedule an callback to fire them in an async</span></span><br><span class="line">    <span class="comment">// event. To ensure serial execution, the callback will be flushed early if</span></span><br><span class="line">    <span class="comment">// we enter rootWithPendingPassiveEffects commit phase before then.</span></span><br><span class="line">    <span class="keyword">let</span> callback = commitPassiveEffects.bind(<span class="literal">null</span>, root, firstEffect);</span><br><span class="line">    <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Avoid this extra callback by mutating the tracing ref directly,</span></span><br><span class="line">      <span class="comment">// like we do at the beginning of commitRoot. I&#x27;ve opted not to do that</span></span><br><span class="line">      <span class="comment">// here because that code is still in flux.</span></span><br><span class="line">      callback = Scheduler_tracing_wrap(callback);</span><br><span class="line">    &#125;</span><br><span class="line">    passiveEffectCallbackHandle = runWithPriority(NormalPriority, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> schedulePassiveEffects(callback);</span><br><span class="line">    &#125;);</span><br><span class="line">    passiveEffectCallback = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isCommitting = <span class="literal">false</span>;</span><br><span class="line">  isWorking = <span class="literal">false</span>;</span><br><span class="line">  stopCommitLifeCyclesTimer();</span><br><span class="line">  stopCommitTimer();</span><br><span class="line">  onCommitRoot(finishedWork.stateNode);</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; ReactFiberInstrumentation.debugTool) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> updateExpirationTimeAfterCommit = finishedWork.expirationTime;</span><br><span class="line">  <span class="keyword">const</span> childExpirationTimeAfterCommit = finishedWork.childExpirationTime;</span><br><span class="line">  <span class="keyword">const</span> earliestRemainingTimeAfterCommit =</span><br><span class="line">    childExpirationTimeAfterCommit &gt; updateExpirationTimeAfterCommit</span><br><span class="line">      ? childExpirationTimeAfterCommit</span><br><span class="line">      : updateExpirationTimeAfterCommit;</span><br><span class="line">  <span class="keyword">if</span> (earliestRemainingTimeAfterCommit === NoWork) &#123;</span><br><span class="line">    <span class="comment">// If there&#x27;s no remaining work, we can clear the set of already failed</span></span><br><span class="line">    <span class="comment">// error boundaries.</span></span><br><span class="line">    legacyErrorBoundariesThatAlreadyFailed = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  onCommit(root, earliestRemainingTimeAfterCommit);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">    <span class="comment">// 开发工具追踪代码 这里可以不管</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对宏观结构做一些总结, 细节一些的地方可以参见注释，为了方便理解根据自己理解给翻译为中文了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">root: FiberRoot, finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.  更新优先级 markCommittedPriorityLevels()</span></span><br><span class="line">    <span class="comment">// 2.  根据effectTag 处理Effect List链表</span></span><br><span class="line">	<span class="comment">// 3.  突变之前操作: commitBeforeMutationLifecycles-&gt;getSnapshotBeforeUpdate</span></span><br><span class="line">    <span class="comment">// 4.  执行side-effects 这里分两个步骤</span></span><br><span class="line">    <span class="comment">// 4.1 执行所有host的插入、更新、删除和ref卸载 commitAllHostEffects</span></span><br><span class="line">    <span class="comment">// 4.2 执行其他所有sideEffect commitAllLifeCycles</span></span><br><span class="line">    <span class="comment">// 5.  onCommitRoot() &amp; onCommit()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h2><p>getSnapshotBeforeUpdate是新增的生命周期函数。它发生在componentWillUpdate、componentDidUpdate之前，它的触发时机是 React 进行修改前（通常是更新 DOM）的“瞬间”，它的返回值会作为第三个参数传入 <code>componentDidUpdate</code> 。这个值会被挂在<code>instance.__reactInternalSnapshotBeforeUpdate</code>上，当实例注销时候也会注销。</p>
<p>它由commitBeforeMutationLifecycles函数引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationLifecycles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Snapshot) &#123;</span><br><span class="line">      recordEffect();</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      commitBeforeMutationLifeCycles(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationLifeCycles</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">      commitHookEffectList(UnmountSnapshot, NoHookEffect, finishedWork);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (finishedWork.effectTag &amp; Snapshot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> prevProps = current.memoizedProps;</span><br><span class="line">          <span class="keyword">const</span> prevState = current.memoizedState;</span><br><span class="line">          startPhaseTimer(finishedWork, <span class="string">&#x27;getSnapshotBeforeUpdate&#x27;</span>);</span><br><span class="line">          <span class="keyword">const</span> instance = finishedWork.stateNode;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> snapshot = instance.getSnapshotBeforeUpdate(</span><br><span class="line">            finishedWork.elementType === finishedWork.type</span><br><span class="line">              ? prevProps</span><br><span class="line">              : resolveDefaultProps(finishedWork.type, prevProps),</span><br><span class="line">            prevState,</span><br><span class="line">          );</span><br><span class="line">          instance.__reactInternalSnapshotBeforeUpdate = snapshot;</span><br><span class="line">          stopPhaseTimer();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里针对FunctionComponent有个单独的分支。主要操作是执行effect.create() || effect.destroy();代码这里逻辑是进行destroy()。更全面点讲，这里遍历finishedWork.updateQueue链表，执行了上面的每个effect.destroy()。</p>
</blockquote>
<h2 id="commitAllHostEffects"><a href="#commitAllHostEffects" class="headerlink" title="commitAllHostEffects"></a>commitAllHostEffects</h2><p>这个函数名称真的足够简练，没有一个字是多余的。。。</p>
<p>All这里提现在对effect的遍历上，Host则提现在对HostComponent的处理上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllHostEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    recordEffect();</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; ContentReset) &#123;</span><br><span class="line">      commitResetTextContent(nextEffect); <span class="comment">// 把节点的文字内容设为空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        commitDetachRef(current); <span class="comment">// 清空ref属性 后面要重新设置</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里swtich/case逻辑只关心替换、更新、删除逻辑。为了避免其他可能值，这里就没有写次要effect值</span></span><br><span class="line">    <span class="keyword">let</span> primaryEffectTag = effectTag &amp; (Placement | Update | Deletion);</span><br><span class="line">    <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">      <span class="keyword">case</span> Placement: &#123;</span><br><span class="line">        commitPlacement(nextEffect);</span><br><span class="line">        <span class="comment">// 清除效果标记中的“placement”，以便在调用componentDidMount之类的生命周期之前</span></span><br><span class="line">        <span class="comment">// 我们知道这是插入的</span></span><br><span class="line">        nextEffect.effectTag &amp;= ~Placement;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> PlacementAndUpdate: &#123;</span><br><span class="line">        commitPlacement(nextEffect);</span><br><span class="line">        nextEffect.effectTag &amp;= ~Placement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update</span></span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> Update: &#123;</span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> Deletion: &#123;</span><br><span class="line">        commitDeletion(nextEffect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有4个case，但是实质上只有3种操作，这三种操作分别是替换、更新、删除。多出来的PlacementAndUpdate实质上是替换+更新的组合。</p>
<p>另外，注意这里的遍历，它遍历了所有的nextEffect。</p>
<p>再次，nextEffect这个链表的构建，在completeUnitOfWork函数里面。</p>
<h3 id="commitPlacement-替换"><a href="#commitPlacement-替换" class="headerlink" title="commitPlacement - 替换"></a>commitPlacement - 替换</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitPlacement</span>(<span class="params">finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!supportsMutation) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据fiber.return向上爬，直到找到一个HostComponent|HostRoot|HostPortal返回</span></span><br><span class="line">  <span class="keyword">const</span> parentFiber = getHostParentFiber(finishedWork);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: 必须同时被更新</span></span><br><span class="line">  <span class="keyword">let</span> parent;</span><br><span class="line">  <span class="keyword">let</span> isContainer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (parentFiber.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> HostComponent: <span class="comment">// 对应v15 ReactDomComponent</span></span><br><span class="line">      parent = parentFiber.stateNode;</span><br><span class="line">      isContainer = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HostRoot:		<span class="comment">// fiberRoot fiber链表第一个元素</span></span><br><span class="line">      parent = parentFiber.stateNode.containerInfo;</span><br><span class="line">      isContainer = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HostPortal: 	<span class="comment">// Portal</span></span><br><span class="line">      parent = parentFiber.stateNode.containerInfo;</span><br><span class="line">      isContainer = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (parentFiber.effectTag &amp; ContentReset) &#123;</span><br><span class="line">     <span class="comment">// 在做插入操作前 清空parnet里面text文本</span></span><br><span class="line">    resetTextContent(parent);</span><br><span class="line">    <span class="comment">// Clear ContentReset from the effect tag</span></span><br><span class="line">    parentFiber.effectTag &amp;= ~ContentReset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> before = getHostSibling(finishedWork);</span><br><span class="line">  <span class="comment">// 我们只有顶部的fiber被插入了。我们需要递归下级节点以找到终端节点</span></span><br><span class="line">  <span class="keyword">let</span> node: Fiber = finishedWork;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.tag === HostComponent || node.tag === HostText) &#123;</span><br><span class="line">      <span class="comment">// 如果它有nextSibling 那么底层使用insertBefore插入节点</span></span><br><span class="line">      <span class="keyword">if</span> (before) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isContainer) &#123;</span><br><span class="line">          insertInContainerBefore(parent, node.stateNode, before);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          insertBefore(parent, node.stateNode, before);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则底层使用appendChild追加到尾部</span></span><br><span class="line">        <span class="keyword">if</span> (isContainer) &#123;</span><br><span class="line">          appendChildToContainer(parent, node.stateNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          appendChild(parent, node.stateNode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.tag === HostPortal) &#123;</span><br><span class="line">      <span class="comment">// 如果操作的是一个Portal组件 我们就不遍历它的子节点 直接对其本身进行插入操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果child节点不为空 那么将firstChild设为node重新遍历</span></span><br><span class="line">      node.child.return = node;</span><br><span class="line">      node = node.child;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node === finishedWork) &#123; <span class="comment">// 此时没有变化 不做操作</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node.sibling === <span class="literal">null</span>) &#123; <span class="comment">// 当前节点没有nextSibling了 返回上级节点</span></span><br><span class="line">      <span class="keyword">if</span> (node.return === <span class="literal">null</span> || node.return === finishedWork) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始遍历上级节点的sibing</span></span><br><span class="line">    node.sibling.return = node.return;</span><br><span class="line">    node = node.sibling;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位与运算符前端不太好理解，不过这里也就懒得说里面的过程。<code>ContentReset = 0b000000010000 =16</code>。当运行<code>parentFiber.effectTag &amp; ContentReset</code>时候，明显可见的规律是，当effectTag除以ContentReset结果取整进行Math.floor操作，如果这个值是奇数，它的值是16，否则为0。</p>
<p>而parentFiber.effectTag &amp;= <del>ContentReset在这里基本等同于<code>parentFiber.effectTag -= ContentReset</code>。不过它和减法还是有很大区别。它对0</del>15不会执行减法——但是0~15显然进不来这个分支。</p>
<p>其他的不妨看看注释，这里主线是对finishWork:fiber进行遍历，核心操作是执行insertBefore或者appendChild操作。</p>
<h3 id="commitWork-更新"><a href="#commitWork-更新" class="headerlink" title="commitWork - 更新"></a>commitWork - 更新</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">current: Fiber | <span class="literal">null</span>, finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!supportsMutation) &#123; <span class="comment">// 这里暂时不理解MemoComponent 略过它</span></span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">      <span class="keyword">case</span> ForwardRef:</span><br><span class="line">      <span class="keyword">case</span> MemoComponent:</span><br><span class="line">      <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">        commitHookEffectList(UnmountMutation, MountMutation, finishedWork);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    commitContainer(finishedWork);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">    <span class="keyword">case</span> MemoComponent:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123; <span class="comment">// 这里暂时不理解MemoComponent 略过它</span></span><br><span class="line">      commitHookEffectList(UnmountMutation, MountMutation, finishedWork);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> instance: Instance = finishedWork.stateNode;</span><br><span class="line">      <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Commit the work prepared earlier.</span></span><br><span class="line">        <span class="keyword">const</span> newProps = finishedWork.memoizedProps;</span><br><span class="line">        <span class="comment">// For hydration we reuse the update path but we treat the oldProps</span></span><br><span class="line">        <span class="comment">// as the newProps. The updatePayload will contain the real change in</span></span><br><span class="line">        <span class="comment">// this case.</span></span><br><span class="line">        <span class="keyword">const</span> oldProps = current !== <span class="literal">null</span> ? current.memoizedProps : newProps;</span><br><span class="line">        <span class="keyword">const</span> type = finishedWork.type;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Type the updateQueue to be specific to host components.</span></span><br><span class="line">        <span class="keyword">const</span> updatePayload: <span class="literal">null</span> | UpdatePayload = (finishedWork.updateQueue: any);</span><br><span class="line">        finishedWork.updateQueue = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (updatePayload !== <span class="literal">null</span>) &#123;</span><br><span class="line">          commitUpdate(</span><br><span class="line">            instance,</span><br><span class="line">            updatePayload,</span><br><span class="line">            type,</span><br><span class="line">            oldProps,</span><br><span class="line">            newProps,</span><br><span class="line">            finishedWork,</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostText: &#123;</span><br><span class="line">	  <span class="comment">// 更新文本 这里暂时略过</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Profiler: &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SuspenseComponent: &#123;</span><br><span class="line">      <span class="comment">// 错误捕获 这里略</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> IncompleteClassComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里加了若干注释，并对干扰代码进行了删除。可以看到，这里核心的处理分支是HostComponent，这也比较符合之前的认知。这里猜测可以进行部分Diff对比了: 先对比instance，然后直接进行HostComponent替换(ComponentDiff)或者子节点的ElementDiff操作。核心是commitUpdate。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">commitUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domElement: Instance,</span></span></span><br><span class="line"><span class="function"><span class="params">  updatePayload: <span class="built_in">Array</span>&lt;mixed&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  type: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldProps: Props,</span></span></span><br><span class="line"><span class="function"><span class="params">  newProps: Props,</span></span></span><br><span class="line"><span class="function"><span class="params">  internalInstanceHandle: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将新的Props挂到domElement上(此时它还挂了一个FiberNode)</span></span><br><span class="line">  updateFiberProps(domElement, newProps);</span><br><span class="line">  <span class="comment">// 它主要还是调用updateDOMProperties</span></span><br><span class="line">  updateProperties(domElement, updatePayload, type, oldProps, newProps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateFiberProps</span>(<span class="params">node, props</span>) </span>&#123;</span><br><span class="line">  node[internalEventHandlersKey] = props;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateProperties</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domElement: Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  updatePayload: <span class="built_in">Array</span>&lt;any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  lastRawProps: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextRawProps: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 略过兼容特例处理</span></span><br><span class="line">  <span class="keyword">const</span> wasCustomComponentTag = isCustomComponent(tag, lastRawProps);</span><br><span class="line">  <span class="keyword">const</span> isCustomComponentTag = isCustomComponent(tag, nextRawProps);</span><br><span class="line">  <span class="comment">// Apply the diff.</span></span><br><span class="line">  updateDOMProperties( <span class="comment">// 这个函数就很眼熟了 v15里面它也是非常重要的函数</span></span><br><span class="line">    domElement,</span><br><span class="line">    updatePayload,</span><br><span class="line">    wasCustomComponentTag,</span><br><span class="line">    isCustomComponentTag,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 略过兼容特例处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的逻辑已经给出了。这里看看重点的updateDOMProperties函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDOMProperties</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domElement: Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  updatePayload: <span class="built_in">Array</span>&lt;any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  wasCustomComponentTag: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  isCustomComponentTag: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Handle wasCustomComponentTag</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; updatePayload.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> propKey = updatePayload[i];</span><br><span class="line">    <span class="keyword">const</span> propValue = updatePayload[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">      setValueForStyles(domElement, propValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) &#123;</span><br><span class="line">      setInnerHTML(domElement, propValue); 	 <span class="comment">// 可以视为innerHTML</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === CHILDREN) &#123;</span><br><span class="line">      setTextContent(domElement, propValue); <span class="comment">// 赋值给textContent|nodeValue</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数对比v15.6版本又做了封装。但是不得不说清爽太多了。但是总体的逻辑倒也没什么变化。主要是区分了样式、Text、Property进行处理。另外就是特例API处理<code>dangerouslySetInnerHTML</code>。</p>
<p>这里最复杂的应该是setValueForProperty:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setValueForProperty</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  node: Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  name: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  value: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">  isCustomComponentTag: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> propertyInfo = getPropertyInfo(name);</span><br><span class="line">  <span class="keyword">if</span> (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) &#123;</span><br><span class="line">    value = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If the prop isn&#x27;t in the special list, treat it as a simple attribute.</span></span><br><span class="line">  <span class="keyword">if</span> (isCustomComponentTag || propertyInfo === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isAttributeNameSafe(name)) &#123;</span><br><span class="line">      <span class="keyword">const</span> attributeName = name;</span><br><span class="line">      <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.removeAttribute(attributeName);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.setAttribute(attributeName, <span class="string">&#x27;&#x27;</span> + (value: any));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123;mustUseProperty&#125; = propertyInfo;</span><br><span class="line">  <span class="keyword">if</span> (mustUseProperty) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;propertyName&#125; = propertyInfo;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;type&#125; = propertyInfo;</span><br><span class="line">      (node: any)[propertyName] = type === BOOLEAN ? <span class="literal">false</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Contrary to `setAttribute`, object properties are properly</span></span><br><span class="line">      <span class="comment">// `toString`ed by IE8/9.</span></span><br><span class="line">      (node: any)[propertyName] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// The rest are treated as attributes with special cases.</span></span><br><span class="line">  <span class="keyword">const</span> &#123;attributeName, attributeNamespace&#125; = propertyInfo;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">    node.removeAttribute(attributeName);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;type&#125; = propertyInfo;</span><br><span class="line">    <span class="keyword">let</span> attributeValue;</span><br><span class="line">    <span class="keyword">if</span> (type === BOOLEAN || (type === OVERLOADED_BOOLEAN &amp;&amp; value === <span class="literal">true</span>)) &#123;</span><br><span class="line">      attributeValue = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// `setAttribute` with objects becomes only `[object]` in IE8/9,</span></span><br><span class="line">      <span class="comment">// (&#x27;&#x27; + value) makes it output the correct toString()-value.</span></span><br><span class="line">      attributeValue = <span class="string">&#x27;&#x27;</span> + (value: any);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (attributeNamespace) &#123;</span><br><span class="line">      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.setAttribute(attributeName, attributeValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分支多。但是说白了，其实最后也就是<code>setAttribute &amp; removeAttribute</code>这套。</p>
<p><strong>总结一下就是:</strong> 它真的只是apply the diff。而不包含Diff计算了。</p>
<h3 id="commitDeletion-删除"><a href="#commitDeletion-删除" class="headerlink" title="commitDeletion-删除"></a>commitDeletion-删除</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitDeletion</span>(<span class="params">current: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsMutation) &#123;</span><br><span class="line">    <span class="comment">// 从current节点上递归删除所有host nodes</span></span><br><span class="line">    <span class="comment">// 移除ref，并调用所有的componentWillUnmount</span></span><br><span class="line">    unmountHostComponents(current);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 移除ref，并调用所有的componentWillUnmount</span></span><br><span class="line">    commitNestedUnmounts(current); <span class="comment">// 递归fiber子节点调用commitUnmount卸载</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空current节点和current.alternate节点(return child updateQueue memoizedState)</span></span><br><span class="line">  detachFiber(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个commitUnmount函数。得讲一讲。它是commitNestedUnmounts的核心，整个umount环节，在粒度上，它应该是最小的情况了。</p>
<p>commitNestedUnmounts主要是对current节点进行下层级递归调用commitUnmount。</p>
<p>而commitUnmount主要是对ref进行清除、递归调用componentWillUnmount、或者是useEffect的清除。特例情况是HostPortal则需要进步遍历下级节点然后递归调用自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitUnmount</span>(<span class="params">current: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  onCommitUnmount(current);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (current.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">    <span class="keyword">case</span> MemoComponent:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123; <span class="comment">// useEffect相关 hook注销。理解这里得先熟悉Hook使用</span></span><br><span class="line">      <span class="keyword">const</span> updateQueue: FunctionComponentUpdateQueue | <span class="literal">null</span> = (current.updateQueue: any);</span><br><span class="line">      <span class="keyword">if</span> (updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> lastEffect = updateQueue.lastEffect;</span><br><span class="line">        <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">          <span class="keyword">let</span> effect = firstEffect;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> destroy = effect.destroy;</span><br><span class="line">            <span class="keyword">if</span> (destroy !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">              safelyCallDestroy(current, destroy);</span><br><span class="line">            &#125;</span><br><span class="line">            effect = effect.next;</span><br><span class="line">          &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      safelyDetachRef(current); <span class="comment">// 清除ref。ref为函数则传入null执行清空</span></span><br><span class="line">      <span class="keyword">const</span> instance = current.stateNode;</span><br><span class="line">      <span class="comment">// 安全执行componentWillUnmount</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentWillUnmount === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        safelyCallComponentWillUnmount(current, instance);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">      safelyDetachRef(current); <span class="comment">// 清除ref。ref为函数则传入null执行清空</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostPortal: &#123;</span><br><span class="line">      <span class="keyword">if</span> (supportsMutation) &#123;</span><br><span class="line">        unmountHostComponents(current);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (supportsPersistence) &#123;</span><br><span class="line">        emptyPortalContainer(current);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是unmountHostComponents函数。其他函数都说了，这个最后还是得看看。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmountHostComponents</span>(<span class="params">current</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We only have the top Fiber that was deleted but we need to recurse down its</span></span><br><span class="line">  <span class="comment">// children to find all the terminal nodes.</span></span><br><span class="line">  <span class="keyword">let</span> node: Fiber = current;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Each iteration, currentParent is populated with node&#x27;s host parent if not</span></span><br><span class="line">  <span class="comment">// currentParentIsValid.</span></span><br><span class="line">  <span class="keyword">let</span> currentParentIsValid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: these two variables *must* always be updated together.</span></span><br><span class="line">  <span class="keyword">let</span> currentParent;</span><br><span class="line">  <span class="keyword">let</span> currentParentIsContainer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!currentParentIsValid) &#123;</span><br><span class="line">      <span class="keyword">let</span> parent = node.return;</span><br><span class="line">      <span class="comment">// 向上遍历node.return, 直到node.tag对应以下三种类型的组件为止 才继续往下走</span></span><br><span class="line">      <span class="comment">// 此时currentParentIsValid赋值为true 后面再进上一个while就不会进入此处</span></span><br><span class="line">      <span class="comment">// 或者说 不会更新currentParent &amp;&amp; currentParentIsContainer</span></span><br><span class="line">      findParent: <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (parent.tag) &#123;</span><br><span class="line">          <span class="keyword">case</span> HostComponent:</span><br><span class="line">            currentParent = parent.stateNode;</span><br><span class="line">            currentParentIsContainer = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span> findParent;</span><br><span class="line">          <span class="keyword">case</span> HostRoot:</span><br><span class="line">            currentParent = parent.stateNode.containerInfo;</span><br><span class="line">            currentParentIsContainer = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span> findParent;</span><br><span class="line">          <span class="keyword">case</span> HostPortal:</span><br><span class="line">            currentParent = parent.stateNode.containerInfo;</span><br><span class="line">            currentParentIsContainer = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span> findParent;</span><br><span class="line">        &#125;</span><br><span class="line">        parent = parent.return;</span><br><span class="line">      &#125;</span><br><span class="line">      currentParentIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.tag === HostComponent || node.tag === HostText) &#123; <span class="comment">// HostComponent&amp;Text直接设法移除</span></span><br><span class="line">      commitNestedUnmounts(node);</span><br><span class="line">      <span class="comment">// umount所有children之后，开始将node从tree中移除</span></span><br><span class="line">      <span class="keyword">if</span> (currentParentIsContainer) &#123; <span class="comment">// 如果当前parent是一个容器组件 比如HostRoot&amp;HostPortal</span></span><br><span class="line">        removeChildFromContainer( <span class="comment">// 这个函数几类于: currentParent.removeChild(node.stateNode) 但是多了个注释节点的处理</span></span><br><span class="line">          ((currentParent: any): Container),</span><br><span class="line">          (node.stateNode: Instance | TextInstance),</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是另外一个HostComponent(原ReactDomComponent)</span></span><br><span class="line">        removeChild(              <span class="comment">// 等同:currentParent.removeChild(node.stateNode)</span></span><br><span class="line">          ((currentParent: any): Instance),</span><br><span class="line">          (node.stateNode: Instance | TextInstance),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Don&#x27;t visit children because we already visited them.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      enableSuspenseServerRenderer &amp;&amp;</span><br><span class="line">      node.tag === DehydratedSuspenseComponent</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 服务端渲染 这里不管 略过</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.tag === HostPortal) &#123; <span class="comment">// 递归HostPortal 对其脱壳处理 转换成普通组件处理</span></span><br><span class="line">      <span class="keyword">if</span> (node.child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// When we go into a portal, it becomes the parent to remove from.</span></span><br><span class="line">        <span class="comment">// We will reassign it back when we pop the portal on the way up.</span></span><br><span class="line">        currentParent = node.stateNode.containerInfo;</span><br><span class="line">        currentParentIsContainer = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// Visit children because portals might contain host components.</span></span><br><span class="line">        node.child.return = node;</span><br><span class="line">        node = node.child;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 遇到FunctionComponent|ClassComponent什么的直接卸载</span></span><br><span class="line">      commitUnmount(node);</span><br><span class="line">      <span class="comment">// 递归node.child</span></span><br><span class="line">      <span class="keyword">if</span> (node.child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node.child.return = node;</span><br><span class="line">        node = node.child;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下都是遍历Fiber树需要的代码</span></span><br><span class="line">    <span class="keyword">if</span> (node === current) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node.sibling === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.return === <span class="literal">null</span> || node.return === current) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.return;</span><br><span class="line">      <span class="keyword">if</span> (node.tag === HostPortal) &#123;</span><br><span class="line">        <span class="comment">// When we go out of the portal, we need to restore the parent.</span></span><br><span class="line">        <span class="comment">// Since we don&#x27;t keep a stack of them, we will search for it.</span></span><br><span class="line">        currentParentIsValid = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node.sibling.return = node.return;</span><br><span class="line">    node = node.sibling;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="commitAllLifeCycles"><a href="#commitAllLifeCycles" class="headerlink" title="commitAllLifeCycles"></a>commitAllLifeCycles</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllLifeCycles</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  finishedRoot: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; (Update | Callback)) &#123;</span><br><span class="line">      recordEffect();</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      commitLifeCycles(</span><br><span class="line">        finishedRoot,</span><br><span class="line">        current,</span><br><span class="line">        nextEffect,</span><br><span class="line">        committedExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">      recordEffect();</span><br><span class="line">      commitAttachRef(nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Passive) &#123;</span><br><span class="line">      rootWithPendingPassiveEffects = finishedRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里commitLifeCycles函数内容比较多。但是核心的地方还是针对几个类型的组件进行分支操作</p>
<ul>
<li>正常的ClassComponent：执行componentDidMount &amp;&amp; componentDidUpdate声明周期勾子函数。调用commitUpdateQueue</li>
<li>FunctionComponent：commitHookEffectList</li>
<li>HostComponent：commitMount</li>
<li>HostRoot：commitUpdateQueue</li>
</ul>
<p>这里commitUpdateQueue遍历UpdateQueue链表，执行每个sideEffect上的effect.callback.bind(instance)</p>
<p>commitMount函数主要是处理焦点获取。没有什么其他操作</p>
<p>commitHookEffectList之前遇到了很多，也提到过一点，这里小改一下: 主要操作是执行effect.create() || effect.destroy();代码根据参数来说这里逻辑晾着都有。更全面点讲，这里遍历finishedWork.updateQueue链表，执行了上面的每个effect.create() &amp; effect.destroy()。当然这里主要还是看effect.tag值来决定。关于这个计算暂时还没搞懂，后面再来补充。</p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react-fiber-render</title>
    <url>/2019/08/07/react-v16-render/</url>
    <content><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>因为最近阅读的代码从v15.6.2换到了v16.8.6了，这之间的版本发布时间大概有一年之久了。其间很多东西都发生了变化，尤其是React Fiber用链表替代了之前的树结构。所以这里的Render必须重新实现。</p>
<p>这里换了地图这块还是必须先看看。</p>
<h1 id="Render线路-初始化"><a href="#Render线路-初始化" class="headerlink" title="Render线路-初始化"></a>Render线路-初始化</h1><p>想了个办法一边展示调用，以便精简代码展示核心调用，这里算是入口级别的路径:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOM.render</span><br><span class="line">  -&gt;legacyRenderSubtreeIntoContainer &#123;</span><br><span class="line">    root = legacyCreateRootFromDOMContainer()</span><br><span class="line">            -&gt; <span class="keyword">new</span> ReactRoot -&gt; createContainer -&gt; createFiberRoot -&gt; <span class="built_in">Object</span>.assign(createHostRootFiber(), &#123;</span><br><span class="line">              current: createHostRootFiber() -&gt; createFiber()</span><br><span class="line">            &#125;)</span><br><span class="line">    root.render() -&gt; ReactRoot.prototype.render() &#123;</span><br><span class="line">      <span class="keyword">const</span> work = <span class="keyword">new</span> ReactWork();</span><br><span class="line">      updateContainer(children, root, <span class="literal">null</span>, work._onCommit)</span><br><span class="line">        -&gt; updateContainerAtExpirationTime</span><br><span class="line">          -&gt; scheduleRootUpdate () &#123;</span><br><span class="line">              flushPassiveEffects();</span><br><span class="line">              enqueueUpdate(current, update) -&gt; appendUpdateToQueue</span><br><span class="line">              scheduleWork(current, expirationTime)</span><br><span class="line">                -&gt; requestWork -&gt; performWorkOnRoot -&gt; (renderRoot -&gt; workLoop) || completeRoot</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里初次渲染的路径大体是: </p>
<ul>
<li>根据给定的DOM创建一个FiberRoot元素，然后将这个FiberRoot.current指向createHostRootFiber()，接下来调用ReactRoot上的render进行渲染。</li>
<li>ReactRoot.render一路走到renderRoot。</li>
</ul>
<p>renderRoot是一个很复杂的函数，核心的调用workLoop里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">isYieldy</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isYieldy) &#123;</span><br><span class="line">    <span class="comment">// Flush work without yielding</span></span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Flush asynchronous work until there&#x27;s a higher priority event</span></span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span> &amp;&amp; !shouldYieldToRenderer()) &#123;</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里暂时不考虑渲染过程的中断，所以核心就是对<code>performUnitOfWork(nextUnitOfWork)</code>的遍历，直到其值返回null为止。</p>
<h2 id="遍历理论"><a href="#遍历理论" class="headerlink" title="遍历理论"></a>遍历理论</h2><p>这里遍历逻辑有点折腾。不精简的话实在有些不太好理解。</p>
<p>究其根本，个人认为基于链表的树遍历确实有些反人类直觉——不然React一开始也不会使用Tree结构而没有考虑用链表。</p>
<p>这里涉及4个API: performUnitOfWork|beginWork|completeUnitOfWork|completeWork。在遍历这个事情上，<strong>我用了参考文章里面提到的伪代码</strong>(没办法，这个看懂了在宏观上对遍历有了概念，理解相关事情就容易多了):</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> next = beginWork(workInProgress);</span><br><span class="line">    <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">        next = completeUnitOfWork(workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">&#x27;work performed for &#x27;</span> + workInProgress.name);</span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> returnFiber = workInProgress.return;</span><br><span class="line">        <span class="keyword">let</span> siblingFiber = workInProgress.sibling;</span><br><span class="line"></span><br><span class="line">        nextUnitOfWork = completeWork(workInProgress);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If there is a sibling, return it </span></span><br><span class="line">            <span class="comment">// to perform work for this sibling</span></span><br><span class="line">            <span class="keyword">return</span> siblingFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If there&#x27;s no more work in this returnFiber, </span></span><br><span class="line">            <span class="comment">// continue the loop to complete the returnFiber.</span></span><br><span class="line">            workInProgress = returnFiber;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We&#x27;ve reached the root.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">&#x27;work completed for &#x27;</span> + workInProgress.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之，这是一套基于Fiber链表结构、但是针对树的遍历算法。这里就算法说一些理论上的东西:</p>
<ol>
<li><p>对指定节点，递归进入第一个child节点(进入子节点 如果子节点还有子节点直接进入 如此类推)</p>
</li>
<li><p>直到child===null, 开始挨个查找sibling节点(如果该节点有child，重新执行整个1&amp;2逻辑)</p>
</li>
<li><p>直到sibling节点===null,返回上一级节点</p>
</li>
<li><p>在上一节节点上找sibing，如果有child，递归child重复之前逻辑，没有直接返回上一级</p>
</li>
<li><p>最后如此重复，一直到返回根节点。</p>
</li>
</ol>
<p>这套遍历算法可以将整棵树都遍历到。如果只是理论上的遍历，理论上它没有之前树遍历快，因为树遍历可以多节点并行遍历，而这里基于链表只能一个一个线性去遍历。</p>
<p>但是，就像之前基于树Tree里面有粗暴的直接替换整个下级一样，这里的线性遍历也可以借助类似方法进行判断跳过一些child的深入以实现相差无几的高效遍历。</p>
<p><strong>这个遍历，是从底部往顶部、从左边向右边的遍历。</strong></p>
<p>至于为什么这里先讲道理再后面说详细流程，说到底，根据代码逆向反推思路，真的是一件费时费力，还掉头发的事情。。。有上层思想指导，再去看就不会走弯路——实在是看v15时候吃了太多这方面的亏，这次有现成文章，就好好参考一下。😂</p>
<h2 id="源码细节-render阶段"><a href="#源码细节-render阶段" class="headerlink" title="源码细节(render阶段)"></a>源码细节(render阶段)</h2><h3 id="workLoop及前置调用"><a href="#workLoop及前置调用" class="headerlink" title="workLoop及前置调用"></a>workLoop及前置调用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateContainerAtExpirationTime</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: OpaqueRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?<span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> If this is a nested container, this won&#x27;t be the root.</span></span><br><span class="line">  <span class="keyword">const</span> current = container.current;</span><br><span class="line">  <span class="comment">// 回去最近的父祖节点context</span></span><br><span class="line">  <span class="comment">// 如果自定义组件定义了childContextTypes则返回该组件context</span></span><br><span class="line">  <span class="keyword">const</span> context = getContextForSubtree(parentComponent);</span><br><span class="line">  <span class="keyword">if</span> (container.context === <span class="literal">null</span>) &#123;</span><br><span class="line">    container.context = context;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    container.pendingContext = context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> scheduleRootUpdate(current, element, expirationTime, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleRootUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?<span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> update = createUpdate(expirationTime);</span><br><span class="line">  <span class="comment">// React DevTools依赖该变量 element</span></span><br><span class="line">  update.payload = &#123;element&#125;;</span><br><span class="line">  callback = callback === <span class="literal">undefined</span> ? <span class="literal">null</span> : callback;</span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="comment">// callback必须为function 否则这里会报错</span></span><br><span class="line">    update.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  flushPassiveEffects();</span><br><span class="line">  enqueueUpdate(current, update);</span><br><span class="line">  scheduleWork(current, expirationTime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> expirationTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里enqueueUpdate主要是调用appendUpdateToQueue。这个函数基本可以理解为向update数组push一个元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendUpdateToQueue</span>(<span class="params">queue, update</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// lastUpdate===null说明之前是空的队列</span></span><br><span class="line">    <span class="keyword">if</span> (queue.lastUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.firstUpdate = queue.lastUpdate = update;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则将update放到链表队列尾部</span></span><br><span class="line">        queue.lastUpdate.next = update;</span><br><span class="line">        queue.lastUpdate = update;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后enqueueUpdate执行的结果是给fiber.updateQueue以及fiber.alternate.updateQueue进行了赋值。这里后面看看具体含义。</p>
<p>核心的调用是scheduleWork。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleWork</span>(<span class="params">fiber: Fiber, expirationTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> root = scheduleWorkToRoot(fiber, expirationTime);</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  markPendingPriorityLevel(root, expirationTime);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">	<span class="comment">// 如果是在render阶段 我们不需要规划update行为</span></span><br><span class="line">    <span class="comment">// 因为必须在存在后才能再去做这些</span></span><br><span class="line">    !isWorking ||</span><br><span class="line">    isCommitting ||</span><br><span class="line">    <span class="comment">// 直到这个root和我们正要render的不一样</span></span><br><span class="line">    nextRoot !== root</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> rootExpirationTime = root.expirationTime;</span><br><span class="line">    requestWork(root, rootExpirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) &#123;</span><br><span class="line">    <span class="comment">// Reset this back to zero so subsequent updates don&#x27;t throw.</span></span><br><span class="line">    nestedUpdateCount = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 一些报错 无关分析 删</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestWork</span>(<span class="params">root: FiberRoot, expirationTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">  addRootToSchedule(root, expirationTime);</span><br><span class="line">  <span class="keyword">if</span> (isRendering) &#123;</span><br><span class="line">    <span class="comment">// 禁止递归调用 后面的任务在结束再重新开始</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isBatchingUpdates) &#123; <span class="comment">// 初始render这里为false</span></span><br><span class="line">    <span class="comment">// 在批处理结束后开始清洗工作(针对脏组件|Fiber?)</span></span><br><span class="line">    <span class="keyword">if</span> (isUnbatchingUpdates) &#123;</span><br><span class="line">      <span class="comment">// 除非被排除在unbatchedUpdates，否则现在需要开始进行清洗</span></span><br><span class="line">      nextFlushedRoot = root;</span><br><span class="line">      nextFlushedExpirationTime = Sync;</span><br><span class="line">      performWorkOnRoot(root, Sync, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Get rid of Sync and use current time?</span></span><br><span class="line">  <span class="comment">// 这里是同步异步处理分支 这里暂时看同步逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (expirationTime === Sync) &#123;</span><br><span class="line">    performSyncWork();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scheduleCallbackWithExpirationTime(root, expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">performSyncWork -&gt; performWork(Sync, <span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWork</span>(<span class="params">minExpirationTime: ExpirationTime, isYieldy: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Keep working on roots until there&#x27;s no more work, or until there&#x27;s a higher</span></span><br><span class="line">  <span class="comment">// priority event.</span></span><br><span class="line">  findHighestPriorityRoot();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isYieldy) &#123;</span><br><span class="line">	<span class="comment">// 异步逻辑 这里暂时不管</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      nextFlushedRoot !== <span class="literal">null</span> &amp;&amp; <span class="comment">// 还有root没有处理完(含有child的节点)</span></span><br><span class="line">      nextFlushedExpirationTime !== NoWork &amp;&amp; <span class="comment">// 过期时间不为NoWork</span></span><br><span class="line">      minExpirationTime &lt;= nextFlushedExpirationTime <span class="comment">// 此时这两个变量相等</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, <span class="literal">false</span>);</span><br><span class="line">      findHighestPriorityRoot();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (nextFlushedExpirationTime !== NoWork) &#123;</span><br><span class="line">    scheduleCallbackWithExpirationTime(</span><br><span class="line">      ((nextFlushedRoot: any): FiberRoot),</span><br><span class="line">      nextFlushedExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Clean-up.</span></span><br><span class="line">  finishRendering();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>findHighestPriorityRoot</code>和<code>performWorkOnRoot</code>函数可能是这里最核心的地方。</p>
<p><code>findHighestPriorityRoot</code>函数命名已经说明它的作用: 「找到最高优先级根」。</p>
<p>这个函数和Fiber结构联系很紧密: <code>Fibler.nextScheduledRoot</code>是核心变量，它主要是对firstScheduledRoot(packages/react-reconciler/src/ReactFiberScheduler.js)变量(闭包变量)进行操作。这个变量记录我们要进行操作的节点根。</p>
<p>但是这个函数需要一个初始值，ReactFiberScheduler.js中它的初始值为null。那么它的常规值从哪儿来呢?从requestWork中的addRootToSchedule函数调用里。</p>
<p>这个函数这里不贴代码，认真看看，可以知道，当我们初次渲染时候，我们得到要操作的节点是根节点。而且根节点的nextScheduledRoot也设为了自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">firstScheduledRoot = lastScheduledRoot = root;</span><br><span class="line">root.nextScheduledRoot = root;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findHighestPriorityRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> highestPriorityWork = NoWork;</span><br><span class="line">  <span class="keyword">let</span> highestPriorityRoot = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (lastScheduledRoot !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> previousScheduledRoot = lastScheduledRoot;</span><br><span class="line">    <span class="keyword">let</span> root = firstScheduledRoot;</span><br><span class="line">    <span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> remainingExpirationTime = root.expirationTime;</span><br><span class="line">      <span class="keyword">if</span> (remainingExpirationTime === NoWork) &#123;</span><br><span class="line"> 		<span class="comment">// 初始render不走这里 略</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (remainingExpirationTime &gt; highestPriorityWork) &#123;</span><br><span class="line">          <span class="comment">// Update the priority, if it&#x27;s higher</span></span><br><span class="line">          highestPriorityWork = remainingExpirationTime;</span><br><span class="line">          highestPriorityRoot = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root === lastScheduledRoot) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 初始render后面被break 略</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nextFlushedRoot = highestPriorityRoot;</span><br><span class="line">  nextFlushedExpirationTime = highestPriorityWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，通过这个函数，nextFlushedRoot这里被设置为rootFiber了。后面更新逻辑我们再来继续研究它更多分支。</p>
<h3 id="performUnitOfWork"><a href="#performUnitOfWork" class="headerlink" title="performUnitOfWork"></a>performUnitOfWork</h3><p>接下来就是performWorkOnRoot函数。这个函数之前有伪代码。这里还是要看看实际代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWorkOnRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  isYieldy: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  isRendering = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查同步还是异步</span></span><br><span class="line">  <span class="keyword">if</span> (!isYieldy) &#123;</span><br><span class="line">    <span class="keyword">let</span> finishedWork = root.finishedWork;</span><br><span class="line">    <span class="keyword">if</span> (finishedWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 此时这个root已经处理好了,可以进入commit阶段</span></span><br><span class="line">      completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      root.finishedWork = <span class="literal">null</span>;</span><br><span class="line">	  <span class="comment">// 如果有之前暂停的任务，重置超时时间</span></span><br><span class="line">      <span class="comment">// 我们将会重新进行渲染</span></span><br><span class="line">      <span class="keyword">const</span> timeoutHandle = root.timeoutHandle;</span><br><span class="line">      <span class="keyword">if</span> (timeoutHandle !== noTimeout) &#123;</span><br><span class="line">        root.timeoutHandle = noTimeout;</span><br><span class="line">        <span class="comment">// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above</span></span><br><span class="line">        cancelTimeout(timeoutHandle);</span><br><span class="line">      &#125;</span><br><span class="line">      renderRoot(root, isYieldy); <span class="comment">// renderRoot是一个链表遍历的过程</span></span><br><span class="line">      finishedWork = root.finishedWork;</span><br><span class="line">      <span class="keyword">if</span> (finishedWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 此时这个root已经处理好了,可以进入commit阶段</span></span><br><span class="line">        completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异步Flush 略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isRendering = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>renderRoot可能是最长的一个函数了。。。</p>
<p>这里保留核心代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRoot</span>(<span class="params">root: FiberRoot, isYieldy: boolean</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 禁止renderRoot递归调用 一旦如此则需要抛出错误</span></span><br><span class="line"></span><br><span class="line">  isWorking = <span class="literal">true</span>; <span class="comment">// 作为禁止被递归调用的Flag</span></span><br><span class="line">  <span class="keyword">const</span> previousDispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">  ReactCurrentDispatcher.current = ContextOnlyDispatcher;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> expirationTime = root.nextExpirationTimeToWorkOn;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if we&#x27;re starting from a fresh stack, or if we&#x27;re resuming from</span></span><br><span class="line">  <span class="comment">// previously yielded work.</span></span><br><span class="line">  <span class="comment">// 判断是一个新的stack开始，还是从之前被中断的地方开始</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    expirationTime !== nextRenderExpirationTime ||</span><br><span class="line">    root !== nextRoot ||</span><br><span class="line">    nextUnitOfWork === <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// Reset the stack and start working from the root.</span></span><br><span class="line">    <span class="comment">// 重置stack 从Root开始工作</span></span><br><span class="line">    resetStack();</span><br><span class="line">    nextRoot = root;</span><br><span class="line">    nextRenderExpirationTime = expirationTime;</span><br><span class="line">    <span class="comment">// 创建nextUnitOfWork === workInProgress:Fiber;</span></span><br><span class="line">    <span class="comment">// 如果进入了这个逻辑 这个nextUnitOfWork变量会被workLoop引用到</span></span><br><span class="line">    nextUnitOfWork = createWorkInProgress(</span><br><span class="line">      nextRoot.current,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextRenderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">    root.pendingCommitExpirationTime = NoWork;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> didFatal = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  startWorkLoopTimer(nextUnitOfWork);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      workLoop(isYieldy);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (thrownValue) &#123;</span><br><span class="line">      <span class="comment">// 错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Ready to commit.</span></span><br><span class="line">  onComplete(root, rootWorkInProgress, expirationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是workLoop,在这个初始render环节里面，它就是一个while遍历，如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时nextUnitOfWork会每次更新，直到nextUnitOfWork === null，此时意味着所有节点被遍历完毕了。不过还是看看里面逻辑。精简一下代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">workInProgress: Fiber</span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> current = workInProgress.alternate;</span><br><span class="line"></span><br><span class="line">  startWorkTimer(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> next;</span><br><span class="line">    </span><br><span class="line">  next = beginWork(current, workInProgress, nextRenderExpirationTime);</span><br><span class="line">  workInProgress.memoizedProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    next = completeUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h3><p>然后就是beginWork——有理由相信，这个函数以及涉及到的相关函数，是整个render环节里面最复杂的，因为它直接负责了N种实例的实例化、更新、挂载，并将fiber.child返回。</p>
<p>这N种实例包括:</p>
<ul>
<li>IndeterminateComponent</li>
<li>LazyComponent</li>
<li>FunctionComponent</li>
<li>ClassComponent</li>
<li>HostRoot</li>
<li>HostComponent</li>
<li>HostText</li>
<li>SuspenseComponent</li>
<li>HostPortal</li>
<li>ForwardRef</li>
<li>Fragment</li>
<li>Mode</li>
<li>Profiler</li>
<li>ContextProvider</li>
<li>ContextConsumer</li>
<li>MemoComponent</li>
<li>SimpleMemoComponent</li>
<li>IncompleteClassComponent</li>
<li>DehydratedSuspenseComponent</li>
</ul>
<p>它是具体负责将各种不同Fiber进行分类的函数，换句时髦的话，它负责『垃圾分类』。当我们初始render时候，走的是HostRoot分支。返回了一个<code>return updateHostRoot(args)</code>。这里用它做切入点，其余暂且不论。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostRoot</span>(<span class="params">current, workInProgress, renderExpirationTime</span>) </span>&#123;</span><br><span class="line">  pushHostRootContext(workInProgress);</span><br><span class="line">  <span class="keyword">const</span> updateQueue = workInProgress.updateQueue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// workInProgress.pendingProps|workInProgress.prevState</span></span><br><span class="line">  <span class="comment">// workInProgress.prevState三个变量含义这里不多说</span></span><br><span class="line">  <span class="comment">// 主要是追溯其赋值来源</span></span><br><span class="line">  <span class="comment">// 回顾调用,workInProgress是都是一个个节点 或fiber.next，或fiber.child</span></span><br><span class="line">  <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">const</span> prevState = workInProgress.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> prevChildren = prevState !== <span class="literal">null</span> ? prevState.element : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 关于这个函数看后面的分析 完了再跳回来</span></span><br><span class="line">  <span class="comment">// 它主要是处理updateQueue队列，并更新了workInProgress.memoizedState</span></span><br><span class="line">  processUpdateQueue(</span><br><span class="line">    workInProgress,</span><br><span class="line">    updateQueue,</span><br><span class="line">    nextProps,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> nextState = workInProgress.memoizedState;</span><br><span class="line">  <span class="comment">// Caution: React DevTools currently depends on this property</span></span><br><span class="line">  <span class="comment">// being called &quot;element&quot;.</span></span><br><span class="line">  <span class="keyword">const</span> nextChildren = nextState.element;</span><br><span class="line">  <span class="keyword">if</span> (nextChildren === prevChildren) &#123; <span class="comment">// 这个分支初始render不会进来</span></span><br><span class="line">    <span class="comment">// If the state is the same as before, that&#x27;s a bailout because we had</span></span><br><span class="line">    <span class="comment">// no work that expires at this time.</span></span><br><span class="line">    resetHydrationState();</span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> root: FiberRoot = workInProgress.stateNode;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// 这个分支初始render不会进来</span></span><br><span class="line">    (current === <span class="literal">null</span> || current.child === <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">    root.hydrate &amp;&amp;</span><br><span class="line">    enterHydrationState(workInProgress)</span><br><span class="line">  ) &#123;</span><br><span class="line">    workInProgress.effectTag |= Placement;</span><br><span class="line">    workInProgress.child = mountChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 初始render会进来</span></span><br><span class="line">    reconcileChildren(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">    resetHydrationState();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关联调用(processUpdateQueue)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">processUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  props: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  hasForceUpdate = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 一般直接返回queue 但是当workInProgress.alternate.updateQueue === queue</span></span><br><span class="line">  <span class="comment">// 需要将workInProgress.updateQueue重新做个副本并赋值回去，再返回这个副本</span></span><br><span class="line">  queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这些值可能在后面迭代中被更改。注意是let不是const</span></span><br><span class="line">  <span class="keyword">let</span> newBaseState = queue.baseState;</span><br><span class="line">  <span class="keyword">let</span> newFirstUpdate = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> newExpirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterate through the list of updates to compute the result.</span></span><br><span class="line">  <span class="keyword">let</span> update = queue.firstUpdate;</span><br><span class="line">  <span class="keyword">let</span> resultState = newBaseState;</span><br><span class="line">  <span class="keyword">while</span> (update !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> updateExpirationTime = update.expirationTime;</span><br><span class="line">    <span class="keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) &#123; <span class="comment">// 这里分支暂时可以忽略</span></span><br><span class="line">      <span class="comment">// 此更新没有足够的优先级。跳过它。</span></span><br><span class="line">      <span class="keyword">if</span> (newFirstUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这是第一次跳过的更新.下次更新列表中它将排第一个</span></span><br><span class="line">        newFirstUpdate = update;</span><br><span class="line">        <span class="comment">// 由于这是第一次跳过的更新, 当前结果是&#x27;the new base state&#x27;.</span></span><br><span class="line">        newBaseState = resultState;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 由于此更新将保留在列表中，因此请更新剩余的到期时间。</span></span><br><span class="line">      <span class="keyword">if</span> (newExpirationTime &lt; updateExpirationTime) &#123;</span><br><span class="line">        newExpirationTime = updateExpirationTime;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 此更新确实具有足够的优先级。处理它并计算新结果。</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 这个分支做了一下这些事:</span></span><br><span class="line">      <span class="comment">// 1.根据update.tag等参数，得到目标update.payload的处理后的State值 </span></span><br><span class="line">      <span class="comment">// 2.根据update.callback设置queue的firstEffect、lastEffect属性</span></span><br><span class="line">      <span class="comment">//   以及queue.lastEffect.nextEffect属性</span></span><br><span class="line">      <span class="comment">// 3.对queue.next执行上面操作 如此重复</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">// getStateFromUpdate还是值得看看. update.tag有4个Enum值：</span></span><br><span class="line">      <span class="comment">// ReplaceState|CaptureUpdate|UpdateState|ForceUpdate</span></span><br><span class="line">      <span class="comment">// 这里初始render对应的是UpdateState 这里针对Function Component和partialState有特殊处理</span></span><br><span class="line">      <span class="comment">// 好吧 这里不管那么多分支 常规的ClassComponent返回的就是一个:</span></span><br><span class="line">      <span class="comment">// update.payload。</span></span><br><span class="line">      <span class="comment">// 简单点理解: (queue.firstUpdate.tag) =&gt; &#123; ...queue.firstUpdate.payload &#125;</span></span><br><span class="line">      resultState = getStateFromUpdate(</span><br><span class="line">        workInProgress,</span><br><span class="line">        queue,</span><br><span class="line">        update,</span><br><span class="line">        resultState,</span><br><span class="line">        props,</span><br><span class="line">        instance,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">const</span> callback = update.callback;</span><br><span class="line">      <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">        workInProgress.effectTag |= Callback;</span><br><span class="line">        <span class="comment">// Set this to null, in case it was mutated during an aborted render.</span></span><br><span class="line">        update.nextEffect = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (queue.lastEffect === <span class="literal">null</span>) &#123; <span class="comment">// 如果这个值为null这queue链表是空</span></span><br><span class="line">          queue.firstEffect = queue.lastEffect = update;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 否则将原来的lastEffect的下个Effect设为update</span></span><br><span class="line">          <span class="comment">// 然后将lastEffect指向update；这个操作实质上类似链表版本的Array.push</span></span><br><span class="line">          <span class="comment">// 是将update放到queue链表最后一个位置上</span></span><br><span class="line">          queue.lastEffect.nextEffect = update;</span><br><span class="line">          queue.lastEffect = update;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Continue to the next update.</span></span><br><span class="line">    update = update.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代list模拟事件捕获 这里不管它只看正常开发用到的冒泡</span></span><br><span class="line">  <span class="comment">// 代码略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有跳过的update 这里会进入分支处理queue.lastUpdate值</span></span><br><span class="line">  <span class="keyword">if</span> (newFirstUpdate === <span class="literal">null</span>) &#123; </span><br><span class="line">    queue.lastUpdate = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newFirstCapturedUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">    queue.lastCapturedUpdate = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress.effectTag |= Callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newFirstUpdate === <span class="literal">null</span> &amp;&amp; newFirstCapturedUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// We processed every update, without skipping. That means the new base</span></span><br><span class="line">    <span class="comment">// state is the same as the result state.</span></span><br><span class="line">    <span class="comment">// 我们处理了每次更新，没有跳过。这意味着新的基本状态与结果状态相同。</span></span><br><span class="line">    newBaseState = resultState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  queue.baseState = newBaseState;</span><br><span class="line">  queue.firstUpdate = newFirstUpdate;</span><br><span class="line">  queue.firstCapturedUpdate = newFirstCapturedUpdate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the remaining expiration time to be whatever is remaining in the queue.</span></span><br><span class="line">  <span class="comment">// This should be fine because the only two other things that contribute to</span></span><br><span class="line">  <span class="comment">// expiration time are props and context. We&#x27;re already in the middle of the</span></span><br><span class="line">  <span class="comment">// begin phase by the time we start processing the queue, so we&#x27;ve already</span></span><br><span class="line">  <span class="comment">// dealt with the props. Context in components that specify</span></span><br><span class="line">  <span class="comment">// shouldComponentUpdate is tricky; but we&#x27;ll have to account for</span></span><br><span class="line">  <span class="comment">// that regardless.</span></span><br><span class="line">  workInProgress.expirationTime = newExpirationTime;</span><br><span class="line">  workInProgress.memoizedState = resultState;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="reconcileChildren"><a href="#reconcileChildren" class="headerlink" title="reconcileChildren"></a>reconcileChildren</h4><p>关联调用(reconcileChildren)，这函数名让我想起了v15版本的树结构的递归mount children节点。然而这里我们不是由它做递归，递归是由workLoop做的。它真的就是只处理父子两个节点的事情。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextChildren: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If this is a fresh new component that hasn&#x27;t been rendered yet, we</span></span><br><span class="line">    <span class="comment">// won&#x27;t update its child set by applying minimal side-effects. Instead,</span></span><br><span class="line">    <span class="comment">// we will add them all to the child before it gets rendered. That means</span></span><br><span class="line">    <span class="comment">// we can optimize this reconciliation pass by not tracking side-effects.</span></span><br><span class="line">    <span class="comment">// 如果是一个新鲜的没有渲染过的组件 我们不会通过最小side-effects更新它的child</span></span><br><span class="line">    <span class="comment">// 相反 我们会在渲染之前将它们全部添加到子节点 </span></span><br><span class="line">    <span class="comment">// 这意味着不需要对side-effects进行跟踪 以优化这个reconciliation过程</span></span><br><span class="line">    workInProgress.child = mountChildFibers( <span class="comment">// -&gt; ChildReconciler(false)</span></span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress.child = reconcileChildFibers( <span class="comment">// -&gt; ChildReconciler(true)</span></span><br><span class="line">      workInProgress,</span><br><span class="line">      current.child, <span class="xml">&lt;-- 更新回传入child 以跟踪side-effects</span></span><br><span class="line"><span class="xml">      nextChildren,</span></span><br><span class="line"><span class="xml">      renderExpirationTime,</span></span><br><span class="line"><span class="xml">    );</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>ChildReconciler是个巨折腾的函数。v16好像就突然一下从基于class的编程转换成了基于function的编程偏好。如果说beginWork是在root处处理了N种不同打Fiber节点，那么ChildReconciler就是在child处处理了这些节点。好在这里遵循常规线路，初始render也不需要太过于深入这些，常规的classComponent这里回一路走到(建议跟着断点调试)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));</span><br></pre></td></tr></table></figure>

<p>placeSingleChild这个在初始render里面没啥用，接到什么返回什么不做处理。</p>
<p>reconcileSingleElement这个函数感觉相对简单，但是它是给初次没渲染过得Fiber链表构建一个完整链表『树』到关键。简单提一下 忽略无关分支。但是可以想见，这个函数肯定是一个递归的调用，毕竟他要构建一棵树。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = element.key;</span><br><span class="line">  <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line">  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123; <span class="comment">// 此时child === null 不会进来</span></span><br><span class="line">	<span class="comment">// 略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) &#123; <span class="comment">// 此时常规情况不满足分支进入条件</span></span><br><span class="line">	<span class="comment">// 略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> created = createFiberFromElement(</span><br><span class="line">      element,</span><br><span class="line">      returnFiber.mode,</span><br><span class="line">      expirationTime,</span><br><span class="line">    );</span><br><span class="line">    created.ref = coerceRef(returnFiber, currentFirstChild, element);</span><br><span class="line">    created.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个createFiberFormElement环节的核心是:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fiber = createFiber(fiberTag, pendingProps, key, mode);</span><br><span class="line">fiber.elementType = type;</span><br><span class="line">fiber.type = resolvedType;</span><br><span class="line">fiber.expirationTime = expirationTime;</span><br></pre></td></tr></table></figure>

<p>大致结果就是:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...DefaultFiberVals,</span><br><span class="line">    tag: fiberTag</span><br><span class="line">    elementType: ClassComponet(),</span><br><span class="line">    pendingProps,</span><br><span class="line">    key,</span><br><span class="line">    mode,</span><br><span class="line">    elementType, </span><br><span class="line">    type,</span><br><span class="line">    expirationTime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时type和ElementType没什么区别，不过后面特殊的functionComponent等情况肯定会有变化。</p>
<h4 id="初始render闭环"><a href="#初始render闭环" class="headerlink" title="初始render闭环"></a>初始render闭环</h4><p>这里需要一个闭环分析。我们生成了一个模拟树的fiber链表，但是这里过于深入细节，需要跳出来，完成一场宏观层面的调用观摩，来看看这个『树』结构是如何完成闭环的——这个闭环这里是指fiber节点的递归生成和链接。</p>
<p>但是这里还不够，我们还有一个环节没有讲到，所以闭环暂时无法完成，那就是completeUnitOfWork函数还没有说完。</p>
<p>所以，稍候。</p>
<h3 id="completeUnitOfWork"><a href="#completeUnitOfWork" class="headerlink" title="completeUnitOfWork"></a>completeUnitOfWork</h3><p>这个函数因为太过于深入beginWork所以导致印象缺失有些，我们回头看看beginWork上面提到的workLoop相关的代码。当可以有一些印象以便继续分析阅读。这里关注点，放到performUnitOfWork函数。我们把相关东西合并来看看:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">workInProgress: Fiber</span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> current = workInProgress.alternate;</span><br><span class="line"></span><br><span class="line">  startWorkTimer(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> next;</span><br><span class="line">    </span><br><span class="line">  next = beginWork(current, workInProgress, nextRenderExpirationTime);</span><br><span class="line">  workInProgress.memoizedProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    next = completeUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如说，performUnitOfWork，beginWork是对firstChild的遍历，那么<code>completeUnitOfWork</code>则是对nextSibling的遍历。原本想将这个函数仔细剖析一下，不过这里终究功力尚且不够，最终简化出来的居然和理论那块几乎一样。所以就只扯一扯主要脉络。</p>
<p>分析preformUnitOfWork这块的设计理念。</p>
<p>preformUnitOfWork函数的设计思路是: 通过beginWork对每个给定的root节点进行firstChild深挖，然后完成操作返回对应的最深层级的firstChild，接下来使用<code>completeUnitOfWork</code>处理这一层的nextSibling节点，如果nextSibling存在，递归调用preformUnitOfWork处理child(为了方便理解，最好假设下面没有child了)，否则这一层级已经处理完毕，返回上一级节点。</p>
<p>返回上一级节点这里还有一些门道，因为这个返回走的completeUnitOfWork逻辑，它这里有判断返回的上一级节点是否有nextSibling节点，如果有就返回，如果没有回直接继续往上回溯直到找到有nextSibling的更上层级的节点。</p>
<p>然后继续child处理流程。</p>
<p>最后根据这套逻辑，所有的节点都会被遍历到直到最后返回<code>nextUnitOfWork === null</code>。</p>
<h2 id="渲染闭环-commit阶段"><a href="#渲染闭环-commit阶段" class="headerlink" title="渲染闭环(commit阶段)"></a>渲染闭环(commit阶段)</h2><p>不妨回到开头再看看「Render线路-初始化」小结的调用栈。我们顺着之前整理的调用栈的末节点，加上后来的源码分析，来继续展开:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">workLoop () &#123;</span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">    nextUnitOfWork = <span class="function"><span class="title">performUnitOfWork</span>(<span class="params">nextUnitOfWork</span>)</span> &#123;</span><br><span class="line">      next = beginWork()</span><br><span class="line">        -&gt;<span class="function"><span class="title">updateHostRoot</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">          <span class="keyword">const</span> prevState = workInProgress.memoizedState;</span><br><span class="line">          <span class="keyword">const</span> prevChildren = prevState !== <span class="literal">null</span> ? prevState.element : <span class="literal">null</span>;</span><br><span class="line">          nextChildren = nextState.element;</span><br><span class="line">          -&gt;reconcileChildren()</span><br><span class="line">            =&gt;workInProgress.child = <span class="function"><span class="title">mountChildFibers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">              -&gt;ChildReconciler.reconcileChildFibers() </span><br><span class="line">              =&gt;placeSingleChild(</span><br><span class="line">                reconcileSingleElement( returnFiber, currentFirstChild, newChild, expirationTime)</span><br><span class="line">              ) </span><br><span class="line">              =&gt;reconcileSingleElement( returnFiber, currentFirstChild, newChild, expirationTime)</span><br><span class="line">              =&gt;createFiberFromElement( element, returnFiber.mode, expirationTime)</span><br><span class="line">                -&gt;createFiber() -&gt; <span class="keyword">new</span> FiberNode(tag, pendingProps, key, mode)</span><br><span class="line">              =&gt;FiberNode</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">        next = completeUnitOfWork(workInProgress);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">onComplete(root, rootWorkInProgress, expirationTime)</span><br></pre></td></tr></table></figure>

<p>这里具体了很多。但是实质上，我们并没有逃脱最前面提到的遍历理论部分的伪代码。</p>
<p>细节虽然深入了一些。但是反而更多细节没有没有暴露出来。这一篇的前置的理论是必须理解链表，以及基于链表理论构建的Fiber节点。</p>
<p>如果说v15基础节点是ReactNode，那么v16的基础节点就是Fiber。ReactNode有children，children不断伸展就是一个完整的树。但是v16里面采用了Fiber做基础，有sibling，child，return属性，基于这些属性，它可以以链表的形式完成遍历。</p>
<p>在v15里面，如果要完成一个root挂载，只需要最外层compositeComponent进行了mount后面就会递归执行mount所有的children，最后执行patch完成vdom到dom过程。</p>
<p>但是v16这里，需要走一遍链表的遍历理论才能完成整体挂载，最后执行类似的patch实现vdom-&gt;dom。</p>
<p>这里commit阶段的调用在<code>performWorkOnRoot</code>函数里面后面的<code>renderRoot</code>后面的<code>completeRoot</code>里面。</p>
<p>当我们将Fiber节点处理好，就可以开始进行commit了。</p>
<h3 id="completeRoot"><a href="#completeRoot" class="headerlink" title="completeRoot"></a>completeRoot</h3><p>关于这块的调用栈:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">completeRoot</span><br><span class="line">-&gt; commitRoot () &#123;</span><br><span class="line">    commitBeforeMutationLifecycles()</span><br><span class="line">    commitAllHostEffects();</span><br><span class="line">    root.current = finishedWork;</span><br><span class="line">    commitAllLifeCycles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="commitBeforeMutationLifecycles"><a href="#commitBeforeMutationLifecycles" class="headerlink" title="commitBeforeMutationLifecycles"></a>commitBeforeMutationLifecycles</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationLifecycles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Snapshot) &#123;</span><br><span class="line">      recordEffect();</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      commitBeforeMutationLifeCycles(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数会在遍历nextEffect链表过程中，针对每个Side-Effect执行<code>commitBeforeMutationLifeCycles</code>。这个函数就常规的ClassComponent来说就是调用<code>getSnapshotBeforeUpdate</code>函数。</p>
<h4 id="commitAllHostEffects"><a href="#commitAllHostEffects" class="headerlink" title="commitAllHostEffects"></a>commitAllHostEffects</h4><p>这个函数会在遍历nextEffect链表过程中，针对Side-Effect执行它。它主要是对React执行DOM更新。将渲染好的DOM放到指定位置去。<strong>这里可能是整个patch核心的地方。</strong></p>
<h4 id="commitAllLifecycles"><a href="#commitAllLifecycles" class="headerlink" title="commitAllLifecycles"></a>commitAllLifecycles</h4><p>生命周期处理。关于生命周期处理其实挺无趣的，参考之前的文章也可以明白。</p>
<p>它确实让API变得好用，但是实质上也确实就是在不同时机进行了不同调用。仅此而已。</p>
<h1 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h1><p>这里着重补充一下可能被忽略掉基础性细节。主要是FiberNode节点及其相关。</p>
<p>FiberNode.updateQueue: 更新队列链表</p>
<p>FiberNode.alternate: 节点副本，<strong>nextUnitOfWork</strong>经常会指向它，他也是FiberNode。</p>
<p>FiberNode.memoizedState: 当前节点已经生效显示到UI上的state</p>
<p>FiberRoot.finishedWork是变化节点树。如果root.finishedWork不等于null，那么说明render阶段完成，可以进入commit阶段。</p>
<p>★workInProgress会组成由链表组成的一棵树。如果对这个树如何构建，可以多仔细揣摩reconcileChildren&amp;ChildReconciler，它主要是通过<code>workInProgress.child = createFibler(args)</code>，createFibler对应的前置调用reconcileSingleElement函数里面做了return配对，来实现父子链接。至于sibling也在ChildReconciler有处理。(当然这也只是其中一部分逻辑分支，感觉这个树的构建值得再写一篇，后面再看看吧)。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>这篇参考文章为个人提供了很重要的参考。如果个人这篇文章看不太懂建议看看大佬的。将我这篇作为补充也未尝不可。</p>
<p>[<a href="https://link.zhihu.com/?target=https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e">Inside Fiber: in-depth overview of the new reconciliation algorithm in React</a></p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>v16的开始 || react-Fiber</title>
    <url>/2019/07/15/react-Fiber/</url>
    <content><![CDATA[<h1 id="一段废话"><a href="#一段废话" class="headerlink" title="一段废话"></a>一段废话</h1><p>我当我把v15.6.2大体的东西读得稍有心得的时候(当时选定React版本时其正陷于许可证争论)，此时版本迭代已经到了16.8.6。</p>
<p>不得不感慨前端库迭代的速度，这一年间，React Fiber 和 React Hook特性正式发布了。工程化上React也放弃了Gulp构建转而换为了Rollup。</p>
<p>读完的时候很多东西已经落时，但是当我写到这里的时候心里也并没有后悔。把React大体的读一遍，一则算是个人对峰顶的一次仰望，二则也算是圆了自己充舒适区走出来的想法，三来React再更新，最核心的地方也算是没有白理解。</p>
<p>感慨完毕之后，这里主要是准备换地图继续看新特性了。<strong>目标版本是16.8.6</strong>。</p>
<p>在15.6.2的源码阅读过程中，学会了很多很多深入理解的小技巧，迷茫时候也曾参考别人的文章，无处参考时候也无数次硬啃过各个难点。回想之前种种，阅读源码这事，真的有些如鱼饮水冷暖自知。</p>
<p>故这里小小记录，以为记。</p>
<p>​                        ——(by 2019.7.15)</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一小节想想了还是列一下想从v16中了解的部分。</p>
<ul>
<li>React新的工程架构</li>
<li>React Fiber</li>
<li>render <strong>可以返回字符串，数组，数字</strong></li>
<li>Error Boundary</li>
<li>新的生命周期</li>
<li>React Portal</li>
<li>Fragement</li>
<li>React Hook</li>
</ul>
<p>这里最想知道的还是React的Fiber部分，在React15上实际已经有了相关代码，但是没有正式发布。</p>
<p>所以这一篇暂时从Fiber开始。</p>
<h1 id="Fiber的动机"><a href="#Fiber的动机" class="headerlink" title="Fiber的动机"></a>Fiber的动机</h1><p>虚拟DOM的理念在设计上个人认为已经接近理想性能的极致了，但是后来它还是遇到了现实意义上的瓶颈——当应用越来越大，卡顿现象也就会多起来。</p>
<p>之前我们认真研读了React15.6.2的reconciler源码，以及Diff算法。基于这些理解，可以很容易明白在React15的机制中，这个相关的调和过程，实际是树状、一路递归到子节点的。虽然Diff算法已经设计得非常高效，但是依然会面对递归大型的树时候，因为密集的计算导致主线程堵塞，进而对动画相关处理无法响应，造成了卡顿。</p>
<p>除此以外，当应用响应用户交互时候，绑定的事件过多，基于V15版本关于这块回调是归总并顺序同步执行，如果事件回调耗时过久，导致后来页面触发的更新渲染过慢，如此再三累计起来，卡顿现象就会更为明显。</p>
<p>想要改变这个现状，就必须在数据结构上有所创新——树结构无法预测它后面会有多少层、每层也无法预知会有多少子节点。所以Fiber采用了扁平化的数据结构，这样操作长度就可以被预知，卡顿的现象就有了处理的余地。</p>
<p>概念上这块这里就不再继续说了，因为这里不想画图，所以给大家一个别人写的<a href="https://juejin.im/post/5be969656fb9a049ad76931f">浅析</a>。</p>
<p>这里提一下概念上的东西，v15的reconciler叫做stack reconciler，v16的reconciler叫做fiber reconciler。</p>
<h1 id="Fiber的拆分"><a href="#Fiber的拆分" class="headerlink" title="Fiber的拆分"></a>Fiber的拆分</h1><p>在React15中，调和的过程实质上是组件的Diff，最后批量进行patch的过程。</p>
<p>这个Diff是可以中间停下来的，而patch批量处理批量处理，当然也是可以停下的，但是这不会有什么实质意义。</p>
<p>就上一小节的Fiber点动机来说，V15中Diff是对一棵树的一个不可预见、不能停止的遍历、递归的diff，它如果面临了过于庞大的树，这个Diff就会长时间占用主进程，页面就会卡，所以对它的拆分，可能是最好的选择。</p>
<p>其次就是patch一次执行太多事情，可能也会导致丢帧，这里也应该是通过上层diff的拆分来是实现。</p>
<p>stack reconciler和fiber reconciler本质的区别在于，fiber reconciler不再像stack reconciler那样直接以树结构遍历实例树，而是改用链表的方式来实现它们。<strong>这个从树到链表的变化，是Fiber的本质改进</strong>。</p>
<p>说实话，将树改成链表，这实际上是一个有点反人类的做法，不过它确实能解决性能上的问题——树的递归是无法中途暂停的(因为上层递归操作依赖下级递归操作的返回值)，但是链表可以。</p>
<p>但是不管是stack reconciler还是fiber reconciler，不变的是，依然是对组件树的遍历的实现。</p>
<p>ps: 如果这块大家理解上有困难，那么可能需要对浏览器的宏任务和微任务有基础认识。我们在react里面的各种diff操作以及事件的集中执行这些都是微任务的范畴，而浏览器的刷新则属于宏任务的范畴。浏览器每次执行宏任务之前都会确保所有的微任务被全部执行完毕。这块知识属于EventLoop的范畴。</p>
<h1 id="Fiber的遍历"><a href="#Fiber的遍历" class="headerlink" title="Fiber的遍历"></a>Fiber的遍历</h1><p>Fiber的遍历是异步的遍历。这个遍历其实非常有意思，这让我想起《javascript忍者秘籍第二版》里面提到的，使用generator函数来进行DOM树的遍历。这块的代码部分主要从书上直接抄过来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt; 　</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">traverseDOM</span>(<span class="params">element, callback</span>) </span>&#123; 　　</span><br><span class="line">    callback(element); 　　⇽---　用回调函数处理当前节点 　　</span><br><span class="line">    element = element.firstElementChild; 　　</span><br><span class="line">    <span class="keyword">while</span> (element) &#123; 　　　</span><br><span class="line">      traverseDOM(element, callback); 　　　</span><br><span class="line">      element = element.nextElementSibling; 　　</span><br><span class="line">    &#125;　　⇽---　遍历每个子树 　</span><br><span class="line">  &#125; 　</span><br><span class="line">  <span class="keyword">const</span> subTree = <span class="built_in">document</span>.getElementById(<span class="string">&quot;subTree&quot;</span>); 　</span><br><span class="line">  traverseDOM(subTree, <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123; 　　</span><br><span class="line">    assert(element !== <span class="literal">null</span>, element.nodeName); 　</span><br><span class="line">  &#125;);　　⇽---　通过调用traverseDOM方法从根节点开始遍历 </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>上面的代码是一个简单的，同步递归。本质上，也就是stack reconciler采用的办法。</p>
<p>如果换成生成器是这样:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">DomTraversal</span>(<span class="params">element</span>)</span>&#123; 　</span><br><span class="line">  <span class="keyword">yield</span> element; 　</span><br><span class="line">  element = element.firstElementChild; 　</span><br><span class="line">  <span class="keyword">while</span> (element) &#123; 　　</span><br><span class="line">    <span class="keyword">yield</span>* DomTraversal(element);　</span><br><span class="line">    element = element.nextElementSibling; 　</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> element <span class="keyword">of</span> DomTraversal(subTree)) &#123; 　</span><br><span class="line">  assert(element !== <span class="literal">null</span>, element.nodeName); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这中间有什么区别呢？区别在于，for…of这个函数的实现。或者说再往根源上说，在于迭代器的本质。</p>
<p>迭代器会有next方法，当我们执行<code>DomTraversal.next()</code>时候，返回值的类型是<code>&#123;done: boolean; value: any&#125;</code>这样的结构。直到到达终点，这个done===true。</p>
<p>而for…of则是对迭代器的遍历。它相当于:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!(<span class="keyword">let</span> item = weaponsIterator.next()).done) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在这个异步的流程中，我们可以随自己心意，随时随地去执行next()，而不需要像同步代码那样，必须一口气，处理到底。</p>
<p>这中间，可以斡旋的余地，就完全可以满足Fiber这种需要了。</p>
<p><strong>以上是原理性说明。</strong>并不是实际实现办法，仅作思路引导。实际上React内部的Fiber节点并不是利用这种方法实现。具体实现可以看看后面的文章。</p>
<h1 id="Fiber节点"><a href="#Fiber节点" class="headerlink" title="Fiber节点"></a>Fiber节点</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    stateNode: <span class="keyword">new</span> Bar, <span class="comment">// 组件的类实例、DOM 节点或与 Fiber&lt;ReactNode&gt;</span></span><br><span class="line">    type: Bar | HTMLDivElement, <span class="comment">// 定义此 Fiber 节点的函数或类</span></span><br><span class="line">    alternate: <span class="literal">null</span>,	<span class="comment">// 这是当前fiberNode节点的副本</span></span><br><span class="line">    key: <span class="literal">null</span>,			<span class="comment">// 唯一标识符 Tree Diff用得上</span></span><br><span class="line">    updateQueue: <span class="literal">null</span>,  <span class="comment">// state更新队列和回调相关</span></span><br><span class="line">    memoizedState: any, <span class="comment">// PrevComponent State</span></span><br><span class="line">    pendingProps: &#123;&#125;,   <span class="comment">// NextComponent Props</span></span><br><span class="line">    memoizedProps: &#123;&#125;,  <span class="comment">// PrevComponent Props</span></span><br><span class="line">    tag: <span class="number">1</span>, 			<span class="comment">// Fiber 的类型</span></span><br><span class="line">    effectTag: <span class="number">0</span>,		<span class="comment">// Enum Effect 副作用类型标记 这里和之前Diff实现中标记有部分吻合</span></span><br><span class="line">    nextEffect: <span class="literal">null</span>,	<span class="comment">// 链表 指向下一个具有Side-Effect的Fiber节点</span></span><br><span class="line">    <span class="keyword">return</span>: Fiber | <span class="literal">null</span>, <span class="comment">// 指向虚拟DOM上一级节点</span></span><br><span class="line">    child: Fiber | <span class="literal">null</span>,  <span class="comment">// 相当于虚拟DOM树上该节点的firstElementChild</span></span><br><span class="line">  	sibling: Fiber | <span class="literal">null</span>,<span class="comment">// 下一个子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/ReactWorkTags.js">tag类型相关</a>可以参见这里。</p>
<h2 id="基于Fiber的Diff算法-理论篇"><a href="#基于Fiber的Diff算法-理论篇" class="headerlink" title="基于Fiber的Diff算法-理论篇"></a>基于Fiber的Diff算法-理论篇</h2><p>在说Fiber的链表Diff实现之前，还是可以考虑一下v16版本之前的基于Tree的Diff算法。</p>
<p>在基于树的对比策略下，v15版本采用的更新策略是: 根据更新逻辑, 从VDOM上确定一个尽可能小范围但是包含所有更新的节点作为对比根节点，然后从根到child节点遍历进行组件对比、Tree对比、Element对比，完成之后执行Patch。关于这个环节更具体的细节可以参考之前的文章。</p>
<p>那么在Fiber下是怎样的操作呢？因为这里不再以Tree作为对比的数据结构，所以之前的Diff实现需要有新的实现(感觉思路上其实倒是类似)。</p>
<p>因为基于链表的设置，这里Diff可以不用尽可能的将对比根节点往下面层级缩小，每次的对比都可以直接从根节点开始，而且因为基于对链表的设计，没什么损耗。</p>
<h1 id="Fiber和ReactElement"><a href="#Fiber和ReactElement" class="headerlink" title="Fiber和ReactElement"></a>Fiber和ReactElement</h1><p>不管如何，当标记更新之后，还是要执行Patch处理，只有这样才会将计算结果反馈到UI，对比才有现实意义。</p>
<p>所以理解Fiber和ReactElement的对应是一个很重要的环节。</p>
<p>同时，他也是衔接v15和v16源码理解的重要线索。</p>
<p>这里它们之间关键联结在FiberNode三个属性上。当渲染的render阶段结束，commit阶段开始</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">memoizedProps: 保存旧节点的ReactElement</span><br><span class="line">pendingProps:  保存新节点的ReactElement</span><br><span class="line">stateNode:	   保存新节点的ReactElement对应的DOM(当然这只是特定场景下的)</span><br></pre></td></tr></table></figure>

<p>关于这个属性，还得牵扯到updateQueue。</p>
]]></content>
      <tags>
        <tag>React Fiber</tag>
      </tags>
  </entry>
  <entry>
    <title>React事件体系设计</title>
    <url>/2019/07/10/react-Event-System-Design/</url>
    <content><![CDATA[<h1 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h1><p>关于事件的源码，主要分布在3个地方。</p>
<p>第一个，<code>src/renderers/dom/client/eventPlugins/</code></p>
<p>第二个，<code>src/renderers/dom/client/syntheticEvents/</code></p>
<p>第三个，<code>src/renderers/shared/stack/event/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/renderers/dom/client/eventPlugins/</span><br><span class="line">├── BeforeInputEventPlugin.js</span><br><span class="line">├── ChangeEventPlugin.js</span><br><span class="line">├── DefaultEventPluginOrder.js</span><br><span class="line">├── EnterLeaveEventPlugin.js</span><br><span class="line">├── FallbackCompositionState.js</span><br><span class="line">├── SelectEventPlugin.js</span><br><span class="line">├── SimpleEventPlugin.js</span><br><span class="line">├── TapEventPlugin.js</span><br><span class="line"></span><br><span class="line">src/renderers/dom/client/syntheticEvents/</span><br><span class="line">├── SyntheticAnimationEvent.js</span><br><span class="line">├── SyntheticClipboardEvent.js</span><br><span class="line">├── SyntheticCompositionEvent.js</span><br><span class="line">├── SyntheticDragEvent.js</span><br><span class="line">├── SyntheticFocusEvent.js</span><br><span class="line">├── SyntheticInputEvent.js</span><br><span class="line">├── SyntheticKeyboardEvent.js</span><br><span class="line">├── SyntheticMouseEvent.js</span><br><span class="line">├── SyntheticTouchEvent.js</span><br><span class="line">├── SyntheticTransitionEvent.js</span><br><span class="line">├── SyntheticUIEvent.js</span><br><span class="line">├── SyntheticWheelEvent.js</span><br><span class="line"></span><br><span class="line">src/renderers/shared/stack/event</span><br><span class="line">├── EventConstants.js</span><br><span class="line">├── EventPluginHub.js</span><br><span class="line">├── EventPluginRegistry.js</span><br><span class="line">├── EventPluginUtils.js</span><br><span class="line">├── EventPropagators.js</span><br><span class="line">├── PluginModuleType.js</span><br><span class="line">├── ReactSyntheticEventType.js</span><br><span class="line">├── SyntheticEvent.js</span><br><span class="line">└── eventPlugins</span><br><span class="line">    ├── ResponderEventPlugin.js</span><br><span class="line">    ├── ResponderSyntheticEvent.js</span><br><span class="line">    ├── ResponderTouchHistoryStore.js</span><br><span class="line">    ├── TouchHistoryMath.js</span><br></pre></td></tr></table></figure>

<h1 id="合成事件设计"><a href="#合成事件设计" class="headerlink" title="合成事件设计"></a>合成事件设计</h1><p>这里首先得看看合成事件是怎样设计的。</p>
<p>从<code>src/renderers/dom/client/syntheticEvents/</code>可以看到，诸多的合成事件，基本都是走的以下处理:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SyntheticInputEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  dispatchConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">  dispatchMarker,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> SyntheticEvent.call(</span><br><span class="line">    <span class="built_in">this</span>,</span><br><span class="line">    dispatchConfig,</span><br><span class="line">    dispatchMarker,</span><br><span class="line">    nativeEvent,</span><br><span class="line">    nativeEventTarget,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);</span><br><span class="line"><span class="built_in">module</span>.exports = SyntheticInputEvent;</span><br></pre></td></tr></table></figure>

<p>这里主要就是两个调用<code>SyntheticEvent.call(args)</code> 、<code>SyntheticEvent.augmentClass</code>。</p>
<p>这里就看看SyntheticEvent它到底做了什么。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SyntheticEvent.augmentClass = <span class="function"><span class="keyword">function</span>(<span class="params">Class, Interface</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Super = <span class="built_in">this</span>; <span class="comment">// this指向SyntheticEvent 此处augmentClass作为SyntheticEvent方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> E = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 建立一个空函数</span></span><br><span class="line">  E.prototype = Super.prototype; <span class="comment">// 为空行书设定SyntheticEvent的原型</span></span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="keyword">new</span> E(); <span class="comment">// new这个函数，新的函数原型链指向了SyntheticEvent的原型</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将Class的(此场景是SyntheticInputEvent)原型合并到new出来的新函数上</span></span><br><span class="line">  <span class="built_in">Object</span>.assign(prototype, Class.prototype); </span><br><span class="line">  <span class="comment">// 设定Class原型 并重置constructor为自身</span></span><br><span class="line">  <span class="comment">// 相当于 Class.prototype = prototype();Class.prototype.constructor = Class;</span></span><br><span class="line">  <span class="comment">// 但是这个方法可以减少一层原型链调用</span></span><br><span class="line">  Class.prototype = prototype;</span><br><span class="line">  Class.prototype.constructor = Class;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其实也就是设定了this.constructor.Interface;</span></span><br><span class="line">  <span class="comment">// Interface的值 此处是SyntheticEvent.Interface 和 InputEventInterface的并集</span></span><br><span class="line">  <span class="comment">// 这里可以注意到第一个参数是&#123;&#125;, SyntheticEvent.Interface没有被污染</span></span><br><span class="line">  Class.Interface = <span class="built_in">Object</span>.assign(&#123;&#125;, Super.Interface, Interface);</span><br><span class="line">  Class.augmentClass = Super.augmentClass;</span><br><span class="line"></span><br><span class="line">  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SyntheticEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  dispatchConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 基于上面SyntheticInputEvent的例子，这里this指向SyntheticInputEvent</span></span><br><span class="line">  <span class="comment">// 具体指向还得看SyntheticEvent.call第一个参数传入的context</span></span><br><span class="line">  <span class="built_in">this</span>.dispatchConfig = dispatchConfig;</span><br><span class="line">  <span class="built_in">this</span>._targetInst = targetInst;</span><br><span class="line">  <span class="built_in">this</span>.nativeEvent = nativeEvent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处是SyntheticEvent.Interface 和 InputEventInterface的并集</span></span><br><span class="line">  <span class="keyword">var</span> Interface = <span class="built_in">this</span>.constructor.Interface;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> Interface) &#123;</span><br><span class="line">    <span class="comment">// 如果propName在原型上 跳过后面代码 进行下一个循环</span></span><br><span class="line">    <span class="keyword">if</span> (!Interface.hasOwnProperty(propName)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> normalize = Interface[propName];</span><br><span class="line">    <span class="comment">// 这里后面的代码可以有这样一个论断:</span></span><br><span class="line">    <span class="comment">// Interface上的属性有两种，一种是属性，值统一为null|undefined之类</span></span><br><span class="line">    <span class="comment">// 一种是方法，这个方法接受event作为参数</span></span><br><span class="line">    <span class="comment">// 最后this被根据Interface统一赋值完毕</span></span><br><span class="line">    <span class="comment">// normalize如果是函数，this[propName]就接受事件运行返回值</span></span><br><span class="line">    <span class="comment">// 否则normalize就是值，this[propName] = nativeEvent[propName]</span></span><br><span class="line">    <span class="keyword">if</span> (normalize) &#123;</span><br><span class="line">      <span class="built_in">this</span>[propName] = normalize(nativeEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (propName === <span class="string">&#x27;target&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = nativeEventTarget;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>[propName] = nativeEvent[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/API/Event/defaultPrevented</span></span><br><span class="line">  <span class="comment">// 返回一个布尔值，表明当前事件是否调用了 event.preventDefault()方法。</span></span><br><span class="line">  <span class="keyword">var</span> defaultPrevented = nativeEvent.defaultPrevented != <span class="literal">null</span></span><br><span class="line">    ? nativeEvent.defaultPrevented</span><br><span class="line">    : nativeEvent.returnValue === <span class="literal">false</span>; <span class="comment">// 旧浏览器兼容</span></span><br><span class="line">  <span class="keyword">if</span> (defaultPrevented) &#123;</span><br><span class="line">    <span class="built_in">this</span>.isDefaultPrevented = emptyFunction.thatReturnsTrue;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.isDefaultPrevented = emptyFunction.thatReturnsFalse;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.isPropagationStopped = emptyFunction.thatReturnsFalse;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里执行的入口是<code>SyntheticEvent.augmentClass</code>，后面跟着执行<code>SyntheticEvent.call(arg)</code>，具体逻辑都详细列出来了。</p>
<p>这两个主要做的事情检出来说说:</p>
<ul>
<li>合并SyntheticEvent和SyntheticInputEvent的两者的Interface，对SyntheticInputEvent按需赋值</li>
<li>SyntheticInputEvent继承SyntheticEvent原型链</li>
<li>SyntheticInputEvent三个属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SyntheticEvent.augmentClass = <span class="function"><span class="keyword">function</span>(<span class="params">Class, Interface</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Super = <span class="built_in">this</span>; <span class="comment">// this指向SyntheticEvent 此处augmentClass作为SyntheticEvent方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> E = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 建立一个空函数</span></span><br><span class="line">  E.prototype = Super.prototype; <span class="comment">// 为空行书设定SyntheticEvent的原型</span></span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="keyword">new</span> E(); <span class="comment">// new这个函数，新的函数原型链指向了SyntheticEvent的原型</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将Class的(此场景是SyntheticInputEvent)原型合并到new出来的新函数上</span></span><br><span class="line">  <span class="built_in">Object</span>.assign(prototype, Class.prototype); </span><br><span class="line">  <span class="comment">// 设定Class原型 并重置constructor为自身</span></span><br><span class="line">  <span class="comment">// 相当于 Class.prototype = prototype();Class.prototype.constructor = Class;</span></span><br><span class="line">  <span class="comment">// 但是这个方法可以减少一层原型链调用</span></span><br><span class="line">  Class.prototype = prototype;</span><br><span class="line">  Class.prototype.constructor = Class;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其实也就是设定了this.constructor.Interface;</span></span><br><span class="line">  <span class="comment">// Interface的值 此处是SyntheticEvent.Interface 和 InputEventInterface的并集</span></span><br><span class="line">  <span class="comment">// 这里可以注意到第一个参数是&#123;&#125;, SyntheticEvent.Interface没有被污染</span></span><br><span class="line">  Class.Interface = <span class="built_in">Object</span>.assign(&#123;&#125;, Super.Interface, Interface);</span><br><span class="line">  Class.augmentClass = Super.augmentClass;</span><br><span class="line"></span><br><span class="line">  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SyntheticEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  dispatchConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 基于上面SyntheticInputEvent的例子，这里this指向SyntheticInputEvent</span></span><br><span class="line">  <span class="comment">// 具体指向还得看SyntheticEvent.call第一个参数传入的context</span></span><br><span class="line">  <span class="built_in">this</span>.dispatchConfig = dispatchConfig;</span><br><span class="line">  <span class="built_in">this</span>._targetInst = targetInst;</span><br><span class="line">  <span class="built_in">this</span>.nativeEvent = nativeEvent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处是SyntheticEvent.Interface 和 InputEventInterface的并集</span></span><br><span class="line">  <span class="keyword">var</span> Interface = <span class="built_in">this</span>.constructor.Interface;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> Interface) &#123;</span><br><span class="line">    <span class="comment">// 如果propName在原型上 跳过后面代码 进行下一个循环</span></span><br><span class="line">    <span class="keyword">if</span> (!Interface.hasOwnProperty(propName)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> normalize = Interface[propName];</span><br><span class="line">    <span class="comment">// 这里后面的代码可以有这样一个论断:</span></span><br><span class="line">    <span class="comment">// Interface上的属性有两种，一种是属性，值统一为null|undefined之类</span></span><br><span class="line">    <span class="comment">// 一种是方法，这个方法接受event作为参数</span></span><br><span class="line">    <span class="comment">// 最后this被根据Interface统一赋值完毕</span></span><br><span class="line">    <span class="comment">// normalize如果是函数，this[propName]就接受事件运行返回值</span></span><br><span class="line">    <span class="comment">// 否则normalize就是值，this[propName] = nativeEvent[propName]</span></span><br><span class="line">    <span class="keyword">if</span> (normalize) &#123;</span><br><span class="line">      <span class="built_in">this</span>[propName] = normalize(nativeEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (propName === <span class="string">&#x27;target&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = nativeEventTarget;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>[propName] = nativeEvent[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/API/Event/defaultPrevented</span></span><br><span class="line">  <span class="comment">// 返回一个布尔值，表明当前事件是否调用了 event.preventDefault()方法。</span></span><br><span class="line">  <span class="keyword">var</span> defaultPrevented = nativeEvent.defaultPrevented != <span class="literal">null</span></span><br><span class="line">    ? nativeEvent.defaultPrevented</span><br><span class="line">    : nativeEvent.returnValue === <span class="literal">false</span>; <span class="comment">// 旧浏览器兼容</span></span><br><span class="line">  <span class="keyword">if</span> (defaultPrevented) &#123;</span><br><span class="line">    <span class="built_in">this</span>.isDefaultPrevented = emptyFunction.thatReturnsTrue;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.isDefaultPrevented = emptyFunction.thatReturnsFalse;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.isPropagationStopped = emptyFunction.thatReturnsFalse;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里执行的入口是<code>SyntheticEvent.augmentClass</code>，后面跟着执行<code>SyntheticEvent.call(arg)</code>，具体逻辑都详细列出来了。</p>
<p>这两个主要做的事情检出来说说:</p>
<ul>
<li>合并SyntheticEvent和SyntheticInputEvent的两者的Interface，对SyntheticInputEvent按需赋值</li>
<li>SyntheticInputEvent继承SyntheticEvent原型链</li>
<li>SyntheticInputEvent三个属性dispatchConfig|_targetInst|nativeEvent的赋值</li>
<li>isDefaultPrevented和isPropagationStopped赋值</li>
</ul>
<p>最后事情捡回来说SyntheticInputEvent实质上还是SyntheticEvent函数的的返回值。所以这里事情的本质还是对SyntheticEvent的继承和扩展。</p>
<p><strong>关于这个继承，主要是基于新的合成类型的Interface和event事件进行处理的。</strong></p>
<h2 id="合成事件-和-原生事件-区别"><a href="#合成事件-和-原生事件-区别" class="headerlink" title="合成事件 和 原生事件 区别"></a>合成事件 和 原生事件 区别</h2><p>这里反思一下，<strong>合成事件和nativeEvent的区别在哪呢</strong>？这里根据源码总结一下:</p>
<ul>
<li>添加了三个属性dispatchConfig|_targetInst|nativeEvent</li>
<li>Interface上设计了一些方法，这里赋值会根据函数进行赋值，这是一个设计模式，类似vue的computed。</li>
<li>defaultPrevented属性设为必有的布尔值,  isPropagationStopped恒等于false</li>
</ul>
<h2 id="合成事件的继承关系"><a href="#合成事件的继承关系" class="headerlink" title="合成事件的继承关系"></a>合成事件的继承关系</h2><p>基于合成事件 和 原生事件和关系，那么不同合成事件的关系继承，就很有一些猜测的意思了。</p>
<p><strong>这里可以直接推论到，继承的核心，就是那些Interface对象上的属性和方法。</strong></p>
<p>下面根据标题做了一个树，需要配合目录层级看合成事件继承关系。</p>
<h3 id="SyntheticEvent"><a href="#SyntheticEvent" class="headerlink" title="SyntheticEvent"></a>SyntheticEvent</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventInterface = &#123;</span><br><span class="line">  type: <span class="literal">null</span>,</span><br><span class="line">  target: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// currentTarget is set when dispatching; no use in copying it here</span></span><br><span class="line">  currentTarget: emptyFunction.thatReturnsNull,</span><br><span class="line">  eventPhase: <span class="literal">null</span>,</span><br><span class="line">  bubbles: <span class="literal">null</span>,</span><br><span class="line">  cancelable: <span class="literal">null</span>,</span><br><span class="line">  timeStamp: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.timeStamp || <span class="built_in">Date</span>.now();</span><br><span class="line">  &#125;,</span><br><span class="line">  defaultPrevented: <span class="literal">null</span>,</span><br><span class="line">  isTrusted: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="SyntheticAnimationEvent"><a href="#SyntheticAnimationEvent" class="headerlink" title="SyntheticAnimationEvent"></a>SyntheticAnimationEvent</h4><p>Extends SyntheticEvent</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> AnimationEventInterface = &#123;</span><br><span class="line">  animationName: <span class="literal">null</span>,</span><br><span class="line">  elapsedTime: <span class="literal">null</span>,</span><br><span class="line">  pseudoElement: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="ClipboardEventInterface"><a href="#ClipboardEventInterface" class="headerlink" title="ClipboardEventInterface"></a>ClipboardEventInterface</h4><p>Extends SyntheticEvent</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ClipboardEventInterface = &#123;</span><br><span class="line">  clipboardData: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;clipboardData&#x27;</span> <span class="keyword">in</span> event</span><br><span class="line">      ? event.clipboardData</span><br><span class="line">      : <span class="built_in">window</span>.clipboardData;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="SyntheticCompositionEvent"><a href="#SyntheticCompositionEvent" class="headerlink" title="SyntheticCompositionEvent"></a>SyntheticCompositionEvent</h4><p>Extends SyntheticEvent</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CompositionEventInterface = &#123;</span><br><span class="line">  data: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="SyntheticInputEvent"><a href="#SyntheticInputEvent" class="headerlink" title="SyntheticInputEvent"></a>SyntheticInputEvent</h4><p>Extends SyntheticEvent</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> InputEventInterface = &#123;</span><br><span class="line">  data: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="SyntheticTransitionEvent"><a href="#SyntheticTransitionEvent" class="headerlink" title="SyntheticTransitionEvent"></a>SyntheticTransitionEvent</h4><p>Extends SyntheticEvent</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TransitionEventInterface = &#123;</span><br><span class="line">  propertyName: <span class="literal">null</span>,</span><br><span class="line">  elapsedTime: <span class="literal">null</span>,</span><br><span class="line">  pseudoElement: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="ResponderSyntheticEvent"><a href="#ResponderSyntheticEvent" class="headerlink" title="ResponderSyntheticEvent"></a>ResponderSyntheticEvent</h4><p>Extends SyntheticEvent</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ResponderEventInterface = &#123;</span><br><span class="line">  touchHistory: <span class="function"><span class="keyword">function</span>(<span class="params">nativeEvent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// Actually doesn&#x27;t even look at the native event.</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="SyntheticUIEvent"><a href="#SyntheticUIEvent" class="headerlink" title="SyntheticUIEvent"></a>SyntheticUIEvent</h4><p>Extends SyntheticEvent</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> UIEventInterface = &#123;</span><br><span class="line">  view: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.view) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> target = getEventTarget(event);</span><br><span class="line">    <span class="keyword">if</span> (target.window === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> doc = target.ownerDocument;</span><br><span class="line">    <span class="keyword">if</span> (doc) &#123;</span><br><span class="line">      <span class="keyword">return</span> doc.defaultView || doc.parentWindow;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  detail: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.detail || <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="SyntheticTouchEvent"><a href="#SyntheticTouchEvent" class="headerlink" title="SyntheticTouchEvent"></a>SyntheticTouchEvent</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TouchEventInterface = &#123;</span><br><span class="line">  touches: <span class="literal">null</span>,</span><br><span class="line">  targetTouches: <span class="literal">null</span>,</span><br><span class="line">  changedTouches: <span class="literal">null</span>,</span><br><span class="line">  altKey: <span class="literal">null</span>,</span><br><span class="line">  metaKey: <span class="literal">null</span>,</span><br><span class="line">  ctrlKey: <span class="literal">null</span>,</span><br><span class="line">  shiftKey: <span class="literal">null</span>,</span><br><span class="line">  getModifierState: getEventModifierState,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="SyntheticFocusEvent"><a href="#SyntheticFocusEvent" class="headerlink" title="SyntheticFocusEvent"></a>SyntheticFocusEvent</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> FocusEventInterface = &#123;</span><br><span class="line">  relatedTarget: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="SyntheticKeyboardEvent"><a href="#SyntheticKeyboardEvent" class="headerlink" title="SyntheticKeyboardEvent"></a>SyntheticKeyboardEvent</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> KeyboardEventInterface = &#123;</span><br><span class="line">  key: getEventKey,</span><br><span class="line">  location: <span class="literal">null</span>,</span><br><span class="line">  ctrlKey: <span class="literal">null</span>,</span><br><span class="line">  shiftKey: <span class="literal">null</span>,</span><br><span class="line">  altKey: <span class="literal">null</span>,</span><br><span class="line">  metaKey: <span class="literal">null</span>,</span><br><span class="line">  repeat: <span class="literal">null</span>,</span><br><span class="line">  locale: <span class="literal">null</span>,</span><br><span class="line">  getModifierState: getEventModifierState,</span><br><span class="line">  charCode: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.type === <span class="string">&#x27;keypress&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> getEventCharCode(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  keyCode: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.type === <span class="string">&#x27;keydown&#x27;</span> || event.type === <span class="string">&#x27;keyup&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.keyCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  which: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.type === <span class="string">&#x27;keypress&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> getEventCharCode(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event.type === <span class="string">&#x27;keydown&#x27;</span> || event.type === <span class="string">&#x27;keyup&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.keyCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="SyntheticMouseEvent"><a href="#SyntheticMouseEvent" class="headerlink" title="SyntheticMouseEvent"></a>SyntheticMouseEvent</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MouseEventInterface = &#123;</span><br><span class="line">  screenX: <span class="literal">null</span>,</span><br><span class="line">  screenY: <span class="literal">null</span>,</span><br><span class="line">  clientX: <span class="literal">null</span>,</span><br><span class="line">  clientY: <span class="literal">null</span>,</span><br><span class="line">  ctrlKey: <span class="literal">null</span>,</span><br><span class="line">  shiftKey: <span class="literal">null</span>,</span><br><span class="line">  altKey: <span class="literal">null</span>,</span><br><span class="line">  metaKey: <span class="literal">null</span>,</span><br><span class="line">  getModifierState: getEventModifierState,</span><br><span class="line">  button: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> button = event.button;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;which&#x27;</span> <span class="keyword">in</span> event) &#123;</span><br><span class="line">      <span class="keyword">return</span> button;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> button === <span class="number">2</span> ? <span class="number">2</span> : button === <span class="number">4</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  buttons: <span class="literal">null</span>,</span><br><span class="line">  relatedTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      event.relatedTarget ||</span><br><span class="line">      (event.fromElement === event.srcElement</span><br><span class="line">        ? event.toElement</span><br><span class="line">        : event.fromElement)</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  pageX: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;pageX&#x27;</span> <span class="keyword">in</span> event</span><br><span class="line">      ? event.pageX</span><br><span class="line">      : event.clientX + ViewportMetrics.currentScrollLeft;</span><br><span class="line">  &#125;,</span><br><span class="line">  pageY: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;pageY&#x27;</span> <span class="keyword">in</span> event</span><br><span class="line">      ? event.pageY</span><br><span class="line">      : event.clientY + ViewportMetrics.currentScrollTop;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="SyntheticDragEvent"><a href="#SyntheticDragEvent" class="headerlink" title="SyntheticDragEvent"></a>SyntheticDragEvent</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DragEventInterface = &#123;</span><br><span class="line">  dataTransfer: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="SyntheticWheelEvent"><a href="#SyntheticWheelEvent" class="headerlink" title="SyntheticWheelEvent"></a>SyntheticWheelEvent</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> WheelEventInterface = &#123;</span><br><span class="line">  deltaX: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;deltaX&#x27;</span> <span class="keyword">in</span> event</span><br><span class="line">      ? event.deltaX</span><br><span class="line">      : <span class="string">&#x27;wheelDeltaX&#x27;</span> <span class="keyword">in</span> event ? -event.wheelDeltaX : <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  deltaY: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;deltaY&#x27;</span> <span class="keyword">in</span> event</span><br><span class="line">      ? event.deltaY</span><br><span class="line">      : <span class="string">&#x27;wheelDeltaY&#x27;</span> <span class="keyword">in</span> event</span><br><span class="line">        ? -event.wheelDeltaY</span><br><span class="line">        : <span class="string">&#x27;wheelDelta&#x27;</span> <span class="keyword">in</span> event ? -event.wheelDelta : <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  deltaZ: <span class="literal">null</span>,</span><br><span class="line">  deltaMode: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="EventPlugin"><a href="#EventPlugin" class="headerlink" title="EventPlugin"></a>EventPlugin</h1><p>XXXPlugins是对合成事件的调配。根据不同的事件，它有一个方法可以专门返回合成事件实例。</p>
<p>它的结构大致是这样的:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DispatchConfig = &#123;</span><br><span class="line">  dependencies: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;,</span><br><span class="line">  phasedRegistrationNames?: &#123;</span><br><span class="line">    bubbled: <span class="built_in">string</span>,</span><br><span class="line">    captured: <span class="built_in">string</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  registrationName?: <span class="built_in">string</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> EventTypes = &#123;[key: <span class="built_in">string</span>]: DispatchConfig&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PluginModule&lt;NativeEvent&gt; = &#123;</span><br><span class="line">  eventTypes: EventTypes,</span><br><span class="line">  extractEvents: (</span><br><span class="line">    topLevelType: <span class="built_in">string</span>,</span><br><span class="line">    targetInst: ReactInstance,</span><br><span class="line">    nativeTarget: NativeEvent,</span><br><span class="line">    nativeEventTarget: EventTarget,</span><br><span class="line">  ) =&gt; <span class="literal">null</span> | ReactSyntheticEvent,</span><br><span class="line">  didPutListener?: (</span><br><span class="line">    inst: ReactInstance,</span><br><span class="line">    registrationName: <span class="built_in">string</span>,</span><br><span class="line">    listener: <span class="function">() =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">  ) =&gt; <span class="built_in">void</span>,</span><br><span class="line">  willDeleteListener?: <span class="function">(<span class="params">inst: ReactInstance, registrationName: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">  tapMoveThreshold?: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> Plugins &#123;</span><br><span class="line">    eventTypes: EventTypes;</span><br><span class="line">    extractEvents: (</span><br><span class="line">        topLevelType: TopLevelTypes,</span><br><span class="line">        targetInst: ReactInstance,</span><br><span class="line">        nativeEvent: MouseEvent,</span><br><span class="line">        nativeEventTarget: EventTarget,</span><br><span class="line">    ) =&gt; PluginModule&lt;NativeEvent&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>extractEvents</code>是一个重要API，它会返回一个合成事件实例。</p>
<p>这里就<code>SimpleEventPlugin</code>讲一讲。这是一个非常重要的Plugin。</p>
<p>它核心逻辑如下：</p>
<ol>
<li>判断<code>topLevelType</code>的值，根据这个值返回一个合成事件生产函数</li>
</ol>
<ul>
<li><p>如果是<code>topAbort topCanPlay topCanPlayThrough topDurationChange topEmptied topEncrypted topEnded topError topInput topInvalid topLoad topLoadedData topLoadedMetadata topLoadStart topPause topPlay topPlaying topProgress topRateChange topReset topSeeked topSeeking topStalled topSubmit topSuspend topTimeUpdate topVolumeChange topWaiting</code>之一，返回SyntheticEvent。</p>
</li>
<li><p>如果是<code>topKeyPress topClick</code>返回null</p>
</li>
<li><p>如果是<code>topKeyUp</code>返回SyntheticKeyboardEvent</p>
</li>
<li><p>如果是<code>topKeyDown topKeyUp</code>返回SyntheticFocusEvent</p>
</li>
<li><p>如果是<code>topDoubleClick topMouseDown topMouseMove topMouseUp topMouseOut topMouseOver topContextMenu</code>返回SyntheticMouseEvent</p>
</li>
<li><p>如果是<code>topDra topDragEn topDragEnte topDragExi topDragLeav topDragOve topDragStar topDrop</code>返回SyntheticDragEvent</p>
</li>
<li><p>如果是<code>topTouchCancel topTouchEnd topTouchMove topTouchStart</code>返回SyntheticTouchEvent</p>
</li>
<li><p>如果是<code>topAnimationEnd topAnimationIteration topAnimationStart</code>返回SyntheticAnimationEvent</p>
</li>
<li><p>如果是<code>topTransitionEnd</code>返回SyntheticTransitionEvent</p>
</li>
<li><p>如果是<code>topScroll</code>返回SyntheticUIEvent</p>
</li>
<li><p>如果是<code>topWheel</code>返回SyntheticWheelEvent</p>
</li>
<li><p>如果是<code>topCopy topCut topPaste</code>返回SyntheticClipboardEvent</p>
</li>
</ul>
<ol start="2">
<li><p>使用这个函数传入目标参数返回合成事件实例</p>
</li>
<li><p>执行<code>EventPropagators.accumulateTwoPhaseDispatches(event)</code>。这个函数在虚拟DOM上模拟事件捕获和冒泡，并将所有的实际回调都缓存到数组保存好，具体可以参见<a href="/2018/06/10/react-event/#extractEvents">React Event#extractEvents</a>，这里不涉及这个细节。<strong>但是当你从这个链接调出再返回时，务必记得<code>event._dispatchListeners &amp;&amp; event._dispatchInstances</code>这两个变量从哪来。</strong></p>
</li>
</ol>
<h1 id="EventPluginHub"><a href="#EventPluginHub" class="headerlink" title="EventPluginHub"></a>EventPluginHub</h1><p>在Plugin上一层，还有一个EventPluginHub的设计。</p>
<p>如果说Plugin是对合成事件的调配，那么EventPluginHub就是对Plugin的调配。它的结构大致如下，细节代码这里不放了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventPluginHub = &#123;</span><br><span class="line">  <span class="comment">// 保存事件回调到`listenerBank[registrationName][key]`这个位置</span></span><br><span class="line">  putListener: <span class="function"><span class="keyword">function</span>(<span class="params">inst, registrationName, listener</span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="comment">// putListener的反向操作 从listenerBank[registrationName][key]读取事件回调</span></span><br><span class="line">  <span class="comment">// 鼠标事件存在Prevent可能 如果被阻止了 那就返回null</span></span><br><span class="line">  getListener: <span class="function"><span class="keyword">function</span>(<span class="params">inst, registrationName</span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="comment">// 从listenerBank[registrationName]移除对应实例的registrationName类型的回调</span></span><br><span class="line">  deleteListener: <span class="function"><span class="keyword">function</span>(<span class="params">inst, registrationName</span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="comment">// 从listenerBank里面移除对应实例所有类型的回调</span></span><br><span class="line">  deleteAllListeners: <span class="function"><span class="keyword">function</span>(<span class="params">inst</span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="comment">// 遍历所有的Plugins(EventPluginRegistry.plugins)，挨个执行每个Plugin上的extractEvents，如果有返回，进入模拟捕获和冒泡环节</span></span><br><span class="line">  extractEvents: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    topLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">    targetInst,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="comment">// 将获取到的合成事件放到processEventQueue以待执行</span></span><br><span class="line">  enqueueEvents: <span class="function"><span class="keyword">function</span>(<span class="params">events</span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="comment">// 调用processEventQueue里面所有的合成事件</span></span><br><span class="line">  processEventQueue: <span class="function"><span class="keyword">function</span>(<span class="params">simulated</span>) </span>&#123; &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="EventPluginRegistry"><a href="#EventPluginRegistry" class="headerlink" title="EventPluginRegistry"></a>EventPluginRegistry</h1><p>上一小结提到了<code>EventPluginRegistry.plugins</code>,这里对这个进行一下分析。其主要结构是:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type DispatchConfig = &#123;</span><br><span class="line">  dependencies: <span class="built_in">Array</span>&lt;string&gt;,</span><br><span class="line">  phasedRegistrationNames?: &#123;</span><br><span class="line">    bubbled: string,</span><br><span class="line">    captured: string,</span><br><span class="line">  &#125;,</span><br><span class="line">  registrationName?: string,</span><br><span class="line">&#125;;</span><br><span class="line">type EventTypes = &#123;[key: string]: DispatchConfig&#125;;</span><br><span class="line">type DomAttrEvent = Omit(DOMAttributes, <span class="string">&#x27;children&#x27;</span>, <span class="string">&#x27;dangerouslySetInnerHTML&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> EventPluginRegistry = &#123;</span><br><span class="line">  plugins: <span class="built_in">Array</span>&lt;Plugins&gt;;</span><br><span class="line">  eventNameDispatchConfigs: EventTypes;</span><br><span class="line">  <span class="comment">// DOMAttributes参见@types/react</span></span><br><span class="line">  <span class="comment">// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts#L1240</span></span><br><span class="line">  registrationNameModules: &#123;[key: keyof DomAttrEvent]: PluginModule&#125;;</span><br><span class="line">  registrationNameDependencies: &#123;[key: keyof DomAttrEvent]: <span class="built_in">Array</span>&lt;keyof topLevelTypes&gt;&#125;,</span><br><span class="line">  possibleRegistrationNames; <span class="comment">// &quot;onabort&quot;: &quot;onAbort&quot;|&quot;onclick&quot;: &quot;onClick&quot;这种键值对</span></span><br><span class="line">  <span class="comment">// 为eventPluginOrder赋值 这里值为固定值 以备后面为进行排序</span></span><br><span class="line">  <span class="comment">// [&quot;ResponderEventPlugin&quot;, &quot;SimpleEventPlugin&quot;, &quot;TapEventPlugin&quot;, &quot;EnterLeaveEventPlugin&quot;, &quot;ChangeEventPlugin&quot;, &quot;SelectEventPlugin&quot;, &quot;BeforeInputEventPlugin&quot;]</span></span><br><span class="line">  injectEventPluginOrder: <span class="function">(<span class="params">injectedEventPluginOrder: EventPluginOrder</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 为namesToPlugins，设定一个Map结构 可以通过PluginName获取Plugin，并根据eventPluginOrder排序</span></span><br><span class="line">  injectEventPluginsByName: <span class="function">(<span class="params">injectedNamesToPlugins: NamesToPlugins</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">  getPluginModuleForEvent: <span class="function">(<span class="params">event: ReactSyntheticEvent</span>) =&gt;</span> <span class="literal">null</span> | PluginModule&lt;AnyNativeEvent&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>平心而论，这个EventPluginRegistry对象是一个极其庞大的对象。</strong>从运行栈里直接copy json(不含函数)，就有72000+行之巨，大多数的dom上的事件props名称的兼容相关，在这里都有体现。</p>
<p>如此巨量的数据，配合Registry名称，这里是所有合成事件相关数据保存位置，以及各种原生事件和合成事件的对应映射、兼容映射。(但是这里不是事件回调保存位置所在)。</p>
<p>关于这个EventPluginRegistry，不是特别容易读，虽然代码还是很简单，但是从代码推导其作用，有点折腾，推荐还是直接看EventPluginRegistry-test.js测试文件。</p>
<p>这里<strong>核心API</strong>就两个<code>injectEventPluginsByName</code>, <code>injectEventPluginOrder</code>。其他的变量、函数要么是为了实现这个API，要么是为了测试这个API而声明的。<strong>这两个函数为EventPluginHub模块实现事件插件模块的加载。</strong></p>
<p>这两个核心API使用时候是可以不在乎调用顺序的，只要调用时传入了有效参数，他们都会走一次排序流程，这个流程定义在recomputePluginOrdering，排序目标是EventPluginRegistry.plugins数组，排序依据是injectEventPluginOrder传入的参数。</p>
<p>这个recomputePluginOrdering函数值得一看。因为有提到phasedRegistrationNames的处理。这个函数里面执行了publishEventForPlugin，这个函数会遍历phasedRegistrationNames里面的bubbled&amp;captured属性，然后调用publishRegistrationName。</p>
<p>这个函数核心逻辑如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;</span><br><span class="line">EventPluginRegistry.registrationNameDependencies[registrationName] =</span><br><span class="line">  pluginModule.eventTypes[eventName].dependencies;</span><br></pre></td></tr></table></figure>

<p>也就是在对应的registrationNameModules[registrationName] &amp;&amp; registrationNameDependencies[registrationName]赋值，改为对应Plugin的值和dependencies。</p>
<p>这可以视为一个瞬时变量，因为每次遇到同名的registrationName会被覆盖，这实际上也是加载模块的意义所在。</p>
<p><font color='red'>★</font>我们再看看当加载完毕后EventPluginHub，这个模块是如何用到的它们。</p>
<ul>
<li>putListener。这里主要是判断<code>EventPluginRegistry.registrationNameModules[registrationName]</code>值存在,执行换个EventPlugin上的<code>didPutListener</code>,这个函数一般是一些兼容hack处理。</li>
<li>deleteListener。这是针对<code>didPutListener</code>的反向操作，执行的是这个EventPlugin上的<code>willDeleteListener</code>。</li>
<li>deleteAllListeners，加强版的deleteListener，直接遍历执行全部EventPlugin的deleteListener。</li>
<li>extractEvents。遍历plugin模拟冒泡并执行。</li>
</ul>
<p><font color='red'>★</font>这里还缺<code>registrationNameDependencies[registrationName]</code>的线索，再找找。在ReactBrowserEventEmitter.js#line254这里开始有引用。</p>
<p>我们忽略特殊分支topWheel、topScroll、topFocus、topBlur。通用性做法是:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(</span><br><span class="line">    dependency,</span><br><span class="line">    topEventMapping[dependency],</span><br><span class="line">    mountAt,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里有很多细节，不过我们在<a href="/2018/06/10/react-event/#ReactEventListener">ReactEvent Part1</a>里面有很详细的说明。这里可以移步过去看看再回来看继续的。</p>
<p>看过Part1,思路就可以更加清晰了，因为这部分是事件触发过后，往后继续执行的过程。在Part1里面我们深入这个过程将他们串联起来，但是并没有架构起合成事件实现的宏观架构。</p>
<p>首先是<code>ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent</code>指向<code>ReactEventListener.trapBubbledEvent</code>。进而调用了<code>EventListener.listen</code>-&gt;<code>target.addEventListener</code>。</p>
<p>也就是说，<strong>在这个链条中dependency进入了真实的DOM事件绑定环节</strong>。维系这个环节关键是addEventListener使用的click这样的事件名，而dependency是topClick这样的字符串数组。这里转换的Map结构是topEventMapping。</p>
<p>关于EventPluginRegistry我们到这一环大概可以结束了，我们带着疑问进入下一环节(后面会继续这块)。</p>
<h1 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h1><p>这里的关联是，指的是SyntheticEvent、EventPlugin、EventPluginHub、EventPluginRegistry、DispatchConfig之间的关联、定义、相互作用这些。</p>
<p>这里画个图看看整体关联。</p>
<p><img src="/images/react-event-design.png" alt="image-20190712081047028"></p>
<p>仔细观察这个图里面的脉络，可以看到<strong>DispatchConfig是一个核心环节，它构成了不同模块之间相互调用的基础</strong>。</p>
<p>在EventPluginRegistry.getPluginModuleForEvent函数中有这样的细节:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getPluginModuleForEvent: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    event: ReactSyntheticEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">null</span> | <span class="title">PluginModule</span>&lt;<span class="title">AnyNativeEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dispatchConfig = event.dispatchConfig;</span><br><span class="line">    <span class="keyword">if</span> (dispatchConfig.registrationName) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        EventPluginRegistry.registrationNameModules[</span><br><span class="line">          dispatchConfig.registrationName</span><br><span class="line">        ] || <span class="literal">null</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dispatchConfig.phasedRegistrationNames !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> &#123;phasedRegistrationNames&#125; = dispatchConfig;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> phase <span class="keyword">in</span> phasedRegistrationNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!phasedRegistrationNames.hasOwnProperty(phase)) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> pluginModule =</span><br><span class="line">          EventPluginRegistry.registrationNameModules[</span><br><span class="line">            phasedRegistrationNames[phase]</span><br><span class="line">          ];</span><br><span class="line">        <span class="keyword">if</span> (pluginModule) &#123;</span><br><span class="line">          <span class="keyword">return</span> pluginModule;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>配合以下测试代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&#x27;should be able to get the plugin from synthetic events&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> clickDispatchConfig = &#123;</span><br><span class="line">    registrationName: <span class="string">&#x27;onClick&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> magicDispatchConfig = &#123;</span><br><span class="line">    phasedRegistrationNames: &#123;</span><br><span class="line">      bubbled: <span class="string">&#x27;onMagicBubble&#x27;</span>,</span><br><span class="line">      captured: <span class="string">&#x27;onMagicCapture&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> OnePlugin = createPlugin(&#123;</span><br><span class="line">    eventTypes: &#123;</span><br><span class="line">      click: clickDispatchConfig,</span><br><span class="line">      magic: magicDispatchConfig,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> clickEvent = &#123;<span class="attr">dispatchConfig</span>: clickDispatchConfig&#125;;</span><br><span class="line">  <span class="keyword">var</span> magicEvent = &#123;<span class="attr">dispatchConfig</span>: magicDispatchConfig&#125;;</span><br><span class="line"></span><br><span class="line">  expect(EventPluginRegistry.getPluginModuleForEvent(clickEvent)).toBe(<span class="literal">null</span>);</span><br><span class="line">  expect(EventPluginRegistry.getPluginModuleForEvent(magicEvent)).toBe(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  EventPluginRegistry.injectEventPluginsByName(&#123;<span class="attr">one</span>: OnePlugin&#125;);</span><br><span class="line">  EventPluginRegistry.injectEventPluginOrder([<span class="string">&#x27;one&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">  expect(EventPluginRegistry.getPluginModuleForEvent(clickEvent)).toBe(</span><br><span class="line">    OnePlugin,</span><br><span class="line">  );</span><br><span class="line">  expect(EventPluginRegistry.getPluginModuleForEvent(magicEvent)).toBe(</span><br><span class="line">    OnePlugin,</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>虽然这个函数没有被源码正式引用过(仅在EventPluginRegistry-test.js使用)，但是依然不妨碍我们去理解DispatchConfig。结合这个测试文件里面的内容，也可以对DispatchConfig做一些推论。</p>
<h2 id="核心-DispatchConfig"><a href="#核心-DispatchConfig" class="headerlink" title="核心:DispatchConfig"></a>核心:DispatchConfig</h2><p>然而你要懂DispatchConfig，就必须回过头重新看看它的定义:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type DispatchConfig = &#123;</span><br><span class="line">  dependencies: <span class="built_in">Array</span>&lt;string&gt;,</span><br><span class="line">  phasedRegistrationNames?: &#123;</span><br><span class="line">    bubbled: string,</span><br><span class="line">    captured: string,</span><br><span class="line">  &#125;,</span><br><span class="line">  registrationName?: string,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然而光看定义还是不够，这里还有问题</p>
<ul>
<li>registrationName，phasedRegistrationNames究竟长什么样呢？</li>
<li>根据getPluginModuleForEvent函数有一个很明确的推导，这两个属性基本是二选一的，它们又有什么区别呢？</li>
<li>dependencies又是从哪来，有什么用？</li>
</ul>
<p>首先registrationName是onChange|onClick这种形式的string，我们写jsx时候很常用。接着就是phasedRegistrationNames，它一般是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">phasedRegistrationNames: &#123;</span><br><span class="line">    bubbled: <span class="string">&#x27;onClickBubble&#x27;</span>,</span><br><span class="line">    captured: <span class="string">&#x27;onClickCapture&#x27;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>其次，他们是什么关系呢? 实际上phasedRegistrationNames里面定义的是冒泡和捕获阶段的事件注册名称，dependencies这相对简单，就是依赖事件名的数组，比如这里就是[topClick], 而registrationName这是topClick。</p>
<p>这里再看看其他的一些例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnterLeaveEventPlugin</span></span><br><span class="line"><span class="keyword">var</span> eventTypes = &#123;</span><br><span class="line">  mouseEnter: &#123;</span><br><span class="line">    registrationName: <span class="string">&#x27;onMouseEnter&#x27;</span>,</span><br><span class="line">    dependencies: [<span class="string">&#x27;topMouseOut&#x27;</span>, <span class="string">&#x27;topMouseOver&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  mouseLeave: &#123;</span><br><span class="line">    registrationName: <span class="string">&#x27;onMouseLeave&#x27;</span>,</span><br><span class="line">    dependencies: [<span class="string">&#x27;topMouseOut&#x27;</span>, <span class="string">&#x27;topMouseOver&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ChangeEventPlugin</span></span><br><span class="line"><span class="keyword">var</span> eventTypes = &#123;</span><br><span class="line">  change: &#123;</span><br><span class="line">    phasedRegistrationNames: &#123;</span><br><span class="line">      bubbled: <span class="string">&#x27;onChange&#x27;</span>,</span><br><span class="line">      captured: <span class="string">&#x27;onChangeCapture&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    dependencies: [</span><br><span class="line">      <span class="string">&#x27;topBlur&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;topChange&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;topClick&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;topFocus&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;topInput&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;topKeyDown&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;topKeyUp&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;topSelectionChange&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>dependencies是都有的，通过topEventMapping[dependencie]获取事件名，它们参与了实际的事件绑定环节。</p>
<p>而通过phasedRegistrationNames || registrationName获取了对应EventPlugin。不过这里我们通过测试文件推论这个虽然不可能不准。但是最好还是找出真实的代码所在(虽然近乎前面已经提到了)。</p>
<p>这里核心代码就是publishEventForPlugin+publishRegistrationName。publishRegistrationName这里就不再提，上一小节已经给做了完善等解析。我们这里来讲讲之前被跳过的publishEventForPlugin。</p>
<p>在这个函数里面针对phasedRegistrationNames || registrationName做了分支处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">publishEventForPlugin</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  dispatchConfig: DispatchConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">  pluginModule: PluginModule&lt;AnyNativeEvent&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventName: string,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;</span><br><span class="line">  <span class="keyword">var</span> phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;</span><br><span class="line">  <span class="keyword">if</span> (phasedRegistrationNames) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> phaseName <span class="keyword">in</span> phasedRegistrationNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (phasedRegistrationNames.hasOwnProperty(phaseName)) &#123;</span><br><span class="line">        <span class="keyword">var</span> phasedRegistrationName = phasedRegistrationNames[phaseName];</span><br><span class="line">        publishRegistrationName(</span><br><span class="line">          phasedRegistrationName,</span><br><span class="line">          pluginModule,</span><br><span class="line">          eventName,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dispatchConfig.registrationName) &#123;</span><br><span class="line">    publishRegistrationName(</span><br><span class="line">      dispatchConfig.registrationName,</span><br><span class="line">      pluginModule,</span><br><span class="line">      eventName,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，核心他们最后都是直接执行了publishRegistrationName函数，这个函数之前有说，这也反应了，其实</p>
<p>registrationName &amp; phasedRegistrationName是同一层面的东西。通过这两个变量，可以确定对应EventPlugin。这里测试文件里面有很明显的指向: <code>EventPluginRegistry.registrationNameModules</code> &amp;&amp; <code>EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]]</code></p>
<p>然后的逻辑里面，这里可以确认dependencies是这里的核心。让我们继续刚才的疑问，当dependencies介入到了真实DOM的事件绑定这里，后面发生什么。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">trapBubbledEvent: <span class="function"><span class="keyword">function</span>(<span class="params">topLevelType, handlerBaseName, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!element) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EventListener.listen(</span><br><span class="line">    element,</span><br><span class="line">    handlerBaseName,</span><br><span class="line">    ReactEventListener.dispatchEvent.bind(<span class="literal">null</span>, topLevelType),</span><br><span class="line">  );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>关于<code>EventListener.listen</code>这段，我们无妨把它理解成:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">	handlerBaseName,</span><br><span class="line">    ReactEventListener.dispatchEvent.bind(<span class="literal">null</span>, topLevelType),</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dispatchEvent: <span class="function"><span class="keyword">function</span>(<span class="params">topLevelType, nativeEvent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ReactEventListener._enabled) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> bookKeeping = TopLevelCallbackBookKeeping.getPooled(</span><br><span class="line">    topLevelType,</span><br><span class="line">    nativeEvent,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    TopLevelCallbackBookKeeping.release(bookKeeping);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这里显然可以看看了<code>ReactEventListener.dispatchEvent.bind(null, topLevelType)</code>。这里还是重申一次(Part1里面提到过)，这里只是提前给topLevelType赋了值，后面一旦作为EventHandle引用，必定还会传入一个NativeEvent对象。所以两个参数最后都不会缺。</p>
<p>我们这里关注点放在<code>bookKeeping</code>上。它实质上是一个对象:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    topLevelType,</span><br><span class="line">    nativeEvent,</span><br><span class="line">    ancestors = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping)</code>这个调用我们不管其细节了，如果想要了解这个细节，这里有两个地方可以做参考<a href="http://que01.top/2019/06/15/react-ReactUpdates/">React ReactUpdates</a>、<a href="http://que01.top/2018/04/20/react-render/">react render环节分析</a>。</p>
<p>这里只针对关键说明，它最终进行了<code>handleTopLevelImpl(bookKeeping)</code>调用。这个函数分析可以参见<a href="http://que01.top/2018/06/10/react-event/">React-Event#handleTopLevelImpl</a>。</p>
<p>我们可以从这个分析里面看到。它调用了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleTopLevel: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里对event是一个合成事件对象，因为extractEvents可能返回null，数组里面也可能有null成员</span></span><br><span class="line">  <span class="keyword">var</span> events = EventPluginHub.extractEvents(</span><br><span class="line">    topLevelType,</span><br><span class="line">    targetInst,</span><br><span class="line">    nativeEvent,</span><br><span class="line">    nativeEventTarget,</span><br><span class="line">  );</span><br><span class="line">  runEventQueueInBatch(events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来还是基于之前的分析来分析这里的重点(如果你逻辑接不上，那么一定需要重新读Part1那些…)。</p>
<p>接下来是executeDispatchesAndRelease函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> executeDispatchesAndRelease = <span class="function"><span class="keyword">function</span>(<span class="params">event, simulated</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event) &#123;</span><br><span class="line">    EventPluginUtils.executeDispatchesInOrder(event, simulated);</span><br><span class="line">    <span class="comment">// 持久化处理 如果不做特别处理 会被释放 后面就无法访问原生NativeEvent了。</span></span><br><span class="line">    <span class="keyword">if</span> (!event.isPersistent()) &#123;</span><br><span class="line">      event.constructor.release(event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>executeDispatchesInOrder函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeDispatchesInOrder</span>(<span class="params">event, simulated</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果不知道这两个变量，EventPlugin小节可以重新看看</span></span><br><span class="line">  <span class="keyword">var</span> dispatchListeners = event._dispatchListeners;</span><br><span class="line">  <span class="keyword">var</span> dispatchInstances = event._dispatchInstances;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(dispatchListeners)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; dispatchListeners.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (event.isPropagationStopped()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      executeDispatch(</span><br><span class="line">        event,</span><br><span class="line">        simulated,</span><br><span class="line">        dispatchListeners[i],</span><br><span class="line">        dispatchInstances[i],</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dispatchListeners) &#123;</span><br><span class="line">    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);</span><br><span class="line">  &#125;</span><br><span class="line">  event._dispatchListeners = <span class="literal">null</span>;</span><br><span class="line">  event._dispatchInstances = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>executeDispatch函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeDispatch</span>(<span class="params">event, simulated, listener, inst</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = event.type || <span class="string">&#x27;unknown-event&#x27;</span>;</span><br><span class="line">  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);</span><br><span class="line">  <span class="keyword">if</span> (simulated) &#123;</span><br><span class="line">    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ReactErrorUtils.invokeGuardedCallback(type, listener, event);</span><br><span class="line">  &#125;</span><br><span class="line">  event.currentTarget = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invokeGuardedCallback函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeGuardedCallback</span>&lt;<span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  name: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  func: (a: A) =&gt; <span class="keyword">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  a: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    func(a);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (caughtError === <span class="literal">null</span>) &#123;</span><br><span class="line">      caughtError = x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了最后，整体的逻辑大致如此:</p>
<ul>
<li>executeDispatchesInOrder函数从合成事件上获取_dispatchListeners回调函数</li>
<li>executeDispatch从合成事件上获取type，获取实质事件名称如click、change、error(获取的事件名称在开发环境下会被用到，生产没有，所以不做分析了)</li>
<li>invokeGuardedCallback则是直接调用上面获取的的回调，第一个参数传入合成事件(类似常规的EventHandle)。</li>
</ul>
<h1 id="Part1-amp-amp-Part2的融合"><a href="#Part1-amp-amp-Part2的融合" class="headerlink" title="Part1 &amp;&amp; Part2的融合"></a>Part1 &amp;&amp; Part2的融合</h1><p>Part1着重讲了绑定了触发，Part2则着重讲了体系。</p>
<p>现在这里需要一个最后的融合，将他们融汇贯通(当然这里还是需要先对Render&amp;Update有印象)。</p>
<p>这里来个简单例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> console.log(&#x27;click test button&#x27;)&#125;&gt;test<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="built_in">document</span>, Bar)</span><br></pre></td></tr></table></figure>

<h2 id="绑定路径"><a href="#绑定路径" class="headerlink" title="绑定路径"></a>绑定路径</h2><h3 id="初始化绑定"><a href="#初始化绑定" class="headerlink" title="初始化绑定"></a>初始化绑定</h3><p>这里对绑定从ReactDom.render开始算起。这一块详细细节都在<a href="/2018/04/20/react-render/">React Render</a>里面。</p>
<p>不过这里在mountComponentIntoNode这一小节有一个细节因为和纯粹的Render联系不大被略过了。</p>
<p>那就是这个函数里面的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> markup = ReactReconciler.mountComponent(</span><br><span class="line">  wrapperInstance,</span><br><span class="line">  transaction,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  ReactDOMContainerInfo(wrapperInstance, container),</span><br><span class="line">  context,</span><br><span class="line">  <span class="number">0</span> <span class="comment">/* parentDebugID */</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这个mountComponent会一路从自定义组件到ReactDom组件的同名方法，最终会调动<code>this._updateDOMProperties</code>。这个函数事件绑定的关键。</p>
<h3 id="更新逻辑绑定"><a href="#更新逻辑绑定" class="headerlink" title="更新逻辑绑定"></a>更新逻辑绑定</h3><p>更新逻辑可以看<a href="/2018/04/26/react-lifecycle/">react生命周期分析</a>。</p>
<p>更新会从ReactReconciler.receiveComponent会一路从自定义组件到ReactDom组件的同名方法，然后走receiveComponent-&gt;updateComponent-&gt;_updateDOMProperties的路径回到和初始化render相同的逻辑上来。</p>
<h2 id="绑定细节"><a href="#绑定细节" class="headerlink" title="绑定细节"></a>绑定细节</h2><p>这里需要看看<code>_updateDOMProperties</code>源码。这里遴选了事件部分的核心代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> registrationNameModules = EventPluginRegistry.registrationNameModules;</span><br><span class="line">_updateDOMProperties: <span class="function"><span class="keyword">function</span>(<span class="params">lastProps, nextProps, transaction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> propKey;</span><br><span class="line">  <span class="keyword">var</span> styleName;</span><br><span class="line">  <span class="keyword">var</span> styleUpdates;</span><br><span class="line">  <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (lastProps[propKey]) &#123; <span class="comment">// 更新过程中移除旧的事件回调</span></span><br><span class="line">        deleteListener(<span class="built_in">this</span>, propKey);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">var</span> nextProp = nextProps[propKey];</span><br><span class="line">    <span class="keyword">var</span> lastProp = lastProps != <span class="literal">null</span> ? lastProps[propKey] : <span class="literal">undefined</span>; <span class="comment">// 方便理解有改动</span></span><br><span class="line">    <span class="keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nextProp) &#123;</span><br><span class="line">        <span class="comment">// EventPluginHub.putListener函数的事务包装 所有操作结束后重新绑定事件</span></span><br><span class="line">        enqueuePutListener(<span class="built_in">this</span>, propKey, nextProp, transaction);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastProp) &#123;</span><br><span class="line">        <span class="comment">// 移除对应propKey的旧元素事件 这里应该是为了确保不会被旧元素事件污染</span></span><br><span class="line">        deleteListener(<span class="built_in">this</span>, propKey);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueuePutListener</span>(<span class="params">inst, registrationName, listener, transaction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (transaction <span class="keyword">instanceof</span> ReactServerRenderingTransaction) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> containerInfo = inst._hostContainerInfo;</span><br><span class="line">  <span class="keyword">var</span> isDocumentFragment =</span><br><span class="line">    containerInfo._node &amp;&amp; containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;</span><br><span class="line">  <span class="keyword">var</span> doc = isDocumentFragment</span><br><span class="line">    ? containerInfo._node</span><br><span class="line">    : containerInfo._ownerDocument;</span><br><span class="line">  listenTo(registrationName, doc);</span><br><span class="line">  transaction.getReactMountReady().enqueue(putListener, &#123;</span><br><span class="line">    inst: inst,</span><br><span class="line">    registrationName: registrationName,</span><br><span class="line">    listener: listener,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>★所以来说，这里可以看出<code>EventPluginRegistry.registrationNameModules</code>是onClick这些的一个Map数据，我们此时可以明白，为什么key是onClick、onChange这些。</p>
<p><strong>这里对事件绑定的两个环节要有概念</strong>，它们都在enqueuePutListener函数里面:</p>
<ul>
<li>listenTo调用了addEventListener绑定了事件到了document，这里绑定的回调函数是ReactEventListener.dispatchEvent.bind(null, topLevelType)</li>
<li>putListener把回调保存到了EventPluginHub.listenerBank</li>
</ul>
<p>这个listenTo里面有些细节必须扯出来说说。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">listenTo: <span class="function"><span class="keyword">function</span>(<span class="params">registrationName, contentDocumentHandle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mountAt = contentDocumentHandle;</span><br><span class="line">  <span class="keyword">var</span> isListening = getListeningForDocument(mountAt);</span><br><span class="line">  <span class="keyword">var</span> dependencies =</span><br><span class="line">    EventPluginRegistry.registrationNameDependencies[registrationName];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; dependencies.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> dependency = dependencies[i];</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !(isListening.hasOwnProperty(dependency) &amp;&amp; isListening[dependency])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dependency === <span class="string">&#x27;topWheel&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dependency === <span class="string">&#x27;topScroll&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dependency === <span class="string">&#x27;topFocus&#x27;</span> || dependency === <span class="string">&#x27;topBlur&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (topEventMapping.hasOwnProperty(dependency)) &#123;</span><br><span class="line">        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(</span><br><span class="line">          dependency, <span class="comment">// 可能会取值onClick, onChange</span></span><br><span class="line">          topEventMapping[dependency], <span class="comment">// 可能会取值click, change</span></span><br><span class="line">          mountAt, <span class="comment">// 大概率取值document</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      isListening[dependency] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>trapBubbledEvent实际上我们之前说到过。这里核心是会调用到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventLinstener(</span><br><span class="line">  topEventMapping[dependency],</span><br><span class="line">  ReactEventListener.dispatchEvent.bind(<span class="literal">null</span>, topLevelType), <span class="comment">// 这里是事件分发的核心</span></span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="事件触发、分发"><a href="#事件触发、分发" class="headerlink" title="事件触发、分发"></a>事件触发、分发</h2><p>事件的触发、分发实际上在<a href="/2018/06/10/react-event/#ReactEventListener">Part1</a>里面已经有了很详细的解析。</p>
<p>这部分分析里面提到了handleTopLevelImpl，它在里面进行模拟冒泡。然后针对每个冒泡环节执行<code>handleTopLevel</code>函数。这个函数通过EventPluginHub.extractEvents获取events数组，然后对数组执行批量执行runEventQueueInBatch。</p>
<p>这里需要着重提events数组里面的event合成事件。遍历执行合成事件的本质是遍历<code>event._dispatchListeners</code>进行执行(参考:<a href="/2018/06/10/react-event/#extractEvents">React Event#extractEvents</a>)。</p>
<p>这里容易疏漏的(可能就我自己容易疏漏😂)是: EventPluginHub.extractEvents获取events数组过程中，会对所有的冒泡元素进行双向的冒泡、捕获模拟(实现的只有冒泡部分)，然后将同一种合成事件涉及的所有回调都放在对应合成事件的<code>event._dispatchListeners</code>属性上，最后顺序批量执行。</p>
<h2 id="事件绑定、分发-amp-amp-事件体系的融合"><a href="#事件绑定、分发-amp-amp-事件体系的融合" class="headerlink" title="事件绑定、分发 &amp;&amp; 事件体系的融合"></a>事件绑定、分发 &amp;&amp; 事件体系的融合</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>首先是事件绑定的前置条件<code>registrationNameModules</code>。这个Map数据参见之前提到的publishRegistrationName。</p>
<p>在这之前，EventPluginRegistry要先注入eventPluginOrder，并注册好EventPlugins。这之后执行<code>recomputePluginOrdering</code>。这个函数会对plugins数组进行排序。</p>
<p>进一步会将<code>EventPluginRegistry.registrationNameModules &amp;&amp; EventPluginRegistry.registrationNameDependencies</code>初始化完毕。</p>
<p>这是两个Map结构的数据，里面键名都是onClick|onChange这些。但是registrationNameModules注册的是EventPlugin，而registrationNameDependencies注册的是EventPlugin对应的dependencies数组。</p>
<p>关于registrationNameDependencies，通俗点讲，针对特定EventPlugin，缓存eventTypes里面的dependencies。以实现指定Plugin，给出registrationName值或者phasedRegistrationNames.bubbled|phasedRegistrationNames.captured值时候，能直接快递查出对应eventName(pluginModule.eventTypes键名)依赖的dependencies数组。</p>
<p><strong>考虑到每个合成事件里面的核心DispatchConfig数据结构，大家可以猜测到它意义是什么——给出一个合成事件，就能查出对应的依赖dependencies数组。</strong></p>
<p><strong>根据这个结论进一步推算，其实registrationNameModules也是走的这个思路。给出一个合成事件，逆向查出其对应EventPlugin。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>前置处理，定义好SyntheticEvent核心, 然后在SyntheticEvent上构建EventPlugin。</p>
<p>所有的EventPlugin要注册到EventPluginRegistry。</p>
<p>这个注册目前来说，满足了两个快速:</p>
<ol>
<li>要求能通过合成事件或特定属性值能快速逆向查询对应EventPlugin。</li>
<li>给出合成事件或特定属性值要能快速查出对应dependencies数组。</li>
<li>根据给定的顺序将EventPlugin放到对应plugins数组里面去。</li>
</ol>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>然后是事件的分发。这里提到过分发的核心的起始调用<code>ReactEventListener.dispatchEvent.bind(null, topLevelType)</code>。</p>
<p>而这里有个topLevelType变量，哪儿来呢？从之前的dependencies数组里面来。我们从这个调用栈分析一下参数的来源(必须自行看下源码才好理解)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactBrowserEventEmitter.listenTo</span><br><span class="line">-&gt;ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency)</span><br><span class="line">--&gt;ReactEventListener.dispatchEvent.bind(<span class="literal">null</span>, topLevelType)</span><br></pre></td></tr></table></figure>

<p>认真看看，就会发现EventPluginRegistry.registrationNameDependencies[registrationName]被遍历然后作为topLevelType被传入了dispatchEvent。</p>
<p>而这个listenTo的registrationName来自于ReactDomComponent的enqueuePutListener函数。那enqueuePutListener呢？来自_updateDOMProperties执行过程对props值的遍历。</p>
<p>如此 上面这一块就完美闭环了。</p>
<p>不过这之前再细细品味一下这其中体系上的设计。</p>
<p>首先是_updateDOMProperties遍历时要求<code>propsKey in registrationNameModules</code>。其次是后面propsKey后面作为registrationName传递后面，然后又作为topLevelType给了ReactEventListener.dispatchEvent。</p>
<p>这个逻辑开始从dispatchEvent往下走。就会执行到(ReactEventListener#line165):</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleTopLevelImpl(&#123;</span><br><span class="line">    topLevelType, nativeEvent</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此时可以进行冒泡模拟了。得模拟冒泡行为把所有需要执行的回调从listenerBank里面捞出来，以备后面顺序批量执行完成最后环节。</p>
<p>回想一下回调在这个地方的保存方式: <code>listenerBank[registrationName][InstanceKey]</code>。此时呢，我们registrationName有了，InstanceKey通过nativeEvent也能拿到。思路是：nativeEvent里面可以获取target,通过<code>ReactDOMComponentTree.getClosestInstanceFromNode</code>可以拿到实例，拿到了实例，也就获取到了InstanceKey。这样我们就可以针对每个冒泡环节拿到对应listener了。</p>
<p>这样整体的逻辑就算通了，React在这里的操作思路是将listener拿到之后，放到对应合成事件的某个属性中，然后批量执行。</p>
<p>具体点说，EventPluginHub,遍历<code>EventPluginRegistry.plugins</code>中的EventPlugins，执行每个EventPlugin上的extractEvents，将返回的合成事件全部返回合并到一个扁平数组中。</p>
<p>这个过程extractEvents返回event过程中，会对<code>event._dispatchListeners &amp; event._dispatchInstances</code>进行赋值，实际就是对上面冒泡模拟提到的listener&amp;实例进行了缓存。</p>
<p>当所有的events数组就位之后(此时listener和实例也就是函数上下文都就位了)，然后进入批量执行阶段。走<code>EventPluginHub.processEventQueue</code>。具体实现前面有提到，这里不再赘述。</p>
<h1 id="React事件体系设计"><a href="#React事件体系设计" class="headerlink" title="React事件体系设计"></a>React事件体系设计</h1><p>当我们把这些整体都串联完毕，整个React设计体系也就不再神秘。</p>
<p><strong>合成事件部分:</strong></p>
<p>合成事件部分实质上的设计其实很少。在合成事件这里只是设计了统一的接口然后对她进行实现。不通的合成事件的区别大部分都只是对nativeEvent上变量的择选和computed。</p>
<p><strong>合成事件Plugins:</strong></p>
<p>个人认为，这里其实算是整个事件体系的核心中核心。</p>
<p>前面说过，合成事件实质上都紧紧是统一接口的实现，它们本身没有在构造器实现里面核心的<code>dispatchConfig &amp; _targetInst &amp; nativeEvent </code>变量。这些东西都是在Plugin里面进行的定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jsx</span></span><br><span class="line">&lt;div onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1234</span>)&#125; /&gt;</span><br><span class="line"><span class="comment">// onClick(内部称为:registrationName)对应的DispatchConfig;</span></span><br><span class="line">&#123;</span><br><span class="line">    phasedRegistrationNames: &#123;</span><br><span class="line">      bubbled: <span class="string">&#x27;onClick&#x27;</span>,</span><br><span class="line">      captured: <span class="string">&#x27;onClickCapture&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    dependencies: [<span class="string">&#x27;topClick&#x27;</span>], <span class="comment">// &#x27;topClick&#x27;内部称为topLevelType</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// step 1:</span></span><br><span class="line"><span class="comment">// &#x27;onClick&#x27; 直接直接props获得，可以用来直接</span></span><br><span class="line"><span class="comment">// 从registrationNameDependencies获取dependencies数组</span></span><br><span class="line"><span class="comment">// 也就是[&#x27;topClick&#x27;, &#x27;topChange&#x27;]之类，内部的Map&lt;DispatchConfig&gt;以它做键名</span></span><br><span class="line"><span class="comment">// 换句话说知道了&#x27;topClick&#x27;才能生成对应的合成事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2:</span></span><br><span class="line"><span class="comment">// &#x27;topClick&#x27;作为快速从Plugin获取这个DispatchConfig的键名使用</span></span><br><span class="line"><span class="comment">// &#x27;topClick&#x27;作为快速从Plugin获取需要调用的合成事件类型</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// step3:</span></span><br><span class="line"><span class="comment">// 综合step1 + step2,可以知道Plugin可以根据onClick获取特定的合成事件类型(瓶子)</span></span><br><span class="line"><span class="comment">// 也能获取DispatchConfig(酒)</span></span><br></pre></td></tr></table></figure>

<p>通过Plugin的extractEvents方法，会对模拟冒泡在虚拟DOM进行模拟，把所有回调放到合成事件私有变量中去。</p>
<p><strong>PS: 这种做法会导致如果回调过多，耗时过长，浏览器会卡在微任务无法进行浏览器刷新，也就是常见卡顿说法。</strong></p>
<p><strong>EventPluginRegistry:</strong></p>
<p>遍历所有被inject的Plugin的eventType。除了按顺序保存plugins。还有做两个Map数据结构。</p>
<ul>
<li>Plugin相关的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [key: registrationName]: EventPlugin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道registrationName可以获得对应EventPlugin。</p>
<ul>
<li>dependencies相关的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [key: registrationName: <span class="built_in">Array</span>&lt;topLevelType&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意phasedRegistrationNames里面的两个值，其实和registrationName一致。</p>
<p>接下来，有registrationName和phasedRegistrationNames其中一个就能获取topLevelType。有了topLevelType，我们就可以获取DispatchConfig，可以获取合成事件类型。</p>
<p>而有了这两样，就可以实例化好一个详细的合成事件。</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React核心:Reconciler调度模块</title>
    <url>/2019/07/04/react-Reconciler/</url>
    <content><![CDATA[<h1 id="Reconciler范畴"><a href="#Reconciler范畴" class="headerlink" title="Reconciler范畴"></a>Reconciler范畴</h1><p>关注点放到<code>src/renders/shared/stack/reconciler</code>上来。这里Reconciler模块的实现代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">renderers/shared/stack/reconciler</span><br><span class="line">├── ReactChildReconciler.js</span><br><span class="line">├── ReactComponentEnvironment.js</span><br><span class="line">├── ReactCompositeComponent.js</span><br><span class="line">├── ReactDefaultBatchingStrategy.js</span><br><span class="line">├── ReactEmptyComponent.js</span><br><span class="line">├── ReactEventEmitterMixin.js</span><br><span class="line">├── ReactHostComponent.js</span><br><span class="line">├── ReactInstanceType.js</span><br><span class="line">├── ReactMultiChild.js</span><br><span class="line">├── ReactMultiChildUpdateTypes.js</span><br><span class="line">├── ReactNodeTypes.js</span><br><span class="line">├── ReactOwner.js</span><br><span class="line">├── ReactReconciler.js</span><br><span class="line">├── ReactRef.js</span><br><span class="line">├── ReactSimpleEmptyComponent.js</span><br><span class="line">├── ReactUpdateQueue.js</span><br><span class="line">├── ReactUpdates.js</span><br><span class="line">├── getHostComponentFromComposite.js</span><br><span class="line">└── instantiateReactComponent.js</span><br></pre></td></tr></table></figure>

<h2 id="getHostComponentFromComposite"><a href="#getHostComponentFromComposite" class="headerlink" title="getHostComponentFromComposite"></a>getHostComponentFromComposite</h2><p>用于从自定义组件上获取实例上的<code>_renderedComponent</code>,如果自定义组件不断相互嵌套使用，他还会不断往下深挖，直到返回的是<code>ReactDomComponent</code>节点为止，如果为空返回null。</p>
<p>这个函数可以反馈组件架构上的涉及：</p>
<ul>
<li><p><code>_renderedComponent</code>保存children节点</p>
</li>
<li><p><code>_renderedNodeType</code>保存节点类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enum ReactNodeTypes &#123;</span><br><span class="line">    HOST: 0,</span><br><span class="line">    COMPOSITE: 1,</span><br><span class="line">    EMPTY: 2,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="instantiateReactComponent"><a href="#instantiateReactComponent" class="headerlink" title="instantiateReactComponent"></a>instantiateReactComponent</h2><p>根据给出的ReactNode返回一个组件实例。</p>
<p>小小研究一下这个函数，其实可以窥见<a href="/2019/04/03/react-VirtualDom/">ReactNode</a>和React组件实例之间的关系。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type ReactDOMElement = &#123; </span><br><span class="line">  type : string, </span><br><span class="line">  props : &#123; </span><br><span class="line">    children : ReactNodeList, </span><br><span class="line">    className : string, </span><br><span class="line">    etc.</span><br><span class="line">  &#125;, </span><br><span class="line">  key : string | boolean | number | <span class="literal">null</span>, </span><br><span class="line">  ref : string | <span class="literal">null</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type ReactComponentElement&lt;TProps&gt; = &#123; </span><br><span class="line">  type : ReactClass&lt;TProps&gt;, </span><br><span class="line">  props : TProps, </span><br><span class="line">  key : string | boolean | number | <span class="literal">null</span>, </span><br><span class="line">  ref : string | <span class="literal">null</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于<code>ReactDOMElement</code>来说，type是字符串<br>对于<code>ReactComponentElement</code>来说， type是一个函数</p>
<p>这里这个函数根据type属性做了4个分支</p>
<ul>
<li>如果是string，使用ReactHostComponent.createInternalComponent(element)返回ReactDOMElement</li>
<li>如果是function且已知(定义好了mountComponent|receiveComponent这些)，那么调用type(自定义组件的render函数)</li>
<li>如果是function且未知，使用<code>new ReactCompositeComponentWrapper(element)</code>返回一个ReactCompositeComponent包装结构。</li>
<li>如果这个节点没有type属性直接是一个string|number，那么返回一个文本节点</li>
</ul>
<h2 id="ReactChildReconciler"><a href="#ReactChildReconciler" class="headerlink" title="ReactChildReconciler"></a>ReactChildReconciler</h2><p>这个函数是<a href="/2019/06/25/react-diff/">Diff算法</a>的一部分。主要是Element Diff部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type ReactChildReconciler &#123;</span><br><span class="line">    instantiateChildren: <span class="function">() =&gt;</span> &#123;&#125; <span class="comment">// 返回新的Children实例对象</span></span><br><span class="line">    updateChildren: <span class="function">() =&gt;</span> &#123;&#125;	  <span class="comment">// 进行内部Diff更新 三种算法都会综合使用</span></span><br><span class="line">    unmountChildren: <span class="function">() =&gt;</span> &#123;&#125;     <span class="comment">// 调用internalInstance.unmountComponent，移除ref引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里updateChildren是diff算法的核心实现。</p>
<h2 id="ReactComponentEnvironment"><a href="#ReactComponentEnvironment" class="headerlink" title="ReactComponentEnvironment"></a>ReactComponentEnvironment</h2><p>代码相关引用路径如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactComponentEnvironment = &#123;</span><br><span class="line">  replaceNodeWithMarkup: (<span class="literal">null</span>: ?ReplaceNodeWithMarkup),</span><br><span class="line">  processChildrenUpdates: (<span class="literal">null</span>: ?ReplaceNodeWithMarkup),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReactDefaultInjection.js</span></span><br><span class="line">ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);</span><br><span class="line"><span class="comment">// ReactComponentBrowserEnvironment.js</span></span><br><span class="line"><span class="keyword">var</span> DOMChildrenOperations = <span class="built_in">require</span>(<span class="string">&#x27;DOMChildrenOperations&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ReactDOMIDOperations = <span class="built_in">require</span>(<span class="string">&#x27;ReactDOMIDOperations&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ReactComponentBrowserEnvironment = &#123;</span><br><span class="line">  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,</span><br><span class="line">  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = ReactComponentBrowserEnvironment;</span><br></pre></td></tr></table></figure>

<p>这里为Reconciler模块抽象出了需要了解浏览器上下文的功能。这些都是一些实质性对浏览器DOM进行操作的函数。</p>
<p>这里先说<code>processChildrenUpdates</code>,它主要引用了<code>DOMChildrenOperations.processUpdates</code>，关于这个函数，参考<a href="/2019/06/25/react-diff/#%E6%9B%B4%E6%96%B0%E5%88%B0DOM">Diff算法-更新到DOM</a>。因为这里是Diff操作后，将虚拟dom变化反馈到实质Dom的流程，所以必须按照浏览器的DOM API来进行dom更新，这里必须知道浏览器上下文。</p>
<p>其次是<code>replaceNodeWithMarkup</code>,它指向了<code>DOMChildrenOperations.DOMChildrenOperations</code>。这个函数用途也是在Diff环节中的，我们知道，如果一个组件没有变化只是props更新，那么它会走更新逻辑，但是变化了呢？它会直接删除旧的+替换为成新生成的，这就是这个API的功能。这里替换都是用的<a href="http://www.w3school.com.cn/xmldom/met_node_replacechild.asp">replaceChild</a>，暂时也没看到和浏览器兼容相关代码，此处兼容相关的是<code>insertTreeChildren</code>。</p>
<h2 id="ReactCompositeComponent"><a href="#ReactCompositeComponent" class="headerlink" title="ReactCompositeComponent"></a>ReactCompositeComponent</h2><p>这个是自定义组件的相关代码，这里不再说细节。</p>
<p>主要是提一下，自定义组件也是Reconciler模块的一部分。</p>
<h2 id="ReactDefaultBatchingStrategy"><a href="#ReactDefaultBatchingStrategy" class="headerlink" title="ReactDefaultBatchingStrategy"></a>ReactDefaultBatchingStrategy</h2><p>这个模块是批量更新的处理。主要涉及到3个部分: 事务、更新。</p>
<p>两个事务在于:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var RESET_BATCHED_UPDATES &#x3D; &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: function() &#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates &#x3D; false;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var FLUSH_BATCHED_UPDATES &#x3D; &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>前者是模块事务操作，后者是更新事务。</strong>其中模块事务完毕后要重设<code>isBatchingUpdates=false;</code></p>
<p>这个<code>isBatchingUpdates</code>变量是事务过程中需要使用的变量：当没有事务执行中的时候直接执行，否则以事务方式执行这个函数(先执行initializeAll, 函数完毕再执行closeAll)。</p>
<p>核心代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  isBatchingUpdates: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Call the provided function in a context within which calls to `setState`</span></span><br><span class="line"><span class="comment">   * and friends are batched such that components aren&#x27;t updated unnecessarily.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  batchedUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// The code is written this way to avoid extra allocations</span></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新事务则关注<code>ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</code>。这里值得扯一扯的是<code>ReactUpdates.batchedUpdates</code>实质上指向了这个<code>ReactDefaultBatchingStrategy.batchedUpdates</code>,最后又根据事务反向指向回去了<code>flushBatchedUpdates</code>。</p>
<p>具体细节在<a href="/2019/06/15/react-ReactUpdates/#batchedUpdates">《React ReactUpdates》</a>里面有抽丝剥茧式得剖析，这里不再赘述。</p>
<p>只是做宏观讲述，这个batchedUpdates最后是对所有脏组件(dirtyComponents),调用其自身<code>receiveComponent</code>函数走Diff，然后反馈到浏览器UI。</p>
<p><font color="red">★</font>这里倒是可以提一提dirtyComponents的维护。直接调用是<code>ReactUpdates.enqueueUpdate</code>,这里有简单的<a href="/2019/06/15/react-ReactUpdates/#enqueueUpdate">说明</a>。</p>
<p>它这里有一个主要维护路径:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props更新(假如有)</span><br><span class="line">-&gt;<span class="built_in">this</span>.setState</span><br><span class="line">--&gt;<span class="built_in">this</span>.updater.enqueueSetState || <span class="built_in">this</span>.updater.enqueueCallback </span><br><span class="line">---&gt;ReactUpdates.enqueueUpdate</span><br></pre></td></tr></table></figure>

<p>这里就是脏组件的维护路径了。关于this.updater的赋值，在ReactCompositeComponent.js,line 255, mountComponent函数中，而不是setState函数里面默认的那一个。</p>
<h2 id="ReactEmptyComponent"><a href="#ReactEmptyComponent" class="headerlink" title="ReactEmptyComponent"></a>ReactEmptyComponent</h2><p>这个地方无甚可说，就是返回一个<code>ReactDOMEmptyComponent</code></p>
<h2 id="ReactEventEmitterMixin"><a href="#ReactEventEmitterMixin" class="headerlink" title="ReactEventEmitterMixin"></a>ReactEventEmitterMixin</h2><p>这个函数作用是从委托到Document上的回调集合里面找到对应当前组件的事件，然后对事件进行分发。</p>
<p>关于这个部分，可以参考<a href="/2018/06/10/react-event/#handleTopLevelImpl">React Event</a>。这里直接链入的是核心调用分析环节，如果想有一个全面了解，还是必须整体通读这一篇。</p>
<h2 id="ReactHostComponent"><a href="#ReactHostComponent" class="headerlink" title="ReactHostComponent"></a>ReactHostComponent</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactHostComponent = &#123;</span><br><span class="line">  createInternalComponent: createInternalComponent,</span><br><span class="line">  createInstanceForText: createInstanceForText,</span><br><span class="line">  isTextComponent: isTextComponent,</span><br><span class="line">  injection: ReactHostComponentInjection,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主要就是两个函数:</p>
<p>createInternalComponent =&gt; new ReactDOMComponent(element)</p>
<p>createInstanceForText =&gt; new ReactDOMTextComponent(text)</p>
<p>这里需要明白，ReactNode和组件实例之间的区别。</p>
<h2 id="ReactMultiChild"><a href="#ReactMultiChild" class="headerlink" title="ReactMultiChild"></a>ReactMultiChild</h2><p>ReactMultiChild是Diff算法环节中重要一环。</p>
<p>这里因为Diff算法已经先总结好了，直接去<a href="/2019/06/25/react-diff/">React Diff算法</a>看即可</p>
<h2 id="ReactOwner"><a href="#ReactOwner" class="headerlink" title="ReactOwner"></a>ReactOwner</h2><p>这个模块和ReactCompositeComponent是有很大关联性的。</p>
<p>这里具体参看之前的文章：<a href="/2019/06/28/react-ReactCurrentOwner/">ReactCurrentOwner:ReacCompositeComponent &amp; ReactDomComponent之间的胶水</a>。</p>
<p>至于除此之外的两个调用:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">owner.attachRef(ref, component);</span><br><span class="line">owner.detachRef(ref);</span><br></pre></td></tr></table></figure>

<p>都是对ReactInstance的属性调用。这两个函数是对ref这个props的处理。</p>
<p>这里涉及的是ReactRef模块</p>
<h2 id="ReactRef"><a href="#ReactRef" class="headerlink" title="ReactRef"></a>ReactRef</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">attachRef</span>(<span class="params">ref, component, owner</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    ref(component.getPublicInstance());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Legacy ref</span></span><br><span class="line">    ReactOwner.addComponentAsRefTo(component, ref, owner);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detachRef</span>(<span class="params">ref, component, owner</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    ref(<span class="literal">null</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Legacy ref</span></span><br><span class="line">    ReactOwner.removeComponentAsRefFrom(component, ref, owner);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个ref经常用到，函数也简单到可以靠猜，所以不再赘述了。</p>
<p>主要提一下其调用。它们在<code>ReactReconciler.receiveComponent</code>和<code>ReactReconciler.unmountComponent</code>分别有相关调用。</p>
<h2 id="ReactSimpleEmptyComponent"><a href="#ReactSimpleEmptyComponent" class="headerlink" title="ReactSimpleEmptyComponent"></a>ReactSimpleEmptyComponent</h2><p>这个函数是给ReactNative用的，这里我们就不管了。</p>
<h2 id="ReactUpdates"><a href="#ReactUpdates" class="headerlink" title="ReactUpdates"></a>ReactUpdates</h2><p>关于这个ReactUpdates,可以直接看之前的一篇, <a href="/2019/06/15/react-ReactUpdates/">React ReactUpdates</a>, 这里有详细的说明。</p>
<h2 id="ReactUpdateQueue"><a href="#ReactUpdateQueue" class="headerlink" title="ReactUpdateQueue"></a>ReactUpdateQueue</h2><p>ReactUpdates是一个队列的执行，但是既然是队列，那么他还是需要一个角色来维护这个队列，以便后面任务有序加入更新队列里。这里ReactUpdateQueue起到的作用就是维护这个队列。</p>
<p>这里还是有些细节可以看，不过这里暂时略过，后面加以补充。</p>
<h1 id="体系-amp-作用"><a href="#体系-amp-作用" class="headerlink" title="体系&amp;作用"></a>体系&amp;作用</h1><p>上面主要提到了构成Reconciler体系的各个小模块。</p>
<p>但是这些在整个React体系里面是怎么发挥其核心作用的呢？这里需要一张图，来简要诠释，在整个React体系中，它是怎么居中调配React各个功能模块，使它井然有序工作的。</p>
<p><img src="/images/React-Reconciler.png" alt="React-Reconciler"></p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React ReactCurrentOwner</title>
    <url>/2019/06/28/react-ReactCurrentOwner/</url>
    <content><![CDATA[<h1 id="最前面"><a href="#最前面" class="headerlink" title="最前面"></a>最前面</h1><p>这里先说明白，这个ReactCurrentOwner实际上是在虚拟DOM中识别自定义组件的关键。</p>
<p>当我们执行了自定义组件的render，返回的虚拟DOM树里面的节点，不算文本节点、注释节点这类，它就是完全有ReactDomComponent节点组成的，这个ReactCurrentOwner.owner变量，保存了一个瞬时变量，用于存到自定义组件生成的ReactDomComponent节点的<code>_owner</code>变量上。</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>ReactCurrentOwner这个主要还是和自定义组件有关系。</p>
<p>使用<code>grep -rn &#39;ReactCurrentOwner.current =&#39; ./src</code>全局查了以下。赋值操作主要是在</p>
<p><code>ReactMultiChild.js</code>和<code>ReactCompositeComponent.js</code>文件中。</p>
<p>它有三种赋值情景:</p>
<ul>
<li><code>ReactCurrentOwner.current = this._currentElement._owner</code></li>
<li><code>ReactCurrentOwner.current = this</code></li>
<li><code>ReactCurrentOwner.current = null</code></li>
</ul>
<h1 id="情景1"><a href="#情景1" class="headerlink" title="情景1"></a>情景1</h1><p>其中，情景一<code>this._currentElement._owner</code>仅在开发环节会执行</p>
<h1 id="情景2"><a href="#情景2" class="headerlink" title="情景2"></a>情景2</h1><p>大部分情况下，一课虚拟DOM树大致由一个TopLevelWrapper组件作为根元素，然后子节点里面ReactCompositeComponent和ReactDomComponent互相交织嵌套，最后以ReactDomComponent为最末节点的结构组成的(这里假装不知道文本在React里面也算节点。。。)。</p>
<p>我们写的业务代码、包含各种生命周期的组件，基本都是ReactCompositeComponent，</p>
<p>ReactCurrentOwner.current也都是指向了这个类型的组件。</p>
<p>在ReactCompositeComponent组件里面存在生命周期，state，props，context这些东西，也存在更新时候的Diff算法优化，如果一个ReactDomComponent组件确定要更新，这里是替换式无脑更新的，不存在Diff算法什么的。</p>
<p>这种情况下，ReactCurrentOwner.current 是指当前正处于构建过程中的组件。</p>
<p>这个变量实际上相当于是一个存在于React作用域全局的一个缓存变量。</p>
<p>ReactCompositeComponent构建时候，ReactCompositeComponent.js里面有一段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_renderValidatedComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> renderedElement;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ || <span class="built_in">this</span>._compositeType !== CompositeTypes.StatelessFunctional) &#123;</span><br><span class="line">    ReactCurrentOwner.current = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      renderedElement = <span class="built_in">this</span>._renderValidatedComponentWithoutOwnerOrContext();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    renderedElement = <span class="built_in">this</span>._renderValidatedComponentWithoutOwnerOrContext();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> renderedElement;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>他会在render&amp;&amp;update时候执行。</p>
<p>然后就是如果从ReactCompositeComponent到ReactDomComponent这个过程中(实质上这两个类型的组件在虚拟DOM上也就是一个变量的区别)的时候，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactElement = <span class="function"><span class="keyword">function</span>(<span class="params">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> element = &#123;</span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element._store.validated = <span class="literal">false</span>;</span><br><span class="line">      element._self = self;</span><br><span class="line">      element._source = source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.freeze) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.freeze(element.props);</span><br><span class="line">      <span class="built_in">Object</span>.freeze(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个current会被缓存到Element对象中。其他时候就是对这个current做null赋值处理了。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>接下来就可以思考一下它在React体系中的作用了。`</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_renderValidatedComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> renderedElement;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ || <span class="built_in">this</span>._compositeType !== CompositeTypes.StatelessFunctional) &#123;</span><br><span class="line">    ReactCurrentOwner.current = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      renderedElement = <span class="built_in">this</span>._renderValidatedComponentWithoutOwnerOrContext();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    renderedElement = <span class="built_in">this</span>._renderValidatedComponentWithoutOwnerOrContext();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> renderedElement;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><code>_renderValidatedComponent</code>是一个很重要的函数。但是他实质上却超级简单。。。。</p>
<p>他就做了两件事：</p>
<ul>
<li>_renderValidatedComponentWithoutOwnerOrContext——说白了就是组件的render函数调用</li>
<li>设置ReactCurrentOwner.current为当前这个组件实例</li>
</ul>
<p>另外，从ReactCompositeComponent到ReactDomComponent这个过程中的时候，参考一下ReactElement函数的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ReactElement &#x3D; function(type, key, ref, self, source, owner, props) &#123;</span><br><span class="line">  var element &#x3D; &#123;</span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    &#x2F;&#x2F; 略</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      element._store.validated &#x3D; false;</span><br><span class="line">      element._self &#x3D; self;</span><br><span class="line">      element._source &#x3D; source;</span><br><span class="line">    &#125;</span><br><span class="line">    if (Object.freeze) &#123;</span><br><span class="line">      Object.freeze(element.props);</span><br><span class="line">      Object.freeze(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个current会被缓存到Element对象中。其他时候就是对这个current做null赋值处理了。</p>
<p>这里归总一下:</p>
<h2 id="初始render"><a href="#初始render" class="headerlink" title="初始render"></a>初始render</h2><p>初始化render时候会执行batchedUpdates，里面下级调用包括<code>ReatReconciler.mountComponent</code>，这里看看ReactCompositeComponent.mountComponent的调用。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">ReactCompositeComponent.mountComponent</span><br><span class="line">-&gt;ReactCompositeComponent.performInitialMount</span><br><span class="line">--&gt;ReactCompositeComponent._renderValidatedComponent</span><br></pre></td></tr></table></figure>

<p>这里自定义组件render执行时候会不断触发其下级自定义组件的render，他们在结构上是嵌套的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Component.render(SubComponent1.render(SubComponent2.render()))</span><br></pre></td></tr></table></figure>

<p>关于这个逻辑，可以参考<a href="/2018/04/26/react-lifecycle/#jsx%E5%88%B0js%E7%9A%84%E8%BD%AC%E6%8D%A2">react生命周期-jsx到js的转换</a>。</p>
<p>他们的render是这样一个逻辑，我们想要执行Component.render实际上会先执行SubComponent1.render，进而要先执行SubComponent2.render。</p>
<p>通过这样的调用，我们最先执行的SubComponent2.render会先将SubComponent2赋值到ReactCurrentOwner.current，然后挂载到其下一级(孙节点和以下都不加)ReactDomComponent实例上。</p>
<p>以上逻辑到了SubComponent1和Component都同样进行类推。这样，所有自定义组件render完毕之后，就是一个干净的(就是一个owner变量的区别)由ReactDomComponent组成的虚拟DOM树(文本节点、注释节点等先忽视)。</p>
<p>而由自定义节点直接生成的ReactDomComponent节点，会有一个非null的<code>_owner</code>属性，指向自定义组件实例。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>看更新还是很有必要看看<a href="/2019/06/25/react-diff/">React Diff算法</a>。</p>
<p>看到Component Diff这一节，就基本上可以大致有数了。这里<code>_updateRenderedComponent</code>函数会组件更新时候必然会调用到<code>ReactCompositeComponent._renderValidatedComponent</code>。</p>
<p>其他逻辑可以完全参考初始render。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>ReactCurrentOwner.current</code>为什么重要?</p>
<p>以为它是自定义节点的指针。所有的ReactCompositeComponent最终render之后都变成了干干净净的ReactDomComponent节点组成的DOM树，但是如何分辨哪些是ReactCompositeComponent生成的呢？</p>
<p>这就依赖这些ReactDomComponent节点上的<code>owner</code>变量。</p>
<p>而<code>ReactCurrentOwner.current</code>正是维护这个在构建虚拟DOM过程中，随时会变动的变量的临时保存位置所在。</p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React Diff算法</title>
    <url>/2019/06/25/react-diff/</url>
    <content><![CDATA[<h1 id="React-Diff算法"><a href="#React-Diff算法" class="headerlink" title="React Diff算法"></a>React Diff算法</h1><h2 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h2><h3 id="传统树对比O-N-3-算法"><a href="#传统树对比O-N-3-算法" class="headerlink" title="传统树对比O(N^3)算法"></a>传统树对比O(N^3)算法</h3><p>计算一棵树形结构转换成另一棵树形结构的最少操作。传统diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)。</p>
<p>这里仅仅简单列一下其原理上的复杂度。其基本原理是先寻找差异，然后计算计算最小转换方式。其中寻找差异的做法是遍历旧的树上的每一个节点，和新的树节点上每个节点遍历对比，这是为了寻找差异节点(判断是不是移动到那个位置去了)，仔细思考一下就可以知道这个过程的算法复杂度已经达到O(N^2), 找到这个差异节点之后还要计算最小的转换方式，最终复杂度为O(N^3)——这个从O(N^2)到O(N^3)的过程是一个复杂且值得研究的问题，这里就不做钻研了。</p>
<h3 id="React-Diff的O-N-算法"><a href="#React-Diff的O-N-算法" class="headerlink" title="React Diff的O(N)算法"></a>React Diff的O(N)算法</h3><p>传统的树对比算法实际上就问题本质的研究来说已经是最理想了，但是这里需要更加高效的算法。算法本身没问题，所以需要对问题本身做出限制以便生成更高效的方案，幸运的是React虚拟DOM方案可以根据方案需要本身做出预设以完成这个设想，并且这些设想经过无数WEB开发的验证证明是合理的。  </p>
<p>针对算法复杂度太高的问题，FB的开发者做出了三个预设：</p>
<ul>
<li>跨层级操作少到忽略不计——所以对比算法只需要对比树当前所在的层级</li>
<li>不同类型(Component)的树有不同的结构，这是在虚拟DOM层次上的设计</li>
<li>同层级的节点通过设置唯一key识别——不需要遍历当前层所有的节点</li>
</ul>
<p>基于这三个假设，diff算法分为Tree Diff、Component Diff、Element Diff三个层面。</p>
<p>这里且不通过代码而是从理论上进行分析它是如何实现让这个算法达到O(N)的——实际上上面已经把所有已经指出了，这里再分析一次。</p>
<p>首先预设1和预设2完美将整个对比压平成了N,他们一个使对比不需要多层级对比，一个通过Key使得同层级的节点通过自身的Key就能直接找到变化后的节点。这算是Tree Diff。</p>
<p>而Component Diff这个算法的预设是针对不同组件涉及了不同的树结构，这样进一步在最小转换上提高了效率减少了对比误差——而一旦确认了是不同组件，那么React在这个最小转换方式计算上采取了<strong>最高效粗暴的方式对这个节点以及下层所有节点整个删除+替换</strong>。</p>
<p>反之，如果是相同的组件，那么就会进入Element Diff这个层面，ReactDomComponent本质上是没有Diff的(因为一旦更新那肯定是直接就替换式更新了)，但是可以在更新前判定更新谁删除谁添加谁，这是Element Diff的意义所在。</p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="Component-Diff"><a href="#Component-Diff" class="headerlink" title="Component Diff"></a>Component Diff</h3><p>这一块逻辑就3个:</p>
<ul>
<li><p>如果是相同类型，继续进行比较(这个比较可能是根据元素类型进行3种比较策略的组合)</p>
</li>
<li><p>如果不同类型 直接替换后面子节点(ReactCompositeComponent._updateRenderedComponent)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 已删除细节代码  </span></span><br><span class="line">_updateRenderedComponent: <span class="function"><span class="keyword">function</span>(<span class="params">transaction, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</span><br><span class="line">      ReactReconciler.receiveComponent(</span><br><span class="line">        prevComponentInstance,</span><br><span class="line">        nextRenderedElement,</span><br><span class="line">        transaction,</span><br><span class="line">        <span class="built_in">this</span>._processChildContext(context),</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> nextMarkup = ReactReconciler.mountComponent(</span><br><span class="line">        child,</span><br><span class="line">        transaction,</span><br><span class="line">        <span class="built_in">this</span>._hostParent,</span><br><span class="line">        <span class="built_in">this</span>._hostContainerInfo,</span><br><span class="line">        <span class="built_in">this</span>._processChildContext(context),</span><br><span class="line">        debugID,</span><br><span class="line">      );</span><br><span class="line">      <span class="built_in">this</span>._replaceNodeWithMarkup(</span><br><span class="line">        oldHostNode,</span><br><span class="line">        nextMarkup,</span><br><span class="line">        prevComponentInstance,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>shouldComponentUpdate Hook函数自行设置是否更新</p>
</li>
</ul>
<p>关于更新渲染是如何产生的，可以看<a href="/2018/04/26/react-lifecycle/#%E6%9B%B4%E6%96%B0-Updation">React生命周期分析</a>里面的部分。这里直说结论，回到组件层面，不管是state更新还是props更新，它最终会执行到<code>ReactCompositeComponent.updateComponent</code>。</p>
<p>PS: 可能<a href="/2018/04/26/react-lifecycle/#%E6%9B%B4%E6%96%B0-Updation">React生命周期分析</a>里面关于props更新关联了state会让人疑虑，那么可以仔细看看<a href="/2019/06/15/react-redux-saga/">React生态 react-redux|redux-saga</a>加以思考，大家会发现，不管props还是state的更新，归根结底还是setState触发的更新。在React-Redux也无非是在自定义组件上层的connect返回的HOC里面执行了setState。</p>
<p>下面看看源代码这块，看看调用路径:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactCompositeComponent.updateComponent</span><br><span class="line">  -&gt;ReactCompositeComponent._updateRenderedComponent</span><br><span class="line">    -&gt; ReactCompositeComponent.receiveComponent</span><br><span class="line">      -&gt; ReactCompositeComponent.updateComponent</span><br><span class="line">        -&gt;ReactCompositeComponent._performComponentUpdate</span><br><span class="line">          -&gt;ReactCompositeComponent._updateRenderedComponent</span><br><span class="line">            -&gt;internalInstance.receiveComponent</span><br><span class="line">              -&gt;internalInstance.updateComponent</span><br></pre></td></tr></table></figure>

<p>这里调用上有一些地方值得注意<code>ReactReconciler.receiveComponent</code>接到的参数是一个<code>nextElement</code>也就是新元素做对比，<code>ReactReconciler.updateComponent</code>则接受这两个新旧element进行对比,但是在这两个函数调用和定义上。前者是调用后者时候传入的是两个新旧元素，但是后者参数逻辑上，是视为新旧ParentElement处理。</p>
<p>截下来是<code>ReactCompositeComponent._performComponentUpdate</code>,这个函数接受element、props、state,将其赋值给当前自定义组件(就虚拟DOM来讲，这样就已经更新完毕了)，然后调用<code>_updateRenderedComponent</code>进行更新。这个函数就是调用它的<code>render</code>函数并更新对应DOM了。用于对比度新旧元素。这是该函数对比的元素:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prevRenderedElement = prevComponentInstance._currentElement;</span><br><span class="line"><span class="keyword">var</span> nextRenderedElement = <span class="built_in">this</span>._renderValidatedComponent();</span><br></pre></td></tr></table></figure>

<p>因为这新旧两个节点都是一棵虚拟DOM树，这棵树是多种节点的组合。此时我们就可以进行Tree Diff分析了。</p>
<h3 id="Tree-Diff"><a href="#Tree-Diff" class="headerlink" title="Tree Diff"></a>Tree Diff</h3><p>续接ComponentDiff的逻辑，当<code>_updateRenderedComponent</code>执行时候，核心调用是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactReconciler.receiveComponent(</span><br><span class="line">    prevComponentInstance,</span><br><span class="line">    nextRenderedElement,</span><br><span class="line">    transaction,</span><br><span class="line">    <span class="built_in">this</span>._processChildContext(context),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>而这个<code>ReactReconciler.receiveComponent</code>函数调用里面，核心代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> receiveComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">   internalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">   nextElement,</span></span></span><br><span class="line"><span class="function"><span class="params">   transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">   context,</span></span></span><br><span class="line"><span class="function"><span class="params"> </span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> prevElement = internalInstance._currentElement;</span><br><span class="line"><span class="comment">// 如果两个元素完全一样 且 上下文不变，那么什么都不做</span></span><br><span class="line">   <span class="keyword">if</span> (nextElement === prevElement &amp;&amp; context === internalInstance._context) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 否则进行更新</span></span><br><span class="line">   internalInstance.receiveComponent(nextElement, transaction, context);</span><br><span class="line">   <span class="keyword">if</span> (</span><br><span class="line">     refsChanged &amp;&amp;</span><br><span class="line">     internalInstance._currentElement &amp;&amp;</span><br><span class="line">     internalInstance._currentElement.ref != <span class="literal">null</span></span><br><span class="line">   ) &#123;</span><br><span class="line">     transaction.getReactMountReady().enqueue(attachRefs, internalInstance);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>这里更新调用的<code>internalInstance.receiveComponent</code>,这个<code>internalInstance</code> 最常见、主要的指向是ReactCompositeComponent 和 ReactDomComponent这种。</p>
<p>这里把关注点重新放到<code>_updateRenderedComponent</code>函数里面两个新旧元素上，一如ComponentDiff里面提到的。不管是<code>_currentElement</code>还是<code>this._renderValidatedComponent</code>(实质上就是对this._instance.render()的包装)，返回都是自定义组件的render执行结果(这<strong>里必须意识到上级render会递归将子节点的render全部递归执行到根节点位置然后冒泡将值递归返回回来</strong>)，也就是说，可以理解他们进行了脱壳(因为对比的是render结果，而不是该组件本身)，返回了其下级虚拟dom节点。</p>
<p>再看看这个函数简略代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_updateRenderedComponent: <span class="function"><span class="keyword">function</span>(<span class="params">transaction, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevComponentInstance = <span class="built_in">this</span>._renderedComponent;</span><br><span class="line">  <span class="keyword">var</span> prevRenderedElement = prevComponentInstance._currentElement;</span><br><span class="line">  <span class="keyword">var</span> nextRenderedElement = <span class="built_in">this</span>._renderValidatedComponent();</span><br><span class="line">  <span class="keyword">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</span><br><span class="line">    ReactReconciler.receiveComponent(</span><br><span class="line">      prevComponentInstance,</span><br><span class="line">      nextRenderedElement,</span><br><span class="line">      transaction,</span><br><span class="line">      <span class="built_in">this</span>._processChildContext(context),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，一个正常更新的ReactCompositeComponent节点，在更新执行到这个环节时候，一定会执行到这个<code>ReactReconciler.receiveComponent</code>指向<code>ReactDomComponent.receiveComponent</code>那一刻——因为即使不论你的自定义组件如何复杂，即使它们一个嵌套一个(此时<code>ReactReconciler.receiveComponent</code>持续指向<code>ReactCompositeComponent.receiveComponent</code>，两个receiveComponent递归调用)，最坏的情况是执行到终点的render，也必然会指向一个ReactDomComponent。</p>
<p>所以这里关注点可以放到<code>ReactDomComponent.receiveComponent</code>上来了。</p>
<p>接下来这里需要关注的调用栈:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDomComponent.receiveComponent</span><br><span class="line"> -&gt;ReactDomComponent.updateComponent</span><br><span class="line">   -&gt;ReactDomComponent._updateDOMChildren</span><br><span class="line">     -&gt;ReactChildReconciler.updateChildren</span><br></pre></td></tr></table></figure>

<p>仔细看了一下源码，同层级对比这个环节在<code>ReactChildReconciler.updateChildren</code>中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">updateChildren: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  prevChildren,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextChildren,</span></span></span><br><span class="line"><span class="function"><span class="params">  mountImages,</span></span></span><br><span class="line"><span class="function"><span class="params">  removedNodes,</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">  hostParent,</span></span></span><br><span class="line"><span class="function"><span class="params">  hostContainerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">  context,</span></span></span><br><span class="line"><span class="function"><span class="params">  selfDebugID, <span class="comment">// 0 in production and for roots</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!nextChildren &amp;&amp; !prevChildren) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  <span class="keyword">var</span> prevChild;</span><br><span class="line">  <span class="comment">// 遍历新节点树</span></span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nextChildren.hasOwnProperty(name)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历nextChildren key并获取节点相同key属性</span></span><br><span class="line">    prevChild = prevChildren &amp;&amp; prevChildren[name]; </span><br><span class="line">    <span class="keyword">var</span> prevElement = prevChild &amp;&amp; prevChild._currentElement;</span><br><span class="line">    <span class="keyword">var</span> nextElement = nextChildren[name];</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// 两个目标元素都同时存在 且 shouldUpdateReactComponent返回true</span></span><br><span class="line">      prevChild != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      shouldUpdateReactComponent(prevElement, nextElement)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 旧节点更新</span></span><br><span class="line">      ReactReconciler.receiveComponent(</span><br><span class="line">        prevChild,</span><br><span class="line">        nextElement,</span><br><span class="line">        transaction,</span><br><span class="line">        context,</span><br><span class="line">      );</span><br><span class="line">      nextChildren[name] = prevChild;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (prevChild) &#123;</span><br><span class="line">        removedNodes[name] = ReactReconciler.getHostNode(prevChild);</span><br><span class="line">        ReactReconciler.unmountComponent(prevChild, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The child must be instantiated before it&#x27;s mounted.</span></span><br><span class="line">      <span class="comment">// 重新实例化节点并替换</span></span><br><span class="line">      <span class="keyword">var</span> nextChildInstance = instantiateReactComponent(nextElement, <span class="literal">true</span>);</span><br><span class="line">      nextChildren[name] = nextChildInstance;</span><br><span class="line">      <span class="comment">// Creating mount image now ensures refs are resolved in right order</span></span><br><span class="line">      <span class="comment">// (see https://github.com/facebook/react/pull/7101 for explanation).</span></span><br><span class="line">      <span class="keyword">var</span> nextChildMountImage = ReactReconciler.mountComponent(</span><br><span class="line">        nextChildInstance,</span><br><span class="line">        transaction,</span><br><span class="line">        hostParent,</span><br><span class="line">        hostContainerInfo,</span><br><span class="line">        context,</span><br><span class="line">        selfDebugID,</span><br><span class="line">      );</span><br><span class="line">      mountImages.push(nextChildMountImage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Unmount children that are no longer present.</span></span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> prevChildren) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      prevChildren.hasOwnProperty(name) &amp;&amp;</span><br><span class="line">      !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))</span><br><span class="line">    ) &#123;</span><br><span class="line">      prevChild = prevChildren[name];</span><br><span class="line">      removedNodes[name] = ReactReconciler.getHostNode(prevChild);</span><br><span class="line">      ReactReconciler.unmountComponent(prevChild, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>代码并不长 主要是进行了同层级对比。如果两个目标元素都同时存在并且<code>shouldUpdateReactComponent</code>返回true，那么调用<code>ReactReconciler.receiveComponent</code>进行更新。否则则通过<code>instantiateReactComponent</code>生成新的React元素并渲染替换原来的(通过removedNodes进行收集并在后面一起unmountComponent)。</p>
<p>而取消跨层级对比这个，实质上是通过良好的规划解决了。比如上一节提到的Component Diff,它对比的是<code>inst._currentElement</code>和render返回值。相同的类型它会一直<code>ReactReconciler.receiveComponent</code>调用直到终点，开始或者中途因为组件不同，那么直接覆盖替换。</p>
<p>由于变更是一个从父组件到子组件一直到最终节点的过程，所以ReactReconciler.updateChildren在运行过程中调用ReactReconciler.receiveComponent最终在遇到还有下层节点时候回返回再次调用自身一直到最终节点。</p>
<p>另外就是这个updateChildren会维护一个removedNodes数组，并在这个调用过程中会一路以参数形式往下传递直到最终节点一起unMound。那么这个removedNodes从哪开始呢？从ReactMultiChild.updateChildren开始。我们梳理一下调用路径,知道这个removeNodes如何维护的还是很重要的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactMultiChild.updateChildren</span><br><span class="line">-&gt;ReactMultiChild._updateChildren -&gt;声明:removedNodes = &#123;&#125;</span><br><span class="line">--&gt;ReactMultiChild._reconcilerUpdateChildren() &lt;- 传入:removedNodes = &#123;&#125;;</span><br><span class="line">----&gt;ReactChildReconciler.updateChildren</span><br><span class="line"><span class="comment">// 该函数在该逻辑的核心代码</span></span><br><span class="line">ReactChildReconciler.updateChildren () &#123;</span><br><span class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          prevChild != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">          shouldUpdateReactComponent(prevElement, nextElement)</span><br><span class="line">        )&#123;</span><br><span class="line">          ReactReconciler.receiveComponent(</span><br><span class="line">            prevChild,</span><br><span class="line">            nextElement,</span><br><span class="line">            transaction,</span><br><span class="line">            context,</span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (prevChild) &#123;</span><br><span class="line">            <span class="comment">// removedNodes是被传入前是一个对象(引用类型) 传值参考&quot;Call By Share&quot;</span></span><br><span class="line">            <span class="comment">// 总之它会直接修改来自ReactMultiChild._updateChildren的removedNodes值</span></span><br><span class="line">            removedNodes[name] = ReactReconciler.getHostNode(prevChild);</span><br><span class="line">            ReactReconciler.unmountComponent(prevChild, <span class="literal">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tree Diff时候就直接计算出nextChild中有、prevChild也有、但是不相等的节点，存到removeNodes中。</p>
<p>这里实际上不会如传统的算法那么追求完美，就像之前提到的，他基本上遇到新的树上出现新的节点后如果在旧的节点上查到同名的，那么会进行shouldUpdateReactComponent判断，这个判断涉及主要设计type&amp;key。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldUpdateReactComponent</span>(<span class="params">prevElement, nextElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevEmpty = prevElement === <span class="literal">null</span> || prevElement === <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> nextEmpty = nextElement === <span class="literal">null</span> || nextElement === <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (prevEmpty || nextEmpty) &#123;</span><br><span class="line">    <span class="keyword">return</span> prevEmpty === nextEmpty;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> prevType = <span class="keyword">typeof</span> prevElement;</span><br><span class="line">  <span class="keyword">var</span> nextType = <span class="keyword">typeof</span> nextElement;</span><br><span class="line">  <span class="keyword">if</span> (prevType === <span class="string">&#x27;string&#x27;</span> || prevType === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextType === <span class="string">&#x27;string&#x27;</span> || nextType === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      nextType === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">      prevElement.type === nextElement.type &amp;&amp;</span><br><span class="line">      prevElement.key === nextElement.key</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有的话直接生成新的并挂载。</p>
<p>Tree Diff到这里应该可以结束了，接下来是Element Diff。</p>
<h3 id="Element-Diff"><a href="#Element-Diff" class="headerlink" title="Element Diff"></a>Element Diff</h3><p>这个Element Diff包括三种操作: 插入、删除、移动。这里为了方便表述先说移动。</p>
<h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><p><strong>这里需要强调的是这个算法，属于同层级下的子节点对比算法。</strong></p>
<p>接上一节的调用路径，这里接下路径是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDomComponent.receiveComponent</span><br><span class="line">-&gt;ReactDomComponent.updateComponent</span><br><span class="line">   -&gt; ReactDomComponent._updateDOMChildren</span><br><span class="line">     -&gt; ReactMultiChild._updateChildren</span><br></pre></td></tr></table></figure>

<p><code>ReactDomComponent.updateComponent</code>这个函数核心调用之前文章有提到过，是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>._updateDOMProperties(lastProps, nextProps, transaction);</span><br><span class="line"><span class="built_in">this</span>._updateDOMChildren(lastProps, nextProps, transaction, context);</span><br></pre></td></tr></table></figure>

<p><code>_updateDOMChildren</code>里调用的<code>this.updateChildren(nextChildren, transaction, context);</code>方法，来自<code>ReactMultiChild.Mixin</code>。这个函数里面完整的实现了Element Diff。</p>
<p>关于Element Diff，可以这么说，我们进行Tree Diff和Component Diff是从顶层设计上降低了算法复杂度，而Element Diff则是那个跑前跑后赚辛苦钱的那个小喽啰，当然，这并不是说它不重要，反而正是在突出其工作的相对复杂性。理解这段话，可以理解为Tree Diff和Component Diff是深谙其中五味的领导，为办事员指明了工作最优方向，但是对于办事员来讲，让然跑不了领导一张嘴下面跑断腿的情景。</p>
<p>关于这个算法，《深入React技术栈》有非常详尽的<a href="https://zhuanlan.zhihu.com/p/20346379?refer=purerender">说明</a>，但是个人觉得如果基于硬啃每一行代码的角度去理解算法的话，理解这个diff算法反而变得过于复杂了。</p>
<p>基于《深入React技术栈》的例子这里自己说下对这个算法排序上的理解。</p>
<p><img src="/images/aaa.png" alt="example"></p>
<p>新旧节点的例子就是如上图所示，我们从ABCD变成了BADC这样的结构，这个算法最后计算出的差异是移动A和C到对应位置。这里问题是如何进行这个计算。</p>
<p>这里我们可以假设ABCD分别代表一个常数变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 旧节点 此时最优排序是 ABCD 可以设其分别为0123四个值</span></span><br><span class="line">A B C D</span><br><span class="line"><span class="comment">// 新节点 此时最优排序是 BADC 为了实现排序 就可以设ABCD分别为1032</span></span><br><span class="line">B A D C <span class="comment">// 当ABCD按照值大小排序完毕 就是BADC的顺序了</span></span><br><span class="line"><span class="comment">// 这里设置一个排序规则: 使ABCD根据其代表的值进行排位。这样就可以进行抽象排序了。</span></span><br></pre></td></tr></table></figure>

<p>这里就可以逆向思考一下，React是如何设计这个算法了。<strong>当我们重设了ABCD的值，计算新的顺序和现有顺序差异时候，并且将要排序但是还没排序时候</strong>，下面对应的索引、值、元素是按下面关系对应的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">index  <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">       A B C D</span><br><span class="line">value  <span class="number">1</span> <span class="number">0</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">done:  B A D C</span><br></pre></td></tr></table></figure>

<p>此时很容易发现了，我们的value的值实际上就是每个元素排序后应该所处的索引，而事实上的索引，则是排序之前的索引。我们需要做的，是把索引正确的(value &lt; index)放着不动，而把错误的(value &gt; index)挑出来，并把排序方案记录下来。</p>
<p>这里操作办法很简单，如果当前值比索引大，那么说明这个位置是错误的需要移动，把这个值移动到值对应的索引上，如果值比当前索引小，那么说明可以不动它(<strong>这里采取只移动实际位置比自己正确位置靠前的元素的策略</strong>，当把这些元素一一归位到对应值的索引的时候，这个排序就完成了)。</p>
<p>但是这里需要说一下，当我们进行对比的时候，实际上BADC的顺序已经是确定的，我们实际的路径是已知变动后的BADC和变动前的ABCD，求这个变动的最小集合。<strong>这个过程中，已经确定变动后的BADC的顺序，可以理解成，上诉排序中，对ABCD重新赋值的过程。</strong></p>
<p>这里看看关于移动的核心代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心代码</span></span><br><span class="line"><span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> lastIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;</span><br><span class="line">  <span class="keyword">var</span> prevChild = prevChildren &amp;&amp; prevChildren[name];</span><br><span class="line">  <span class="keyword">var</span> nextChild = nextChildren[name];</span><br><span class="line">  <span class="keyword">if</span> (prevChild === nextChild) &#123;</span><br><span class="line">    updates = enqueue(</span><br><span class="line">      updates,</span><br><span class="line">      <span class="built_in">this</span>.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex), <span class="comment">// 标记移动</span></span><br><span class="line">    );</span><br><span class="line">    lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</span><br><span class="line">    prevChild._mountIndex = nextIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">nextIndex++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用到的调用函数</span></span><br><span class="line">moveChild: <span class="function"><span class="keyword">function</span>(<span class="params">child, afterNode, toIndex, lastIndex</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// If the index of `child` is less than `lastIndex`, then it needs to</span></span><br><span class="line">  <span class="comment">// be moved. Otherwise, we do not need to move it because a child will be</span></span><br><span class="line">  <span class="comment">// inserted or moved before `child`.</span></span><br><span class="line">  <span class="keyword">if</span> (child._mountIndex &lt; lastIndex) &#123;</span><br><span class="line">    <span class="keyword">return</span> makeMove(child, afterNode, toIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用到的调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeMove</span>(<span class="params">child, afterNode, toIndex</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> Null values reduce hidden classes.</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&#x27;MOVE_EXISTING&#x27;</span>,</span><br><span class="line">    content: <span class="literal">null</span>,</span><br><span class="line">    fromIndex: child._mountIndex,</span><br><span class="line">    fromNode: ReactReconciler.getHostNode(child),</span><br><span class="line">    toIndex: toIndex,</span><br><span class="line">    afterNode: afterNode,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里简要分析一下，moveChild函数判断<code>child._mountIndex &lt; lastIndex</code>,如果符合条件那么调用<code>makeMove</code>将这个元素标记为移动。这个移动过程和上面提到的原理是一致的，唯一需要理解的是<code>nextIndex</code>和<code>lastIndex</code>两个变量。这里代码上差异分析过程是以新的BADC为目标，分析ABCD到BADC的过程。</p>
<p>这里可以简单代入分析一下。</p>
<ul>
<li><p>首先按BADC顺序，取B(排序后index也就是<code>nextIndex === 0</code>), 这时候，此时<code>prevChild._mountIndex</code>也就是key为1，此时mounIndex(1) &gt; lastIndex(0) 不满足移动标记条件，不标记。lastIndex=0。</p>
<ul>
<li><p><code>lastIndex = Math.max(prevChild._mountIndex, lastIndex);</code>设置lastIndex为遍历过得节点里mountIndex的最大值。</p>
</li>
<li><p><code>prevChild._mountIndex = nextIndex;</code>虚拟dom上节点完成移动。</p>
<p><font color="red">★</font> 这里要注意到<code>nextIndex</code>是满足条件后 要移动到的索引值。lastIndex则记录遍历过的节点在旧结构中的最大索引值。<code>nextIndex</code>相当于之前ABCD=0123赋值过程中的index, <code>lastIndex</code>则相当于value。</p>
</li>
</ul>
</li>
<li><p>取A(<code>nextIndex === 1</code>)，同上此时mounIndex(0) &lt; lastIndex(Math.Max(0, 1) === 1)，那么标记A从0移动到1，lastIndex=1。</p>
</li>
<li><p>取D(<code>nextIndex === 2</code>)，此时mounIndex(3) = lastIndex(Math.Max(3, 2) === 3), 不标记。lastIndex=3。</p>
</li>
<li><p>取C(<code>nextIndex === 3</code>)，此时mounIndex(2) &lt; lastIndex(Math.Max(2, 3) === 3), 标记移动到3，lastIndex = 2。</p>
</li>
</ul>
<p>这里需要重点理解lastIndex，它的意义在于确保设置一个动态的值用于对比。当我们根据新的结构按照nextIndex累加往后移动计算差异时候，我们必须有一个尺度用来进行排序，这和我们之前给ABCD重新赋值是一个道理。只不过这里采用了lastIndex的方式。</p>
<p>lastIndex在这里，记录了最大的<code>prevChild._mountIndex</code>，它配合从0开始累加的nextIndex,顺序将新节点在旧结构中的索引记录下来(如果它比前面的都更大，否则忽略)，然后随着nextIndex累加，新结构中的节点一一出现，如果它的mountIndex小于这个lastIndex，就统统往后移动，否则就不需要移动。</p>
<p>这里再来两个例子看看，这里需要注意，只有<code>&lt;</code>符号出现才需要移动，<code>x</code>代表不需要移动，<code>*</code>表示需要标记移动</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子1: 12345 =&gt; 53421 </span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>&gt;<span class="number">0</span> <span class="number">2</span>&lt;<span class="number">4</span> <span class="number">3</span>&lt;<span class="number">4</span> <span class="number">1</span>&lt;<span class="number">4</span> <span class="number">0</span>&lt;<span class="number">4</span></span><br><span class="line"> x   *   *   *   *</span><br><span class="line"></span><br><span class="line"> <span class="number">5</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">2</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子2: 12345 =&gt; 14253</span></span><br><span class="line"> <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>=<span class="number">0</span> <span class="number">3</span>&gt;<span class="number">0</span> <span class="number">1</span>&lt;<span class="number">3</span> <span class="number">4</span>&gt;<span class="number">3</span> <span class="number">2</span>&lt;<span class="number">4</span></span><br><span class="line"> x   x   *   x   *</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span>   <span class="number">4</span>   <span class="number">2</span>   <span class="number">5</span>   <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>继续刚才业务代码逻辑，这里核心是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心业务代码</span></span><br><span class="line"><span class="keyword">if</span> (prevChild === nextChild) &#123; <span class="comment">// 如果节点更新前后没有变化</span></span><br><span class="line">  <span class="comment">// 略 这里是移动逻辑</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果有变化</span></span><br><span class="line">  <span class="keyword">if</span> (prevChild) &#123; <span class="comment">// 关注点:A 如果该节点在变化之前也有</span></span><br><span class="line">    <span class="comment">// Update `lastIndex` before `_mountIndex` gets unset by unmounting.</span></span><br><span class="line">    lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</span><br><span class="line">    <span class="comment">// 通过遍历 removedNodes 删除子节点 prevChild</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// The child must be instantiated before it&#x27;s mounted.</span></span><br><span class="line">  updates = enqueue(</span><br><span class="line">    updates,</span><br><span class="line">    <span class="built_in">this</span>._mountChildAtIndex(</span><br><span class="line">      nextChild,</span><br><span class="line">      mountImages[nextMountIndex],</span><br><span class="line">      lastPlacedNode,</span><br><span class="line">      nextIndex,</span><br><span class="line">      transaction,</span><br><span class="line">      context,</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Remove children that are no longer present.</span></span><br><span class="line"><span class="keyword">for</span> (name <span class="keyword">in</span> removedNodes) &#123;</span><br><span class="line">  <span class="keyword">if</span> (removedNodes.hasOwnProperty(name)) &#123;</span><br><span class="line">    updates = enqueue(</span><br><span class="line">      updates,</span><br><span class="line">      <span class="built_in">this</span>._unmountChild(prevChildren[name], removedNodes[name]),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相关调用代码</span></span><br><span class="line">_mountChildAtIndex: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"> child,</span></span></span><br><span class="line"><span class="function"><span class="params"> mountImage,</span></span></span><br><span class="line"><span class="function"><span class="params"> afterNode,</span></span></span><br><span class="line"><span class="function"><span class="params"> index,</span></span></span><br><span class="line"><span class="function"><span class="params"> transaction,</span></span></span><br><span class="line"><span class="function"><span class="params"> context,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    child._mountIndex = index;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.createChild(child, afterNode, mountImage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相关调用代码</span></span><br><span class="line">createChild: <span class="function"><span class="keyword">function</span>(<span class="params">child, afterNode, mountImage</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> makeInsertMarkup(mountImage, afterNode, child._mountIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相关调用代码</span></span><br><span class="line">_unmountChild: <span class="function"><span class="keyword">function</span>(<span class="params">child, node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> update = <span class="built_in">this</span>.removeChild(child, node);</span><br><span class="line">    child._mountIndex = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> update;</span><br><span class="line">&#125;,</span><br><span class="line">removeChild: <span class="function"><span class="keyword">function</span>(<span class="params">child, node</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> makeRemove(child, node);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 相关调用代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeInsertMarkup</span>(<span class="params">markup, afterNode, toIndex</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> Null values reduce hidden classes.</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&#x27;INSERT_MARKUP&#x27;</span>,</span><br><span class="line">    content: markup,</span><br><span class="line">    fromIndex: <span class="literal">null</span>,</span><br><span class="line">    fromNode: <span class="literal">null</span>,</span><br><span class="line">    toIndex: toIndex,</span><br><span class="line">    afterNode: afterNode,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相关调用代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRemove</span>(<span class="params">child, node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> Null values reduce hidden classes.</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&#x27;REMOVE_NODE&#x27;</span>,</span><br><span class="line">    content: <span class="literal">null</span>,</span><br><span class="line">    fromIndex: child._mountIndex,</span><br><span class="line">    fromNode: node,</span><br><span class="line">    toIndex: <span class="literal">null</span>,</span><br><span class="line">    afterNode: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先必须说一说，插入和删除很多时候是混合进行的。</p>
<p>比如我们原来结构式ABCD，后来变化成了AECD，这样在diff算法中，会删除B然后插入一个E。</p>
<p>和上面的移动差不多，这个操作都是标记操作，先标记B为删除，然后标记E为添加——但是不管是不是移动，这里lastIndex逻辑还是和上面一样，所以代码进入了[关注点A]标记的逻辑的话，那么说明这个节点就必须标记删除了(因为他们已经不相等了，类似上面B变成E)。关于<strong>标记添加这个很好理解，主要是拿到nextIndex和nextChild之后标记为添加就可以了。</strong></p>
<p>而删除则有另外一套逻辑。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除逻辑相对复杂一些，整体逻辑是从removeNodes里面遍历，然后获取对应的变更前元素mountIndex,挨个进行标记删除。关于这个removeNodes数组，可以回过头参考Tree Diff细节。当我们开始更新时候，TreeDiff在最上游，它在最上游Diff环节已经归集好了removeNodes。</p>
<p>这个removeNodes归集过程参考Tree Diff环节。</p>
<h3 id="更新到DOM"><a href="#更新到DOM" class="headerlink" title="更新到DOM"></a>更新到DOM</h3><p>无论如何，浏览器不认识虚拟DOM，最终它还是要是要具现化到浏览器的UI层。</p>
<p><code>DOMChildrenOperations.js</code>文件中<code>DOMChildrenOperations.processUpdates</code>内部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">processUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">parentNode, updates</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; updates.length; k++) &#123;</span><br><span class="line">    <span class="keyword">var</span> update = updates[k];</span><br><span class="line">    <span class="keyword">switch</span> (update.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;INSERT_MARKUP&#x27;</span>:</span><br><span class="line">        insertLazyTreeChildAt(</span><br><span class="line">          parentNode,</span><br><span class="line">          update.content,</span><br><span class="line">          getNodeAfter(parentNode, update.afterNode),</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;MOVE_EXISTING&#x27;</span>:</span><br><span class="line">        moveChild(</span><br><span class="line">          parentNode,</span><br><span class="line">          update.fromNode,</span><br><span class="line">          getNodeAfter(parentNode, update.afterNode),</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;SET_MARKUP&#x27;</span>:</span><br><span class="line">        setInnerHTML(parentNode, update.content);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;TEXT_CONTENT&#x27;</span>:</span><br><span class="line">        setTextContent(parentNode, update.content);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;REMOVE_NODE&#x27;</span>:</span><br><span class="line">        removeChild(parentNode, update.fromNode);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这个函数被调用的路径:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactMultiChild.Minxin._updateChildren</span><br><span class="line">-&gt;processQueue(<span class="built_in">this</span>, updates)</span><br><span class="line">  -&gt;ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue)</span><br></pre></td></tr></table></figure>

<p>其中<code>processChildrenUpdates</code>是在ReactDefautlInject.js中注入的，最终引用的是<code>ReactDOMIDOperations.dangerouslyProcessChildrenUpdates</code>,这个函数里面调用了<code>DOMChildrenOperations.processUpdates</code>。</p>
<p>而顶部的<code>ReactMultiChild.Minxin._updateChildren</code>是上面ElementDiff环节的核心调用。</p>
<p>最后是<code>processUpdates</code>函数本身, 因为做标记时候，就是按顺序进行标记加入队列，所以这个函数直接进行遍历，然后根据type进行分支处理就完事了,并不会出现意外情况。</p>
<h1 id="Diff算法的层次和例子"><a href="#Diff算法的层次和例子" class="headerlink" title="Diff算法的层次和例子"></a>Diff算法的层次和例子</h1><p>我们已经知道了三种Diff，但是这里还是要将其思考一番，了解他们在整体上是如何运行的。</p>
<p>这里思考: <strong>React程序什么会进行更新？如果触发了更新三种Diff又是怎么样配合运作的呢？</strong></p>
<h2 id="分析一"><a href="#分析一" class="headerlink" title="分析一"></a>分析一</h2><p>这里写个例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    index: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  onClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(</span><br><span class="line">      index: <span class="built_in">this</span>.state.index + <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.onClick&#125;&gt;click me&lt;/button&gt;</span><br><span class="line">      &lt;span&gt;Foo, <span class="attr">Index</span>: &#123;<span class="built_in">this</span>.state.index&#125;&lt;/span&gt;</span><br><span class="line">      &lt;Bar /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDom.render(Foo, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>

<p>当按钮被点击，此时Diff是如何计算呢？可以参考之前提到的声明周期的文章，当setState被触发，那么组件会被标记脏组件，然后后面会调用<code>runBatchedUpdates</code>批量更新。接下最后每个脏组件会被遍历，然后调用<code>internalInstance.performUpdateIfNecessary(transaction);</code>。就本例来讲，他会遵循下面的调用栈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactCompositeComponent.performUpdateIfNecessary</span><br><span class="line">-&gt;ReactReconciler.receiveComponent</span><br><span class="line">  -&gt;ReactCompositeComponent.receiveComponent</span><br><span class="line">    -&gt; ReactCompositeComponent.updateComponent</span><br><span class="line">      -&gt;ReactCompositeComponent._performComponentUpdate</span><br><span class="line">        -&gt;ReactCompositeComponent._updateRenderedComponent</span><br><span class="line">          -&gt;internalInstance.receiveComponent</span><br><span class="line">            -&gt;internalInstance.updateComponent</span><br></pre></td></tr></table></figure>

<p>后面这一截调用栈和ComponentDiff一致。</p>
<p>此时第一时间触发的是ComponentDiff。此时这个internalInstance明显指向ReactCompositeComponent</p>
<p>调用路径:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ComponentDiff</span></span><br><span class="line">ReactCompositeComponent.updateComponent</span><br><span class="line">  -&gt;ReactCompositeComponent._updateRenderedComponent</span><br><span class="line">    -&gt; ReactCompositeComponent.receiveComponent</span><br><span class="line">      -&gt; ReactCompositeComponent.updateComponent</span><br><span class="line">        -&gt;ReactCompositeComponent._performComponentUpdate</span><br><span class="line">          -&gt;ReactCompositeComponent._updateRenderedComponent</span><br></pre></td></tr></table></figure>

<p>到了这里，接下就是TreeDiff，此时_updateRenderedComponent对比的是新旧Foo节点。这个节点的结构是:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div&gt; <span class="comment">// A</span></span><br><span class="line">  &lt;button onClick=&#123;<span class="built_in">this</span>.onClick&#125;&gt;click me&lt;<span class="regexp">/button&gt; /</span><span class="regexp">/ B</span></span><br><span class="line"><span class="regexp">  &lt;span&gt;Foo, Index: &#123;this.state.index&#125;&lt;/</span>span&gt; <span class="comment">// C</span></span><br><span class="line">  &lt;Bar /&gt; <span class="comment">// D</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>因为节点变化了，所以这个ReactDomcomponent要开始进行对比。也就是<code>ReactDomComponent.receiveComponent</code>开始执行。</p>
<p>路线：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Element Diff</span></span><br><span class="line">ReactDomComponent.receiveComponent</span><br><span class="line">-&gt;ReactDomComponent.updateComponent</span><br><span class="line">   -&gt; ReactDomComponent._updateDOMChildren</span><br><span class="line">     -&gt; ReactMultiChild._updateChildren</span><br></pre></td></tr></table></figure>

<p>此时这个ReactDomComponent指向A。其子节点 B &amp; D没有变化，按照ElementDiff不变，而C变化了，实例化<strong>新节点C</strong>并标记添加，<strong>removedNodes中含有的C后面被删除</strong>。</p>
<p>这些完成之后，通过更新到DOM，就完成了整体更新。</p>
<h2 id="分析二"><a href="#分析二" class="headerlink" title="分析二"></a>分析二</h2><p>分析一大致的分析比较浅的DOM树。接下来分析一个相对复杂的。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>A&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>B&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C D 走一样逻辑</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    index: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  onClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(</span><br><span class="line">      index: <span class="built_in">this</span>.state.index + <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    &lt;div&gt; <span class="comment">// 1</span></span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.onClick&#125;&gt;click me&lt;<span class="regexp">/button&gt; /</span><span class="regexp">/ 1</span></span><br><span class="line"><span class="regexp">      &lt;span&gt;Foo, Index: &#123;this.state.index&#125;&lt;/</span>span&gt; <span class="comment">// 2</span></span><br><span class="line">      &lt;A index=&#123;<span class="built_in">this</span>.state.index&#125;&gt; <span class="comment">// 3</span></span><br><span class="line">          &lt;B&gt;<span class="xml"><span class="tag">&lt;<span class="name">C</span> <span class="attr">index</span>=<span class="string">&#123;this.state.index&#125;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">C</span>&gt;</span></span>&lt;/B&gt;</span><br><span class="line">      &lt;/A&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDom.render(Foo, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>

<p>现在捋一下，如果点击click me按钮，会发生如下事情:</p>
<p>Foo启动Component Diff</p>
<p>然后新旧两颗VirtualDom开始进行Tree Diff， Tree Diff开始判定这两棵树下级子节点里面的差异节点。这里1不变2、3变化，所以旧节点23三个地方都会被放到removeNodes里面备删除，因为1、2节点在新旧节点里面都存在且shouldUpdateReactComponent，所以两个个节点接下来都直接触发ReactReconciler.receiveComponent，这三个节点分别是ReactDomComponent、ReactCompositeComponent。</p>
<p>接下来三个调用分别触发<code>ReactDomComponent.receiveComponent</code>、<code>ReactCompositeComponent.receiveComponent</code>。</p>
<p>此时节点2变化的是内部文本。当<code>ReactDomComponent.receiveComponent</code>一路走到<code>_updateDOMChildren</code>,因为内部节点都是字符串所以，<code>_updateDOMChildren</code>执行到<code>this.updateTextContent(&#39;&#39; + nextContent);</code>就结束了。</p>
<p>接下是节点3。因为节点3传入的props变化了，所以<code>ReactCompositeComponent.receiveComponent</code>,在随后的<code>this._updateRenderedComponent</code>调用栈中，进行了结构<code>&lt;div&gt;A&lt;B&gt;&lt;C /&gt;&lt;/B&gt;&lt;/div&gt;</code>的虚拟DOM对比。</p>
<p>接下来因为这两棵树根节点又是ReactDomComponent又进入了<code>ReactDomComponent.receiveComponent</code>，此时执行到<code>_updateDOMChildren</code>,新旧节点就不是字符串了，所以它调用了<code>ReactDomComponent.updateChildren</code>,它指向<code>ReatMultiChild.updateChildren</code>,那么树对比开始,此时因为节点3变更了，而且新旧结构里面都有，所以React这里直接将旧的3放到removeNodes里面，然后标记新的节点3为添加。</p>
<p>到此时整个Diff就完事了。</p>
<p> <font color="red">★</font>接下来我们思考: B组件并没有变更，如果我们想B不动的情况下更新C，也就是给B加上<code>shouldComponentUpdate = () =&gt; false</code>,会怎样去走这个Diff呢？</p>
<p>接着上面提到的<code>&lt;div&gt;A&lt;B&gt;&lt;C /&gt;&lt;/B&gt;&lt;/div&gt;</code>的虚拟DOM对比开始。因为此时根节点又是ReactDomComponent，所以引入<code>ReactDomComponent.receiveComponent</code>,进而执行了<code>_updateDOMChildren</code>,此时这个函数执行到了<code>this.updateChildren(nextChildren, transaction, context)</code>，也就是<code>ReactMultiChild.updateChildren(nextChildren, transaction, context)</code>。这个函数下级的调用里面有<code>ReactMultiChild._updateChildren</code>里面有一个调用: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nextChildren = <span class="built_in">this</span>._reconcilerUpdateChildren(</span><br><span class="line">    prevChildren,</span><br><span class="line">    nextNestedChildrenElements,</span><br><span class="line">    mountImages,</span><br><span class="line">    removedNodes,</span><br><span class="line">    transaction,</span><br><span class="line">    context,</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 此时。。。</span></span><br><span class="line">_reconcilerUpdateChildren</span><br><span class="line">--&gt;ReactChildReconciler.updateChildren</span><br><span class="line">----&gt;ReactReconciler.receiveComponent</span><br><span class="line">------&gt;ReactCompositeComponent.receiveComponent</span><br><span class="line">-------&gt;ReactCompositeComponent.updateComponent</span><br></pre></td></tr></table></figure>

<p>最后在<code>ReactCompositeComponent.updateComponent</code>有这么一段:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldUpdate) &#123;</span><br><span class="line">  <span class="built_in">this</span>._pendingForceUpdate = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// Will set `this.props`, `this.state` and `this.context`.</span></span><br><span class="line">  <span class="comment">// 会调用_updateRenderedComponent将ReactCompositeComponent脱壳成ReactDomComponent</span></span><br><span class="line">  <span class="comment">// 然后ReactDomComponent.receiveComponent-&gt;ReactDomComponent._updateDOMChildren</span></span><br><span class="line">  <span class="built_in">this</span>._performComponentUpdate( </span><br><span class="line">    nextParentElement,</span><br><span class="line">    nextProps,</span><br><span class="line">    nextState,</span><br><span class="line">    nextContext,</span><br><span class="line">    transaction,</span><br><span class="line">    nextUnmaskedContext,</span><br><span class="line">  );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// If it&#x27;s determined that a component should not update, we still want</span></span><br><span class="line">  <span class="comment">// to set props and state but we shortcut the rest of the update.</span></span><br><span class="line">  <span class="built_in">this</span>._currentElement = nextParentElement;</span><br><span class="line">  <span class="built_in">this</span>._context = nextUnmaskedContext;</span><br><span class="line">  inst.props = nextProps;</span><br><span class="line">  inst.state = nextState;</span><br><span class="line">  inst.context = nextContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然 第二个分支直接给旧节点进行修改赋值而没有去替换它。正常的更新则会直接用新的替代。</p>
<p>关于这个nextParentElement，需要清晰意思到之前在它之前调用的ReactDomComponent更新调用到的<code>_updateDOMChildren</code>函数，里面直接使用的<code>nextProps.children</code>。关于这个<code>nextProps.children</code>其实就是<code>var nextChildren = this._reconcilerUpdateChildren()</code>。</p>
<p><font color="red">★</font>这里有需要对<span id="reconcilerUpdateChildren"><code>_reconcilerUpdateChildren</code></span>有个清晰认识。一方面它是diff过程中的一个环节(计算nextChildren备用)，一方面它又是Diff计算的结果，它计算nextChildren过程中会也会进行Diff，然后将Diff后的结果返回来(这也是为什么, shouldComponentUpdate返回false，可以直接进行currentElement赋值的原因)。</p>
<h1 id="一些小思考"><a href="#一些小思考" class="headerlink" title="一些小思考"></a>一些小思考</h1><ul>
<li><p>Q: React jsx内部如何处理以下语法的:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;v&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>A: <code>ReactMultiChild._reconcilerUpdateChildren</code>内部<code>flattenChildren</code>函数的调用。</p>
</li>
<li><p>Q：React 虚拟Dom在Diff过程中如何处理标签单节点反复嵌套，<code>_updateDOMChildren</code>函数毕竟是处理多个节点的。</p>
<p>A: <code>_updateDOMChildren</code>会调用起<code>ReactMultiChild._reconcilerUpdateChildren</code>，它内部包含<code>ReactChildReconciler.updateChildren</code>函数的调用。如下面结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&lt;div&gt;&lt;div&gt;1234&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>它会<code>ReactChildReconciler.updateChildren</code>会触发以下调用链：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDomComponent.updateChildren <span class="comment">// 第一层</span></span><br><span class="line">-&gt;_updateDOMChildren</span><br><span class="line">--&gt;ReactDomComponent.updateChildren <span class="comment">// 第二层</span></span><br><span class="line">---&gt;updateDOMChildren</span><br><span class="line">----&gt;ReactDomComponent.updateChildren <span class="comment">// 第三层</span></span><br><span class="line">-----&gt;updateDOMChildren</span><br></pre></td></tr></table></figure>

<p>一直到终点进行文本节点更新。当然，如果中途第二层如果有变化，它就会直接被删除然后被新渲染的节点直接替换不走第三层了。</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://book.douban.com/subject/26918038/">《深入React技术栈》</a></p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React ReactUpdates</title>
    <url>/2019/06/15/react-ReactUpdates/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>ReactUpdates模块在整个生命周期中是基础性质的模块，它是调用虚拟DOM算法更新DOM的主要调用者，其重要性不言而喻。</p>
<p>React在更新DOM过程中有几个重要的职责，其中事务职责和批量更新职责是核心。</p>
<p>这其中事务负责实用innerHTML更新小范围DOM时候，将其中各种状态预先保存，完成替换后还原这些状态。批量更新则包括componentDidMount带来的更新，以及用户操作带来的各种更新。</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactUpdates = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * React references `ReactReconcileTransaction` using this property in order</span></span><br><span class="line"><span class="comment">   * to allow dependency injection.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ReactReconcileTransaction: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  batchedUpdates: batchedUpdates,</span><br><span class="line">  enqueueUpdate: enqueueUpdate,</span><br><span class="line">  flushBatchedUpdates: flushBatchedUpdates,</span><br><span class="line">  injection: ReactUpdatesInjection,</span><br><span class="line">  asap: asap</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性/方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ReactReconcileTransaction</td>
<td>更新需要依赖的事务调度</td>
</tr>
<tr>
<td>batchedUpdates</td>
<td>批量更新方法</td>
</tr>
<tr>
<td>enqueueUpdate</td>
<td>队列更新方法</td>
</tr>
<tr>
<td>flushBatchedUpdates</td>
<td>batchedUpdates的实际执行者</td>
</tr>
<tr>
<td>injection</td>
<td>依赖注入，ReactReconcileTransaction、batchingStrategy(batchedUpdates依赖)由它来注入</td>
</tr>
<tr>
<td>asap</td>
<td>将回调排入队列以在当前批处理循环结束时运行</td>
</tr>
</tbody></table>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="enqueueUpdate"><a href="#enqueueUpdate" class="headerlink" title="enqueueUpdate"></a>enqueueUpdate</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Various parts of our code (such as ReactCompositeComponent&#x27;s</span></span><br><span class="line">  <span class="comment">// _renderValidatedComponent) assume that calls to render aren&#x27;t nested;</span></span><br><span class="line">  <span class="comment">// verify that that&#x27;s the case. (This is called by each top-level update</span></span><br><span class="line">  <span class="comment">// function, like setState, forceUpdate, etc.; creation and</span></span><br><span class="line">  <span class="comment">// destruction of top-level components is guarded in ReactMount.)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">  <span class="keyword">if</span> (component._updateBatchNumber == <span class="literal">null</span>) &#123;</span><br><span class="line">    component._updateBatchNumber = updateBatchNumber + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是一个入队操作。</p>
<p>如果当前没有处于更新过程中，那么直接进行更新(<code>batchingStrategy.batchedUpdates(enqueueUpdate, component)</code>)不加入<code>dirtyComponents</code>。</p>
<p>否则将需要更新的component压入到<code>dirtyComponents</code>,并设置<code>component._updateBatchNumber</code>。</p>
<h2 id="batchedUpdates"><a href="#batchedUpdates" class="headerlink" title="batchedUpdates"></a>batchedUpdates</h2><p>本质上只是对<code>batchingStrategy.batchedUpdates(callback, a, b, c, d, e)</code>的调用。</p>
<p>batchingStrategy对应的路径是:src/renderers/shared/stack/reconciler/ReactDefaultBatchingStrategy.js</p>
<p>所以这里重点就扯一扯batchingStrategy。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDefaultBatchingStrategyTransaction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.reinitializeTransaction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, &#123;</span><br><span class="line">  getTransactionWrappers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TRANSACTION_WRAPPERS;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> ReactDefaultBatchingStrategyTransaction();</span><br><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  isBatchingUpdates: <span class="literal">false</span>,</span><br><span class="line">  batchedUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里更新逻辑还是比较简单，根据维护的isBatchingUpdates这个标记来判定直接回调调用还是事务完成后进行函数调用。这里核心还是ReactDefaultBatchingStrategyTransaction。关于这个事务定义比较简单是RESET_BATCHED_UPDATES &amp;&amp; FLUSH_BATCHED_UPDATES两个事务的组合。</p>
<p>核心是事务完成后执行:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</span><br></pre></td></tr></table></figure>
<p>这里就涉及到flushBatchedUpdates了，而asap被它依赖，所以先扯一扯它。</p>
<h2 id="asap"><a href="#asap" class="headerlink" title="asap"></a>asap</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">asapCallbackQueue.enqueue(callback, context);</span><br></pre></td></tr></table></figure>

<p>这个函数核心代码只有一行。asapCallbackQueue.enqueue作用是将一个函数和其上下文推入到维护的函数队列中。</p>
<p>关于这个函数，它是一个特殊的操作，它是针对bug <a href="https://github.com/facebook/react/issues/1698">#1698</a>的解决方案。</p>
<p>它的调用主要位于表单元素Input、Select和TextArea的_handleChange函数中,主要调用是<code>ReactUpdates.asap(forceUpdateIfMounted, this);</code>,用于在事务close外添加一个给CallbackQueue队列进行入队的操作，以图实现最快进行更新。</p>
<h2 id="flushBatchedUpdates"><a href="#flushBatchedUpdates" class="headerlink" title="flushBatchedUpdates"></a>flushBatchedUpdates</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flushBatchedUpdates = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ReactUpdatesFlushTransaction&#x27;s wrappers will clear the dirtyComponents</span></span><br><span class="line">  <span class="comment">// array and perform any updates enqueued by mount-ready handlers (i.e.,</span></span><br><span class="line">  <span class="comment">// componentDidUpdate) but we need to check here too in order to catch</span></span><br><span class="line">  <span class="comment">// updates enqueued by setState callbacks and asap calls.</span></span><br><span class="line">  <span class="keyword">while</span> (dirtyComponents.length || asapEnqueued) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirtyComponents.length) &#123;</span><br><span class="line">      <span class="keyword">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">      transaction.perform(runBatchedUpdates, <span class="literal">null</span>, transaction);</span><br><span class="line">      ReactUpdatesFlushTransaction.release(transaction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (asapEnqueued) &#123;</span><br><span class="line">      asapEnqueued = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">var</span> queue = asapCallbackQueue;</span><br><span class="line">      asapCallbackQueue = CallbackQueue.getPooled();</span><br><span class="line">      queue.notifyAll();</span><br><span class="line">      CallbackQueue.release(queue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其一-对象池"><a href="#其一-对象池" class="headerlink" title="其一 对象池"></a>其一 对象池</h3><p>这里先关注dirtyComponents这一截。</p>
<p>这里对dirtyComponents进行了遍历，如果没有对象池处理，每次遍历过程中的更新都会重新new一个ReactUpdatesFlushTransaction事务，然后重新销毁。但是这里有了事务之后就可以直接getPooled()，用完之后可以使用release缓存，这样对象池里面就是一个初始化状态的实例。</p>
<p>当然提到release这个过程显然跑不了查看一下实例上的<code>destructor</code>——<code>transaction.release</code>环节会执行这个函数。它实质上是调用<code>instance.destructor()</code>后将instance压入到对象池方便后面<code>getPooled</code>获取。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">destructor: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.dirtyComponentsLength = <span class="literal">null</span>;</span><br><span class="line">  CallbackQueue.release(<span class="built_in">this</span>.callbackQueue);</span><br><span class="line">  <span class="built_in">this</span>.callbackQueue = <span class="literal">null</span>;</span><br><span class="line">  ReactUpdates.ReactReconcileTransaction.release(<span class="built_in">this</span>.reconcileTransaction);</span><br><span class="line">  <span class="built_in">this</span>.reconcileTransaction = <span class="literal">null</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>对照一下其构造器:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactUpdatesFlushTransaction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.reinitializeTransaction();</span><br><span class="line">  <span class="built_in">this</span>.dirtyComponentsLength = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.callbackQueue = CallbackQueue.getPooled();</span><br><span class="line">  <span class="built_in">this</span>.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(</span><br><span class="line">    <span class="comment">/* useCreateElement */</span> <span class="literal">true</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很容易发现这两个操作除了dirtyComponentsLength赋值外都是反向操作。很有意思的是他们里面也有一个CallbackQueue的getPooled和release过程。这里<strong>需要主要就是对象池的操作了，<code>release</code>执行时候会执行instance.destructor使实例进入初始化环境放到对象池，<code>getPooled</code>获取的时候回重新执行一次构造器。</strong></p>
<p>除此以外就是runBatchedUpdates函数的执行了。</p>
<h3 id="其二-ReactUpdatesFlushTransaction事务"><a href="#其二-ReactUpdatesFlushTransaction事务" class="headerlink" title="其二 ReactUpdatesFlushTransaction事务"></a>其二 ReactUpdatesFlushTransaction事务</h3><p>ReactUpdatesFlushTransaction事务是<code>NESTED_UPDATES</code> 和<code>UPDATE_QUEUEING</code>的组合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> NESTED_UPDATES = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.dirtyComponentsLength = dirtyComponents.length;</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.dirtyComponentsLength !== dirtyComponents.length) &#123;</span><br><span class="line">      <span class="comment">// Additional updates were enqueued by componentDidUpdate handlers or</span></span><br><span class="line">      <span class="comment">// similar; before our own UPDATE_QUEUEING wrapper closes, we want to run</span></span><br><span class="line">      <span class="comment">// these new updates so that if A&#x27;s componentDidUpdate calls setState on</span></span><br><span class="line">      <span class="comment">// B, B will update before the callback A&#x27;s updater provided when calling</span></span><br><span class="line">      <span class="comment">// setState.</span></span><br><span class="line">      dirtyComponents.splice(<span class="number">0</span>, <span class="built_in">this</span>.dirtyComponentsLength);</span><br><span class="line">      flushBatchedUpdates();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dirtyComponents.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> UPDATE_QUEUEING = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.callbackQueue.reset();</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.callbackQueue.notifyAll();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>UPDATE_QUEUEING</code>比较简单，初始化时候清空队列中的回调和context，事务结束时候则按上下文调用所有回调。</p>
<p><code>NESTED_UPDATES</code>相对复杂一点。初始化时候缓存<code>dirtyComponents.length</code>到<code>dirtyComponentsLength</code>,事务结束时候检查缓存的长度值和当前<code>dirtyComponents.length</code>是否相等，相等则清空<code>dirtyComponents</code>,否则在<code>dirtyComponents</code>里面移除已经更新好的，重新执行<code>flushBatchedUpdates</code>来继续更新后续加入的组件，这是一个递归操作直到<code>dirtyComponents.length === 0</code>。这个一般发生在父组件更新导致子组件联动更新上。</p>
<h2 id="runBatchedUpdates"><a href="#runBatchedUpdates" class="headerlink" title="runBatchedUpdates"></a>runBatchedUpdates</h2><p>这个函数没有导出使用，但是在内部则实质上承担了调用组件的更新逻辑职责。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runBatchedUpdates</span>(<span class="params">transaction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = transaction.dirtyComponentsLength;</span><br><span class="line">  invariant(</span><br><span class="line">    len === dirtyComponents.length,</span><br><span class="line">    <span class="string">&quot;Expected flush transaction&#x27;s stored dirty-components length (%s) to &quot;</span> +</span><br><span class="line">      <span class="string">&#x27;match dirty-components array length (%s).&#x27;</span>,</span><br><span class="line">    len,</span><br><span class="line">    dirtyComponents.length,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Since reconciling a component higher in the owner hierarchy usually (not</span></span><br><span class="line">  <span class="comment">// always -- see shouldComponentUpdate()) will reconcile children, reconcile</span></span><br><span class="line">  <span class="comment">// them before their children by sorting the array.</span></span><br><span class="line">  dirtyComponents.sort(mountOrderComparator);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Any updates enqueued while reconciling must be performed after this entire</span></span><br><span class="line">  <span class="comment">// batch. Otherwise, if dirtyComponents is [A, B] where A has children B and</span></span><br><span class="line">  <span class="comment">// C, B could update twice in a single batch if C&#x27;s render enqueues an update</span></span><br><span class="line">  <span class="comment">// to B (since B would have already updated, we should skip it, and the only</span></span><br><span class="line">  <span class="comment">// way we can know to do so is by checking the batch counter).</span></span><br><span class="line">  updateBatchNumber++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// If a component is unmounted before pending changes apply, it will still</span></span><br><span class="line">    <span class="comment">// be here, but we assume that it has cleared its _pendingCallbacks and</span></span><br><span class="line">    <span class="comment">// that performUpdateIfNecessary is a noop.</span></span><br><span class="line">    <span class="keyword">var</span> component = dirtyComponents[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If performUpdateIfNecessary happens to enqueue any new updates, we</span></span><br><span class="line">    <span class="comment">// shouldn&#x27;t execute the callbacks until the next render happens, so</span></span><br><span class="line">    <span class="comment">// stash the callbacks first</span></span><br><span class="line">    <span class="keyword">var</span> callbacks = component._pendingCallbacks;</span><br><span class="line">    component._pendingCallbacks = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> markerName;</span><br><span class="line">    <span class="keyword">if</span> (ReactFeatureFlags.logTopLevelRenders) &#123;</span><br><span class="line">      <span class="keyword">var</span> namedComponent = component;</span><br><span class="line">      <span class="comment">// Duck type TopLevelWrapper. This is probably always true.</span></span><br><span class="line">      <span class="keyword">if</span> (component._currentElement.type.isReactTopLevelWrapper) &#123;</span><br><span class="line">        namedComponent = component._renderedComponent;</span><br><span class="line">      &#125;</span><br><span class="line">      markerName = <span class="string">&#x27;React update: &#x27;</span> + namedComponent.getName();</span><br><span class="line">      <span class="built_in">console</span>.time(markerName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReactReconciler.performUpdateIfNecessary(</span><br><span class="line">      component,</span><br><span class="line">      transaction.reconcileTransaction,</span><br><span class="line">      updateBatchNumber,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (markerName) &#123;</span><br><span class="line">      <span class="built_in">console</span>.timeEnd(markerName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callbacks) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; callbacks.length; j++) &#123;</span><br><span class="line">        transaction.callbackQueue.enqueue(</span><br><span class="line">          callbacks[j],</span><br><span class="line">          component.getPublicInstance(),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数里面主要就是个嵌套遍历过程，第一层先遍历dirtyComponents对每个component调用ReactReconciler.performUpdateIfNecessary，然后第二层对当前component前期没有更新的callbacks进行遍历执行。</p>
<p>ReactReconciler.performUpdateIfNecessary主要是判断当前component._updateBatchNumber和updateBatchNumber是否相等 不相等直接退出，否则调用当前component自身performUpdateIfNecessary进行更新。</p>
<p><strong>这个不相等直接退出是什么意思呢</strong>？假设dirtyComponents中队列为[A, B], 但是它们结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     +------+</span><br><span class="line">     |  A   |</span><br><span class="line">   +---------+</span><br><span class="line">   |         |</span><br><span class="line">+-----+  +------+</span><br><span class="line">|  B  |  |  C   |</span><br><span class="line">+-----+  +------+</span><br></pre></td></tr></table></figure>

<p>此时B会触发2次更新，显然这是一个重复的操作，那么问题是两次更新，抛弃哪一个更新呢？</p>
<p>这里仔细想一想react更新流程，很容易明白，当dirtyComponents进行操作维护的时候，基本都是处于正在更新中否则会直接进行更新，直到更新结束时候才会进行批处理对dirtyComponents中component进行更新。</p>
<p>当我们dirtyComponents中队列为[A, B]时候，相关的callback|state都已经在这个时间段中收集完毕了，不会出现更新过程中突然新加入一些callback|state的情况。</p>
<p>React在进行dirtyComponents更新时候会采用队列中第一次更新，而抛弃队列中后续相同组件的更新。</p>
<h2 id="enqueueUpdate-1"><a href="#enqueueUpdate-1" class="headerlink" title="enqueueUpdate"></a>enqueueUpdate</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Various parts of our code (such as ReactCompositeComponent&#x27;s</span></span><br><span class="line">  <span class="comment">// _renderValidatedComponent) assume that calls to render aren&#x27;t nested;</span></span><br><span class="line">  <span class="comment">// verify that that&#x27;s the case. (This is called by each top-level update</span></span><br><span class="line">  <span class="comment">// function, like setState, forceUpdate, etc.; creation and</span></span><br><span class="line">  <span class="comment">// destruction of top-level components is guarded in ReactMount.)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">  <span class="keyword">if</span> (component._updateBatchNumber == <span class="literal">null</span>) &#123;</span><br><span class="line">    component._updateBatchNumber = updateBatchNumber + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是一个入队操作。</p>
<p>如果当前没有处于更新过程中，那么直接进行更新(<code>batchingStrategy.batchedUpdates(enqueueUpdate, component)</code>)不加入<code>dirtyComponents</code>。</p>
<p>否则将需要更新的component压入到<code>dirtyComponents</code>,并设置<code>component._updateBatchNumber</code>。</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React PooledClass</title>
    <url>/2019/06/15/react-PooledClass/</url>
    <content><![CDATA[<h1 id="PooledClass用途"><a href="#PooledClass用途" class="headerlink" title="PooledClass用途"></a>PooledClass用途</h1><p>PooledClass在整个react运作流程中用处很多。前面分析各个模块时候都曾遇到过。</p>
<p>例如ReactUpdates.js中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);</span><br></pre></td></tr></table></figure>

<p>例如ReactReconcileTransaction.js中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">PooledClass.addPoolingTo(ReactReconcileTransaction);</span><br></pre></td></tr></table></figure>

<p>例如CallbackQueue.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = PooledClass.addPoolingTo(CallbackQueue);</span><br></pre></td></tr></table></figure>

<p>用到的地方确实不少。有些是事务上，也有一些是Class(这里应该算是一个工厂函数)上。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addPoolingTo = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  CopyConstructor: Class&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pooler: Pooler,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Class</span>&lt;<span class="title">T</span>&gt; &amp; </span>&#123;</span><br><span class="line">  getPooled(): <span class="comment">/* arguments of the constructor */</span> T,</span><br><span class="line">  release(): <span class="keyword">void</span>,</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="comment">// Casting as any so that flow ignores the actual implementation and trusts</span></span><br><span class="line">  <span class="comment">// it to match the type we declared</span></span><br><span class="line">  <span class="keyword">var</span> NewKlass = (CopyConstructor: any);</span><br><span class="line">  NewKlass.instancePool = [];</span><br><span class="line">  NewKlass.getPooled = pooler || DEFAULT_POOLER;</span><br><span class="line">  <span class="keyword">if</span> (!NewKlass.poolSize) &#123;</span><br><span class="line">    NewKlass.poolSize = DEFAULT_POOL_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  NewKlass.release = standardReleaser;</span><br><span class="line">  <span class="keyword">return</span> NewKlass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里注意函数传参后的处理就可以了，当CopyConstructor作为参数传入时候会复制一份引用，此时函数内的NewClass和CopyConstructor其实是两个独立的变量，但由于是引用类型所以指向了同一份引用，所以当修改时候这个引用会被修改，这样最终会导致CopyConstructor引用的变量也会变化。这就是<strong>call by sharing</strong>。</p>
<p>这个函数是有返回值的，但是这里需要注意这个返回值最后和CopyConstructor引用了同一份引用，所以捕获不捕获这个返回值其实没有任何区别。</p>
<p>当然addPoolingTo只是一个简单的加工函数，它给CopyConstructor添加了一个属性两个方法。</p>
<table>
<thead>
<tr>
<th>属性or方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>instancePool</td>
<td>Array 实例池</td>
</tr>
<tr>
<td>getPooled</td>
<td>Method 从实例池获取实例</td>
</tr>
<tr>
<td>release</td>
<td>Method</td>
</tr>
</tbody></table>
<p>默认情况下NewKlass.getPooled指向oneArgumentPooler</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oneArgumentPooler = <span class="function"><span class="keyword">function</span> (<span class="params">copyFieldsFrom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Klass = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (Klass.instancePool.length) &#123;</span><br><span class="line">    <span class="keyword">var</span> instance = Klass.instancePool.pop();</span><br><span class="line">    Klass.call(instance, copyFieldsFrom);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Klass(copyFieldsFrom);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时oneArgumentPooler作为NewKlass方法指向NewKlass本身。</p>
<p>这个函数的意义在于，会对instancePool做检查，如果instancePool(实例池)里面有东西那么就把最后一个拿出来用，否则新new一个实例。</p>
<p>release指向了standardReleaser</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> standardReleaser = <span class="function"><span class="keyword">function</span> (<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Klass = <span class="built_in">this</span>;</span><br><span class="line">  !(instance <span class="keyword">instanceof</span> Klass) ? process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> ? invariant(<span class="literal">false</span>, <span class="string">&#x27;Trying to release an instance into a pool of a different type.&#x27;</span>) : _prodInvariant(<span class="string">&#x27;25&#x27;</span>) : <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">  instance.destructor();</span><br><span class="line">  <span class="keyword">if</span> (Klass.instancePool.length &lt; Klass.poolSize) &#123;</span><br><span class="line">    Klass.instancePool.push(instance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它会调用CopyConstructor.destructor方法，然后将Klass压到对象池内。一般来说此时Klass就是一个空白的实例。当后面哪一次再次调用getPooled它会直接从对象池中返回这个实例而不去new新的返回。</p>
<p>以CallbackQueue为例。首先它返回一个CallbackQueue构造器，它的原型上有destructor方法。</p>
<p>当执行addPoolingTo后，它就加上了<code>instancePool、getPooled、release</code>属性或者方法。</p>
<p>第一次执行getPooled它会new CallbackQueue构造器(此处设赋值给instance)。如果在这之后再次对这个实例执行CallbackQueue.release(instance)，那么就会被推入到对象池，下次再次getPooled就会直接从对象池里面获取这个实例。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>那么现在的问题很明显，究竟是为什么要做这个机制呢？</p>
<p>观察这个PooledClass包装后的结果的引用位置，会发现基本都是在事务环节。而事务环节有大量的清场、还原现场的需求，而它本身更是存在被频繁触发的可能。所以这里就有了一个缓存的需要。这是PooledClass存在的意义所在。</p>
<p>为了印证这个想法，我把批量更新到函数找了出来 flushBatchedUpdates(ReactUpdates.js)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flushBatchedUpdates = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ReactUpdatesFlushTransaction&#x27;s wrappers will clear the dirtyComponents</span></span><br><span class="line">  <span class="comment">// array and perform any updates enqueued by mount-ready handlers (i.e.,</span></span><br><span class="line">  <span class="comment">// componentDidUpdate) but we need to check here too in order to catch</span></span><br><span class="line">  <span class="comment">// updates enqueued by setState callbacks and asap calls.</span></span><br><span class="line">  <span class="keyword">while</span> (dirtyComponents.length || asapEnqueued) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirtyComponents.length) &#123;</span><br><span class="line">      <span class="keyword">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">      transaction.perform(runBatchedUpdates, <span class="literal">null</span>, transaction);</span><br><span class="line">      ReactUpdatesFlushTransaction.release(transaction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (asapEnqueued) &#123;</span><br><span class="line">      asapEnqueued = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">var</span> queue = asapCallbackQueue;</span><br><span class="line">      asapCallbackQueue = CallbackQueue.getPooled();</span><br><span class="line">      queue.notifyAll();</span><br><span class="line">      CallbackQueue.release(queue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很显然，这里对dirtyComponents进行了遍历，如果没有对象池处理，每次遍历过程中的更新都会重新new一个事务，然后重新销毁。但是这里有了事务之后就可以直接getPooled()用完之后release，这样对象池里面就是一个初始化状态的实例。提到初始化这个过程显然跑不了查看一下事务上的destructor(transaction.release环节会执行这个函数):</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">destructor: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.dirtyComponentsLength = <span class="literal">null</span>;</span><br><span class="line">  CallbackQueue.release(<span class="built_in">this</span>.callbackQueue);</span><br><span class="line">  <span class="built_in">this</span>.callbackQueue = <span class="literal">null</span>;</span><br><span class="line">  ReactUpdates.ReactReconcileTransaction.release(<span class="built_in">this</span>.reconcileTransaction);</span><br><span class="line">  <span class="built_in">this</span>.reconcileTransaction = <span class="literal">null</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>对照一下其构造器:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactUpdatesFlushTransaction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.reinitializeTransaction();</span><br><span class="line">  <span class="built_in">this</span>.dirtyComponentsLength = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.callbackQueue = CallbackQueue.getPooled();</span><br><span class="line">  <span class="built_in">this</span>.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(</span><br><span class="line">    <span class="comment">/* useCreateElement */</span> <span class="literal">true</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很容易发现这两个反向操作。很有意思的是他们里面也有一个CallbackQueue的getPooled和release过程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>getPooled<strong>其实是基于React事务需要频繁new和销毁的需要</strong>构建的抽象对象池逻辑，以达到节省性能和内存支出的目的。</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React ReactDOMComponentTree</title>
    <url>/2019/06/15/react-ReactDOMComponentTree/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>ReactDOMComponentTree主要是对DOM Node 和 ConponentInst做一些映射，不过这个映射不通过Map结构来处理，而是通过在它们自身上面挂载属性做缓存的方式来实现。</p>
<p>这样当给出一个DOM Node 或者 ConponentInst时候 就可以对应给出它们对应的DOM Node 或者 ConponentInst了。</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getClosestInstanceFromNode</td>
<td>根据传入的DOM Node返回临近的(实际上是往上找)ReactDOMComponent or ReactDOMTextComponent</td>
</tr>
<tr>
<td>getInstanceFromNode</td>
<td>根据传入的DOM Node返回对应的ReactDOMComponent or ReactDOMTextComponent实例 可能返回null</td>
</tr>
<tr>
<td>getNodeFromInstance</td>
<td>根据传入的组件实例获得对应的DOM Node</td>
</tr>
<tr>
<td>precacheChildNodes</td>
<td>为所有的子节点实例添加_hostNode属性进行缓存, 这个缓存操作是双向的</td>
</tr>
<tr>
<td>precacheNode</td>
<td>使用给定的DOM node填充在给定的实例的_hostNode属性上</td>
</tr>
<tr>
<td>uncacheNode</td>
<td>将给定实例的_hostNode设为null</td>
</tr>
</tbody></table>
<p>这之前，需要先弄清楚，DOM Node和Instance是什么。DOM Node这个不提默认大家知道，Instance这个，可以参见instantiateReactComponent返回的几种实例。</p>
<h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><h2 id="getRenderedHostOrTextFromComponent"><a href="#getRenderedHostOrTextFromComponent" class="headerlink" title="getRenderedHostOrTextFromComponent"></a>getRenderedHostOrTextFromComponent</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRenderedHostOrTextFromComponent</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> rendered;</span><br><span class="line">  <span class="keyword">while</span> ((rendered = component._renderedComponent)) &#123;</span><br><span class="line">    component = rendered;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数被导出多个方法调用到。它的作用是从给定的component(自定义组件或者空组件)一直向下钻，直到获取到一个<code>component._renderedComponent === void 0</code>的组件并返回(如果一开始就满足这个条件就直接返回了传入的componet)。这个过程中如果component上已经有<code>_renderedComponent</code>那么它会被赋值给component并再次重复这个步骤。</p>
<h2 id="precacheNode"><a href="#precacheNode" class="headerlink" title="precacheNode"></a>precacheNode</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">precacheNode</span>(<span class="params">inst, node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hostInst = getRenderedHostOrTextFromComponent(inst);</span><br><span class="line">  hostInst._hostNode = node;</span><br><span class="line">  node[internalInstanceKey] = hostInst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码就三行，但是这里做了三件事:</p>
<ul>
<li>获取hostInst 从inst上一直往下钻获取_renderedComponent 参见上面的分析</li>
<li>在实例上绑定<strong>_hostNode</strong>将其设为DOM Node</li>
<li>在DOM Node上将inst使用<strong>internalInstanceKey</strong>做key挂载好</li>
</ul>
<p>所以这里的缓存是两步: 在DOM Node上缓存inst的同时也在实例上缓存了DOM Node</p>
<h2 id="uncacheNode"><a href="#uncacheNode" class="headerlink" title="uncacheNode"></a>uncacheNode</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uncacheNode</span>(<span class="params">inst</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = inst._hostNode;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="keyword">delete</span> node[internalInstanceKey];</span><br><span class="line">    inst._hostNode = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>precacheNode的反向操作。双向解绑。</p>
<h2 id="precacheChildNodes"><a href="#precacheChildNodes" class="headerlink" title="precacheChildNodes"></a>precacheChildNodes</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">precacheChildNodes</span>(<span class="params">inst, node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (inst._flags &amp; Flags.hasCachedChildNodes) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> children = inst._renderedChildren;</span><br><span class="line">  <span class="keyword">var</span> childNode = node.firstChild;</span><br><span class="line">  outer: <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> children) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!children.hasOwnProperty(name)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> childInst = children[name];</span><br><span class="line">    <span class="keyword">var</span> childID = getRenderedHostOrTextFromComponent(childInst)._domID;</span><br><span class="line">    <span class="keyword">if</span> (childID === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// We&#x27;re currently unmounting this child in ReactMultiChild; skip it.</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We assume the child nodes are in the same order as the child instances.</span></span><br><span class="line">    <span class="keyword">for</span> (; childNode !== <span class="literal">null</span>; childNode = childNode.nextSibling) &#123;</span><br><span class="line">      <span class="keyword">if</span> (shouldPrecacheNode(childNode, childID)) &#123;</span><br><span class="line">        precacheNode(childInst, childNode);</span><br><span class="line">        <span class="keyword">continue</span> outer;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We reached the end of the DOM children without finding an ID match.</span></span><br><span class="line">    invariant(<span class="literal">false</span>, <span class="string">&#x27;Unable to find element with ID %s.&#x27;</span>, childID);</span><br><span class="line">  &#125;</span><br><span class="line">  inst._flags |= Flags.hasCachedChildNodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数用处是遍历所有下级children并为其调用precacheNode进行缓存。</p>
<p>这个遍历是遍历当前实例下一级且只有这一级的children。缓存完毕之后更新<code>_flags</code>,这里的运算是位或运算，只要<code>inst._flags、Flags.hasCachedChildNodes</code>之一为1那么为1，否则同时为0就为0.</p>
<p>这个缓存过程是为了避免算法纬度达到<code>n^2</code>。</p>
<p>这里注释里面提到这里代码存在的BUG: <code>inst._renderedChildren</code>更新和这里的缓存会存在赛跑问题,所以更改它之前会调用<code>prepareToManageChildren</code>来避免这种情况。不过就当前观察的版本15.6.2来说这个函数已经被移除了。后面会分析一下当前版本是怎样做的。</p>
<h2 id="getClosestInstanceFromNode"><a href="#getClosestInstanceFromNode" class="headerlink" title="getClosestInstanceFromNode"></a>getClosestInstanceFromNode</h2><p>这个函数逻辑有些小绕。它的逻辑是:</p>
<ul>
<li>判断传入的DOM Node是否已经挂载internalInstanceKey属性，有则返回 否则下一步</li>
<li>一直往上找自己的父元素，直到找到一个已经被缓存internalInstanceKey属性的父元素</li>
<li>返回这个找到的元素，如果之前向上溯源超过两级就使用<code>precacheChildNodes(inst, node)</code>对这个元素的child进行缓存操作</li>
</ul>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react-route</title>
    <url>/2019/06/15/react-route/</url>
    <content><![CDATA[<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>之前有过分析react大体的渲染和更新，这里再次看看react配套的react-router是如何实现其路由系统的。</p>
<p>下面是一个react-router使用的简单例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Route exact path=<span class="string">&quot;/&quot;</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;/news&quot;</span> component=&#123;NewsFeed&#125;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure>

<h1 id="简要分析"><a href="#简要分析" class="headerlink" title="简要分析"></a>简要分析</h1><p>BrowserRouter组件代码:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserRouter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    basename: PropTypes.string,</span><br><span class="line">    forceRefresh: PropTypes.bool,</span><br><span class="line">    getUserConfirmation: PropTypes.func,</span><br><span class="line">    keyLength: PropTypes.number,</span><br><span class="line">    children: PropTypes.node</span><br><span class="line">  &#125;;</span><br><span class="line">  history = createHistory(<span class="built_in">this</span>.props);</span><br><span class="line">  <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    warning(</span><br><span class="line">      !<span class="built_in">this</span>.props.history,</span><br><span class="line">      <span class="string">&quot;&lt;BrowserRouter&gt; ignores the history prop. To use a custom history, &quot;</span> +</span><br><span class="line">        <span class="string">&quot;use `import &#123; Router &#125;` instead of `import &#123; BrowserRouter as Router &#125;`.&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;this.history&#125;</span> <span class="attr">children</span>=<span class="string">&#123;this.props.children&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>BrowserRouter</code>组件返回<code>Router</code>组件，带了<code>history &amp;&amp; children</code>两个props。</p>
<p>Router组件代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    history: PropTypes.object.isRequired,</span><br><span class="line">    children: PropTypes.node</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.object</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    router: PropTypes.object.isRequired</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      router: &#123;</span><br><span class="line">        ...this.context.router,</span><br><span class="line">        history: <span class="built_in">this</span>.props.history,</span><br><span class="line">        route: &#123;</span><br><span class="line">          location: <span class="built_in">this</span>.props.history.location,</span><br><span class="line">          match: <span class="built_in">this</span>.state.match</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    match: <span class="built_in">this</span>.computeMatch(<span class="built_in">this</span>.props.history.location.pathname)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">computeMatch</span>(<span class="params">pathname</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      path: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">      url: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">      params: &#123;&#125;,</span><br><span class="line">      isExact: pathname === <span class="string">&quot;/&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children, history &#125; = <span class="built_in">this</span>.props;</span><br><span class="line"></span><br><span class="line">    invariant(</span><br><span class="line">      children == <span class="literal">null</span> || React.Children.count(children) === <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;A &lt;Router&gt; may have only one child element&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.unlisten = history.listen(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        match: <span class="built_in">this</span>.computeMatch(history.location.pathname)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span> &#123;</span><br><span class="line">    warning(</span><br><span class="line">      <span class="built_in">this</span>.props.history === nextProps.history,</span><br><span class="line">      <span class="string">&quot;You cannot change &lt;Router history&gt;&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.unlisten();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> children ? React.Children.only(children) : <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Router这块的render没有太多内容，仅仅是判定children里面的仅有一个有效，这样返回这个Route，否则就会返回null。</p>
<p>但是这里有一个特别重要的定义<code>getChildContext</code>,他就是传说中的<code>context</code>,一个几乎所有流行库都在用，但是自己业务逻辑上可能永远都用不到的设定。</p>
<p>当它设定了这个<code>getChildContext</code>之后，其所有子组件都可以访问到里面的这个对象。这里需要注意的是，当设定好了这个，那么<code>childContextTypes</code>的设定，也就是必不可少的了。</p>
<p>Route组件代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    computedMatch: PropTypes.object, <span class="comment">// private, from &lt;Switch&gt;</span></span><br><span class="line">    path: PropTypes.string,</span><br><span class="line">    exact: PropTypes.bool,</span><br><span class="line">    strict: PropTypes.bool,</span><br><span class="line">    sensitive: PropTypes.bool,</span><br><span class="line">    component: PropTypes.func,</span><br><span class="line">    render: PropTypes.func,</span><br><span class="line">    children: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),</span><br><span class="line">    location: PropTypes.object</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.shape(&#123;</span><br><span class="line">      history: PropTypes.object.isRequired,</span><br><span class="line">      route: PropTypes.object.isRequired,</span><br><span class="line">      staticContext: PropTypes.object</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    router: PropTypes.object.isRequired</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      router: &#123;</span><br><span class="line">        ...this.context.router,</span><br><span class="line">        route: &#123;</span><br><span class="line">          location: <span class="built_in">this</span>.props.location || <span class="built_in">this</span>.context.router.route.location,</span><br><span class="line">          match: <span class="built_in">this</span>.state.match</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    match: <span class="built_in">this</span>.computeMatch(<span class="built_in">this</span>.props, <span class="built_in">this</span>.context.router)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  computeMatch(</span><br><span class="line">    &#123; computedMatch, location, path, strict, exact, sensitive &#125;,</span><br><span class="line">    router</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (computedMatch) <span class="keyword">return</span> computedMatch; <span class="comment">// &lt;Switch&gt; already computed the match for us</span></span><br><span class="line">    <span class="keyword">const</span> &#123; route &#125; = router;</span><br><span class="line">    <span class="keyword">const</span> pathname = (location || route.location).pathname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> matchPath(pathname, &#123; path, strict, exact, sensitive &#125;, route.match);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps, nextContext</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      match: <span class="built_in">this</span>.computeMatch(nextProps, nextContext.router)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; match &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> &#123; children, component, render &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; history, route, staticContext &#125; = <span class="built_in">this</span>.context.router;</span><br><span class="line">    <span class="keyword">const</span> location = <span class="built_in">this</span>.props.location || route.location;</span><br><span class="line">    <span class="keyword">const</span> props = &#123; match, location, history, staticContext &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (component) <span class="keyword">return</span> match ? React.createElement(component, props) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (render) <span class="keyword">return</span> match ? render(props) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> children === <span class="string">&quot;function&quot;</span>) <span class="keyword">return</span> children(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (children &amp;&amp; !isEmptyChildren(children))</span><br><span class="line">      <span class="keyword">return</span> React.Children.only(children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要的更新流程是这样的:</p>
<ul>
<li><code>Router</code>设定<code>getChildContext</code>,然后使用观察者模式(<code>history.listen</code>)调用state更新。而state更新之后，我们<code>getChildContext</code>返回的<code>context</code>也会随之变更，并触发updates流程</li>
<li><code>Route</code>组件收到更新通知后<code>componentWillReceiveProps</code>里面同样也会触发这个<code>getChildContext</code>返回值的变更并触发下级的更新。</li>
</ul>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>router的使用大致是有两周，一种是组件<code>Link</code>式跳转，一种是编程式跳转。</p>
<h2 id="Link跳转"><a href="#Link跳转" class="headerlink" title="Link跳转"></a>Link跳转</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> invariant <span class="keyword">from</span> <span class="string">&quot;invariant&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createLocation &#125; <span class="keyword">from</span> <span class="string">&quot;history&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    onClick: PropTypes.func,</span><br><span class="line">    target: PropTypes.string,</span><br><span class="line">    replace: PropTypes.bool,</span><br><span class="line">    to: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired,</span><br><span class="line">    innerRef: PropTypes.oneOfType([PropTypes.string, PropTypes.func])</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    replace: <span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.shape(&#123;</span><br><span class="line">      history: PropTypes.shape(&#123;</span><br><span class="line">        push: PropTypes.func.isRequired,</span><br><span class="line">        replace: PropTypes.func.isRequired,</span><br><span class="line">        createHref: PropTypes.func.isRequired</span><br><span class="line">      &#125;).isRequired</span><br><span class="line">    &#125;).isRequired</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.props.onClick) <span class="built_in">this</span>.props.onClick(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !event.defaultPrevented &amp;&amp; <span class="comment">// onClick prevented default</span></span><br><span class="line">      event.button === <span class="number">0</span> &amp;&amp; <span class="comment">// ignore everything but left clicks</span></span><br><span class="line">      !<span class="built_in">this</span>.props.target &amp;&amp; <span class="comment">// let browser handle &quot;target=_blank&quot; etc.</span></span><br><span class="line">      !isModifiedEvent(event) <span class="comment">// ignore clicks with modifier keys</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; history &#125; = <span class="built_in">this</span>.context.router;</span><br><span class="line">      <span class="keyword">const</span> &#123; replace, to &#125; = <span class="built_in">this</span>.props;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">        history.replace(to);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        history.push(to);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; replace, to, innerRef, ...props &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; history &#125; = <span class="built_in">this</span>.context.router;</span><br><span class="line">    <span class="keyword">const</span> location =</span><br><span class="line">      <span class="keyword">typeof</span> to === <span class="string">&quot;string&quot;</span></span><br><span class="line">        ? createLocation(to, <span class="literal">null</span>, <span class="literal">null</span>, history.location)</span><br><span class="line">        : to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> href = history.createHref(location);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;a &#123;...props&#125; onClick=&#123;<span class="built_in">this</span>.handleClick&#125; href=&#123;href&#125; ref=&#123;innerRef&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Link;</span><br></pre></td></tr></table></figure>

<p>这里可以看出，<code>Link</code>实质上是捕获了<code>context.router</code>,直接调用的<code>context.router.history.push &amp;&amp; context.router.history.replace</code>进行跳转。</p>
<h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>编程式导航也可以很容易理解。当我们做了一个交互，满足一定条件使用代码来跳转。</p>
<p>本质上，他还是对<code>context.router.history</code>的方法的引用。</p>
<p>不过这里一般可以使用<code>withRouter</code>来对组件进行包裹(如果还有redux那么<code>withRouter(connect(...)(MyComponent))</code>)。<code>withRouter</code>是一个高阶组件,他给组件加上了<code>context.router</code>的引用并作为props传入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> withRouter = <span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> C = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; wrappedComponentRef, ...remainingProps &#125; = props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Route</span><br><span class="line">        children=&#123;<span class="function"><span class="params">routeComponentProps</span> =&gt;</span> (</span><br><span class="line">          &lt;Component</span><br><span class="line">            &#123;...remainingProps&#125;</span><br><span class="line">            &#123;...routeComponentProps&#125;</span><br><span class="line">            ref=&#123;wrappedComponentRef&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  C.displayName = <span class="string">`withRouter(<span class="subst">$&#123;Component.displayName || Component.name&#125;</span>)`</span>;</span><br><span class="line">  C.WrappedComponent = Component;</span><br><span class="line">  C.propTypes = &#123;</span><br><span class="line">    wrappedComponentRef: PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hoistStatics(C, Component);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后就和<code>Link</code>组件里面走一致的操作就好。</p>
<h1 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h1><p>// TODO: 需要完善一下整体脉络<br>这里暂时先这样，去年到今年留下好多文章没有发到blog，再不批量传上来可能就不会传了…</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react-redux-saga</title>
    <url>/2019/06/15/react-redux-saga/</url>
    <content><![CDATA[<h1 id="react-redux追索"><a href="#react-redux追索" class="headerlink" title="react-redux追索"></a>react-redux追索</h1><p>不管如何，react-redux是在redux的基础上的封装。</p>
<h1 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h1><p>这里确定一下版本号 这里版本号是<strong>v5.1.1</strong>。后面版本有一些变化，我们后面再看看。</p>
<p>react-redux大致上和router一样 也是走的HOC(高阶组件) &amp;&amp; context的线路。不过这里还是简单了解一下。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(rootReducer)</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/&quot;</span> component=&#123;App&#125;&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;foo&quot;</span> component=&#123;Foo&#125;/&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;bar&quot;</span> component=&#123;Bar&#125;/&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里<code>Provider</code>必须和<code>connect</code>配合使用。</p>
<p><a href="https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos">TODO例子</a></p>
<h1 id="Provider组件"><a href="#Provider组件" class="headerlink" title="Provider组件"></a>Provider组件</h1><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Children &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; storeShape, subscriptionShape &#125; <span class="keyword">from</span> <span class="string">&#x27;../utils/PropTypes&#x27;</span></span><br><span class="line"><span class="keyword">import</span> warning <span class="keyword">from</span> <span class="string">&#x27;../utils/warning&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> didWarnAboutReceivingStore = <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnAboutReceivingStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (didWarnAboutReceivingStore) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  didWarnAboutReceivingStore = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createProvider</span>(<span class="params">storeKey = <span class="string">&#x27;store&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> subscriptionKey = <span class="string">`<span class="subst">$&#123;storeKey&#125;</span>Subscription`</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; [storeKey]: <span class="built_in">this</span>[storeKey], [subscriptionKey]: <span class="literal">null</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">props, context</span>)</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>(props, context)</span><br><span class="line">          <span class="built_in">this</span>[storeKey] = props.store;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> Children.only(<span class="built_in">this</span>.props.children)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Provider.propTypes = &#123;</span><br><span class="line">        store: storeShape.isRequired,</span><br><span class="line">        children: PropTypes.element.isRequired,</span><br><span class="line">    &#125;</span><br><span class="line">    Provider.childContextTypes = &#123;</span><br><span class="line">        [storeKey]: storeShape.isRequired,</span><br><span class="line">        [subscriptionKey]: subscriptionShape,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Provider</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createProvider()</span><br></pre></td></tr></table></figure>

<p>这里的核心还是context相关的代码——<code>getChildContext</code> &amp;&amp; <code>childContextTypes</code>。这里Provider导出的是<code>createProvider()</code>。返回的就是一个初始化了的，带有名为store的context的组件。</p>
<h1 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h1><h2 id="项目使用简况"><a href="#项目使用简况" class="headerlink" title="项目使用简况"></a>项目使用简况</h2><p>看看connect在一个react-redux项目中是怎么使用的，常见的就是在Container(页面级别)对组件进行一重包装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@connect(</span><br><span class="line">  (state: RootState, ownProps): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">dashBoard</span>: state.dashBoard &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  (dispatch: Dispatch): <span class="function"><span class="params">any</span> =&gt;</span> (&#123;</span><br><span class="line">    actions: bindActionCreators(omit(dashBoardActions, <span class="string">&#x27;Type&#x27;</span>), dispatch),</span><br><span class="line">  &#125;),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">DashBoard</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">DashBoard</span>.<span class="title">Props</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>经过包装后的组件，就可以在组件内部引用到this.props.dashBoard属性，并且可以调用this.props.actions.xxxActions。</p>
<p>可以看出connect这个注解的作用，主要是第一个函数(mapStateToProps)给props挂载了函数一返回的属性，第二个函数(mapDispatchToProps)这挂载了相关的actions到props上。</p>
<hr>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>下面我们看看connect函数内容。</p>
<p><code>connect</code>最后返回的实质上是一个HOC。</p>
<h3 id="createConnect"><a href="#createConnect" class="headerlink" title="createConnect"></a>createConnect</h3><p>通过这个HOC方法，监听reduxStore，然后把下级组件需要的state(通过mapStateToProps获取)和action creator(通过mapDispatchToProps)。并绑定到wrappedComponent的props。</p>
<p>这一块的代码比较多，所以仅仅遴选最关键的逻辑节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createConnect</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  connectHOC = connectAdvanced,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapStateToPropsFactories = defaultMapStateToPropsFactories,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,</span></span></span><br><span class="line"><span class="function"><span class="params">  mergePropsFactories = defaultMergePropsFactories,</span></span></span><br><span class="line"><span class="function"><span class="params">  selectorFactory = defaultSelectorFactory</span></span></span><br><span class="line"><span class="function"><span class="params">&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    mapStateToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    mapDispatchToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    mergeProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      pure = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      areStatesEqual = strictEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">      areOwnPropsEqual = shallowEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">      areStatePropsEqual = shallowEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">      areMergedPropsEqual = shallowEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">      ...extraOptions</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125; = &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, <span class="string">&#x27;mapStateToProps&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, <span class="string">&#x27;mapDispatchToProps&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> initMergeProps = match(mergeProps, mergePropsFactories, <span class="string">&#x27;mergeProps&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> connectHOC(selectorFactory, &#123;</span><br><span class="line">      methodName: <span class="string">&#x27;connect&#x27;</span>,</span><br><span class="line">      getDisplayName: <span class="function"><span class="params">name</span> =&gt;</span> <span class="string">`Connect(<span class="subst">$&#123;name&#125;</span>)`</span>,</span><br><span class="line">      shouldHandleStateChanges: <span class="built_in">Boolean</span>(mapStateToProps),</span><br><span class="line">      initMapStateToProps,</span><br><span class="line">      initMapDispatchToProps,</span><br><span class="line">      initMergeProps,</span><br><span class="line">      pure,</span><br><span class="line">      areStatesEqual,</span><br><span class="line">      areOwnPropsEqual,</span><br><span class="line">      areStatePropsEqual,</span><br><span class="line">      areMergedPropsEqual,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createConnect()</span><br></pre></td></tr></table></figure>

<p>所以默认导出的就是<code>return function connect(...)&#123;...&#125;</code>这一块的代码。</p>
<h3 id="connectAdvanced"><a href="#connectAdvanced" class="headerlink" title="connectAdvanced"></a>connectAdvanced</h3><p>connect的操作实质指向了connectAdvanced。其代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">connectAdvanced</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  selectorFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    getDisplayName = name =&gt; <span class="string">`ConnectAdvanced(<span class="subst">$&#123;name&#125;</span>)`</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    methodName = <span class="string">&#x27;connectAdvanced&#x27;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    renderCountProp = <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    shouldHandleStateChanges = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    storeKey = <span class="string">&#x27;store&#x27;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    withRef = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    ...connectOptions</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125; = &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> subscriptionKey = storeKey + <span class="string">&#x27;Subscription&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> version = hotReloadingVersion++</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> contextTypes = &#123;</span><br><span class="line">    [storeKey]: storeShape,</span><br><span class="line">    [subscriptionKey]: subscriptionShape,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> childContextTypes = &#123;</span><br><span class="line">    [subscriptionKey]: subscriptionShape,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">wrapWithConnect</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> wrappedComponentName = WrappedComponent.displayName</span><br><span class="line">      || WrappedComponent.name</span><br><span class="line">      || <span class="string">&#x27;Component&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> displayName = getDisplayName(wrappedComponentName)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> selectorFactoryOptions = &#123;</span><br><span class="line">      ...connectOptions,</span><br><span class="line">      getDisplayName,</span><br><span class="line">      methodName,</span><br><span class="line">      renderCountProp,</span><br><span class="line">      shouldHandleStateChanges,</span><br><span class="line">      storeKey,</span><br><span class="line">      withRef,</span><br><span class="line">      displayName,</span><br><span class="line">      wrappedComponentName,</span><br><span class="line">      WrappedComponent</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* eslint-enable react/no-deprecated */</span></span><br><span class="line"></span><br><span class="line">    Connect.WrappedComponent = WrappedComponent</span><br><span class="line">    Connect.displayName = displayName</span><br><span class="line">    Connect.childContextTypes = childContextTypes</span><br><span class="line">    Connect.contextTypes = contextTypes</span><br><span class="line">    Connect.propTypes = contextTypes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hoistStatics(Connect, WrappedComponent)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而经过@connect注解后的组件，实质上是调用了connectAdvanced中返回的wrapWithConnect对组件进行了操作。</p>
<h3 id="wrapWithConnect"><a href="#wrapWithConnect" class="headerlink" title="wrapWithConnect"></a>wrapWithConnect</h3><p>hoistStatics因为涉及最终返回结果的包装处理，所以必须首先看看。<a href="https://github.com/reactjs/reactjs.org/blob/master/content/docs/higher-order-components.md">这个hoistStatics实质上是解决HOC中一个缺陷而诞生的</a>。它的作用是将被包装组件的静态属性、方法等非react属性放到HOC上去，这样被包装组件上的静态属性在HOC上也就可以正常访问了。</p>
<p>这里hoistStatics函数是将WrappedComponent上帝静态属性放到Connect组件上并返回修改后的Connect组件。这里回忆一下我们写React页面时候很多时候会设定静态的属性就很容易理解了。</p>
<h4 id="Connect组件"><a href="#Connect组件" class="headerlink" title="Connect组件"></a>Connect组件</h4><p>截下来是研究一下关键的Connect组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">props, context</span>)</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>(props, context)</span><br><span class="line"></span><br><span class="line">     <span class="built_in">this</span>.version = version</span><br><span class="line">     <span class="built_in">this</span>.state = &#123;&#125;</span><br><span class="line">     <span class="built_in">this</span>.renderCount = <span class="number">0</span></span><br><span class="line">     <span class="built_in">this</span>.store = props[storeKey] || context[storeKey]</span><br><span class="line">     <span class="built_in">this</span>.propsMode = <span class="built_in">Boolean</span>(props[storeKey])</span><br><span class="line">     <span class="built_in">this</span>.setWrappedInstance = <span class="built_in">this</span>.setWrappedInstance.bind(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">     invariant(<span class="built_in">this</span>.store,</span><br><span class="line">       <span class="string">`Could not find &quot;<span class="subst">$&#123;storeKey&#125;</span>&quot; in either the context or props of `</span> +</span><br><span class="line">       <span class="string">`&quot;<span class="subst">$&#123;displayName&#125;</span>&quot;. Either wrap the root component in a &lt;Provider&gt;, `</span> +</span><br><span class="line">       <span class="string">`or explicitly pass &quot;<span class="subst">$&#123;storeKey&#125;</span>&quot; as a prop to &quot;<span class="subst">$&#123;displayName&#125;</span>&quot;.`</span></span><br><span class="line">     )</span><br><span class="line"></span><br><span class="line">     <span class="built_in">this</span>.initSelector()</span><br><span class="line">     <span class="built_in">this</span>.initSubscription()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> subscription = <span class="built_in">this</span>.propsMode ? <span class="literal">null</span> : <span class="built_in">this</span>.subscription</span><br><span class="line">     <span class="keyword">return</span> &#123; [subscriptionKey]: subscription || <span class="built_in">this</span>.context[subscriptionKey] &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (!shouldHandleStateChanges) <span class="keyword">return</span></span><br><span class="line">     <span class="built_in">this</span>.subscription.trySubscribe()</span><br><span class="line">     <span class="built_in">this</span>.selector.run(<span class="built_in">this</span>.props)</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">this</span>.selector.shouldComponentUpdate) <span class="built_in">this</span>.forceUpdate()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.selector.run(nextProps)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.selector.shouldComponentUpdate</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">this</span>.subscription) <span class="built_in">this</span>.subscription.tryUnsubscribe()</span><br><span class="line">     <span class="built_in">this</span>.subscription = <span class="literal">null</span></span><br><span class="line">     <span class="built_in">this</span>.notifyNestedSubs = noop</span><br><span class="line">     <span class="built_in">this</span>.store = <span class="literal">null</span></span><br><span class="line">     <span class="built_in">this</span>.selector.run = noop</span><br><span class="line">     <span class="built_in">this</span>.selector.shouldComponentUpdate = <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">getWrappedInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     invariant(withRef,</span><br><span class="line">       <span class="string">`To access the wrapped instance, you need to specify `</span> +</span><br><span class="line">       <span class="string">`&#123; withRef: true &#125; in the options argument of the <span class="subst">$&#123;methodName&#125;</span>() call.`</span></span><br><span class="line">     )</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.wrappedInstance</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">setWrappedInstance</span>(<span class="params">ref</span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.wrappedInstance = ref</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">initSelector</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> sourceSelector = selectorFactory(<span class="built_in">this</span>.store.dispatch, selectorFactoryOptions)</span><br><span class="line">     <span class="built_in">this</span>.selector = makeSelectorStateful(sourceSelector, <span class="built_in">this</span>.store)</span><br><span class="line">     <span class="built_in">this</span>.selector.run(<span class="built_in">this</span>.props)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">initSubscription</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (!shouldHandleStateChanges) <span class="keyword">return</span></span><br><span class="line">     <span class="keyword">const</span> parentSub = (<span class="built_in">this</span>.propsMode ? <span class="built_in">this</span>.props : <span class="built_in">this</span>.context)[subscriptionKey]</span><br><span class="line">     <span class="built_in">this</span>.subscription = <span class="keyword">new</span> Subscription(<span class="built_in">this</span>.store, parentSub, <span class="built_in">this</span>.onStateChange.bind(<span class="built_in">this</span>))</span><br><span class="line">     <span class="built_in">this</span>.notifyNestedSubs = <span class="built_in">this</span>.subscription.notifyNestedSubs.bind(<span class="built_in">this</span>.subscription)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">onStateChange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.selector.run(<span class="built_in">this</span>.props)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!<span class="built_in">this</span>.selector.shouldComponentUpdate) &#123;</span><br><span class="line">       <span class="built_in">this</span>.notifyNestedSubs()</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.componentDidUpdate = <span class="built_in">this</span>.notifyNestedSubsOnComponentDidUpdate</span><br><span class="line">       <span class="built_in">this</span>.setState(dummyState)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">notifyNestedSubsOnComponentDidUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.componentDidUpdate = <span class="literal">undefined</span></span><br><span class="line">     <span class="built_in">this</span>.notifyNestedSubs()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">isSubscribed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Boolean</span>(<span class="built_in">this</span>.subscription) &amp;&amp; <span class="built_in">this</span>.subscription.isSubscribed()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">addExtraProps</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (!withRef &amp;&amp; !renderCountProp &amp;&amp; !(<span class="built_in">this</span>.propsMode &amp;&amp; <span class="built_in">this</span>.subscription)) <span class="keyword">return</span> props</span><br><span class="line">     <span class="keyword">const</span> withExtras = &#123; ...props &#125;</span><br><span class="line">     <span class="keyword">if</span> (withRef) withExtras.ref = <span class="built_in">this</span>.setWrappedInstance</span><br><span class="line">     <span class="keyword">if</span> (renderCountProp) withExtras[renderCountProp] = <span class="built_in">this</span>.renderCount++</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">this</span>.propsMode &amp;&amp; <span class="built_in">this</span>.subscription) withExtras[subscriptionKey] = <span class="built_in">this</span>.subscription</span><br><span class="line">     <span class="keyword">return</span> withExtras</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> selector = <span class="built_in">this</span>.selector</span><br><span class="line">     selector.shouldComponentUpdate = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (selector.error) &#123;</span><br><span class="line">       <span class="keyword">throw</span> selector.error</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> createElement(WrappedComponent, <span class="built_in">this</span>.addExtraProps(selector.props))</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>查看完它的源代码可以很容易知道，这个组件本质上呢，是将WrappedComponent加入了一些新的props属性后作为一个children的HOC，所以相关更新逻辑，都在Connect里面。</p>
<h4 id="initSelector-amp-amp-redux回顾"><a href="#initSelector-amp-amp-redux回顾" class="headerlink" title="initSelector &amp;&amp; redux回顾"></a>initSelector &amp;&amp; redux回顾</h4><p>关于initSelector这个，必须关联redux来看。当我们进行订阅时候实质上是在依赖redux进行订阅，而react-redux这里的订阅只是基于此的包装。我们在Provider组件中传入的store这个props，它的初始值由redux包里面的createStore函数而来。</p>
<p>关于这个函数，可以看看它最后的return部分和ReadMe里面的最简用例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  dispatch,</span><br><span class="line">  subscribe,</span><br><span class="line">  getState,</span><br><span class="line">  replaceReducer,</span><br><span class="line">  [$$observable]: observable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">state = <span class="number">0</span>, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;INCREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DECREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> store = createStore(counter)</span><br><span class="line">store.subscribe(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(store.getState()))</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;) <span class="comment">// 1</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;) <span class="comment">// 2</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;DECREMENT&#x27;</span> &#125;) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>initSelector这个函数中selectorFactory函数指向selectorFactory.js中的finalPropsSelectorFactory。</p>
<p>当我们在页面内运行this.props.dispatch实际上是在执行redux上的dispatch, 那么可以看看这个dispatch是如何挂载到HOC的props上的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">finalPropsSelectorFactory</span>(<span class="params">dispatch, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  initMapStateToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  initMapDispatchToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  initMergeProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  ...options</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mapStateToProps = initMapStateToProps(dispatch, options)</span><br><span class="line">  <span class="keyword">const</span> mapDispatchToProps = initMapDispatchToProps(dispatch, options)</span><br><span class="line">  <span class="keyword">const</span> mergeProps = initMergeProps(dispatch, options)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> selectorFactory = options.pure</span><br><span class="line">    ? pureFinalPropsSelectorFactory</span><br><span class="line">    : impureFinalPropsSelectorFactory</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> selectorFactory(</span><br><span class="line">    mapStateToProps,</span><br><span class="line">    mapDispatchToProps,</span><br><span class="line">    mergeProps,</span><br><span class="line">    dispatch,</span><br><span class="line">    options</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合initSelector的代码，可以相对容易理解这一点。</p>
<h4 id="initSubscription"><a href="#initSubscription" class="headerlink" title="initSubscription"></a>initSubscription</h4><p>关于initSubscription函数呢，他做的事情很明显是利用redux的dispatch来触发我们的组件重新加载，这里按图索骥看看这个操作是如何达成的。</p>
<p>首先是更新这块的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">onStateChange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.selector.run(<span class="built_in">this</span>.props)</span><br><span class="line">  <span class="comment">// 如果不需要更新直接发布 有些store变量没有被组件引用</span></span><br><span class="line">  <span class="comment">// 否则设置组件componentDidUpdate生命周期方法 并使用setState空数据进行更新</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.selector.shouldComponentUpdate) &#123; </span><br><span class="line">    <span class="built_in">this</span>.notifyNestedSubs()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// notifyNestedSubsOnComponentDidUpdate</span></span><br><span class="line">    <span class="built_in">this</span>.componentDidUpdate = <span class="built_in">this</span>.notifyNestedSubsOnComponentDidUpdate</span><br><span class="line">    <span class="built_in">this</span>.setState(dummyState)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">notifyNestedSubsOnComponentDidUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 当`onStateChange`确定需要发布嵌套的subs时，`componentDidUpdate`是有条件触发的 </span></span><br><span class="line">    <span class="comment">// 一旦这个函数被调用，`componentDidUpdate`不会直接被调用，直到进一步发生状态变化才会被调用。 </span></span><br><span class="line">    <span class="comment">// 采用这样做法相比使用永久的`componentDidUpdate`每次进行布尔值检查</span></span><br><span class="line">    <span class="comment">// 避免了大部分场景下的不必要的方法调用 从而带来一些性能提升。</span></span><br><span class="line">    <span class="built_in">this</span>.componentDidUpdate = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.notifyNestedSubs()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个notifyNestedSubsOnComponentDidUpdate的注释怎么理解呢？当我们后面调用this.setState({})后，将会触发组件的更新行为。</p>
<p>假设有一个嵌套发布行为，如果每次发布直接手动计算要不要继续发布(意思是直接发布还是更新组件后再发布)，势必每次都要计算这个布尔值。</p>
<p>而通过对componentDidUpdate进行处理，每次发布后只有更新了 才会继续跟进发布。<strong>简而言之，这里是一个有条件的遍历行为，只不过利用了componentDidUpdate生命周期。</strong>这里的遍历行为基本是onStateChange函数依托componentDidUpdate&amp;&amp;notifyNestedSubs进行的。</p>
<p>他的遍历路径大致是这样的：</p>
<p><strong>首先， onStateChange被触发，如果经过计算，需要更新组件，那么设置componentDidUpdate为notifyNestedSubsOnComponentDidUpdate，并使用setState进行更新，更新完毕之后notifyNestedSubsOnComponentDidUpdate被react生命周期componentDidUpdate调用(同时会设置ComponentDid为undefined防止下次被无故调用)，它执行的notifyNestedSubs会再次触发onStateChange，如此循环遍历直到不再需要进行组件更新。</strong></p>
<p>到这里这个更新环节如何运行的基本就有脉络了。<strong>现在的问题在于订阅后是如何调用到onStateChange的</strong>。</p>
<hr>
<p>这里订阅如何引起onStateChange？这里在initSubscription这里找找路径。这里主要代码是react-redux/src/utils/Subscription.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">store, parentSub, onStateChange</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.store = store</span><br><span class="line">    <span class="built_in">this</span>.parentSub = parentSub</span><br><span class="line">    <span class="built_in">this</span>.onStateChange = onStateChange</span><br><span class="line">    <span class="built_in">this</span>.unsubscribe = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.listeners = nullListeners</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addNestedSub</span>(<span class="params">listener</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.trySubscribe()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.listeners.subscribe(listener)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">trySubscribe</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.unsubscribe) &#123;</span><br><span class="line">      <span class="built_in">this</span>.unsubscribe = <span class="built_in">this</span>.parentSub</span><br><span class="line">        ? <span class="built_in">this</span>.parentSub.addNestedSub(<span class="built_in">this</span>.onStateChange)</span><br><span class="line">        : <span class="built_in">this</span>.store.subscribe(<span class="built_in">this</span>.onStateChange)</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">this</span>.listeners = createListenerCollection()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里核心部分是trySubscribe和addNestedSub里面的<code>this.store.subscribe(this.onStateChange)</code>和<code>this.listeners.subscribe(listener)</code>部分。对比之前提到的redux简单用例，可以发现这里就完成了整体的过程的追索。这里的unsubscribe赋值只是从闭包中缓存一个解除订阅的函数指针，这个函数可以方便的直接解除订阅(退订)。</p>
<h1 id="一个成熟项目的结构"><a href="#一个成熟项目的结构" class="headerlink" title="一个成熟项目的结构"></a>一个成熟项目的结构</h1><p>前面扯了那么多，最后还是看看一个成熟项目是如何应用react-redux的, 这里代码基本保留主体，删除无关redux代码。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: App.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&#x27;app/store&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = configureStore();</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// file: app/store/index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Store, createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RootState, rootReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;app/reducers&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; rootSaga &#125; <span class="keyword">from</span> <span class="string">&#x27;../sagas&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">initialState?: RootState</span>): <span class="title">Store</span>&lt;<span class="title">RootState</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sagaMiddleware = createSagaMiddleware();</span><br><span class="line">  <span class="keyword">const</span> store = createStore(rootReducer <span class="keyword">as</span> any, initialState <span class="keyword">as</span> any, middleware) <span class="keyword">as</span> Store&lt;</span><br><span class="line">    RootState</span><br><span class="line">  &gt;</span><br><span class="line">  sagaMiddleware.run(rootSaga);</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// file: app/reducers/index.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> rootReducer = combineReducers&lt;RootState&gt;(&#123;</span><br><span class="line">  routing: routerReducer,</span><br><span class="line">  <span class="built_in">global</span>: globalReducer <span class="keyword">as</span> any,</span><br><span class="line">  dashBoard: dashBoardReducer <span class="keyword">as</span> any,</span><br><span class="line">  ......</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState: RootState.DashBoardState = <span class="keyword">from</span>(&#123;</span><br><span class="line">  loading: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// file: dashBoardReducer.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> dashBoardReducer = handleActions&lt;RootState.DashBoardState, DashBoardModel&gt;(</span><br><span class="line">  &#123;</span><br><span class="line">    [dashBoardActions.Type.SAVE]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.merge(action.payload || &#123;&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    [dashBoardActions.Type.RESET]: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> initialState;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  initialState,</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里项目里面用到了Typescript, 不过忽略它，看看当前redux主流的应用，基本都是基于这个结构了。</p>
<p>关于redux.createReducer在前面已经提到过了，这里就不再说，主要是combineReducers可能要简单提一下，他本质上是将对个对象合并为一个对象，然后传入到createReduce使用。仔细思考一下，其实这样就和前面提到的一模一样了。</p>
<h1 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h1><p>这里还需要提到的是redux-saga。redux相关操作都是实时的，那么异步只靠它也就无能为力了，但是它定义了中间件接口。通过这个中间件，它可以实现异步的处理。</p>
<p>Redux 的中间件提供的是位于 <code>action</code> 被发起之后，到达 <code>reducer</code> 之前的扩展点，换而言之，原本 <code>view -&gt; action -&gt; reducer -&gt; store</code> 的数据流加上中间件后变成了 <code>view -&gt; action -&gt; middleware -&gt; reducer -&gt; store</code> ，在这一环节我们可以做一些 “副作用” 的操作，如 异步请求、打印日志。</p>
<p>一个简单的中间件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> logger: Middleware = <span class="function">(<span class="params">store</span>) =&gt;</span> <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(action);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里不对redux-sagas做太多的分析，我们看看一个简单的sagas是怎样写的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getUserSagas</span>(<span class="params">action: any</span>): <span class="title">Iterator</span>&lt;<span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; id &#125; = action.payload;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">yield</span> call(AuthApi.getUserDetail, id);</span><br><span class="line">    <span class="keyword">yield</span> put(accountEditActions.saveAction(&#123; <span class="attr">user</span>: data &#125;));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">watchFetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> takeEvery(accountEditActions.Type.GET_USER, getUserSagas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当GET_USER这个action被触发，那么getUserSagas也会被触发。这里非常值得关注的，是这里的generate函数。</p>
<p>这里我们来看看applyMiddleware函数是如何实现的，以便对redux-sagas的实现进行一些分析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line">    <span class="keyword">let</span> dispatch = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&#x27;Dispatching while constructing your middleware is not allowed. &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;Other middleware would not be applied to this dispatch.&#x27;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// compose Function</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用参考</span></span><br><span class="line"><span class="keyword">let</span> middleware = applyMiddleware(loggerMiddleware);</span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer <span class="keyword">as</span> any, initialState <span class="keyword">as</span> any, middleware) <span class="keyword">as</span> Store&lt;</span><br><span class="line">RootState</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>除了这些不妨看看redux源码里面createStore里面关于第三个函数的处理:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综合起来看看这个调用路径做一些思考。思考一下这个体系中他们整体的调用路径:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">applyMiddleware(loggerMiddleware)-----------+</span><br><span class="line">    							            ↓</span><br><span class="line">createStore(rootReducer, initialState, sagaMiddleware)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看看applyMiddleware的代码结构:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(...middlewares) =&gt; <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...store,</span><br><span class="line">        dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当middleware被传入到createStore时候，他的结构脱去一层 变成了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> M = <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...store,</span><br><span class="line">        dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时如果设变量M为这个函数那么<code>const store = createStore(rootReducer, initialState, middleware)</code>实质上是执行了<code>M(createStore)(rootReducer, initialState)</code>。</p>
<p>那么，此处rootReducer, initialState就是作为…args参数执行进来了。此时呢,middlewares.map(() =&gt; {})这块代码又开始有些绕起来了,每个middleware(middlewareAPI)实质上都是这个函数结构被执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(store) =&gt; <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> next(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chain最终返回的结构式这样的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> chain: <span class="built_in">Array</span>&lt;<span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> next(action);</span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>多看看compose函数，假设我们有多个中间件被传入进来，会发生什么呢？</p>
<p>这个变量M里面的<code>dispatch = compose(...chain)(store.dispatch)</code>最终是这样的一个逻辑:</p>
<p>假设我们最终有个ABC三个中间件，那么dispath最终调用链条是A(B(C(store.dispatch)))。这里一层一层的调用，在执行环节上从里面到外面。对于C来说next是store.dispatch，对于B来说next是C(store.dispatch)，对于A来说next是B(C(store.dispatch))。</p>
<p><strong>但是无论如何，最终所有的ABC都获取到了action</strong>，并且这个action并没有什么不同(假设这个action没有被认为修改的话)。</p>
<p>而对于store.dispatch来讲新的dispatch函数(在最终节点 它是store.dispatch(action)这样的调用),其实是在上游对原料做了有点小修改，但是并没有对后面的dispatch操作有任何干涉。</p>
<p><strong>也就是说redux中间件环节上并没有对genertor函数有依赖</strong>，理解这块对redux-sagas的工作范围有不小帮助。</p>
<h2 id="redux-saga追索"><a href="#redux-saga追索" class="headerlink" title="redux-saga追索"></a>redux-saga追索</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>项目中可能写了很多很多saga代码了，大概可以了解到，redux-saga本质上是对generator函数的深入应用。</p>
<p>结合generator特性(即：generator会返回一个迭代器对象，而不是立即执行)、迭代器相关知识、以及redux中间件的理解，可以对saga的原理做出一些猜想(如果对Generator、Iterator了解不够的值得回程票去了解这块)。</p>
<p>这里的猜想是：saga本质上是利用generator函数返回一个根节点迭代器(设其名称为RootSaga)，这个迭代器可以通过中间件每次触发事件时候进行完整的遍历，并触发和当前action对应的generator函数(设名称为UserSaga)，并在generator利用yield关键词可以在这个函数中像写同步代码一样写相关回调。</p>
<p>在最后也会完整遍历这个UserSaga生成的迭代器。在这个UsserSaga中因为中间件缘故可以获取到state也可以获取dispatch，所以可以对state做读取，也可以做修改，这样就当里面的异步行为完成之后，可以实现异步对redux的state做变更。</p>
<h3 id="探寻"><a href="#探寻" class="headerlink" title="探寻"></a>探寻</h3><p>这里找到了最新的提交记录(commit: 10fc193f56f5db05a5ac45140642dbc6a4eed087)</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>这里来个实际项目里面redux-saga如何注册的代码。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">initialState?: RootState</span>): <span class="title">Store</span>&lt;<span class="title">RootState</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// create the saga middleware</span></span><br><span class="line">  <span class="keyword">const</span> sagaMiddleware = createSagaMiddleware();</span><br><span class="line">  <span class="keyword">let</span> middleware = applyMiddleware(loggerMiddleware, sagaMiddleware);</span><br><span class="line">  <span class="keyword">const</span> store = createStore(rootReducer <span class="keyword">as</span> any, initialState <span class="keyword">as</span> any, middleware) <span class="keyword">as</span> Store&lt;</span><br><span class="line">    RootState</span><br><span class="line">  &gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then run the saga</span></span><br><span class="line">  sagaMiddleware.run(rootSaga);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.tsx</span></span><br><span class="line"><span class="keyword">const</span> store = configureStore();</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>),</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里看看createSagaMiddleware。这里它实质上redux-saga的default导出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sagaMiddlewareFactory</span>(<span class="params">&#123; context = &#123;&#125;, channel = stdChannel(), sagaMonitor, ...options &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> boundRunSaga</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sagaMiddleware</span>(<span class="params">&#123; getState, dispatch &#125;</span>) </span>&#123;</span><br><span class="line">    boundRunSaga = runSaga.bind(<span class="literal">null</span>, &#123;</span><br><span class="line">      ...options,</span><br><span class="line">      context,</span><br><span class="line">      channel,</span><br><span class="line">      dispatch,</span><br><span class="line">      getState,</span><br><span class="line">      sagaMonitor,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sagaMonitor &amp;&amp; sagaMonitor.actionDispatched) &#123;</span><br><span class="line">        sagaMonitor.actionDispatched(action)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> result = next(action) <span class="comment">// hit reducers</span></span><br><span class="line">      channel.put(action)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sagaMiddleware.run = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> boundRunSaga(...args)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sagaMiddleware.setContext = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    assignWithSymbols(context, props)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sagaMiddleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上它的返回值和之前提到的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(store) =&gt; <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> next(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构并无二致。<code>&#123; getState, dispatch &#125;</code>也无非是对store解构赋值。</p>
<p>后面的sagaMiddleware.run(rootSaga)则实质上调用了boundRunSaga，这个boundRunSaga是对runSaga进行了上下文绑定和传参，但是没有执行。runSaga函数如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runSaga</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  &#123; channel = stdChannel(), dispatch, getState, context = &#123;&#125;, sagaMonitor, effectMiddlewares, onError = logError &#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  saga,</span></span></span><br><span class="line"><span class="function"><span class="params">  ...args</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> iterator = saga(...args)</span><br><span class="line">  <span class="keyword">const</span> effectId = nextSagaId()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...略过若干</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> env = &#123;</span><br><span class="line">    channel,</span><br><span class="line">    dispatch: wrapSagaDispatch(dispatch),</span><br><span class="line">    getState,</span><br><span class="line">    sagaMonitor,</span><br><span class="line">    onError,</span><br><span class="line">    finalizeRunEffect,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> immediately(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> task = proc(env, iterator, context, effectId, getMetaInfo(saga), <span class="comment">/* isRoot */</span> <span class="literal">true</span>, noop)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sagaMonitor) &#123;</span><br><span class="line">      sagaMonitor.effectResolved(effectId, task)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其返回值是immediately(cb), 这个immediately正常情况下会将cb原样返回。也就是说，正常情况下返回值是<code>proc(env, iterator, context, effectId, getMetaInfo(saga), /* isRoot */ true, noop)</code>。而proc返回值，又是newTask函数的返回值，这是一个预先定义好的task对象。</p>
<p>也就是说<code>sagaMiddleware.run</code>、<code>runSaga</code>、<code>proc</code>执行后都返回了一个「task」的对象。</p>
<p>其中我们编写的saga业务代码都在iterator中，这是其中需要重点理解的地方。proc函数是整个redux-saga里面很关键的一个函数，不过这之前，先看看业务代码里面的saga，以及承担分发任务的takeEvery和takeLatest。</p>
<h4 id="分发-takeEvery-amp-amp-takeLatest"><a href="#分发-takeEvery-amp-amp-takeLatest" class="headerlink" title="分发:takeEvery &amp;&amp; takeLatest"></a>分发:takeEvery &amp;&amp; takeLatest</h4><p>这两个分发函数区别在于takeEvery允许多个异步任务同时触发，而takeLatest则一次只能触发一个异步任务，当已有异步任务执行中，那么新的将会被取消。</p>
<p>下面是它们的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// takeEvery</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">takeEvery</span>(<span class="params">patternOrChannel, worker, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> yTake = &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: take(patternOrChannel) &#125;</span><br><span class="line">  <span class="keyword">const</span> yFork = <span class="function"><span class="params">ac</span> =&gt;</span> (&#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: fork(worker, ...args, ac) &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> action,</span><br><span class="line">    setAction = <span class="function"><span class="params">ac</span> =&gt;</span> (action = ac)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fsmIterator(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="title">q1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">nextState</span>: <span class="string">&#x27;q2&#x27;</span>, <span class="attr">effect</span>: yTake, <span class="attr">stateUpdater</span>: setAction &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">q2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">nextState</span>: <span class="string">&#x27;q1&#x27;</span>, <span class="attr">effect</span>: yFork(action) &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;q1&#x27;</span>,</span><br><span class="line">    <span class="string">`takeEvery(<span class="subst">$&#123;safeName(patternOrChannel)&#125;</span>, <span class="subst">$&#123;worker.name&#125;</span>)`</span>,</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// takeLatest</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">takeLatest</span>(<span class="params">patternOrChannel, worker, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> yTake = &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: take(patternOrChannel) &#125;</span><br><span class="line">  <span class="keyword">const</span> yFork = <span class="function"><span class="params">ac</span> =&gt;</span> (&#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: fork(worker, ...args, ac) &#125;)</span><br><span class="line">  <span class="keyword">const</span> yCancel = <span class="function"><span class="params">task</span> =&gt;</span> (&#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: cancel(task) &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> task, action</span><br><span class="line">  <span class="keyword">const</span> setTask = <span class="function"><span class="params">t</span> =&gt;</span> (task = t)</span><br><span class="line">  <span class="keyword">const</span> setAction = <span class="function"><span class="params">ac</span> =&gt;</span> (action = ac)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fsmIterator(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="title">q1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">nextState</span>: <span class="string">&#x27;q2&#x27;</span>, <span class="attr">effect</span>: yTake, <span class="attr">stateUpdater</span>: setAction &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">q2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> task</span><br><span class="line">          ? &#123; <span class="attr">nextState</span>: <span class="string">&#x27;q3&#x27;</span>, <span class="attr">effect</span>: yCancel(task) &#125;</span><br><span class="line">          : &#123; <span class="attr">nextState</span>: <span class="string">&#x27;q1&#x27;</span>, <span class="attr">effect</span>: yFork(action), <span class="attr">stateUpdater</span>: setTask &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">q3</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">nextState</span>: <span class="string">&#x27;q1&#x27;</span>, <span class="attr">effect</span>: yFork(action), <span class="attr">stateUpdater</span>: setTask &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;q1&#x27;</span>,</span><br><span class="line">    <span class="string">`takeLatest(<span class="subst">$&#123;safeName(patternOrChannel)&#125;</span>, <span class="subst">$&#123;worker.name&#125;</span>)`</span>,</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里fsmIterator函数是关键。它生成了一个Iterator，并为这个Iterator自定义了一个next</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">fsmIterator</span>(<span class="params">fsm, startState, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stateUpdater,</span><br><span class="line">    errorState,</span><br><span class="line">    effect,</span><br><span class="line">    nextState = startState</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">arg, error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextState === qEnd) &#123;</span><br><span class="line">      <span class="keyword">return</span> done(arg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error &amp;&amp; !errorState) &#123;</span><br><span class="line">      nextState = qEnd</span><br><span class="line">      <span class="keyword">throw</span> error</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stateUpdater &amp;&amp; stateUpdater(arg)</span><br><span class="line">      <span class="keyword">const</span> currentState = error ? fsm[errorState](error) : fsm[nextState]()</span><br><span class="line">      ;(&#123; nextState, effect, stateUpdater, errorState &#125; = currentState)</span><br><span class="line">      <span class="keyword">return</span> nextState === qEnd ? done(arg) : effect</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> makeIterator(next, <span class="function"><span class="params">error</span> =&gt;</span> next(<span class="literal">null</span>, error), name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>makeIterator这个函数比较简单，这里只简单说下，它主要接收三个三个参数，next函数、抛错函数、name, 根据这个返回一个迭代器对象回来。</p>
<p>那么这里可以返回fsmIterator思考一下它做了什么。仔细观察这个next函数，以及其返回值，可以很容易发现:无论何种原因和状况，只有在nextState === qEnd时候才会才会返回{done: true, value}(done函数返回值)，而其他情况下呢，只会<strong>不断地执行stateUpdater(q1,q2, q3里面定义的，如果有的话)，并返回effect</strong>(也是q1,q2, q3里面的)——永不停止，直到有一天，它抛出错误，捕获然后执行done——这时候所有后面所有的异步都不会再执行了，换句话说，你的应用，依赖异步的部分，全挂了。</p>
<p>这个过程如果足够完美，takeEvery地路径是q1-&gt;q2-&gt;q1-&gt;q2….，takeLastet地路径有分支并不固定，但是也是在当前的nextState中，如此循环往复永不歇止。</p>
<p><strong>这种不会停止的遍历循环，正是redux-saga之所以注册一次就可以不断异步响应action的精髓所在。而它一旦停止下来，整个应用也就随之戛然而止——也许大家都有遇到过在一个sagas文件里面没有try…catch捕获错误而导致整个应用所有异步请求全挂的经历。</strong></p>
<h4 id="Side-Effect"><a href="#Side-Effect" class="headerlink" title="Side Effect"></a>Side Effect</h4><p>之所以单独小章节来说，还是因为takeEvery&amp;takeLastest循环往复的遍历过程中会不会的调用到fork、take、cancel这些。</p>
<p>Side Effect包括take|fork|cancel|put|select|call等等这些。</p>
<p>这些都是redux-saga使用时候可以用到的Side Effect，这其中呢，call, select, put尤其常用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// put</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params">channel, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is.undef(action)) &#123;</span><br><span class="line">    action = channel</span><br><span class="line">    <span class="comment">// `undefined` instead of `null` to make default parameter work</span></span><br><span class="line">    channel = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> makeEffect(effectTypes.PUT, &#123; channel, action &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// call</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">call</span>(<span class="params">fnDescriptor, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> makeEffect(effectTypes.CALL, getFnCallDescriptor(fnDescriptor, args))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// select</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params">selector = identity, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> makeEffect(effectTypes.SELECT, &#123; selector, args &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makeEffect</span></span><br><span class="line"><span class="keyword">const</span> makeEffect = <span class="function">(<span class="params">type, payload</span>) =&gt;</span> (&#123;</span><br><span class="line">  [IO]: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// this property makes all/race distinguishable in generic manner from other effects</span></span><br><span class="line">  <span class="comment">// currently it&#x27;s not used at runtime at all but it&#x27;s here to satisfy type systems</span></span><br><span class="line">  combinator: <span class="literal">false</span>,</span><br><span class="line">  type,</span><br><span class="line">  payload,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// getFnCallDescriptor</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFnCallDescriptor</span>(<span class="params">fnDescriptor, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> fn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is.func(fnDescriptor)) &#123;</span><br><span class="line">    fn = fnDescriptor</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (is.array(fnDescriptor)) &#123;</span><br><span class="line">      ;[context, fn] = fnDescriptor</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ;(&#123; context, fn &#125; = fnDescriptor)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context &amp;&amp; is.string(fn) &amp;&amp; is.func(context[fn])) &#123;</span><br><span class="line">      fn = context[fn]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; context, fn, args &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后返回的结构大致如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;@@redux-saga/IO&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;combinator&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;PUT&quot;</span>,</span><br><span class="line">  <span class="string">&quot;payload&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;channel&quot;</span>: <span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;action&quot;</span>: <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="proc函数"><a href="#proc函数" class="headerlink" title="proc函数"></a>proc函数</h4><p>proc应该可以拎出来单独说说，前面提到了takeEvery&amp;takelatest返回的迭代器正常情况是一个无限向后遍历的迭代器，但是这个迭代器之前又在另外一个迭代器rootSaga里面，所以我们还需要一个引子来开个头点个火。proc干的就是这事。</p>
<p><strong>他本质上和for…of遍历迭代器没啥区别</strong>，不过内部还是有很多细节处理。</p>
<p>当我们编写的业务异步代码被执行的时候，执行各种put、call、select各种Side Effect的时候，实质上所有的返回值最后都会返回Side Effect的返回值作为迭代器next的返回值给proc函数。也就是上面提到的那个大致结构。到最后各种情况，风也好雨也罢，最终会执行到effectRunner函数。这个函数来自effectRunnerMap，这是一个Map结构，可以根据上面那个数据结构的type返回一个函数effectRunner，并做出最终处理的调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> effectRunnerMap = &#123;</span><br><span class="line">  [effectTypes.TAKE]: runTakeEffect,</span><br><span class="line">  [effectTypes.PUT]: runPutEffect,</span><br><span class="line">  [effectTypes.ALL]: runAllEffect,</span><br><span class="line">  [effectTypes.RACE]: runRaceEffect,</span><br><span class="line">  [effectTypes.CALL]: runCallEffect,</span><br><span class="line">  [effectTypes.CPS]: runCPSEffect,</span><br><span class="line">  [effectTypes.FORK]: runForkEffect,</span><br><span class="line">  [effectTypes.JOIN]: runJoinEffect,</span><br><span class="line">  [effectTypes.CANCEL]: runCancelEffect,</span><br><span class="line">  [effectTypes.SELECT]: runSelectEffect,</span><br><span class="line">  [effectTypes.ACTION_CHANNEL]: runChannelEffect,</span><br><span class="line">  [effectTypes.CANCELLED]: runCancelledEffect,</span><br><span class="line">  [effectTypes.FLUSH]: runFlushEffect,</span><br><span class="line">  [effectTypes.GET_CONTEXT]: runGetContextEffect,</span><br><span class="line">  [effectTypes.SET_CONTEXT]: runSetContextEffect,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="部分effectRunner"><a href="#部分effectRunner" class="headerlink" title="部分effectRunner"></a>部分effectRunner</h5><p>这里看最常见的<strong>yield call</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runCallEffect</span>(<span class="params">env, &#123; context, fn, args &#125;, cb, &#123; task &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// catch synchronous failures; see #152</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = fn.apply(context, args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is.promise(result)) &#123;</span><br><span class="line">      resolvePromise(result, cb)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is.iterator(result)) &#123;</span><br><span class="line">      <span class="comment">// resolve iterator</span></span><br><span class="line">      proc(env, result, task.context, currentEffectId, getMetaInfo(fn), <span class="comment">/* isRoot */</span> <span class="literal">false</span>, cb)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cb(result)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    cb(error, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有fn和args，分别是我们写的generator函数里面传入call的两个参数，可以看到这里call不仅可以接受Promise，它还能接一个一个generator函数这样返回的迭代器可以用proc来遍历。这里generator操作可能会比Promise更加灵活，例如，我们初始化一个3级的级联菜单初始值，如果用promise可能要saga里面手动写三个yield call(PromiseFunction, args), 而generator里面可以直接放三个yield PromiseFunction(args)然后通过proc遍历就可以了。</p>
<p>再看看<strong>yield put</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runPutEffect</span>(<span class="params">env, &#123; channel, action, resolve &#125;, cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   Schedule the put in case another saga is holding a lock.</span></span><br><span class="line"><span class="comment">   The put will be executed atomically. ie nested puts will execute after</span></span><br><span class="line"><span class="comment">   this put has terminated.</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  asap(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = (channel ? channel.put : env.dispatch)(action)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      cb(error, <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolve &amp;&amp; is.promise(result)) &#123;</span><br><span class="line">      resolvePromise(result, cb)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cb(result)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// Put effects are non cancellables</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般项目里面正常情况put都是直接接到一个action然后执行redux的dispatch(action)。</p>
<p>asap这个函数很常见，主要是用来调度微任务，让当前任务立刻排到当前微任务队列最后面以尽可能快的速度执行。在此处的话，如果我们yield put里面还嵌套一个yield put的话，因为函数执行都是先里层后外层，所以内部嵌套的put会排在前面被先执行。</p>
<p><strong>select</strong>的比较简单就不提及了。</p>
<h5 id="saga的注册"><a href="#saga的注册" class="headerlink" title="saga的注册"></a>saga的注册</h5><p>这里需要串联一下前面所有的内容。主要是以下几点</p>
<ul>
<li><p><code>sagaMiddleware.run(rootSaga)</code>最终调用<code>proc</code>函数</p>
</li>
<li><p><code>rootSaga</code>最终执行返回的迭代最终是<code>takeEvery & takeLatest</code>返回值</p>
</li>
<li><p><code>takeEvery & takeLatest</code>无限遍历，返回值是<code>Side Effect</code></p>
</li>
<li><p><code>Side Effect</code>最终结构为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;@@redux-saga/IO&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;combinator&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Fork&quot;</span>,</span><br><span class="line">  <span class="string">&quot;payload&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;channel&quot;</span>: <span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;action&quot;</span>: <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>effectRunner会接收这个参数并做出响应。</p>
</li>
</ul>
<p>鉴于takeEvery里面调用到了take、fork，所以这里最后分析一下下面代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> yTake = &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: take(patternOrChannel) &#125;</span><br><span class="line"><span class="keyword">const</span> yFork = <span class="function"><span class="params">ac</span> =&gt;</span> (&#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: fork(worker, ...args, ac) &#125;)</span><br><span class="line"><span class="keyword">return</span> fsmIterator(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="title">q1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">nextState</span>: <span class="string">&#x27;q2&#x27;</span>, <span class="attr">effect</span>: yTake, <span class="attr">stateUpdater</span>: setAction &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">q2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">nextState</span>: <span class="string">&#x27;q1&#x27;</span>, <span class="attr">effect</span>: yFork(action) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;q1&#x27;</span>,</span><br><span class="line">  <span class="string">`takeEvery(<span class="subst">$&#123;safeName(patternOrChannel)&#125;</span>, <span class="subst">$&#123;worker.name&#125;</span>)`</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h6 id="take相关"><a href="#take相关" class="headerlink" title="take相关"></a>take相关</h6><p>通常来说take(patternOrChannel)返回值是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  @@redux-saga/IO: <span class="literal">true</span>,</span><br><span class="line">  combinator: <span class="literal">false</span>,</span><br><span class="line">  type: <span class="string">&#x27;TAKE&#x27;</span>,</span><br><span class="line">  payload: &#123; <span class="attr">pattern</span>: patternOrChannel &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看看对应的runTakeEffect</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runTakeEffect</span>(<span class="params">env, &#123; channel = env.channel, pattern, maybe &#125;, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> takeCb = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">      cb(input, <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEnd(input) &amp;&amp; !maybe) &#123;</span><br><span class="line">      cb(TERMINATE)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    cb(input)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    channel.take(takeCb, is.notUndef(pattern) ? matcher(pattern) : <span class="literal">null</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    cb(err, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  cb.cancel = takeCb.cancel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的代码还是chanel.take的调用。这里channel常规情况下有一个默认值，来自stdChannel函数的返回值，而这个函数中返回值又来自multicastChannel函数(这两个函数都在packages/core/src/internal/channel.js)。</p>
<p>它返回了一个有put|take|close三个方法的对象。</p>
<p><strong>take所做的事基本就是将cb也就是runTakeEffect函数中的takeCb存到nextTakers中，这个nextTakers在闭包中，可以被其他地方调用put调用到</strong>。这个时候，回头去看看<code>sagaMiddlewareFactory</code>函数，看看里面的这一块代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sagaMiddleware</span>(<span class="params">&#123; getState, dispatch &#125;</span>) </span>&#123;</span><br><span class="line">  boundRunSaga = runSaga.bind(<span class="literal">null</span>, &#123;</span><br><span class="line">    ...options,</span><br><span class="line">    context,</span><br><span class="line">    channel,</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">    sagaMonitor,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sagaMonitor &amp;&amp; sagaMonitor.actionDispatched) &#123;</span><br><span class="line">      sagaMonitor.actionDispatched(action)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = next(action) <span class="comment">// hit reducers</span></span><br><span class="line">    channel.put(action)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关注点放到<code>channel.put(action)</code>,一切就尽在不言中了——他用于针对特定action注册好函数调用，当中间件收到这个action就立刻调用这个函数。</p>
<p>return这里有个<code>stateUpdater</code>参数需要注意，我们的迭代(fsmIterator)里面的自定义next函数会判断它，如果有就会被执行，那么在这里，<strong>yFork还会通过闭包获取上次take执行时候传进来的action</strong>。</p>
<p>但是这里还有一个地方需要思考，这个回调函数，是如何进一步迭代这个迭代器的呢？要知道，迭代器虽然可以不断遍历，但是仍然需要一只手时不时拨动一下让它不断往下走。这里需要进行参数追溯。其路径是这样：</p>
<p>proc函数中定义了一个next函数作为迭代器自定义的next，其中核心代码是<code>digestEffect(result.value, parentEffectId, next)</code>,当proc头一次运行时候执行了一次next，然后有一下调用路径：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">digestEffect-&gt;finalRunEffect-&gt;runEffect-&gt;RunTakeEffect-&gt;channel.take</span><br></pre></td></tr></table></figure>

<p>这样next函数通过这一条调用链，被digestEffect函数传参一直被传入到了channel.take里面，然后通过take缓存到了takers数组中，最后被put调用到了的同时，通过遍历takers数组并执行数组中符合action判定的函数——next函数的执行，便能将这个迭代器，每次接到新的action时候往前推进一步。同时，结合刚才提到的<code>stateUpdater</code>缓存action，我们也能进一步将目光放到fork上了。</p>
<h6 id="fork相关"><a href="#fork相关" class="headerlink" title="fork相关"></a>fork相关</h6><p>take看完之后得看看fork, 但是接上文的，我们可以明白take函数呢，至少是在当前这一步最多是执行的将action、next函数缓存下来，对函数执行并没有什么直接的调用，所以这个异步函数的执行，最终还是看fork函数或者更后面的调用。</p>
<p>我们接着take的逻辑往下推，当put执行的时候调用next，然后我们的迭代器被这个函数里面的往前执行了一步，当它执行这个操作的时候，它正停在take对应的q1上，向下一步之后就到了q2, 观察一下源代码发现又走到了runForkEffect(SideEffect)这条线上了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runForkEffect</span>(<span class="params">env, &#123; context, fn, args, detached &#125;, cb, &#123; task: parent &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> taskIterator = createTaskIterator(&#123; context, fn, args &#125;)</span><br><span class="line">  <span class="keyword">const</span> meta = getIteratorMetaInfo(taskIterator, fn)</span><br><span class="line"></span><br><span class="line">  immediately(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> child = proc(env, taskIterator, parent.context, currentEffectId, meta, detached, noop)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (detached) &#123;</span><br><span class="line">      cb(child)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.isRunning()) &#123;</span><br><span class="line">        parent.queue.addTask(child)</span><br><span class="line">        cb(child)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.isAborted()) &#123;</span><br><span class="line">        parent.queue.abort(child.error())</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cb(child)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// Fork effects are non cancellables</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个createTaskIterator函数，就最简单的应用来讲<sup>注1</sup>，我们这里传进去的fn是我们写的业务代码generator函数，此时返回的就是一个业务generator函数生成的迭代器，同时action、SideEffect相关信息也被传入进去了。因为这个迭代器和takeEvery生成的不同它是有终点的，所以这个生成的child Task到了最后会被完整执行并停止。</p>
<p>这里先返回这个函数来讲，首先是child这个事proc返回一个Task对象，然后执行到后面isRuning() === true,接下来在cb(child)，这个cb之前有讲过，实质上是对proc函数内部的next的封装。当我们执行cb(task)时候，这里会触发一个对child迭代器的遍历。这里的脉络是:</p>
<ul>
<li><p>cb首先是proc函数传下来的next函数，执行他，如果我们使用takeEvery来注册绑定，那么此时会从q2回到q1。</p>
</li>
<li><p>基于上一条，fork会读取到闭包里面的take Action，这样会触发runTakeEffect,take动作此时才会被执行。</p>
</li>
<li><p>cb也就是next执行时候会触发内部那条<code>result = iterator.next(arg)</code>,然后这个iterator(业务代码生产的迭代器)就开始往下走，如果它的done值不为true，那么将会由digestEffect来触发runEffect函数，进而触发到达runForkEffect等等，而这些函数里面都会继续进而调用next直到这个迭代器done===true。</p>
</li>
</ul>
<h5 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h5><p>takeEvery不是必须。</p>
<p>实现同一个逻辑，我们可以有不同的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">rootSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  takeEvery(<span class="string">&#x27;INCREMENT_ASYNC&#x27;</span>, incrementAsync)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">rootSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> take(<span class="string">&#x27;INCREMENT_ASYNC&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> incrementAsync()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二 如果需要参数...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">rootSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> action = <span class="keyword">yield</span> take(globalActions.Type.LOGIN);</span><br><span class="line">    <span class="keyword">yield</span> loginSaga(action);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三 如果需要参数...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">rootSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> action = <span class="keyword">yield</span> take(globalActions.Type.LOGIN);</span><br><span class="line">    <span class="keyword">yield</span> fork(<span class="function">() =&gt;</span> loginSaga(action));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以试想一下，</p>
<ul>
<li><p>为什么takeEvery可以不用while(true){}这种写法？而后面需要？</p>
<p>如果我们后面不写while(true){}这种语法，那么会导致我们的异步仅仅会被触发一次。</p>
<p>当使用了这种写法，按照js语法那肯定是死循环了，但是在generator函数中，配合yield就可以进行中断，可以保证这个迭代器永远不会有done===true那一刻。</p>
<p>为什么redux-saga内部采用这种简单省事的做法？因为redux-saga里面有对异步任务的cancel机制，我们可以需要一个异步任务的执行，如果采用这种机制，则没有取消的余地——takeLatest就是采用了这种机制。</p>
</li>
<li><p>yield fork(() =&gt; sagaGeneraotor())和直接yield sagaGeneraotor()调用有什么区别？</p>
<p>这点其实在分析fork函数行为中已经可见一斑了，fork会在next执行过程中采用新建task的方式进行插队并立刻执行，而不用等待后面相关action的完成。</p>
</li>
</ul>
<h1 id="一些有用的包"><a href="#一些有用的包" class="headerlink" title="一些有用的包"></a>一些有用的包</h1><h2 id="redux-actions"><a href="#redux-actions" class="headerlink" title="redux-actions"></a>redux-actions</h2><p>mapDispatchToProps的编写是挺折腾人的。举个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    changePickerTarget: <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">      dispatch(changePickTarget(index));</span><br><span class="line">      dispatch(changePickState());</span><br><span class="line">    &#125;,</span><br><span class="line">    changeRoute: <span class="function">(<span class="params">url</span>) =&gt;</span> dispatch(push(url)),</span><br><span class="line">    togglePick: <span class="function">() =&gt;</span> dispatch(changePickState()),</span><br><span class="line">    toggleDatePick: <span class="function">() =&gt;</span> dispatch(changeDatePickState()),</span><br><span class="line">    fetchPickData: <span class="function">() =&gt;</span> dispatch(fetchPickData()),</span><br><span class="line">    fetchStoreInfo: <span class="function">() =&gt;</span> dispatch(fetchStoreInfo()),</span><br><span class="line">    fetchProjectData: <span class="function">() =&gt;</span> dispatch(fetchProjectData()),</span><br><span class="line">    changeSubmitData: <span class="function">(<span class="params">idx, val</span>) =&gt;</span> dispatch(changeSubmitData(idx, val)),</span><br><span class="line">    changePickText: <span class="function">(<span class="params">idx, val</span>) =&gt;</span> dispatch(changePickText(idx, val)),</span><br><span class="line">    submitData: <span class="function">() =&gt;</span> dispatch(submitData()),</span><br><span class="line">    submitCallback: <span class="function">(<span class="params">data</span>) =&gt;</span> dispatch(submitCallback(data)),</span><br><span class="line">    dispatch,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>actions的编写也挺烦：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setSubmitStatus</span>(<span class="params">bool</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: CHANGE_SUBMIT_STATUS,</span><br><span class="line">    bool,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过redux-actions我们可以做很大的简化:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// actions</span></span><br><span class="line"><span class="keyword">export</span> namespace carInfoListActions &#123;</span><br><span class="line">  <span class="keyword">export</span> enum Type &#123;</span><br><span class="line">    GETLIST = <span class="string">&#x27;carInfoList/GETLIST&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> getListAction = createAction&lt;Partial&lt;CarInfoListModel&gt;&gt;(Type.GETLIST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type carInfoListActions = Omit&lt;<span class="keyword">typeof</span> carInfoListActions, <span class="string">&#x27;Type&#x27;</span>&gt;;</span><br><span class="line"><span class="comment">// Page.tsx</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = (dispatch: Dispatch): <span class="function"><span class="params">any</span> =&gt;</span> (&#123;</span><br><span class="line">   actions: bindActionCreators(omit(carInfoListActions, <span class="string">&#x27;Type&#x27;</span>), dispatch),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">this</span>.props.actions.getListAction(params);</span><br></pre></td></tr></table></figure>





<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://hookey.cc/react/p/6376b912d6209066045402df6275dc6f.html">Redux-Saga原始碼解析 - 初始化和take</a></p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React Transaction</title>
    <url>/2019/06/15/react-Transaction/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>事务机制在react中是一个非常重要的概念，它可以将诸多方法调用包裹起来集中执行。事务这个概念在数据库操作过程中非常常见，事务具有原子性这个特性，简单说，一个事务中若干任务是作为一个整体执行，要么全部执行成功，要么其中一个失败导致全部失败然后撤回修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `Transaction` creates a black box that is able to wrap any method such that</span></span><br><span class="line"><span class="comment"> * certain invariants are maintained before and after the method is invoked</span></span><br><span class="line"><span class="comment"> * (Even if an exception is thrown while invoking the wrapped method). Whoever</span></span><br><span class="line"><span class="comment"> * instantiates a transaction can provide enforcers of the invariants at</span></span><br><span class="line"><span class="comment"> * creation time. The `Transaction` class itself will supply one additional</span></span><br><span class="line"><span class="comment"> * automatic invariant for you - the invariant that any transaction instance</span></span><br><span class="line"><span class="comment"> * should not be run while it is already being run. You would typically create a</span></span><br><span class="line"><span class="comment"> * single instance of a `Transaction` for reuse multiple times, that potentially</span></span><br><span class="line"><span class="comment"> * is used to wrap several different methods. Wrappers are extremely simple -</span></span><br><span class="line"><span class="comment"> * they only require implementing two methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * invariant词汇的理解释义参考: http://wulfric.me/2017/11/what-is-invariant/</span></span><br><span class="line"><span class="comment"> * `Transaction`创建一个黑盒，这样他可以包裹任何方法，以达到在执行这个方法前后维护某些确定的约束(</span></span><br><span class="line"><span class="comment"> * 即使这个方法抛出了错误)的目标。无论如何，实例化一个事务可以在在创建时提供约束的实施方(需求方)。</span></span><br><span class="line"><span class="comment"> * Transaction Class本身提供额外的绝对约束条件给你-任何事务实例的不变量不应该在它已经运行时运行。</span></span><br><span class="line"><span class="comment"> * 你一般会创建一个Transaction单例来重用多次，它可能被用来包装不同的方法。Wrappers是非常简单的,</span></span><br><span class="line"><span class="comment"> * 它仅仅要求继承initialize&amp;&amp;close这两个方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Use cases:</span></span><br><span class="line"><span class="comment"> * - Preserving the input selection ranges before/after reconciliation.</span></span><br><span class="line"><span class="comment"> *   Restoring selection even in the event of an unexpected error.</span></span><br><span class="line"><span class="comment"> * - Deactivating events while rearranging the DOM, preventing blurs/focuses,</span></span><br><span class="line"><span class="comment"> *   while guaranteeing that afterwards, the event system is reactivated.</span></span><br><span class="line"><span class="comment"> * - Flushing a queue of collected DOM mutations to the main UI thread after a</span></span><br><span class="line"><span class="comment"> *   reconciliation takes place in a worker thread.</span></span><br><span class="line"><span class="comment"> * - Invoking any collected `componentDidUpdate` callbacks after rendering new</span></span><br><span class="line"><span class="comment"> *   content.</span></span><br><span class="line"><span class="comment"> * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue</span></span><br><span class="line"><span class="comment"> *   to preserve the `scrollTop` (an automatic scroll aware DOM).</span></span><br><span class="line"><span class="comment"> * - (Future use case): Layout calculations before and after DOM updates.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用例:</span></span><br><span class="line"><span class="comment"> * - 在执行前后保存输入框选择范围(即鼠标选中一个文字高亮区块)，即使过程中出错也可以返回这个选择范围</span></span><br><span class="line"><span class="comment"> * - 页面重绘前解除事件绑定,防止鼠标焦点进出，当完成了页面重绘恢复事件绑定</span></span><br><span class="line"><span class="comment"> * - 在工作线程中进行协调后，将收集的DOM突变队列刷新到主UI线程(批量更新)。</span></span><br><span class="line"><span class="comment"> * - render新的内容后 批量执行componentDidUpdate中收集到的回调</span></span><br><span class="line"><span class="comment"> * - (未来用例) 保留scrollTop</span></span><br><span class="line"><span class="comment"> * - (未来用例) 布局计算</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>在React事务这里的注释里面对使用场景已经有相对详细的描述了。所以后面主要是看看事务的实例和使用。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>这里暂时跳过服务端和ReactNative端的调用。主要的使用在以下三个文件中。</p>
<h2 id="ReactReconcileTransaction-js"><a href="#ReactReconcileTransaction-js" class="headerlink" title="ReactReconcileTransaction.js"></a>ReactReconcileTransaction.js</h2><p>调度模块这里使用到了事务，注册了三个事务。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SELECTION_RESTORATION = &#123;</span><br><span class="line">  initialize: ReactInputSelection.getSelectionInformation,</span><br><span class="line">  close: ReactInputSelection.restoreSelection,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> EVENT_SUPPRESSION = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentlyEnabled = ReactBrowserEventEmitter.isEnabled();</span><br><span class="line">    ReactBrowserEventEmitter.setEnabled(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> currentlyEnabled;</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params">previouslyEnabled</span>) </span>&#123;</span><br><span class="line">    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ON_DOM_READY_QUEUEING = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.reactMountReady.reset();</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.reactMountReady.notifyAll();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SELECTION_RESTORATION这个事务还是比较好理解，用来保存input的选择范围&amp;刷新后重新选中这个返回。</p>
<p>这里不妨通过这个来看看这个过程中事务的数据流是如何运行的，尤其是,这个数据保存在哪儿，又如何恢复的。</p>
<p>这里需要对事务逻辑中等初始化和结束事务逻辑进行分析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">initializeAll: <span class="function"><span class="keyword">function</span> (<span class="params">startIndex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> transactionWrappers = <span class="built_in">this</span>.transactionWrappers;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = startIndex; i &lt; transactionWrappers.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> wrapper = transactionWrappers[i];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.wrapperInitData[i] = OBSERVED_ERROR;</span><br><span class="line">      <span class="built_in">this</span>.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(<span class="built_in">this</span>) : <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.wrapperInitData[i] === OBSERVED_ERROR) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.initializeAll(i + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">closeAll: <span class="function"><span class="keyword">function</span> (<span class="params">startIndex</span>) </span>&#123;</span><br><span class="line">    !<span class="built_in">this</span>.isInTransaction() ? <span class="string">&quot;development&quot;</span> !== <span class="string">&#x27;production&#x27;</span> ? invariant(<span class="literal">false</span>, <span class="string">&#x27;Transaction.closeAll(): Cannot close transaction when none are open.&#x27;</span>) : _prodInvariant(<span class="string">&#x27;28&#x27;</span>) : <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> transactionWrappers = <span class="built_in">this</span>.transactionWrappers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = startIndex; i &lt; transactionWrappers.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> wrapper = transactionWrappers[i];</span><br><span class="line">      <span class="keyword">var</span> initData = <span class="built_in">this</span>.wrapperInitData[i];</span><br><span class="line">      <span class="keyword">var</span> errorThrown;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        errorThrown = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (initData !== OBSERVED_ERROR &amp;&amp; wrapper.close) &#123;</span><br><span class="line">          wrapper.close.call(<span class="built_in">this</span>, initData);</span><br><span class="line">        &#125;</span><br><span class="line">        errorThrown = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorThrown) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.closeAll(i + <span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.wrapperInitData.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当事务开始初始化时候会将数据保存在this.wrapperInitData中，这是一个数组，数据的索引对应着事务索引，当事务结束时候将数据从this.wrapperInitData拿到并还原，一切完毕之后执行<code>this.wrapperInitData.length = 0</code>将其数据清空。</p>
<p>事务简况:</p>
<table>
<thead>
<tr>
<th>事务名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>SELECTION_RESTORATION</td>
<td>input textarea选择状态保存和恢复</td>
</tr>
<tr>
<td>EVENT_SUPPRESSION</td>
<td>DOM上事件的卸载和重新激活</td>
</tr>
<tr>
<td>ON_DOM_READY_QUEUEING</td>
<td></td>
</tr>
</tbody></table>
<h2 id="ReactDefaultBatchingStrategy-js"><a href="#ReactDefaultBatchingStrategy-js" class="headerlink" title="ReactDefaultBatchingStrategy.js"></a>ReactDefaultBatchingStrategy.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>事务名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>RESET_BATCHED_UPDATES</td>
<td>仅在事务结束后将isBatchingUpdates重置为false</td>
</tr>
<tr>
<td>FLUSH_BATCHED_UPDATES</td>
<td>批量更新标记的dirtyComponents数组</td>
</tr>
</tbody></table>
<h2 id="ReactUpdates-js"><a href="#ReactUpdates-js" class="headerlink" title="ReactUpdates.js"></a>ReactUpdates.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> NESTED_UPDATES = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.dirtyComponentsLength = dirtyComponents.length;</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.dirtyComponentsLength !== dirtyComponents.length) &#123;</span><br><span class="line">      dirtyComponents.splice(<span class="number">0</span>, <span class="built_in">this</span>.dirtyComponentsLength);</span><br><span class="line">      flushBatchedUpdates();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dirtyComponents.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> UPDATE_QUEUEING = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.callbackQueue.reset();</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.callbackQueue.notifyAll();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>事务名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>NESTED_UPDATES</td>
<td>标记事务开始时候的dirtyComponents并在结束时候对其进行更新，并从中删除更新的dirtyComponents元素</td>
</tr>
<tr>
<td>UPDATE_QUEUEING</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactCompositeComponent</title>
    <url>/2019/06/15/react-ReactCompositeComponent/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>ReactCompositeComponent在整个环节中是负责自定义组件的处理。</p>
<p>当我们写下一个<code>div、span</code>标签的时候react使用ReactDomComponent来处理它，而当我们定义了一个<code>Bar、Foo</code>标签的时候React则会使用ReactCompositeComponent来处理它。</p>
<p>而应该说，当我们写下一个业务时候，大多数时候都是在使用自定义组件来实现它们，所以React源码模块中如果有个模块是不得不读，那么肯定就是它了。</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>在说API之前有句话不得不说，当我想分析ReactCompositeComponent的时候，其实我想的其实是ReactCompositeComponentWrapper，它基本是ReactCompositeComponent的实例的一个小扩展。</p>
<p>不过在开始之前 还是先谈谈ReactCompositeComponent的API。过滤内部私有的方法和属性，大致如此:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>construct</td>
<td>构造器，实例化时候需要先执行这个函数</td>
</tr>
<tr>
<td>mountComponent</td>
<td>初始化组件(_constructComponent)，渲染markup(performInitialMount)并注册事件</td>
</tr>
<tr>
<td>_constructComponent</td>
<td>引用_constructComponentWithoutOwner初始化组件。 <strong>被mountComponent引用</strong></td>
</tr>
<tr>
<td>_constructComponentWithoutOwner</td>
<td>初始化组件 <strong>被_constructComponent引用</strong></td>
</tr>
<tr>
<td>performInitialMountWithErrorHandling</td>
<td>渲染markup <strong>被mountComponent引用</strong></td>
</tr>
<tr>
<td>performInitialMount</td>
<td>渲染markup <strong>被mountComponent引用</strong></td>
</tr>
<tr>
<td>getHostNode</td>
<td>获取组件对应的HTMLElement,这里主要是_updateRenderedComponent用到</td>
</tr>
<tr>
<td>unmountComponent</td>
<td>调用组件自身的unmountComponent并清空相关数据</td>
</tr>
<tr>
<td>_maskContext</td>
<td>被_processContext引用</td>
</tr>
<tr>
<td>_processContext</td>
<td>过滤有效contextTypes</td>
</tr>
<tr>
<td>_processChildContext</td>
<td>将子元素context和当前context合并并返回</td>
</tr>
<tr>
<td>_checkContextTypes</td>
<td>开发模式下辅助函数 检查contextTypes</td>
</tr>
<tr>
<td>receiveComponent</td>
<td>归集收到的新旧元素 调用updateComponent进行更新</td>
</tr>
<tr>
<td>performUpdateIfNecessary</td>
<td>传入事务对象,对事务过程中影响的元素进行更新</td>
</tr>
<tr>
<td>updateComponent</td>
<td>满足更新条件后调用_performComponentUpdate进行更新</td>
</tr>
<tr>
<td>_processPendingState</td>
<td></td>
</tr>
<tr>
<td>_performComponentUpdate</td>
<td>调用_updateRenderedComponent进行组件更新</td>
</tr>
<tr>
<td>_updateRenderedComponent</td>
<td>调用组件自身的render进行更新(或者直接调用_replaceNodeWithMarkup替换)，并触发当前组件生命周期</td>
</tr>
<tr>
<td>_replaceNodeWithMarkup</td>
<td>使用markup直接替换旧的组件</td>
</tr>
<tr>
<td>attachRef</td>
<td>为组件设置refs引用 ref内部属性指向组件的HTMLElement</td>
</tr>
<tr>
<td>detachRef</td>
<td>移除refs引用</td>
</tr>
<tr>
<td>getName</td>
<td>获取组件的名称 例如TopLevelWrapper</td>
</tr>
<tr>
<td>getPublicInstance</td>
<td>获取component instance,createElement返回的那种</td>
</tr>
<tr>
<td>_instantiateReactComponent</td>
<td>null</td>
</tr>
</tbody></table>
<h1 id="内部调用"><a href="#内部调用" class="headerlink" title="内部调用"></a>内部调用</h1><p>这里自己调用自己方法比较多，简单捋一捋</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>mountComponent</span><br><span class="line">	-&gt; _constructComponent(初始化组件) &amp;&amp; performInitialMount(渲染markup)</span><br><span class="line">				|-&gt;_constructComponentWithoutOwner   |-&gt; _renderValidatedComponent</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>_processContext </span><br><span class="line">	-&gt; _maskContext</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>updateComponent</span><br><span class="line">	-&gt; _performComponentUpdate</span><br><span class="line">		-&gt; _updateRenderedComponent</span><br><span class="line">			-&gt; component.render || _replaceNodeWithMarkup</span><br></pre></td></tr></table></figure>



<h2 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h2><h3 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h3><p>主要为实例是挂载以下属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this._currentElement &#x3D; element;</span><br><span class="line">this._rootNodeID &#x3D; 0;</span><br><span class="line">this._compositeType &#x3D; null;</span><br><span class="line">this._instance &#x3D; null;</span><br><span class="line">this._hostParent &#x3D; null;</span><br><span class="line">this._hostContainerInfo &#x3D; null;</span><br><span class="line">this._updateBatchNumber &#x3D; null;</span><br><span class="line">this._pendingElement &#x3D; null;</span><br><span class="line">this._pendingStateQueue &#x3D; null;</span><br><span class="line">this._pendingReplaceState &#x3D; false;</span><br><span class="line">this._pendingForceUpdate &#x3D; false;</span><br><span class="line">this._renderedNodeType &#x3D; null;</span><br><span class="line">this._renderedComponent &#x3D; null;</span><br><span class="line">this._context &#x3D; null;</span><br><span class="line">this._mountOrder &#x3D; 0;</span><br><span class="line">this._topLevelWrapper &#x3D; null;</span><br><span class="line">this._pendingCallbacks &#x3D; null;</span><br><span class="line">this._calledComponentWillUnmount &#x3D; false;</span><br></pre></td></tr></table></figure>

<h3 id="constructComponentWithoutOwner"><a href="#constructComponentWithoutOwner" class="headerlink" title="_constructComponentWithoutOwner"></a>_constructComponentWithoutOwner</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Component &#x3D; this._currentElement.type;</span><br><span class="line"></span><br><span class="line">if (doConstruct) &#123;</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    &#x2F;&#x2F; 略</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return new Component(publicProps, publicContext, updateQueue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; This can still be an instance in case of factory components</span><br><span class="line">&#x2F;&#x2F; but we&#39;ll count this as time spent rendering as the more common case.</span><br><span class="line">if (__DEV__) &#123;</span><br><span class="line">  &#x2F;&#x2F; 略</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return Component(publicProps, publicContext, updateQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里type是一个函数, 实际上它就是我们写的组件、页面这类。这块可以参考jsx到js的转换这块。</p>
<p>他最终返回的是一个React.createElement()返回值。</p>
<h3 id="performInitialMount"><a href="#performInitialMount" class="headerlink" title="performInitialMount"></a>performInitialMount</h3><p>这个函数里面执行了mount之前的一些生命周期函数。</p>
<p>关键代码是这样的，实在是不得不提。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If not a stateless component, we now render</span></span><br><span class="line"><span class="keyword">if</span> (renderedElement === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  renderedElement = <span class="built_in">this</span>._renderValidatedComponent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nodeType = ReactNodeTypes.getType(renderedElement);</span><br><span class="line"><span class="built_in">this</span>._renderedNodeType = nodeType;</span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">this</span>._instantiateReactComponent(</span><br><span class="line">  renderedElement,</span><br><span class="line">  nodeType !== ReactNodeTypes.EMPTY <span class="comment">/* shouldHaveDebugID */</span>,</span><br><span class="line">);</span><br><span class="line"><span class="built_in">this</span>._renderedComponent = child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> markup = ReactReconciler.mountComponent(</span><br><span class="line">  child,</span><br><span class="line">  transaction,</span><br><span class="line">  hostParent,</span><br><span class="line">  hostContainerInfo,</span><br><span class="line">  <span class="built_in">this</span>._processChildContext(context),</span><br><span class="line">  debugID,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>_renderValidatedComponent</code>是内部的一个私有的安全的render调用，调用组件自身的render函数返回结果。</p>
</li>
<li><p><code>_instantiateReactComponent</code>则实际上是在<code>ReactCompositeComponentWrapper</code>上定义的。关于<code>ReactCompositeComponentWrapper</code>实际上<code>instantiateReactComponent</code>中有过定义，它会根据<code>renderedElement.type</code>情况返回四种实例中等之一，这里的<code>child</code>是自定义元素内部的子元素。</p>
</li>
<li><p><code>ReactReconciler.mountComponent</code>也有过分析，它实质上只负责找到child对应的模块类型，然后调用其自身的<code>mountComponent</code>进行挂载。</p>
</li>
</ul>
<h3 id="unmountComponent"><a href="#unmountComponent" class="headerlink" title="unmountComponent"></a>unmountComponent</h3><p>这里做了几件事</p>
<ul>
<li>生命周期componentWillUnmount函数激活</li>
<li>将construct函数挂载上去的东西清空</li>
<li>调用组件自身unmountComponent来卸载</li>
<li>ReactInstanceMap.remove(inst) 移除内部对此实例的内部引用。</li>
</ul>
<h3 id="updateComponent"><a href="#updateComponent" class="headerlink" title="updateComponent"></a>updateComponent</h3><p>这里有一个调用链，可以简单回顾一下。</p>
<p>这里的主要逻辑是</p>
<ul>
<li>归集prevProps、nextProps、nextState、nextConext判断是否进行更新</li>
<li>如果更新 调用_performComponentUpdate来进行更新</li>
<li>如果不更新将上面收集到props、state、content赋值给nextElement并更新_currentElement引用</li>
</ul>
<h3 id="performComponentUpdate"><a href="#performComponentUpdate" class="headerlink" title="_performComponentUpdate"></a>_performComponentUpdate</h3><p>它也不是更新的实质性执行者。它做了以下的事情</p>
<ul>
<li>处理好componentWillUpdate&amp;componentDidUpdate生命周期函数的调用</li>
<li>调用_updateRenderedComponent执行实质性更新</li>
</ul>
<h3 id="updateRenderedComponent"><a href="#updateRenderedComponent" class="headerlink" title="_updateRenderedComponent"></a>_updateRenderedComponent</h3><p>这个函数呢有两个分支。</p>
<p>它会做这样的处理。</p>
<ul>
<li>如果是同一个组件 则需要更新 =&gt; 就执行组件的receiveComponent来呼起自身的更新逻辑</li>
<li>如果不是同一个组件则需要进行替换 =&gt; 这是先卸载原组件 然后挂载新组件</li>
</ul>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react-instantiateReactComponent</title>
    <url>/2019/06/15/react-instantiateReactComponent/</url>
    <content><![CDATA[<h2 id="简况"><a href="#简况" class="headerlink" title="简况"></a>简况</h2><p>instantiateReactComponent是在ReactReconciler中被经常引用的一个函数，用于调度并返回组件实例。</p>
<p>目标路径:<code>src/renderers/shared/stack/reconciler/instantiateReactComponent.js </code></p>
<p>关于这个函数有使用注释，移除DEV和一些警告抛错类函数调用，它大致是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- Given a ReactNode, create an instance that will actually be mounted.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">- <span class="doctag">@param <span class="type">&#123;ReactNode&#125;</span> <span class="variable">node</span></span></span></span><br><span class="line"><span class="comment">- <span class="doctag">@param <span class="type">&#123;boolean&#125;</span> <span class="variable">shouldHaveDebugID</span></span></span></span><br><span class="line"><span class="comment">- <span class="doctag">@return <span class="type">&#123;object&#125;</span> </span>A new instance of the element&#x27;s constructor.</span></span><br><span class="line"><span class="comment">- <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node, shouldHaveDebugID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span> || node === <span class="literal">false</span>) &#123;</span><br><span class="line">    instance = ReactEmptyComponent.create(instantiateReactComponent);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> element = node;</span><br><span class="line">    <span class="keyword">var</span> type = element.type;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> type !== <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> type !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> info = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      info += getDeclarationErrorAddendum(element._owner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> element.type === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      instance = ReactHostComponent.createInternalComponent(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInternalComponentType(element.type)) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> element.type(element);</span><br><span class="line">      <span class="keyword">if</span> (!instance.getHostNode) &#123;</span><br><span class="line">        instance.getHostNode = instance.getNativeNode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> ReactCompositeComponentWrapper(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> node === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    instance = ReactHostComponent.createInstanceForText(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">  &#125;</span><br><span class="line">  instance._mountIndex = <span class="number">0</span>;</span><br><span class="line">  instance._mountImage = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它返回的实例有以下几种:</p>
<ul>
<li>ReactEmptyComponent.create -&gt; ReactDOMEmptyComponent实例</li>
<li>ReactHostComponent.createInternalComponent -&gt; ReactDOMComponent实例</li>
<li>new element.type(element) </li>
<li>new ReactCompositeComponentWrapper(element) -&gt; ReactCompositeComponentWrapper实例</li>
</ul>
<p>这几个实例都有一个共性。那就是他们全<strong>都在原型上定义了mountComponent、receiveComponent、getHostNode、unmountComponent四个方法</strong>。这也是ReactReconciler模块的规划需要。</p>
<p>这里有个补充，后来我在&lt;&lt;深入react技术栈&gt;&gt;看到一个小结，说是高屋建瓴也没错，这里可以作为补充:</p>
<p><img src="/images/image-20190617090423902.png" alt="image-20190617090423902"></p>
<h2 id="参数和返回"><a href="#参数和返回" class="headerlink" title="参数和返回"></a>参数和返回</h2><p>前面提到的实例类型的返回取决于它的参数，这里一共有四种情况。</p>
<table>
<thead>
<tr>
<th>type</th>
<th>末节点调用</th>
</tr>
</thead>
<tbody><tr>
<td>null 或 false</td>
<td>ReactEmptyComponent.create</td>
</tr>
<tr>
<td>string</td>
<td>ReactDOMComponent</td>
</tr>
<tr>
<td>function &amp;&amp; element.type原生组件</td>
<td>element.type(element)</td>
</tr>
<tr>
<td>function &amp;&amp; element.type自定义组件</td>
<td>new ReactCompositeComponentWrapper(element)</td>
</tr>
</tbody></table>
<h3 id="ReactEmptyComponent"><a href="#ReactEmptyComponent" class="headerlink" title="ReactEmptyComponent"></a>ReactEmptyComponent</h3><p>当node传入值为null 或者 false时候回返回它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactDOMEmptyComponent = <span class="function"><span class="keyword">function</span>(<span class="params">instantiate</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ReactCompositeComponent uses this:</span></span><br><span class="line">  <span class="built_in">this</span>._currentElement = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// ReactDOMComponentTree uses these:</span></span><br><span class="line">  <span class="built_in">this</span>._hostNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>._hostParent = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>._hostContainerInfo = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>._domID = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么可以设想一下？<strong>什么情况下，node值会是null 或者 false</strong>?</p>
<p>回顾一下之前提到的jsx到js的转换,我们都jsx在转换后，children会依次按层级放在其父元素的type属性上。那么可想而知我们最终节点是没有children的，此时node值可能会是null 或者 false。</p>
<p><strong>但是，虽然上文的推论很浅显直观，但是它是有漏洞的</strong>。不仅仅是自定义组件内部会含有html标记，而且一般来说末节点才有可能是null或者false,但是一般来说它都是string,也就是说末节点一般是常规的html标记。</p>
<p> 准确的来讲,以下情况才是会发生返回这种children的场景:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// return</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">Foo</span> /&gt;</span></span>, container)</span><br></pre></td></tr></table></figure>

<p>ReactCompositeComponent line511-514，对child的取值。当达到末节点，此时type为null。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">this</span>._instantiateReactComponent(</span><br><span class="line">  renderedElement,</span><br><span class="line">  nodeType !== ReactNodeTypes.EMPTY <span class="comment">/* shouldHaveDebugID */</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>而且这个实例中有一个属性 <code>this._currentElement = null</code>会被其用到。</p>
<h3 id="ReactDOMComponent"><a href="#ReactDOMComponent" class="headerlink" title="ReactDOMComponent"></a>ReactDOMComponent</h3><p>ReactDOMComponent的情况可能是最容易理解的，当渲染的元素是HTML标准的<code>div</code>、<code>span</code>标记这类, 此时type类型就是string。</p>
<p>这种情况情况常常发生在末节点，和自定义组件里面的children里。</p>
<h3 id="element-type-element"><a href="#element-type-element" class="headerlink" title="element.type(element)"></a>element.type(element)</h3><p>暂时可用于一些非字符串标识的自定义组件,不过目前来说这是一个当前版本的妥协(临时措施), 未来版本会将其作为字符串标识,完成之后这个分支会被删除。</p>
<h3 id="ReactCompositeComponentWrapper"><a href="#ReactCompositeComponentWrapper" class="headerlink" title="ReactCompositeComponentWrapper"></a>ReactCompositeComponentWrapper</h3><p>ReactCompositeComponentWrapper比较常规。它用来处理自定义组件，比如之前提到的<code>Foo</code>组件就需要用它来处理一遍。</p>
<p>这个函数的作用呢就是对自定义组件做一些处理，比如我们的生命周期函数，事件绑定等一般都是在这里，当组件挂载、更新、卸载也都需要一个比较专门的逻辑来处理。不过虽然如此，但是这个函数其实也是相对抽象的，因为一旦到了type为string时候它会将事情转交给ReactDOMComponent模块。</p>
<p>它本身更多的是对自定义组件的生命周期调用、事务处理、状态更新进行了抽象。</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React虚拟DOM</title>
    <url>/2019/04/03/react-VirtualDom/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这一节实际上很靠后才整理的。</p>
<p>主要整理的动机是自己看完很多源码后进行消化、重构整体知识体系时候，看到&lt;&lt;深入React技术栈&gt;&gt;源码分析里面关于虚拟DOM这块以后，对这个部分强化了个人对这块的体系认知之后的整理。</p>
<p>这里主要是宏观体系层次的整理，不太涉及细节。</p>
<h1 id="虚拟DOM构成"><a href="#虚拟DOM构成" class="headerlink" title="虚拟DOM构成"></a>虚拟DOM构成</h1><p>虚拟DOM是一棵树，从根节点一直向下生长，它有很多节点，这些节点有相同，也有不同。</p>
<h2 id="相同处"><a href="#相同处" class="headerlink" title="相同处"></a>相同处</h2><p>各个节点都会有以下基础属性：</p>
<ul>
<li>标签名</li>
<li>节点属性: style|attr|event</li>
<li>children</li>
<li>key</li>
</ul>
<h2 id="不同处"><a href="#不同处" class="headerlink" title="不同处"></a>不同处</h2><p><strong>React虚拟DOM的节点统称React Node, 包含三中类型的节点，ReactElement、ReactFragment、ReactText。这其中ReactElement包含ReactComponentElement &amp; ReactDomElement。</strong>这里直接用一下&lt;&lt;深入React技术栈&gt;&gt;里面的一个集合定义，个人看到的时候有点恍然大悟的感觉。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReactNode = ReactElement | ReactFragment | ReactText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReactElement = ReactComponentElement | ReactDOMElement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReactDOMElement = &#123; </span><br><span class="line">  <span class="keyword">type</span> : <span class="built_in">string</span>, </span><br><span class="line">  props : &#123; </span><br><span class="line">    children : ReactNodeList, </span><br><span class="line">    className : <span class="built_in">string</span>, </span><br><span class="line">    etc.</span><br><span class="line">  &#125;, </span><br><span class="line">  key : <span class="built_in">string</span> | <span class="built_in">boolean</span> | <span class="built_in">number</span> | <span class="literal">null</span>, </span><br><span class="line">  ref : <span class="built_in">string</span> | <span class="literal">null</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReactComponentElement&lt;TProps&gt; = &#123; </span><br><span class="line">  <span class="keyword">type</span> : ReactClass&lt;TProps&gt;, </span><br><span class="line">  props : TProps, </span><br><span class="line">  key : <span class="built_in">string</span> | <span class="built_in">boolean</span> | <span class="built_in">number</span> | <span class="literal">null</span>, </span><br><span class="line">  ref : <span class="built_in">string</span> | <span class="literal">null</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReactFragment = <span class="built_in">Array</span>&lt;ReactNode | ReactEmpty&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReactNodeList = ReactNode | ReactEmpty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReactText = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReactEmpty = <span class="literal">null</span> | <span class="literal">undefined</span> | <span class="built_in">boolean</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>入口虚拟DOM节点创建是有分支处理的，上面已经提到了不同类型的节点，这里有创建入口，它会根据情况调用不同的方法创建不同类型的节点， 关键文件是instantiateReactComponent.js</p>
<p>这里之前有过分析，直接跳转。 <a href="/2019/06/15/react-instantiateReactComponent/">Go</a></p>
<h2 id="ReactDomElement"><a href="#ReactDomElement" class="headerlink" title="ReactDomElement"></a>ReactDomElement</h2><p>实际上就是ReactDomComponent实例。</p>
<p>这里也有分析。直接跳转。 <a href="/2018/05/01/react-domComponent/">Go</a></p>
<h2 id="ReactComponentElement"><a href="#ReactComponentElement" class="headerlink" title="ReactComponentElement"></a>ReactComponentElement</h2><p>实际上就是ReacCompositeComponent实例。</p>
<p>这里也有分析。直接跳转。 <a href="/2019/06/15/react-ReactCompositeComponent/">Go</a></p>
<h2 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h2><p>文本本质上不算节点，但是React内部为了渲染一致，还是讲起封装成了文本组件ReactDOMTextComponent。通过这个封装，文本也可以实现Diff。</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>typescript在redux-react项目中的应用</title>
    <url>/2018/11/05/2018-11-5-typescript-redux-starter/</url>
    <content><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>这开头呢，我只想说一句 如何过好这一生。</p>
<p>关于React实际上早在很久很久之前写过一篇基于<a href="/2016/11/20/dva-react/">Dva方案的文章</a>，如果不考虑typecript和版本的话其实一切用起来至今也倒尚好。</p>
<p>可能typecript自己至今尚未学好，关于react、redux、typescript三者的结合，一直碎碎念，打磨不好。</p>
<p>这其中，有redux写起来繁琐的缘故、有typescript不到家的缘故。</p>
<p>直到几个月前看到github上<a href="https://github.com/rokoroku/react-redux-typescript-boilerplate"><strong>react-redux-typescript-boilerplate</strong></a>,终于觉得这是自己想要的方案，拖延好几个月，这里就简单整理一下，顺便把之前的Dva方案升级一下。</p>
<h1 id="方案简析"><a href="#方案简析" class="headerlink" title="方案简析"></a>方案简析</h1><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>这里redux，有很多概念，譬如Action/Reducer/Store/Middleware。在项目里面有对应的actions/reducers/store/middleware目录对应。这里不是redux的安利文所以不做特别说明。</p>
<p>关于方案的优势这里必须提一下其使用上的便利。一般情况下，我们使用redux时候dispatch一个状态都需要经过引用，然后在mapDispatchToProps里面注册，最后再<code>this.props.dispatch(&#123;type: Action, &#123;payload: &#123;&#125;&#125;&#125;)</code>进行状态触发。</p>
<p>在本方案中，redux和react的连接部分 代码是这样的：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">@connect(</span><br><span class="line">  (state: RootState, ownProps): Pick&lt;App.Props, <span class="string">&#x27;todos&#x27;</span> | <span class="string">&#x27;filter&#x27;</span>&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> hash = ownProps.location &amp;&amp; ownProps.location.hash.replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> filter = FILTER_VALUES.find(<span class="function">(<span class="params">value</span>) =&gt;</span> value === hash) || TodoModel.Filter.SHOW_ALL;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">todos</span>: state.todos, filter &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  (dispatch: Dispatch): Pick&lt;App.Props, <span class="string">&#x27;actions&#x27;</span>&gt; =&gt; (&#123;</span><br><span class="line">    actions: bindActionCreators(omit(TodoActions, <span class="string">&#x27;Type&#x27;</span>), dispatch)</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在这个小结，这里仅仅注意到bindActionCreators这个API的便利性即可。</p>
<h2 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h2><p>谈到ts，这里感觉巧妙的地方有些多。</p>
<p>比如actions/todo.ts</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createAction &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-actions&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; TodoModel &#125; <span class="keyword">from</span> <span class="string">&#x27;app/models&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> namespace TodoActions &#123;</span><br><span class="line">  <span class="keyword">export</span> enum Type &#123;</span><br><span class="line">    ADD_TODO = <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">    EDIT_TODO = <span class="string">&#x27;EDIT_TODO&#x27;</span>,</span><br><span class="line">    DELETE_TODO = <span class="string">&#x27;DELETE_TODO&#x27;</span>,</span><br><span class="line">    COMPLETE_TODO = <span class="string">&#x27;COMPLETE_TODO&#x27;</span>,</span><br><span class="line">    COMPLETE_ALL = <span class="string">&#x27;COMPLETE_ALL&#x27;</span>,</span><br><span class="line">    CLEAR_COMPLETED = <span class="string">&#x27;CLEAR_COMPLETED&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> addTodo = createAction&lt;PartialPick&lt;TodoModel, <span class="string">&#x27;text&#x27;</span>&gt;&gt;(Type.ADD_TODO);</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> editTodo = createAction&lt;PartialPick&lt;TodoModel, <span class="string">&#x27;id&#x27;</span>&gt;&gt;(Type.EDIT_TODO);</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> deleteTodo = createAction&lt;TodoModel[<span class="string">&#x27;id&#x27;</span>]&gt;(Type.DELETE_TODO);</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> completeTodo = createAction&lt;TodoModel[<span class="string">&#x27;id&#x27;</span>]&gt;(Type.COMPLETE_TODO);</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> completeAll = createAction(Type.COMPLETE_ALL);</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> clearCompleted = createAction(Type.CLEAR_COMPLETED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type TodoActions = Omit&lt;<span class="keyword">typeof</span> TodoActions, <span class="string">&#x27;Type&#x27;</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>这里有一个namespace和一个type。其中type这里使用了<code>Omit = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</code>这个高级类型,将namespace中的enum Type进行了排除。它的作用是给Container组件设置props类型的接口。</p>
<p>而namespace里面除了<code>addTodo</code>这些的引用，因为可以访问到Type，还可以在Reducer里面获得引用。</p>
<p>然后我们看看namespace这里面的addTodo这些。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addTodo = createAction&lt;PartialPick&lt;TodoModel, <span class="string">&quot;text&quot;</span>&gt;&gt;(actionType: string): ActionFunction1&lt;PartialPick&lt;TodoModel, <span class="string">&quot;text&quot;</span>&gt;, Action&lt;PartialPick&lt;TodoModel, <span class="string">&quot;text&quot;</span>&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>这里<code>PartialPick&lt;TodoModel, &quot;text&quot;&gt;</code>用来约束后面<code>dispatch</code>事件时候的传值。其中PartialPick是<code> Partial&lt;T&gt; &amp; Pick&lt;T, K&gt;</code>组成的联合类型。这里的意义是将TodoModel里面除了‘text’之外的属性改成选填状态。</p>
<p>然后是App/index.js文件。这里摘录一些关键代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> namespace App &#123;</span><br><span class="line">  <span class="keyword">export</span> interface Props <span class="keyword">extends</span> RouteComponentProps&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">    todos: RootState.TodoState;</span><br><span class="line">    actions: TodoActions;</span><br><span class="line">    filter: TodoModel.Filter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@connect(</span><br><span class="line">  (state: RootState, ownProps): Pick&lt;App.Props, <span class="string">&#x27;todos&#x27;</span> | <span class="string">&#x27;filter&#x27;</span>&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> hash = ownProps.location &amp;&amp; ownProps.location.hash.replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> filter = FILTER_VALUES.find(<span class="function">(<span class="params">value</span>) =&gt;</span> value === hash) || TodoModel.Filter.SHOW_ALL;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">todos</span>: state.todos, filter &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  (dispatch: Dispatch): Pick&lt;App.Props, <span class="string">&#x27;actions&#x27;</span>&gt; =&gt; (&#123;</span><br><span class="line">    actions: bindActionCreators(omit(TodoActions, <span class="string">&#x27;Type&#x27;</span>), dispatch)</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">App</span>.<span class="title">Props</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这其中，<code>type TodoActions</code>用在了<code>interface Props</code>中。</p>
<p>然后mapDispatchToProps函数中则是使用了bindActionCreators这个API并根据之前提到的Omit构建了一个函数排除‘Type’生成了我们常见的dispatch到props的注册。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>实际上在这个方案中，并没有太多特别的地方。只不过，在这里有几个地方处理得很好。</p>
<ul>
<li>typescript的namespace 和 type用得巧妙，namespace内部的enum这个也用的很巧妙</li>
<li>配合bindActionCreators方便了mapDispatchToProps函数的恼人操作</li>
</ul>
<h2 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h2><h3 id="Antd按需加载"><a href="#Antd按需加载" class="headerlink" title="Antd按需加载"></a>Antd按需加载</h3><p>官方推荐的按需加载用的是<code>babel-import-plugin</code>,不过这里因为用了Typescript，所以不推荐用它了，转而推荐其Ts版本的<code>ts-import-plugin</code>。</p>
<p>另外，按需加载依赖less。所以也需要配置一下less-loader这些。</p>
<p>最后就是<code>extract-text-webpack-plugin</code>在webpack4这里无法使用，所以转而使用了<code>mini-css-extract-plugin</code>,这里已经自带，不过注意不要将其和<code>style-loader</code>一同使用，这是冲突操作。</p>
<p>首先是依赖：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i ts-<span class="keyword">import</span>-plugin less less-loader postcss-less antd --save</span><br></pre></td></tr></table></figure>

<p>其次修改webpack配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          !isProduction &amp;&amp; &#123;</span><br><span class="line">            loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              plugins: [</span><br><span class="line">                <span class="string">&#x27;react-hot-loader/babel&#x27;</span></span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              transpileOnly: <span class="literal">true</span>,</span><br><span class="line">              getCustomTransformers: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">                before: [ tsImportPluginFactory(&#123;</span><br><span class="line">                  libraryName: <span class="string">&#x27;antd&#x27;</span>,</span><br><span class="line">                  libraryDirectory: <span class="string">&#x27;es&#x27;</span>,</span><br><span class="line">                  style: <span class="literal">true</span>,</span><br><span class="line">                &#125;) ]</span><br><span class="line">              &#125;),</span><br><span class="line">              compilerOptions: &#123;</span><br><span class="line">                <span class="built_in">module</span>: <span class="string">&#x27;es2015&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ].filter(<span class="built_in">Boolean</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">...</span><br><span class="line">      <span class="comment">// Rules for Ant-Design</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, <span class="comment">// replaces extract text plugin in webpack 4</span></span><br><span class="line">          <span class="string">`css-loader`</span>,</span><br><span class="line">          &#123;<span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>, <span class="attr">options</span>: postcssOptions&#125;,</span><br><span class="line">          &#123;<span class="attr">loader</span>: <span class="string">&#x27;less-loader&#x27;</span>, <span class="attr">options</span>: &#123; <span class="attr">javascriptEnabled</span>: <span class="literal">true</span> &#125;&#125;,</span><br><span class="line">        ],</span><br><span class="line">        include: [<span class="regexp">/[\\/]node_modules[\\/].*antd/</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, <span class="comment">// replaces extract text plugin in webpack 4</span></span><br><span class="line">          <span class="string">`css-loader?modules&amp;importLoaders=1&amp;localIdentName=[local]_[hash:base64:5]&amp;-autoprefixer`</span>,</span><br><span class="line">          &#123;<span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>, <span class="attr">options</span>: postcssOptions&#125;,</span><br><span class="line">          &#123;<span class="attr">loader</span>: <span class="string">&#x27;less-loader&#x27;</span>, <span class="attr">options</span>: &#123; <span class="attr">javascriptEnabled</span>: <span class="literal">true</span> &#125;&#125;,</span><br><span class="line">        ],</span><br><span class="line">        include: [projectPath],</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

<p>这里仅仅标出代码，详细可以直接看相关代码。</p>
<h3 id="添加异步库"><a href="#添加异步库" class="headerlink" title="添加异步库"></a>添加异步库</h3><p>这里使用redux-sagas。详细直接看代码。不作详细解说。</p>
<h3 id="API请求处理"><a href="#API请求处理" class="headerlink" title="API请求处理"></a>API请求处理</h3><p>这里根据之前代码简单封装whatwg-fetch。</p>
<p>不过这个请求库一般需要根据自己业务自行整体处理。这里聊作参考。</p>
<p>另外<strong>mock服务</strong>这里暂时不做了，如果考虑要做mock实质上还是推荐直接使用<code>devServer.proxy</code>来直接对请求进行反向代理，然后是如果远程rap方案的mock这里就不消说，如果是预备本地代理那就找个mockServer配合nodemon的watch和自动重启来做(不过mockServer也可能自带这个功能)。</p>
<h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>这块实质上是demo完成后补上的。</p>
<p>用意是虽然在Typescript体验上ok了，但是每次手动写那么多代码 建立那么多文件还是过于繁琐，于是参考别的项目使用<code>plop</code>做了若干配置。这里运行<code>npm run g</code>之后会有询问框，可以自行生成component &amp;&amp; container代码，component支持es6和stateless模块。</p>
<p>这里代码生成这里最麻烦的是container这块的redux相关配置，除了script/generators里面的配置、模版外，<strong>需要注意不要删除各个文件里面的/* PREPEND IMPORT HERE */、/* PREPEND ATTR HERE */之类</strong>，这里是插入相关引用必须的插入点。</p>
<h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><p>临push时候想起还没这个生产级别的基础配置，这里简单配置了一下。主要是<code>loadable-components &amp;&amp; @babel/plugin-syntax-dynamic-import &amp;&amp; @babel/react</code>。</p>
<p>这里集成到plop模版了，默认开启，使用<code>npm run g</code>创建container时候会默认开启这个功能。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐 方便看master代码</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;que01&#x2F;react-redux-typescript-boilerplate </span><br><span class="line">cd react-redux-typescript-boilerplate</span><br><span class="line">git checkout -b demo</span><br><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;demo demo</span><br><span class="line">git pull</span><br><span class="line">&#x2F;&#x2F; 直接</span><br><span class="line">git clone -b demo https:&#x2F;&#x2F;github.com&#x2F;que01&#x2F;react-redux-typescript-boilerplate</span><br></pre></td></tr></table></figure>






]]></content>
      <tags>
        <tag>react redux</tag>
      </tags>
  </entry>
  <entry>
    <title>react Event</title>
    <url>/2018/06/10/react-event/</url>
    <content><![CDATA[<h1 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h1><p>这里暂时不做高屋建瓴式的解读直接给出关键文件。而是从之前已有的分析开始，尝试自己蛛丝马迹找出来。</p>
<p>既然是事件绑定，那么必然在<code>ReactDom.render</code>的环节里面有处理。所以这里简单回顾然后把它挖出来。</p>
<p>我们知道React在浏览器的运行时里面的渲染存在两种情况，一种是第一次的初次渲染，一种是props更新带来的更新。</p>
<p>当我们说事件的时候，我们是在说谁的事件？之前分析已经提到了调度函数ReactReconciler返回的几种实例：<code>ReactDOMEmptyComponent</code>、<code>ReactDOMComponent</code>实例、<code>ReactCompositeComponentWrapper</code>实例。</p>
<p>那么回想一下，当我们绑定事件的时候第一次渲染里面必然会有，props和state更新时候我们的React事务也会这样做(清场和现场还原)。</p>
<p>这个操作呢，第一次渲染时候大抵在<code>ReactCompositeComponentWrapper.mountComponent</code>里面，它可能是这个组件上绑定，再不济也应该是在其children中绑定，后面的渲染，则大抵在<code>ReactUpdates.js</code>的<code>ReactUpdatesFlushTransaction</code>中。</p>
<p>不过整体按React抽象至死的尿性，显然最后都会殊途同归。不过这里还是尝试整理一下两条路线下的调用路径。</p>
<h2 id="mountComponent路径"><a href="#mountComponent路径" class="headerlink" title="mountComponent路径"></a>mountComponent路径</h2><p>这里不再重复贴代码,如果读到这里的时候没有看过之前的分析,也没有自己打开IDE debug过，其实这篇文章读与不读，本质上区别不大。</p>
<p>这个函数代码不多，配合这个函数的注释简直确认了我自己猜测的注释:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes the component, renders markup, and registers event listeners.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ReactReconcileTransaction|ReactServerRenderingTransaction&#125;</span> <span class="variable">transaction</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;?object&#125;</span> <span class="variable">hostParent</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;?object&#125;</span> <span class="variable">hostContainerInfo</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;?object&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;?string&#125;</span> </span>Rendered markup to be inserted into the DOM.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@final</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>简单分析<code>ReactCompositeComponent.mountComponent</code>可以很容易知道这里的事件绑定,下一步路径是<code>ReactCompositeComponentWrapper.performInitialMount</code>。</p>
<p>在这个函数内</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">this</span>._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY <span class="comment">/* shouldHaveDebugID */</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">this</span>._renderedComponent = child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, <span class="built_in">this</span>._processChildContext(context), debugID);</span><br></pre></td></tr></table></figure>

<p>child是自定义函数里面的render里面的子组件，他的type是一个string，这样调度模块使用ReactDOMComponent.mountComponent来定义这块。</p>
<p>回顾一下<code>ReactDOMComponent._updateDOMProperties</code> 里面提到的<code>enqueuePutListener</code>，这里是事件注册的关注点。这个函数里面进行绑定的关键代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">listenTo(registrationName, doc);</span><br><span class="line">transaction.getReactMountReady().enqueue(putListener, &#123;</span><br><span class="line">  inst: inst,</span><br><span class="line">  registrationName: registrationName,</span><br><span class="line">  listener: listener,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里事件绑定到document上，然后使用putListener来进行事件绑定。</p>
<p>其中<code>listenTo</code>指向<code>ReactBrowserEventEmitter.listenTo</code>，<code>putListener</code>指向<code>EventPluginHub.putListener</code>。</p>
<h2 id="props更新路径"><a href="#props更新路径" class="headerlink" title="props更新路径"></a>props更新路径</h2><p>参考之前lifecycle里面props更新环节的render分析和<code>ReactCompositeComponent._updateRenderedComponent</code>分析。这里的定位分析点是起始点<code>ReactCompositeComponent._updateRenderedComponent</code>。</p>
<p>这里有替换和更新两个分支 我们这里只谈更新。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactReconciler.receiveComponent(</span><br><span class="line">  prevComponentInstance,</span><br><span class="line">  nextRenderedElement,</span><br><span class="line">  transaction,</span><br><span class="line">  <span class="built_in">this</span>._processChildContext(context),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>和之前同样的道理，定位到<code>ReactDOMComponent.receiveComponent</code>。一路顺着</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOMComponent.receiveComponent</span><br><span class="line">	-&gt; ReactDOMComponent.updateComponent</span><br><span class="line">		-&gt; ReactDOMComponent._updateDOMProperties</span><br></pre></td></tr></table></figure>

<p>的路径，显然，最初的猜测一点没错。</p>
<h2 id="补充-amp-旁白"><a href="#补充-amp-旁白" class="headerlink" title="补充 &amp; 旁白"></a>补充 &amp; 旁白</h2><p>这里两个路径的探索，说白了还是从断点角度的摸索，属于从下往上的摸索。虽然可以摸清楚这些，但是实际上不是最好的办法。</p>
<p>但是如果可以对虚拟DOM节点、render、和Diff路径有相对清晰的了解和认知，那么当可以从顶层设计上对这个<code>ReactDOMComponent._updateDOMProperties</code>函数进行定位。</p>
<p>如果非要一个思路，这里可以这样思考:</p>
<ul>
<li>Diff算法实质上除了’移动’，不存在实质意义上的’更新’，这个更新本质是删除旧的+替换新的。</li>
<li>不管是初始render还是替换，都需要对一个新的ReactDomCompositeComponent进行实例化备用。</li>
<li>这个过程中终究会伴随<code>_updateDOMProperties</code>函数调用。</li>
<li>这个<code>_updateDOMProperties</code>函数，是自定义组件渲染为ReactDOMComponent的核心调用。</li>
</ul>
<h1 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h1><h2 id="事件保存-amp-amp-绑定"><a href="#事件保存-amp-amp-绑定" class="headerlink" title="事件保存 &amp;&amp; 绑定"></a>事件保存 &amp;&amp; 绑定</h2><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>事件保存主要是走的<code>EventPluginHub.putListener</code>,将putListener保存到了listenerBank。具体一点来说，是将事件放到了<code>listenerBank[registrationName][getDictionaryKey(inst)]</code>。这里<code>getDictionaryKey</code>的返回值是<code>&#39;.&#39; + inst._rootNodeID</code>。</p>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>来自ReacDomComponent.js文件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueuePutListener</span>(<span class="params">inst, registrationName, listener, transaction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (transaction <span class="keyword">instanceof</span> ReactServerRenderingTransaction) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> containerInfo = inst._hostContainerInfo;</span><br><span class="line">  <span class="keyword">var</span> isDocumentFragment =</span><br><span class="line">    containerInfo._node &amp;&amp; containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;</span><br><span class="line">  <span class="keyword">var</span> doc = isDocumentFragment</span><br><span class="line">    ? containerInfo._node</span><br><span class="line">    : containerInfo._ownerDocument;</span><br><span class="line">  listenTo(registrationName, doc);</span><br><span class="line">  transaction.getReactMountReady().enqueue(putListener, &#123;</span><br><span class="line">    inst: inst,</span><br><span class="line">    registrationName: registrationName,</span><br><span class="line">    listener: listener,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个绑定是由<code>listenTo(registrationName, doc)</code>处理的，直接把事件绑定到document，利用事件冒泡性质来进行事件委托处理。这个listenTo实际上就是<code>ReactBrowserEventEmitter.listenTo</code>。</p>
<h2 id="事件触发-amp-amp-分发"><a href="#事件触发-amp-amp-分发" class="headerlink" title="事件触发 &amp;&amp; 分发"></a>事件触发 &amp;&amp; 分发</h2><p><strong>事件触发</strong>这个实际上在上一小结就提到了，当事件在某个元素上触发，会冒泡到document，然后document开始触发相关逻辑。</p>
<p><strong>事件分发</strong>主要是通过<code>ReactBrowserEventEmitter.listenTo</code>处理。这里关于浏览器兼容有点多，不过这里管住核心代码就好。这里的<code>listenTo</code>有两个核心调用, 都在<code>ReactBrowserEventEmitter.ReactEventListener</code>上。</p>
<h3 id="ReactEventListener"><a href="#ReactEventListener" class="headerlink" title="ReactEventListener"></a>ReactEventListener</h3><ul>
<li>trapBubbledEvent</li>
<li>trapCapturedEvent</li>
</ul>
<p>看看它们引用到的listen和capture中的listen(React 15.6是支持冒泡+捕获两种事件传播的,具体参考traverseTwoPhase函数，但是这仅仅是传播的支持，并没有具体实现这个捕获事件触发)。这里就是我们熟悉的原生API了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">listen: <span class="function"><span class="keyword">function</span> (<span class="params">target, eventType, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target.addEventListener) &#123;</span><br><span class="line">    target.addEventListener(eventType, callback, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      remove: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        target.removeEventListener(eventType, callback, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target.attachEvent) &#123;</span><br><span class="line">    target.attachEvent(<span class="string">&#x27;on&#x27;</span> + eventType, callback);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      remove: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        target.detachEvent(<span class="string">&#x27;on&#x27;</span> + eventType, callback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意的是我们这里的addEventListener是在DOM层级上触发的，当我们触发了这个事件，接下来需要找到我们保存的回调函数，不然这个触发就毫无意义。</p>
<p>以<code>trapBubbledEvent</code>为例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">trapBubbledEvent: <span class="function"><span class="keyword">function</span>(<span class="params">topLevelType, handlerBaseName, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!element) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EventListener.listen(</span><br><span class="line">    element,</span><br><span class="line">    handlerBaseName,</span><br><span class="line">    ReactEventListener.dispatchEvent.bind(<span class="literal">null</span>, topLevelType),</span><br><span class="line">  );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这里传入到listen中的事件回调是<code>ReactEventListener.dispatchEvent.bind(null, topLevelType)</code></p>
<p><strong>首先，这里有个十分重要的地方需要注意，那就是这个<code>element</code>变量。这个element常规情况下直接指向的document对象。也就是说，事件绑定在document上了</strong>。这可以方便整体的事件管理，原理同大家用过的Jquery事件委托。</p>
<p>其次，这里进一步看看<code>ReactEventListener.dispatchEvent</code>的基础定义:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dispatchEvent: <span class="function"><span class="keyword">function</span> (<span class="params">topLevelType, nativeEvent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ReactEventListener._enabled) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    TopLevelCallbackBookKeeping.release(bookKeeping);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>EventListener.listen</code>本质上还是<code>addEventListener</code>的封装,所以作为回调的函数<code>ReactEventListener.dispatchEvent.bind(null, topLevelType)</code>它会被传入一个event事件对象 ,这个对象会被作为nativeEvent参数传入到<code>TopLevelCallbackBookKeeping</code>。<strong>然后就是重点了</strong>: <code>event</code>对象中有触发的DOM node节点引用，这点非常重要，只有如此，我们才可以进一步在虚拟DOM树中获取到需要触发冒泡捕获的所有节点，这点同样非常重要。</p>
<p>PS: 除了这里常规的事件委托，关于<code>SimpleEventPlugin.putListener</code>可以了解一下。</p>
<h4 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a>dispatchEvent</h4><p><code>ReactEventListener.dispatchEvent</code>这里做的事情显然是触发我们定义好的回调，我们所有的事件绑定的回调函数都被储存在一个集中的地方，那么我们现在看看它如何从这个集合中正确找出我们需要的事件回调。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dispatchEvent: <span class="function"><span class="keyword">function</span>(<span class="params">topLevelType, nativeEvent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ReactEventListener._enabled) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> bookKeeping = TopLevelCallbackBookKeeping.getPooled(</span><br><span class="line">    topLevelType,</span><br><span class="line">    nativeEvent,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Event queue being processed in the same cycle allows</span></span><br><span class="line">    <span class="comment">// `preventDefault`.</span></span><br><span class="line">    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    TopLevelCallbackBookKeeping.release(bookKeeping);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>关于<code>ReactUpdates.batchedUpdates</code>之前在render相关文章里面有分析，这里不做更多分析，这里的关键是<code>handleTopLevelImpl</code></p>
<h4 id="handleTopLevelImpl"><a href="#handleTopLevelImpl" class="headerlink" title="handleTopLevelImpl"></a>handleTopLevelImpl</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleTopLevelImpl</span>(<span class="params">bookKeeping</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);</span><br><span class="line">  <span class="comment">// 关于这个函数 用于从原生元素上获取最近的上级ReactNode实例</span></span><br><span class="line">  <span class="keyword">var</span> targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(</span><br><span class="line">    nativeEventTarget,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Loop through the hierarchy, in case there&#x27;s any nested components.</span></span><br><span class="line">  <span class="comment">// It&#x27;s important that we build the array of ancestors before calling any</span></span><br><span class="line">  <span class="comment">// event handlers, because event handlers can modify the DOM, leading to</span></span><br><span class="line">  <span class="comment">// inconsistencies with ReactMount&#x27;s node cache. See #1105.</span></span><br><span class="line">  <span class="comment">// 提前缓存祖先组件，因为事件回调可能会中途修改它，导致无法找对正确对应ReactNode实例</span></span><br><span class="line">  <span class="keyword">var</span> ancestor = targetInst;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    bookKeeping.ancestors.push(ancestor);</span><br><span class="line">    ancestor = ancestor &amp;&amp; findParent(ancestor);</span><br><span class="line">  &#125; <span class="keyword">while</span> (ancestor);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookKeeping.ancestors.length; i++) &#123;</span><br><span class="line">    targetInst = bookKeeping.ancestors[i];</span><br><span class="line">    ReactEventListener._handleTopLevel(</span><br><span class="line">      bookKeeping.topLevelType,</span><br><span class="line">      targetInst,</span><br><span class="line">      bookKeeping.nativeEvent,</span><br><span class="line">      getEventTarget(bookKeeping.nativeEvent),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>do~while</code>先缓存target触发事件那一瞬的所有父组件，这是一个数组，从左到右，右边的是左边的父组件。<strong>这里i从0起，其实也就是事实上走了从子到父的路径，也就是说，只有冒泡被实现了</strong>。这里<code>_handleTopLevel</code>指向<code>ReactEventEmitterMixin.handleTopLevel</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleTopLevel: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> events = EventPluginHub.extractEvents(</span><br><span class="line">    topLevelType,</span><br><span class="line">    targetInst,</span><br><span class="line">    nativeEvent,</span><br><span class="line">    nativeEventTarget,</span><br><span class="line">  );</span><br><span class="line">  runEventQueueInBatch(events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有<code>extractEvents</code>从注册的事件里面将目标事件取出，然后调用<code>runEventQueueInBatch</code>批量执行回调。其内容仍旧是<code>EventPluginHub</code>上的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventPluginHub.enqueueEvents(events);</span><br><span class="line">EventPluginHub.processEventQueue(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>接下来看看这两个函数细节。enqueueEvents作用相对简单，维护<code>EventPluginHub.eventQueue</code>变量确保其是一个事件组成的一维数组(也可能是null)。</p>
<p>processEventQueue函数则是触发所有事件，将事件清空，并抛出其运行时的错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">processEventQueue: <span class="function"><span class="keyword">function</span>(<span class="params">simulated</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> processingEventQueue = eventQueue;</span><br><span class="line">  eventQueue = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (simulated) &#123;</span><br><span class="line">    forEachAccumulated(</span><br><span class="line">      processingEventQueue,</span><br><span class="line">      executeDispatchesAndReleaseSimulated,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    forEachAccumulated(</span><br><span class="line">      processingEventQueue,</span><br><span class="line">      executeDispatchesAndReleaseTopLevel,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  ReactErrorUtils.rethrowCaughtError();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这里<code>executeDispatchesAndReleaseSimulated</code>、<code>executeDispatchesAndReleaseTopLevel</code>都是调用的<code>executeDispatchesAndRelease</code>只不过一个传入了true参数，一个传入了false参数。</p>
<p>一路深入这个函数的调用栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">executeDispatchesAndRelease</span><br><span class="line">-&gt;EventPluginUtils.executeDispatchesInOrder</span><br><span class="line">--&gt;executeDispatch</span><br><span class="line">---&gt;invokeGuardedCallback</span><br></pre></td></tr></table></figure>

<p>其实他们最终调用到的都是同一个函数<code>invokeGuardedCallback</code>。这个函数作用就是直接执行eventHandle,并捕获错误，没别的作用了。</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>前面分析的都是具体的路径，不过总归对触发还是需要一个原理上的总结。</p>
<p>我们知道事件在DOM中的传播是先从外层逐层捕获，然后从里层逐层冒泡。这个过程涉及到的DOM层实际上就是触发事件的target node,和其上级的各个父祖元素。这是其一。</p>
<p>其二，当冒泡捕获发生以后，会在各个父祖元素上也触发对应的事件回调。</p>
<p>其三，当我们在document上触发事件时候，事件回调会被传入一个event对象，这个event对象里面会有触发事件的target node(HTMLElement)的引用，配合ReactDOMComponentTree的API或者其他，总之精确获取到要触发冒泡的目标组件集合就可以做到顺手拈来。</p>
<p>最后，触发的那瞬间在储存的事件集合里面找到对应<code>inst._rootNodeID</code>的事件并触发即可。当然，这里的触发也会进行批处理优化(runEventQueueInBatch)。</p>
<p>这就是整体的原理。至于细节，可以慢慢从上面的分析上思考。</p>
<h1 id="源码细节"><a href="#源码细节" class="headerlink" title="源码细节"></a>源码细节</h1><h2 id="EventPluginHub"><a href="#EventPluginHub" class="headerlink" title="EventPluginHub"></a>EventPluginHub</h2><table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>putListener</td>
<td>保存listener到集合</td>
</tr>
<tr>
<td>getListener</td>
<td>从集合中获取listener</td>
</tr>
<tr>
<td>deleteListener</td>
<td>从集合删除这个listener</td>
</tr>
<tr>
<td>deleteAllListeners</td>
<td>移除集合里面所有listener</td>
</tr>
<tr>
<td>extractEvents</td>
<td>允许已注册插件从浏览器原生事件获取已注册事件</td>
</tr>
<tr>
<td>enqueueEvents</td>
<td>将事件排队推入一个合成事件中，在processEventQueue执行时触发</td>
</tr>
<tr>
<td>processEventQueue</td>
<td>执行事件队列上的所有合成事件</td>
</tr>
</tbody></table>
<h3 id="extractEvents"><a href="#extractEvents" class="headerlink" title="extractEvents"></a>extractEvents</h3><p>extractEvents方法可能是整个流程中比较影响深入理解的，这里简单分析一下。</p>
<p>这个函数实质上遍历<code>EventPluginRegistry.plugins</code>,然后通过根据其内部的plugin自身的<code>extractEvents</code>方法来获取事件。以<code>SimpleEventPlugin</code>为例。这里假设<code>TopLevelTypes === ‘topError’ </code>。此时这个代码的逻辑就相当于:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event = SyntheticEvent(</span><br><span class="line">	dispatchConfig,</span><br><span class="line">  targetInst,</span><br><span class="line">  nativeEvent,</span><br><span class="line">  nativeEventTarget</span><br><span class="line">)</span><br><span class="line">EventPropagators.accumulateTwoPhaseDispatches(event);</span><br><span class="line"><span class="keyword">return</span> event;</span><br></pre></td></tr></table></figure>

<p>此时event的数据结构是这样的</p>
<p><img src="/images/20180906111656.png"></p>
<p><code>EventPropagators.accumulateTwoPhaseDispatches(event)</code>顺藤摸瓜则指向了:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventPluginUtils.traverseTwoPhase(</span><br><span class="line">  event._targetInst,</span><br><span class="line">  accumulateDirectionalDispatches,</span><br><span class="line">  event,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其最终的指向则是<code>ReactDOMTreeTraversal.traverseTwoPhase</code>,这个函数模拟冒泡/捕获环节的事件分发的遍历行为，实质上它是获取所有父元素得到数组(索引升序对应更上层的父元素)，先降序遍历触发捕获回调，然后升序遍历触发冒泡回调的过程。而这个回调则指向了<code>accumulateDirectionalDispatches</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accumulateDirectionalDispatches</span>(<span class="params">inst, phase, event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> listener = listenerAtPhase(inst, event, phase);</span><br><span class="line">  <span class="keyword">if</span> (listener) &#123;</span><br><span class="line">    event._dispatchListeners = accumulateInto(</span><br><span class="line">      event._dispatchListeners,</span><br><span class="line">      listener,</span><br><span class="line">    );</span><br><span class="line">    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数整体来说做了两件事就是操作<code>event._dispatchListeners &amp;&amp; event._dispatchInstances</code>。</p>
<p>在之前我们提到<code>traverseTwoPhase</code>是冒泡捕获的遍历过程的模拟，对应的说这里的<code>phase</code>参数就是这个过程的标志，<code>captured</code>和<code>bubbled</code>是其可选值。之所以有这个参数 就是因为在不同阶段对应的listener并不一样。**<code>listenerAtPhase</code>实质上调用<code>EventPluginHub.getListener</code>来获取这个listener**。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除了这些，这里还有一个injection方法，通过<code>EventPluginRegistry</code>上的方法来进行一些依赖注入。</p>
<p>这个注入还是在之前见过很多次的<code>ReactDefaultInjection.js</code>里面。这里整体代码是这样的，为了方便阅读有简单修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactInjection.EventPluginHub.injectEventPluginOrder([</span><br><span class="line">  <span class="string">&#x27;ResponderEventPlugin&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;SimpleEventPlugin&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;TapEventPlugin&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;EnterLeaveEventPlugin&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;ChangeEventPlugin&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;SelectEventPlugin&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;BeforeInputEventPlugin&#x27;</span>,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">ReactInjection.EventPluginHub.injectEventPluginsByName(&#123;</span><br><span class="line">  SimpleEventPlugin: SimpleEventPlugin,</span><br><span class="line">  EnterLeaveEventPlugin: EnterLeaveEventPlugin,</span><br><span class="line">  ChangeEventPlugin: ChangeEventPlugin,</span><br><span class="line">  SelectEventPlugin: SelectEventPlugin,</span><br><span class="line">  BeforeInputEventPlugin: BeforeInputEventPlugin,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="EventPluginRegistry"><a href="#EventPluginRegistry" class="headerlink" title="EventPluginRegistry"></a>EventPluginRegistry</h2><p>EventPluginHub是一个Hub，更多时候它只是一个调度。而EventPluginRegistry，是EventPlugin实际上的数据源，上面提到的注入实际上还是注入到这里，所以还是看看里面东西。</p>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>injectEventPluginOrder</td>
<td>注入 插件排序的次序表 这里仅仅是插件名称(Array)</td>
</tr>
<tr>
<td>injectEventPluginsByName</td>
<td>注入 插件本体 这个必须在次序表中</td>
</tr>
<tr>
<td>getPluginModuleForEvent</td>
<td>查找提供的事件的plugin</td>
</tr>
<tr>
<td>_resetEventPlugins</td>
<td>单元测试专用API</td>
</tr>
</tbody></table>
<h1 id="总结-amp-思考"><a href="#总结-amp-思考" class="headerlink" title="总结&amp;思考"></a>总结&amp;思考</h1><p>关于React的事件系统实际上源码里面(<code>ReactBrowserEventEmitter</code>)有注释，并且还有一个流程图示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Summary of `ReactBrowserEventEmitter` event handling:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - Top-level delegation is used to trap most native browser events. This</span></span><br><span class="line"><span class="comment"> *    may only occur in the main thread and is the responsibility of</span></span><br><span class="line"><span class="comment"> *    ReactEventListener, which is injected and can therefore support pluggable</span></span><br><span class="line"><span class="comment"> *    event sources. This is the only work that occurs in the main thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - 顶级委派用于捕获大多数本机浏览器事件。 </span></span><br><span class="line"><span class="comment"> *	  这可能只发生在主线程中 并且这是ReactEventListener的主要职责。</span></span><br><span class="line"><span class="comment"> *    ReactEventListener是注入的，因此可以支持可插入的事件源。 这是浏览器主线程中发生的唯一工作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - We normalize and de-duplicate events to account for browser quirks. This</span></span><br><span class="line"><span class="comment"> *    may be done in the worker thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    我们对事件进行规范化和去重处理 以解决浏览器怪癖问题。这可以在工作线程中完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - Forward these native events (with the associated top-level type used to</span></span><br><span class="line"><span class="comment"> *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want</span></span><br><span class="line"><span class="comment"> *    to extract any synthetic events.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - 将这些浏览器原生事件（以及用于捕获它的相关顶级类型）转发给`EventPluginHub`</span></span><br><span class="line"><span class="comment"> *    它会询问`EventPluginHub`是否保存有它所需要提取的合成事件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - The `EventPluginHub` will then process each event by annotating them with</span></span><br><span class="line"><span class="comment"> *    &quot;dispatches&quot;, a sequence of listeners and IDs that care about that event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - 然后，`EventPluginHub`将通过使用“dispatches”来处理每个事件</span></span><br><span class="line"><span class="comment"> *    一系列侦听器和IDs 关联到这些事件。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - The `EventPluginHub` then dispatches the events.</span></span><br><span class="line"><span class="comment"> *  - 最后 `EventPluginHub` 会分发/触发这些事件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Overview of React and the event system:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * +------------+    .</span></span><br><span class="line"><span class="comment"> * |    DOM     |    .</span></span><br><span class="line"><span class="comment"> * +------------+    .</span></span><br><span class="line"><span class="comment"> *       |           .</span></span><br><span class="line"><span class="comment"> *       v           .</span></span><br><span class="line"><span class="comment"> * +------------+    .</span></span><br><span class="line"><span class="comment"> * | ReactEvent |    .</span></span><br><span class="line"><span class="comment"> * |  Listener  |    .</span></span><br><span class="line"><span class="comment"> * +------------+    .                         +-----------+</span></span><br><span class="line"><span class="comment"> *       |           .               +--------+|SimpleEvent|</span></span><br><span class="line"><span class="comment"> *       |           .               |         |Plugin     |</span></span><br><span class="line"><span class="comment"> * +-----|------+    .               v         +-----------+</span></span><br><span class="line"><span class="comment"> * |     |      |    .    +--------------+                    +------------+</span></span><br><span class="line"><span class="comment"> * |     +-----------.---&gt;|EventPluginHub|                    |    Event   |</span></span><br><span class="line"><span class="comment"> * |            |    .    |              |     +-----------+  | Propagators|</span></span><br><span class="line"><span class="comment"> * | ReactEvent |    .    |              |     |TapEvent   |  |------------|</span></span><br><span class="line"><span class="comment"> * |  Emitter   |    .    |              |&lt;---+|Plugin     |  |other plugin|</span></span><br><span class="line"><span class="comment"> * |            |    .    |              |     +-----------+  |  utilities |</span></span><br><span class="line"><span class="comment"> * |     +-----------.---&gt;|              |                    +------------+</span></span><br><span class="line"><span class="comment"> * |     |      |    .    +--------------+</span></span><br><span class="line"><span class="comment"> * +-----|------+    .                ^        +-----------+</span></span><br><span class="line"><span class="comment"> *       |           .                |        |Enter/Leave|</span></span><br><span class="line"><span class="comment"> *       +           .                +-------+|Plugin     |</span></span><br><span class="line"><span class="comment"> * +-------------+   .                         +-----------+</span></span><br><span class="line"><span class="comment"> * | application |   .</span></span><br><span class="line"><span class="comment"> * |-------------|   .</span></span><br><span class="line"><span class="comment"> * |             |   .</span></span><br><span class="line"><span class="comment"> * |             |   .</span></span><br><span class="line"><span class="comment"> * +-------------+   .</span></span><br><span class="line"><span class="comment"> *                   .</span></span><br><span class="line"><span class="comment"> *    React Core     .  General Purpose Event Plugin System</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>这里暂时还有很多细节没有被理解：</p>
<ul>
<li>合成事件概念 &amp;&amp; 事件定义的数据结构</li>
<li>EventPluginHub &amp;&amp; EventPluginRegistry 联系 </li>
</ul>
<h2 id="合成事件-amp-amp-其数据结构"><a href="#合成事件-amp-amp-其数据结构" class="headerlink" title="合成事件 &amp;&amp; 其数据结构"></a>合成事件 &amp;&amp; 其数据结构</h2><p>React定义了合成事件，它在顶层API上，对不同浏览器进行了兼容处理。它里面和原生事件一样有<code>preventDefault &amp;&amp; preventDefault</code>。</p>
<p>这里仅就最简单的<code>SyntheticEvent</code>做分析，其他的鼠标、滚动、拖曳之类的合成事件都是对它的拓展、继承。</p>
<p>这个合成事件的定义主要是三个地方。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventInterface = &#123;</span><br><span class="line">  type: <span class="literal">null</span>,</span><br><span class="line">  target: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// currentTarget is set when dispatching; no use in copying it here</span></span><br><span class="line">  currentTarget: emptyFunction.thatReturnsNull,</span><br><span class="line">  eventPhase: <span class="literal">null</span>,</span><br><span class="line">  bubbles: <span class="literal">null</span>,</span><br><span class="line">  cancelable: <span class="literal">null</span>,</span><br><span class="line">  timeStamp: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.timeStamp || <span class="built_in">Date</span>.now();</span><br><span class="line">  &#125;,</span><br><span class="line">  defaultPrevented: <span class="literal">null</span>,</span><br><span class="line">  isTrusted: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SyntheticEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  dispatchConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义位置一</span></span><br><span class="line">  <span class="built_in">this</span>.dispatchConfig = dispatchConfig;</span><br><span class="line">  <span class="built_in">this</span>._targetInst = targetInst;</span><br><span class="line">  <span class="built_in">this</span>.nativeEvent = nativeEvent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Interface = <span class="built_in">this</span>.constructor.Interface;</span><br><span class="line">  <span class="comment">// 定义位置二 配合EventInterface看</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> Interface) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Interface.hasOwnProperty(propName)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> normalize = Interface[propName];</span><br><span class="line">    <span class="keyword">if</span> (normalize) &#123;</span><br><span class="line">      <span class="built_in">this</span>[propName] = normalize(nativeEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (propName === <span class="string">&#x27;target&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = nativeEventTarget;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>[propName] = nativeEvent[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义位置三</span></span><br><span class="line"><span class="built_in">Object</span>.assign(SyntheticEvent.prototype, &#123;</span><br><span class="line">  preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  persist: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  isPersistent: emptyFunction.thatReturnsFalse,</span><br><span class="line">  destructor: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>整体的属性、方法如下表。<strong>最有可能影响理解的可能是对原生event对象属性的基础上</strong>。仔细看看可以看到合成事件大部分都是在模拟原生Event对象的属性和方法。</p>
<table>
<thead>
<tr>
<th>属性、方法名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>dispatchConfig</td>
<td></td>
<td></td>
</tr>
<tr>
<td>_targetInst</td>
<td>ReactDomComponent实例或其他实例</td>
<td>ReactNode实例</td>
</tr>
<tr>
<td>nativeEvent</td>
<td>DOMEvent</td>
<td>原生event对象</td>
</tr>
<tr>
<td>type</td>
<td>string</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/type">type</a></td>
</tr>
<tr>
<td>target</td>
<td>DOMEventTarget</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/target">target</a></td>
</tr>
<tr>
<td>currentTarget</td>
<td>DOMEventTarget</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/currentTarget">currentTarget</a></td>
</tr>
<tr>
<td>eventPhase</td>
<td>number</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/eventPhase">event.eventPhase</a></td>
</tr>
<tr>
<td>bubbles</td>
<td>boolean</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/bubbles">bubbles</a></td>
</tr>
<tr>
<td>cancelable</td>
<td>boolean</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/cancelable">cancelable</a></td>
</tr>
<tr>
<td>timeStamp</td>
<td>number</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/timeStamp">timeStamp</a></td>
</tr>
<tr>
<td>defaultPrevented</td>
<td>boolean</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/defaultPrevented">defaultPrevented</a></td>
</tr>
<tr>
<td>isTrusted</td>
<td>boolean</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/isTrusted">isTrusted</a></td>
</tr>
<tr>
<td>preventDefault</td>
<td>Function</td>
<td>阻止浏览器默认行为</td>
</tr>
<tr>
<td>stopPropagation</td>
<td>Function</td>
<td>停止冒泡</td>
</tr>
<tr>
<td>persist</td>
<td>Function</td>
<td>阻止将其放入对象池 保持其引用</td>
</tr>
<tr>
<td>isPersistent</td>
<td>boolean</td>
<td>检查是否应将此事件释放回对象池中</td>
</tr>
<tr>
<td>destructor</td>
<td>Function</td>
<td>PooledClass会用到它</td>
</tr>
</tbody></table>
<p>这里dispatchConfig的大致结构如下, 关于这个数据结构<code>SimpleEventPlugin.js</code>中<code>eventTypes</code>变量有注释和代码定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  phasedRegistrationNames: &#123;</span><br><span class="line">    bubbled: <span class="string">&#x27;onClick&#x27;</span>,</span><br><span class="line">    captured: <span class="string">&#x27;onClickCapture&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  dependencies: [<span class="string">&#x27;topClick&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说，onClick注册的事件会在冒泡环节触发，如果要在捕获环节触发，那么使用onClickCapture进行注册。这里<code>phasedRegistrationNames</code>还是很容易理解。而<code>dependencies</code>则是被依赖的top事件组成的数组，在冒泡捕获触发环节所有的事件诸如提到的<code>onClick、onClickCapture</code>最后都会被转换为<code>topClick</code>这样的形式进行触发。</p>
<h2 id="EventPluginHub-amp-amp-EventPluginRegistry-联系"><a href="#EventPluginHub-amp-amp-EventPluginRegistry-联系" class="headerlink" title="EventPluginHub &amp;&amp; EventPluginRegistry 联系"></a>EventPluginHub &amp;&amp; EventPluginRegistry 联系</h2><p>这里EventPluginHub是建立在EventPluginRegistry上的，从理解上，个人认为EventPluginRegistry实际上是处理的依赖注入的事情。他将plugin名称和本体保存起来，以供EventPluginHub方便调用。</p>
<h1 id="三张图"><a href="#三张图" class="headerlink" title="三张图"></a>三张图</h1><p>想了一下，虽然自己最后分析了这么多，但是太过于重视细枝末节其实很难把握宏观上的处理方式。这源码就算读破了天，最终如果没有建立起体系其实没有什么卵用，所以这里画张图。</p>
<p>不过合成事件的各种继承，其实应该也值得很好研究一下，这里暂时不去细读这一块了。</p>
<p><img src="/images/react-event-save.png" alt="reac 事件保存"></p>
<p><img src="/images/react-event-dispatch.png" alt="react事件分发"></p>
<p><img src="/images/react-event-system.png" alt="react-event-system"></p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react ReactDOMComponent分析</title>
    <url>/2018/05/01/react-domComponent/</url>
    <content><![CDATA[<h1 id="ReactDOMComponent"><a href="#ReactDOMComponent" class="headerlink" title="ReactDOMComponent"></a>ReactDOMComponent</h1><p>虽然整体的逻辑看起来异常复杂，但是仔细分析，实际上它处理的事情也仍然很清晰。</p>
<p>这件简要分析</p>
<p>line461-line482简单的定义了ReactDOMComponent内部的私有变量。</p>
<p>line1203-line1207的Object.assign则很简单将<code>ReactDOMComponent.Mixin&amp;ReactMultiChild.Mixin</code>复制到<code>ReactDOMComponent</code>的原型上。所以这里需要对<code>ReactDOMComponent.Mixin&amp;ReactMultiChild.Mixin</code>做一些分析</p>
<h2 id="ReactDOMComponent-Mixin"><a href="#ReactDOMComponent-Mixin" class="headerlink" title="ReactDOMComponent.Mixin"></a>ReactDOMComponent.Mixin</h2><table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>mountComponent</strong></td>
<td>生成根标记然后递归生成内部标记。这个生成是在事务支持下的生成(更新前卸载事件更新后重新绑定诸如此类)。这个操作不是冥等的，多次执行结果并不完全一致。</td>
</tr>
<tr>
<td>_createOpenTagMarkupAndPutListeners</td>
<td>生成html标记的openTag markup并处理事件绑定</td>
</tr>
<tr>
<td>_createContentMarkup</td>
<td>为html标签内的内容创建对应的markup</td>
</tr>
<tr>
<td>_createInitialChildren</td>
<td>遍历下级children标记放到目标元素中</td>
</tr>
<tr>
<td><strong>receiveComponent</strong></td>
<td>更新_currentElement并调用this.updateComponent更新组件</td>
</tr>
<tr>
<td>updateComponent</td>
<td>使用_updateDOMProperties &amp; _updateDOMChildren更新props、styles和children</td>
</tr>
<tr>
<td>_updateDOMProperties</td>
<td>更新styles和props</td>
</tr>
<tr>
<td>_updateDOMChildren</td>
<td>更新children</td>
</tr>
<tr>
<td><strong>getHostNode</strong></td>
<td>获取组件对应的HTMLElement节点</td>
</tr>
<tr>
<td><strong>unmountComponent</strong></td>
<td>卸载事件注册 但不直接影响DOM</td>
</tr>
<tr>
<td>getPublicInstance</td>
<td>获取组件对应的HTMLElement节点 同getHostNode</td>
</tr>
</tbody></table>
<h3 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h3><p>生成根标记然后递归生成内部标记。这个生成是在事务支持下的生成(更新前卸载事件更新后重新绑定诸如此类)。这个操作不是冥等的，多次执行结果并不完全一致。</p>
<p>关于事务的分析，我们后面再总体分析一下看看，这里简单看看这里的遍历生成标记是如何做到的。</p>
<p>首先看看mountComponent整体执行完毕后的返回数据结构</p>
<p><img src="/images/20180824104927.png"></p>
<p>其次，这个函数里面有两行非常关键的代码，这是遍历生成标记的核心调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lazyTree = DOMLazyTree(el);</span><br><span class="line"><span class="built_in">this</span>._createInitialChildren(transaction, props, context, lazyTree);</span><br></pre></td></tr></table></figure>

<p>这里看看lazyTree返回值:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOMLazyTree</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    node: node,</span><br><span class="line">    children: [],</span><br><span class="line">    html: <span class="literal">null</span>,</span><br><span class="line">    text: <span class="literal">null</span>,</span><br><span class="line">    toString,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这里接下来先看看<code>_createInitialChildren</code></p>
<h3 id="createInitialChildren"><a href="#createInitialChildren" class="headerlink" title="_createInitialChildren"></a>_createInitialChildren</h3><p>它的作用是遍历下级children标记放到目标元素中</p>
<p>先看看大致逻辑和参数问题，这里有transaction, props, context, lazyTree</p>
<p>这里props是实例化ReactDOMComponent时候传入的element，transaction、context这里不再讲，lazyTree是上一步传入。此时props上显然会有children保存其子元素的数组。</p>
<p>这里有两个逻辑分支</p>
<ul>
<li><p>props.children 是string|number -&gt; contentToUse 此时DOMLazyTree.queueText(lazyTree, contentToUse)</p>
</li>
<li><p>否则childrenToUse执行</p>
</li>
<li><p>下一步:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mountImages = <span class="built_in">this</span>.mountChildren(</span><br><span class="line">  childrenToUse,</span><br><span class="line">  transaction,</span><br><span class="line">  context,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mountImages.length; i++) &#123;</span><br><span class="line">  DOMLazyTree.queueChild(lazyTree, mountImages[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这个this.mountChildren在ReactMultiChild.Mixin被集成到原型上来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mountChildren: <span class="function"><span class="keyword">function</span>(<span class="params">nestedChildren, transaction, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> children = <span class="built_in">this</span>._reconcilerInstantiateChildren(</span><br><span class="line">    nestedChildren,</span><br><span class="line">    transaction,</span><br><span class="line">    context,</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">this</span>._renderedChildren = children;</span><br><span class="line">  <span class="keyword">var</span> mountImages = [];</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> children) &#123;</span><br><span class="line">    <span class="keyword">if</span> (children.hasOwnProperty(name)) &#123;</span><br><span class="line">      <span class="keyword">var</span> child = children[name];</span><br><span class="line">      <span class="keyword">var</span> selfDebugID = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">var</span> mountImage = ReactReconciler.mountComponent(</span><br><span class="line">        child,</span><br><span class="line">        transaction,</span><br><span class="line">        <span class="built_in">this</span>,</span><br><span class="line">        <span class="built_in">this</span>._hostContainerInfo,</span><br><span class="line">        context,</span><br><span class="line">        selfDebugID,</span><br><span class="line">      );</span><br><span class="line">      child._mountIndex = index++;</span><br><span class="line">      mountImages.push(mountImage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mountImages;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这里暂不用去理会<code>this._reconcilerInstantiateChildren</code>只是简单提一下，它是一个数组，里面的元素的结构和lazyTree返回值是一致的。</p>
<p>仅仅看ReactReconciler.mountComponent就可以知道，mountComponent里面说到的这个遍历，便是从这里而来。他的流程是:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOMComponent.mountComponent </span><br><span class="line">  -&gt; ReactDOMComponent._createInitialChildren </span><br><span class="line">   	-&gt; ReactMultiChild.Mixin.mountChildren </span><br><span class="line">		-&gt; ReactReconciler.mountComponent </span><br><span class="line">    		-&gt; instantiateReactComponent </span><br><span class="line">    			-&gt; ReactDOMComponent.mountComponent</span><br></pre></td></tr></table></figure>

<p>至于ReactReconciler.mountComponent 到 ReactDOMComponent.mountComponent这个环节，请参考上文ReactReconciler.mountComponent。</p>
<p>这里的遍历是起到这样的作用。我们知道jsx转换到js之后是近似</p>
<p><img src="/images/20180823140712.png"></p>
<p>的嵌套结构，如果有子组件那么也是这样的结构放在props.children上，以此类推。</p>
<p>而这里的遍历则是将这个结构转换成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    node: node,</span><br><span class="line">    children: [],</span><br><span class="line">    html: <span class="literal">null</span>,</span><br><span class="line">    text: <span class="literal">null</span>,</span><br><span class="line">    toString,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的结构，子元素放到children数组中。只不过此时这里的node已经是HTML元素了可以直接插入到DOM中。</p>
<p>这时候使用ReactMount._mountImageIntoNode就可以将其渲染到DOM了。</p>
<p>PS: 需要注意的，这个转换仅仅是在<code>transaction.useCreateElement</code>成立(在这里,<strong>服务端渲染才会为fasle</strong>,这里暂不考虑这块)，否则回直接返回html标记字符串。</p>
<h3 id="updateDOMChildren"><a href="#updateDOMChildren" class="headerlink" title="_updateDOMChildren"></a>_updateDOMChildren</h3><p>_updateDOMChildren这个方法是当children更新后的调用。它在updateComponent环节被调用过。</p>
<p>在这个函数中有个调用非常关键 <code>this.updateChildren</code>，它从<code>ReactMultiChild.Mixin</code>继承而来。这里设计到了diff算法处理，暂且放下。</p>
<h3 id="createOpenTagMarkupAndPutListeners"><a href="#createOpenTagMarkupAndPutListeners" class="headerlink" title="_createOpenTagMarkupAndPutListeners"></a>_createOpenTagMarkupAndPutListeners</h3><p>这个函数可以返回一个<code>&lt;div class=&quot;name&quot; /&gt;</code>代码中的<code>&lt;div class=&quot;name&quot;</code>这个部分。并对事件进行绑定。<strong>服务端渲染会用到。</strong></p>
<h3 id="createContentMarkup"><a href="#createContentMarkup" class="headerlink" title="_createContentMarkup"></a>_createContentMarkup</h3><p>为html标签内的内容创建对应的markup。<strong>服务端渲染会用到。</strong></p>
<p>和_createOpenTagMarkupAndPutListeners有一些关联，前者是获得openTagMarkup,这个获取标记中间的元素内容Markup。</p>
<h3 id="updateComponent"><a href="#updateComponent" class="headerlink" title="updateComponent"></a>updateComponent</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>._updateDOMProperties(lastProps, nextProps, transaction);</span><br><span class="line"><span class="built_in">this</span>._updateDOMChildren(lastProps, nextProps, transaction, context);</span><br></pre></td></tr></table></figure>

<h3 id="unmountComponent"><a href="#unmountComponent" class="headerlink" title="unmountComponent"></a>unmountComponent</h3><p>关键代码是:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.unmountChildren(safely);</span><br><span class="line">ReactDOMComponentTree.uncacheNode(<span class="built_in">this</span>);</span><br><span class="line">EventPluginHub.deleteAllListeners(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<p>主要涉及了ReactDOMComponentTree、EventPluginHub、ReactMultiChild三个模块</p>
<h3 id="getHostNode"><a href="#getHostNode" class="headerlink" title="getHostNode"></a>getHostNode</h3><p>调用了ReactDOMComponentTree.getNodeFromInstance获取组件对应的HTMLElement节点。这个模块后面分析。</p>
<h3 id="updateDOMProperties"><a href="#updateDOMProperties" class="headerlink" title="_updateDOMProperties"></a>_updateDOMProperties</h3><p>这个函数其实还挺重要的。在我们的使用过程中，我们在props上放style放className 放refs放onClick。这些都会得到体现。</p>
<p>这里有三个逻辑分支</p>
<ul>
<li>style的处理</li>
<li>事件注册的处理[registrationNameModules.hasOwnProperty(propKey)]。先解绑后重新绑定。关键函数enqueuePutListener</li>
<li>自定义标签的处理</li>
</ul>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react生命周期分析</title>
    <url>/2018/04/26/react-lifecycle/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>这一节分析一下react的声明周期</p>
<p>这里直接引用一下现有图片,图片来自<a href="https://hackernoon.com/reactjs-component-lifecycle-methods-a-deep-dive-38275d9d13c0">这里</a></p>
<p><img src="/images/20180825110656.png"></p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这里需要认真思考一下的是:</p>
<ul>
<li>钩子函数在一个组件里是按怎样的数据形式保存的</li>
<li>调用的时机在react内部是如何进行的</li>
<li>钩子函数是在哪些模块内被触发调用的</li>
<li>如何进行方便的调试和验证</li>
</ul>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>我们还是依照测试文件直接debug。</p>
<p>目标文件为ReactComponentLifeCycle-test.js。这是react框架自带的lifecycle测试文件，我们不需要自己去写测试用例和DEMO。</p>
<h2 id="初始化-Initialization"><a href="#初始化-Initialization" class="headerlink" title="初始化 Initialization"></a>初始化 Initialization</h2><p>组件的props&amp;&amp;state<strong>初始化</strong>实质上和DOM无关，和更新相关生命周期也无关。</p>
<p>这里找到了ReactES6Class-test.js。使用下面的断言进行debug查看组件初始化环节。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&#x27;renders based on state using initial values in this.props&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;<span class="attr">bar</span>: <span class="built_in">this</span>.props.initialValue&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;this.state.bar&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  test(<span class="xml"><span class="tag">&lt;<span class="name">Foo</span> <span class="attr">initialValue</span>=<span class="string">&quot;foo&quot;</span> /&gt;</span></span>, <span class="string">&#x27;SPAN&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>我们在super(props)这里打一个断点开始debug,断点到了之后step into。然后点下一步直接跳到了src/isomorphic/modern/class/ReactBaseClasses.js。不过ES6这里定义过于简单了(直接走了构造器将props和state挂在上面了)看不出太深入的，所以我们继续向下深入render。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ReactComponent(props, context, updater) &#123;</span><br><span class="line">  this.props &#x3D; props;</span><br><span class="line">  this.context &#x3D; context;</span><br><span class="line">  this.refs &#x3D; emptyObject;</span><br><span class="line">  &#x2F;&#x2F; We initialize the default updater but the real one gets injected by the</span><br><span class="line">  &#x2F;&#x2F; renderer.</span><br><span class="line">  this.updater &#x3D; updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里断点放在render的return这一行，到了之后step into, 然后进入了src/isomorphic/classic/element/ReactElementValidator.js，光标放到line243点run to cursor,然后step into。这样就到了src/isomorphic/classic/element/ReactElement.js。</p>
<p>props这一块其实还是很容易理解，babel对jsx转换时候就将props传入了。</p>
<p><img src="/images/20180823140712.png"></p>
<p>这个图其实说得很清晰了，我们主要分析state的处理。</p>
<p>getInitialState这个发生在组件产生之后，挂载之前。它是在mountComponentIntoNode中，具体一点的话，它的调用路径是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mountComponentIntoNode</span><br><span class="line">	-&gt; ReactReconciler.mountComponent</span><br><span class="line">		-&gt; internalInstance.mountComponent</span><br><span class="line">			-&gt; ReactCompositeComponent.mountComponent</span><br><span class="line">				-&gt; ReactCompositeComponent._constructComponent</span><br></pre></td></tr></table></figure>

<p>之前对这个render是如何渲染到dom有过分析，完整的流程是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactMount.render</span><br><span class="line">	-&gt; ReactMount._renderSubtreeIntoContainer</span><br><span class="line">		-&gt;  ReactMount._renderNewRootComponent</span><br><span class="line">			-&gt; ReactUpdates.batchedUpdates</span><br><span class="line">				-&gt; ReactUpdates.batchedMountComponentIntoNode</span><br><span class="line">					-&gt; mountComponentIntoNode</span><br><span class="line">						-&gt; ReactMount._mountImageIntoNode</span><br></pre></td></tr></table></figure>

<p>具体一些来说，我们的分析环节是在mountComponentIntoNode中，排除ReactMount._mountImageIntoNode调用之外的地方。</p>
<p>回顾一下</p>
<p>mountComponentIntoNode做了这些事:</p>
<ul>
<li>调用ReactReconciler.mountComponent生成markup标记内部含有{children: markup数组, node:HTMLElement}</li>
<li>调用ReactMount._mountImageIntoNode渲染markup</li>
</ul>
<p>ReactReconciler.mountComponent生成markup这一节在之前分析过，详细看之前的分析，这里只就关键的引用代码<a href="/2019/06/17/react-instantiateReactComponent/">instantiateReactComponent</a>做说明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node, shouldHaveDebugID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span> || node === <span class="literal">false</span>) &#123;</span><br><span class="line">    instance = ReactEmptyComponent.create(instantiateReactComponent);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> element = node;</span><br><span class="line">    <span class="keyword">var</span> type = element.type;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> type !== <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> type !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> info = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      info += getDeclarationErrorAddendum(element._owner);</span><br><span class="line">      invariant(</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&#x27;Element type is invalid: expected a string (for built-in components) &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;or a class/function (for composite components) but got: %s.%s&#x27;</span>,</span><br><span class="line">        type == <span class="literal">null</span> ? type : <span class="keyword">typeof</span> type,</span><br><span class="line">        info,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special case string values</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> element.type === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      instance = ReactHostComponent.createInternalComponent(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInternalComponentType(element.type)) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> element.type(element);</span><br><span class="line">      <span class="keyword">if</span> (!instance.getHostNode) &#123;</span><br><span class="line">        instance.getHostNode = instance.getNativeNode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> ReactCompositeComponentWrapper(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> node === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    instance = ReactHostComponent.createInstanceForText(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    invariant(<span class="literal">false</span>, <span class="string">&#x27;Encountered invalid React node of type %s&#x27;</span>, <span class="keyword">typeof</span> node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  instance._mountIndex = <span class="number">0</span>;</span><br><span class="line">  instance._mountImage = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前我们说到过<code>instance = ReactHostComponent.createInternalComponent(element);</code>的情况，然而我们关注的getInitialState，事情恰好发生在<code>instance = new ReactCompositeComponentWrapper(element);</code></p>
<p>回顾instantiateReactComponent，看看ReactCompositeComponentWrapper的定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactCompositeComponentWrapper = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.construct(element);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">  ReactCompositeComponentWrapper.prototype,</span><br><span class="line">  ReactCompositeComponent,</span><br><span class="line">  &#123;</span><br><span class="line">    _instantiateReactComponent: instantiateReactComponent,</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>此时，生成markup的代码实质上是调用ReactCompositeComponent.mountComponent</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> markup = internalInstance.mountComponent(</span><br><span class="line">    transaction,</span><br><span class="line">    hostParent,</span><br><span class="line">    hostContainerInfo,</span><br><span class="line">    context,</span><br><span class="line">    parentDebugID,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>然而这个例子这里存在internalInstance.mountComponent被调用了两次的问题</p>
<h3 id="第一次渲染"><a href="#第一次渲染" class="headerlink" title="第一次渲染"></a>第一次渲染</h3><p>第一次渲染是TopLevelWrapper组件的渲染</p>
<p>在ReactCompositeComponent.mountComponent节点的函数中,可以看到<code>inst.state = initialState = null</code></p>
<p>而这个inst是_constructComponent的返回值，所以最终的定义就在这个函数内部了，重点跟踪一下这个引用好了。</p>
<p>这个函数内部引用了ReactCompositeComponent._constructComponentWithoutOwner,这里核心代码引用到了<code>Component(publicProps, publicContext, updateQueue)</code> ,<br>这里的Component是_currentElement.type的引用，debugger断点打过来，最简单的元素初始渲染这里是TopLevelWrapper实例(同时也是Component实例)。<br>可以看到此时initialState === undefined,所以它最后被赋值为null了。</p>
<p>第一次定义state这里 仅仅相当于是一个初始化流程。最终定义还是看后面的定义</p>
<h3 id="第二次渲染"><a href="#第二次渲染" class="headerlink" title="第二次渲染"></a>第二次渲染</h3><p>到了第二次时候 也就是performInitialMount内执行到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> markup = ReactReconciler.mountComponent(</span><br><span class="line">    child,</span><br><span class="line">    transaction,</span><br><span class="line">    hostParent,</span><br><span class="line">    hostContainerInfo,</span><br><span class="line">    <span class="built_in">this</span>._processChildContext(context),</span><br><span class="line">    debugID,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这一块代码时候触发的(关于这个第一次和第二次这个，可以参考后面提到的『jsx到js的转换 』)。</p>
<p>此时child是ReactCompositeComponentWrapper实例所以markup生成还是调用ReactCompositeComponent.mountComponent。</p>
<p>这时候就是我们的Foo组件了。这里获取实例使用了ReactReconciler._constructComponent,它又调用了_constructComponentWithoutOwner。它大致代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_constructComponentWithoutOwner: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  doConstruct,</span></span></span><br><span class="line"><span class="function"><span class="params">  publicProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  publicContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  updateQueue,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Component = <span class="built_in">this</span>._currentElement.type;</span><br><span class="line">  <span class="keyword">if</span> (doConstruct) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">	  <span class="comment">// ... 略</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Component(publicProps, publicContext, updateQueue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>我们在之前代码里面可以找到<code>this._currentElement = element</code>,所以它实质上调用的是ReactElement实例的<strong>type</strong>属性。这个属性在这里对应的是我们的Foo函数。而Foo在构造器里面对state做了定义。<strong>这里就是state数据被录入的根源环节</strong>。</p>
<p>但是Initialization此刻还没有完毕。继续往下走，直到ReactCompositeComponent.js line252-320这几行都执行完毕，我们的<strong>Initialization环节才正式完毕</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">inst.props = publicProps;</span><br><span class="line">inst.context = publicContext;</span><br><span class="line">inst.refs = emptyObject;</span><br><span class="line">inst.updater = updateQueue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>._instance = inst;</span><br><span class="line"></span><br><span class="line">ReactInstanceMap.set(inst, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> initialState = inst.state;</span><br><span class="line"><span class="keyword">if</span> (initialState === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  inst.state = initialState = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>by the way,我们再往下走一些，可以看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (inst.componentDidMount) &#123;</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">	&#x2F;&#x2F; 略略略...</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是的<strong>componentDidMount</strong>在初始化完毕后就接着被调用了。</p>
<p>PS:上面提到了type属性，这里再次温习一下jsx到js的转换防止一知半解。</p>
<h4 id="jsx到js的转换"><a href="#jsx到js的转换" class="headerlink" title="jsx到js的转换"></a>jsx到js的转换</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">bar</span>: <span class="built_in">this</span>.props.initialValue&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;this.state.bar&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Bar</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Foo className=<span class="string">&quot;test&quot;</span> /&gt;, </span><br><span class="line">  mountNode</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时&lt;Foo className=&#123;this.state.bar&#125; /&gt;在大体的结构上会转换成:</span></span><br><span class="line">React.createElement( <span class="comment">// a</span></span><br><span class="line">	React.createElement( <span class="comment">// b</span></span><br><span class="line">        <span class="string">&quot;span&quot;</span>,</span><br><span class="line">        &#123; <span class="attr">className</span>: <span class="built_in">this</span>.state.bar &#125;,</span><br><span class="line">        React.createElement( <span class="comment">// c</span></span><br><span class="line">            React.createElement( <span class="comment">// d</span></span><br><span class="line">                <span class="string">&quot;div&quot;</span>,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                <span class="built_in">this</span>.props.name</span><br><span class="line">      		)</span><br><span class="line">        , &#123; <span class="attr">name</span>: <span class="string">&quot;test&quot;</span> &#125;)</span><br><span class="line">    ),</span><br><span class="line">	&#123; <span class="attr">className</span>: <span class="string">&quot;test&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是:</p>
<ul>
<li>React.createElement返回值是一个ReactElement对象, 但是它本身则是一个Function</li>
<li>对 a|b|c标记的createElement来说，他们的返回值的type是一个Function，对应的是组件的定义函数</li>
<li>对 a|b|c标记的createElement来说，<strong>他们的第一个参数并不真的就是直接传入React.createElement这个函数</strong>，而是组件的定义函数的转译(bable处理),它里面一定会有一个render，render里面会调用React.createElement()返回一个ReactElement对象</li>
<li>而对于d标记的createElement来说，它的返回值是一个ReactElement对象。</li>
</ul>
<p>关于这个render的调用。参见ReactCompositeComponent.performInitialMount</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If not a stateless component, we now render</span></span><br><span class="line"><span class="keyword">if</span> (renderedElement === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    renderedElement = <span class="built_in">this</span>._renderValidatedComponent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一路跟进引用最终你会发现render在这里被调用了。</p>
<h2 id="挂载-Mounting"><a href="#挂载-Mounting" class="headerlink" title="挂载 Mounting"></a>挂载 Mounting</h2><h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h3><p>这个函数在ReactCompositeComponent.performInitialMount中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (inst.componentWillMount) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">	<span class="comment">// 略略略...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    inst.componentWillMount();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// When mounting, calls to `setState` by `componentWillMount` will set</span></span><br><span class="line">  <span class="comment">// `this._pendingStateQueue` without triggering a re-render.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>._pendingStateQueue) &#123;</span><br><span class="line">    inst.state = <span class="built_in">this</span>._processPendingState(inst.props, inst.context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><p>这个不再废话,参见上文的『第二次渲染』。ReactCompositeComponent.mountComponent中</p>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>render这个也不再说了,参见『 jsx到js的转换』。ReactCompositeComponent.performInitialMount中，更细致一些，那就是在ReactCompositeComponent._renderValidatedComponent中。</p>
<h1 id="更新-Updation"><a href="#更新-Updation" class="headerlink" title="更新 Updation"></a>更新 Updation</h1><p>更新这个环节的钩子函数需要配合分析: 当收到新的props、state时，会发生什么？</p>
<p>不然就会发生这些<strong>钩子函数好找，但是何时会被触发却不明确</strong>的问题。</p>
<p>我们之前分析过render的流程，所以这里顺便也分析一下，update的流程。</p>
<h2 id="State更新"><a href="#State更新" class="headerlink" title="State更新"></a>State更新</h2><p>观察State更新需要对这个更新是怎样被唤起的，所以会分为之前和之后两个环节。</p>
<h3 id="Before-更新之前"><a href="#Before-更新之前" class="headerlink" title="Before 更新之前"></a>Before 更新之前</h3><p>这里使用这个测试用例(ReactES6Class-test.js里面)来测试观察state更新环节来对整体逻辑做初步概览。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&#x27;setState through an event handler&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;<span class="attr">bar</span>: props.initialValue&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;<span class="attr">bar</span>: <span class="string">&#x27;bar&#x27;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Inner name=&#123;<span class="built_in">this</span>.state.bar&#125; onClick=&#123;<span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)&#125; /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  test(<span class="xml"><span class="tag">&lt;<span class="name">Foo</span> <span class="attr">initialValue</span>=<span class="string">&quot;foo&quot;</span> /&gt;</span></span>, <span class="string">&#x27;DIV&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  attachedListener();</span><br><span class="line">  expect(renderedName).toBe(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个setState的调用的定义在：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 略略略...</span></span><br><span class="line">  <span class="built_in">this</span>.updater.enqueueSetState(<span class="built_in">this</span>, partialState);</span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    <span class="built_in">this</span>.updater.enqueueCallback(<span class="built_in">this</span>, callback, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>step in方式进入了ReactUpdateQueue.enqueueSetState，进行了一些验证后，将这个state纯对象push进入了internalInstance._pendingStateQueue数组，然后调用ReactUpdates.enqueueUpdate(internalInstance)来更新这个组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">  <span class="keyword">if</span> (component._updateBatchNumber == <span class="literal">null</span>) &#123;</span><br><span class="line">    component._updateBatchNumber = updateBatchNumber + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的调用有些绕而且看起来必要性不高因为ReactDefaultBatchingStrategy.batchedUpdates在此时必然会执行到<code>transaction.perform(callback, null, a, b, c, d, e)</code>——实质上它是<code>callback(a, b, c, d, e)</code>的事务版本，执行有前后置条件。<strong>最后调用自身将component推到dirtyComponents进行更新标记</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">batchedUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line">  ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// The code is written this way to avoid extra allocations</span></span><br><span class="line">  <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(a, b, c, d, e);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个debug环节，transaction.perform基本就是一个大体的调用终点了。But,这个更新Component的调用去哪儿了？</p>
<p>这里不得不说事务概念了，ReactDefaultBatchingStrategy的事物实例是有两个事务注册的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们都更新环节就是在ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)这里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flushBatchedUpdates = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (dirtyComponents.length || asapEnqueued) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirtyComponents.length) &#123;</span><br><span class="line">      <span class="keyword">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">      transaction.perform(runBatchedUpdates, <span class="literal">null</span>, transaction);</span><br><span class="line">      ReactUpdatesFlushTransaction.release(transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 略略略...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，当我们处理好了函数执行之后，组件也会随之被runBatchedUpdates更新。这其中还有很多细节，但是这里仅仅做好整理逻辑梳理即可，暂时不做细致分析(但是很显然，相关更新的钩子函数会在里面)。</p>
<h3 id="After-正式开始"><a href="#After-正式开始" class="headerlink" title="After 正式开始"></a>After 正式开始</h3><p>继续上一步分析。在这个例子中，执行到runBatchedUpdates后，这里的更新最终会执行到ReactCompositeComponent.updateComponent。所以后面的生命周期函数都会在这里一一展现。这里回顾一下更新环节生命周期的顺序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate</span><br><span class="line">	-&gt; componentWillUpdate</span><br><span class="line">		-&gt; render</span><br><span class="line">			-&gt; componentDidUpdate</span><br></pre></td></tr></table></figure>

<h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h4><p>ReactCompositeComponent line 838-860</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>._pendingForceUpdate) &#123;</span><br><span class="line">  <span class="keyword">if</span> (inst.shouldComponentUpdate) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">		<span class="comment">// 略略略...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      shouldUpdate = inst.shouldComponentUpdate(</span><br><span class="line">        nextProps,</span><br><span class="line">        nextState,</span><br><span class="line">        nextContext,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._compositeType === CompositeTypes.PureClass) &#123;</span><br><span class="line">      shouldUpdate =</span><br><span class="line">        !shallowEqual(prevProps, nextProps) ||</span><br><span class="line">        !shallowEqual(inst.state, nextState);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步生命周期完成之后我们进入了<strong>ReactCompositeComponent._performComponentUpdate</strong>(具体流程参见ReactCompositeComponent.updateComponent)</p>
<h4 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h4><p>ReactCompositeComponent line 955-965</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (inst.componentWillUpdate) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// 略略略...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    inst.componentWillUpdate(nextProps, nextState, nextContext);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="render-1"><a href="#render-1" class="headerlink" title="render"></a>render</h4><p>ReactCompositeComponent line 973</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>._updateRenderedComponent(transaction, unmaskedContext);</span><br></pre></td></tr></table></figure>

<h4 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h4><p>ReactCompositeComponent line 975-1002</p>
<p>这一步还是很好理解，如果有定义这个函数，那么就通过事务机制再render完成之后执行componentDidUpdate。至此State更新环节的流程就完整、畅通了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasComponentDidUpdate) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// 略略略...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    transaction</span><br><span class="line">      .getReactMountReady()</span><br><span class="line">      .enqueue(</span><br><span class="line">        inst.componentDidUpdate.bind(</span><br><span class="line">          inst,</span><br><span class="line">          prevProps,</span><br><span class="line">          prevState,</span><br><span class="line">          prevContext,</span><br><span class="line">        ),</span><br><span class="line">        inst,</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Props更新"><a href="#Props更新" class="headerlink" title="Props更新"></a>Props更新</h2><p>props引起的更新可能会不太容易理解。</p>
<p>setState这个是一个函数理解它的触发没有太大难度。这里回顾一下props和state的区别: state是组件内部的状态，是可以修改；而props是父组件上传下来的，他不能在组件内部被修改。</p>
<h3 id="Before-更新之前-1"><a href="#Before-更新之前-1" class="headerlink" title="Before 更新之前"></a>Before 更新之前</h3><p>为了辅助说明，这里还是使用上面提到过的测试用例，但是我们这里换个角度来看这个用例。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&#x27;setState through an event handler&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;<span class="attr">bar</span>: props.initialValue&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;<span class="attr">bar</span>: <span class="string">&#x27;bar&#x27;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Inner name=&#123;<span class="built_in">this</span>.state.bar&#125; onClick=&#123;<span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)&#125; /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  test(<span class="xml"><span class="tag">&lt;<span class="name">Foo</span> <span class="attr">initialValue</span>=<span class="string">&quot;foo&quot;</span> /&gt;</span></span>, <span class="string">&#x27;DIV&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  attachedListener();</span><br><span class="line">  expect(renderedName).toBe(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>稍微分析一下这个测试用例，可以看到Inner组件在handleClick被触发以后，它的this.props.name的值从foo变为了bar。所以我们这里重点分析一下，这个变化是如何最终反应到DOM上的。</p>
<p>在一切开始之前，我们还是得回顾，这个this.props.name到底是如何传递到Inner组件上的——this.setState，是的，就是this.setState。</p>
<p>回顾一下state的钩子函数触发顺序:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate</span><br><span class="line">	-&gt; componentWillMount</span><br><span class="line">		-&gt; render</span><br><span class="line">			-&gt; componentDidUpdate</span><br></pre></td></tr></table></figure>

<p>实际上此时，对于Inner来讲，<strong>它在State钩子函数的render环节，我们就开始了一轮Props的更新生命周期函数</strong>。</p>
<p><strong>在这个环节中，有几个特别关键的地方值得深思(理解它有助于深入理解React)。</strong></p>
<ul>
<li>『jsx到js的转换』 环节里面jsx 转换为React.createElement的结构，和提到的相关的注意项</li>
<li>React.createElement嵌套的层级问题，它不仅仅可以从TopLevelWrapper开始渲染，实际上，他可以从任意中间的任何一个React.createElement开始渲染</li>
<li>为什么说React是最小局部更新？除了调度和算法的作用，React.createElement嵌套结构可以从任何环节开始向下级渲染，是一个非常关键的机制，它极大程度上缩小了需要更新到DOM的数据。</li>
</ul>
<p><strong>以上可能是最重要的，如果没有理解上面的那么值得卡在这里琢磨。</strong></p>
<h3 id="After-正式开始-1"><a href="#After-正式开始-1" class="headerlink" title="After 正式开始"></a>After 正式开始</h3><p>如果上面的准备就绪了可以继续下面的了。回顾一下，当state触发的生命周期开始render环节的时候，会执行ReactCompositeComponent line 973的代码这里仅仅是比State多一个componentWillReceiveProps。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>._updateRenderedComponent(transaction, unmaskedContext);</span><br></pre></td></tr></table></figure>

<p>这里直接在测试用例的attachedListener()这一行打一个断点,待它停住以后，在render里面打一个断点，最后点执行。当它再次停住以后，这样我们就捕获了state之后的render环节。最后将光标定位到ReactCompositeComponent line 973，点run to corsur，我们就对程序进行了精准的捕获。</p>
<p>接下来它的调用栈:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactCompositeComponent._updateRenderedComponent</span><br><span class="line">	-&gt; ReactReconciler.receiveComponent</span><br><span class="line">		-&gt; internalInstance.receiveComponent</span><br><span class="line">			-&gt; ReactCompositeComponent.updateComponent</span><br></pre></td></tr></table></figure>

<p>到这个环节生命周期函数的调用就简单多了。先看整体的生命周期:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">componentWillReceiveProps</span><br><span class="line">	-&gt;shouldComponentUpdate</span><br><span class="line">		-&gt; componentWillUpdate</span><br><span class="line">			-&gt; render</span><br><span class="line">				-&gt; componentDidUpdate</span><br></pre></td></tr></table></figure>

<h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h4><p>ReactCompositeComponent.updateComponent内, ReactCompositeComponent.js line 823-833</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">	<span class="comment">// 略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    inst.componentWillReceiveProps(nextProps, nextContext);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shouldComponentUpdate-1"><a href="#shouldComponentUpdate-1" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h4><p>ReactCompositeComponent.updateComponent内, ReactCompositeComponent.js line 838-860</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>._pendingForceUpdate) &#123;</span><br><span class="line">  <span class="keyword">if</span> (inst.shouldComponentUpdate) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">	  <span class="comment">// 略</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      shouldUpdate = inst.shouldComponentUpdate(</span><br><span class="line">        nextProps,</span><br><span class="line">        nextState,</span><br><span class="line">        nextContext,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._compositeType === CompositeTypes.PureClass) &#123;</span><br><span class="line">      shouldUpdate =</span><br><span class="line">        !shallowEqual(prevProps, nextProps) ||</span><br><span class="line">        !shallowEqual(inst.state, nextState);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="componentWillUpdate-1"><a href="#componentWillUpdate-1" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h4><p>ReactCompositeComponent.updateComponent 调用了ReactCompositeComponent._performComponentUpdate。</p>
<p>这个生命周期执行在这个函数内, 代码定位line955-965</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (inst.componentWillUpdate) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    inst.componentWillUpdate(nextProps, nextState, nextContext);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="render-2"><a href="#render-2" class="headerlink" title="render"></a>render</h4><p>ReactCompositeComponent._performComponentUpdate内</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>._updateRenderedComponent(transaction, unmaskedContext);</span><br></pre></td></tr></table></figure>

<h4 id="componentDidUpdate-1"><a href="#componentDidUpdate-1" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h4><p>ReactCompositeComponent._performComponentUpdate内</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasComponentDidUpdate) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">	<span class="comment">// 略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    transaction</span><br><span class="line">      .getReactMountReady()</span><br><span class="line">      .enqueue(</span><br><span class="line">        inst.componentDidUpdate.bind(</span><br><span class="line">          inst,</span><br><span class="line">          prevProps,</span><br><span class="line">          prevState,</span><br><span class="line">          prevContext,</span><br><span class="line">        ),</span><br><span class="line">        inst,</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>卸载这个环节的生命周期就比较好理解了。</p>
<p>我们的render环节会调用一个ReactCompositeComponent._updateRenderedComponent。</p>
<p>这个函数又一个非常显眼的逻辑分支。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</span><br><span class="line">    ReactReconciler.receiveComponent(</span><br><span class="line">        prevComponentInstance,</span><br><span class="line">        nextRenderedElement,</span><br><span class="line">        transaction,</span><br><span class="line">        <span class="built_in">this</span>._processChildContext(context),</span><br><span class="line">    );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);</span><br><span class="line">    ReactReconciler.unmountComponent(prevComponentInstance, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReactReconciler.receiveComponent这个方法里面调用了<code>internalInstance.unmountComponent(safely)</code>,它可以对各种组件实例的unmountComponent进行调用。</p>
<p>常规来说，我们最常用到的是是ReactCompositeComponent.unmountComponent。其中内容不再赘述。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此整个React的声明周期分析也算完整了。我们整体的分析了初次渲染、更新、卸载过程中的生命周期函数式如何被调用、在哪里调用，以及涉及到相关知识点，乃至如何进行方便的调试。</p>
]]></content>
      <tags>
        <tag>react lifecycle</tag>
      </tags>
  </entry>
  <entry>
    <title>react render环节分析</title>
    <url>/2018/04/20/react-render/</url>
    <content><![CDATA[<h1 id="render微观细节"><a href="#render微观细节" class="headerlink" title="render微观细节"></a>render微观细节</h1><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>这里从Component开始分析，因为我们一般使用 react时候最基础的用法是： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jsx file </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> ( </span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Hello Wolrd</span><br><span class="line">      &lt;/div&gt; </span><br><span class="line">    ); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HelloMessage name=<span class="string">&quot;Taylor&quot;</span> /&gt;, </span><br><span class="line">  mountNode</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>所以这里暂时以这个为目标，看看react最终是怎样实现这个jsx到js再到html上显示出HelloWorld的 </p>
<p>当代码开始处理时候首先时通过 babel的预处理，这段代码关键的地方被转译后是这样 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(HelloMessage, &#123; <span class="attr">name</span>: Taylor &#125;, <span class="string">&quot;&quot;</span>), </span><br><span class="line">  mountNode</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>不过值得一提是createElement实质上并不会直接处理<HelloMessage name="Taylor" />， </p>
<p>如果HelloMessage里面还有更多元素，那么第三个参数依旧用React.createElement来遍历子节点创建元素直到没有更多子元素了——这就是为什么 jsx里面render的元素必须用一个元素包裹起来的原因。 </p>
<p>举例来说，就像下面代码:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> ( </span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;</span><br><span class="line">        	&lt;span&gt;Helloword&lt;/span&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">      &lt;/div&gt; </span><br><span class="line">    ); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HelloMessage name=<span class="string">&quot;Taylor&quot;</span> /&gt;, </span><br><span class="line">  mountNode</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 被转换为:</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    React.createElement(</span><br><span class="line">        HelloMessage, </span><br><span class="line">        &#123; <span class="attr">name</span>: Taylor &#125;, </span><br><span class="line">        React.createElement(</span><br><span class="line">            <span class="string">&quot;div&quot;</span>,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            React.createElement(</span><br><span class="line">              <span class="string">&quot;span&quot;</span>,</span><br><span class="line">              <span class="literal">null</span>,</span><br><span class="line">              React.createElement(</span><br><span class="line">                <span class="string">&quot;span&quot;</span>,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                <span class="string">&quot;Helloword&quot;</span></span><br><span class="line">              )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    ), mountNode</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>这里暂时跳过React.createElement执行过程，先了解一下React.render是如何将react这些渲染到HTML上的。</p>
<p>在此之前，我们先在ReactDomComponent-test.js line 42打一个断点，然后在webstorm里点调试，接下来前往src/renderers/dom/ReactDOM.js目录将光标定位到568行。点击 <img src="/images/20180823151956.png" width="30px">图标,程序将会运行到这一行并断点，这样我们可以看到createElement函数最终返回的结构。它是这样的</p>
<p><img src="/images/20180823140712.png"></p>
<h2 id="Render的流程"><a href="#Render的流程" class="headerlink" title="Render的流程"></a>Render的流程</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactMount.render</span><br><span class="line">	-&gt; ReactMount._renderSubtreeIntoContainer</span><br><span class="line">		-&gt;  ReactMount._renderNewRootComponent</span><br><span class="line">			-&gt; ReactUpdates.batchedUpdates</span><br><span class="line">				-&gt; ReactUpdates.batchedMountComponentIntoNode</span><br><span class="line">					-&gt; mountComponentIntoNode(ReactMount.js中)</span><br><span class="line">						-&gt; ReactMount._mountImageIntoNode</span><br></pre></td></tr></table></figure>



<h3 id="ReactMount-renderSubtreeIntoContainer"><a href="#ReactMount-renderSubtreeIntoContainer" class="headerlink" title="ReactMount._renderSubtreeIntoContainer"></a>ReactMount._renderSubtreeIntoContainer</h3><p>_renderSubtreeIntoContainer做了哪些事情呢？</p>
<ul>
<li>参数校验:<ul>
<li>setState异步回调是否合法 </li>
<li>目标渲染的元素是否是createElement返回的合法结构</li>
<li>是否传入了根节点容器</li>
</ul>
</li>
<li>使用TopLevelWrapper包装目标渲染元素 &amp;&amp; 设定Context预备传入</li>
<li>是否是更新环节 当前例子这里设置的null 如果更新环节需要保留一些状态传入</li>
<li>将ReactElement、根节点容器、重用标记(shouldReuseMarkup)、Context传入ReactMount._renderNewRootComponent进行渲染</li>
</ul>
<h3 id="ReactMount-renderNewRootComponent"><a href="#ReactMount-renderNewRootComponent" class="headerlink" title="ReactMount._renderNewRootComponent"></a>ReactMount._renderNewRootComponent</h3><p>它做了这些:</p>
<ul>
<li>参数校验<ul>
<li>ReactCurrentOwner校验</li>
<li>容器合法性校验</li>
</ul>
</li>
<li>记录scroll值</li>
<li>生成最终会被挂载上去的ReactNode(框架内私有表现形式，componentInstance) </li>
<li>调用ReactUpdates.batchedUpdates进行更新</li>
</ul>
<h3 id="ReactUpdates-batchedUpdates"><a href="#ReactUpdates-batchedUpdates" class="headerlink" title="ReactUpdates.batchedUpdates"></a>ReactUpdates.batchedUpdates</h3><p>它做了这些:</p>
<ul>
<li>确认事务模型就绪 &amp;&amp; batchingStrategy就绪</li>
<li>调用batchingStrategy.batchedUpdates进行下一步</li>
<li>根据isBatchingUpdates进行调度处理<ul>
<li>如果为true 那么仅执行传入的callback</li>
<li>如果为false 使用transaction.perform对callback进行调用(这里有前置和收尾处理 这是事务的特点)</li>
</ul>
</li>
<li>不管如何callback会被执行(这里callback是batchedMountComponentIntoNode,定义在ReactMount.js中)</li>
</ul>
<h3 id="batchedMountComponentIntoNode"><a href="#batchedMountComponentIntoNode" class="headerlink" title="batchedMountComponentIntoNode"></a>batchedMountComponentIntoNode</h3><p>它做了:</p>
<ul>
<li>获取ReactReconcileTransaction事务实例</li>
<li>使用该事务实例调用mountComponentIntoNode来进行下一步更新</li>
</ul>
<h3 id="mountComponentIntoNode"><a href="#mountComponentIntoNode" class="headerlink" title="mountComponentIntoNode"></a>mountComponentIntoNode</h3><p>这个函数的作用是挂载组件并将其渲染到DOM</p>
<p>它做了:</p>
<ul>
<li>调用ReactReconciler.mountComponent生成markup标记内部含有{children: markup数组, node:HTMLElement}。此时mountComponent实质是ReactDomComponent.mountComponent。可以参考ReactDomComponent篇看看这个函数做了什么。</li>
<li>调用ReactMount._mountImageIntoNode渲染markup(markup.node是HTML元素可以直接插入DOM)</li>
</ul>
<h3 id="ReactMount-mountImageIntoNode"><a href="#ReactMount-mountImageIntoNode" class="headerlink" title="ReactMount._mountImageIntoNode"></a>ReactMount._mountImageIntoNode</h3><p>这个函数是最终的函数 它没有返回值，只是将相关处理好的结果插入DOM中 </p>
<p>在这个例子时里面因为没有旧的元素而是全部新生成所以进入了</p>
<p>useCreateElement分支，这个分支中将会删除所有的</p>
<p>container子元素，并执行DOMLazyTree.insertTreeBefore</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (transaction.useCreateElement) &#123;</span><br><span class="line">  <span class="keyword">while</span> (container.lastChild) &#123;</span><br><span class="line">    container.removeChild(container.lastChild);</span><br><span class="line">  &#125;</span><br><span class="line">  DOMLazyTree.insertTreeBefore(container, markup, <span class="literal">null</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>而DOMLazyTree.insertTreeBefore这个函数，这个函数里面有一个比较核心的函数insertTreeChildren，这个函数会调用insertTreeChildren，insertTreeChildren又会根据传入的 tree的 node长度递归调用insertTreeChildren，总之这两个函数会互相调用。直到所有的children都被放入其对应的node，并渲染到对应容器里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (children.length) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    insertTreeBefore(node, children[i], <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，它的执行结果是 insertTreeBefore最外层获取了一个markup, 这个markup的node最终将所有的children里面的node渲染到这个markup的node节点 也就是我们最最终想要渲染的HTMLELement。获取之后，就被插入到了container里面。</p>
<p>最终，整个渲染就到此结束了。</p>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul>
<li>ReactReconciler.mountComponent过程是怎样的</li>
<li>事件的处理是怎样的</li>
<li>生命周期的实现</li>
</ul>
]]></content>
      <tags>
        <tag>react render</tag>
      </tags>
  </entry>
  <entry>
    <title>react工程结构浅析</title>
    <url>/2018/04/15/react-build/</url>
    <content><![CDATA[<h1 id="浅析"><a href="#浅析" class="headerlink" title="浅析"></a>浅析</h1><p>这里以 15-stable 这个 tag,也就是 15.6.2 为基准分析<br>这里还是得从 package.json 开始，npm scrip 命令如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;grunt build&quot;,</span><br><span class="line">  &quot;linc&quot;: &quot;git diff --name-only --diff-filter=ACMRTUB `git merge-base HEAD master` | grep &#x27;\\.js$&#x27; | xargs eslint --&quot;,</span><br><span class="line">  &quot;lint&quot;: &quot;grunt lint&quot;,</span><br><span class="line">  &quot;postinstall&quot;: &quot;node node_modules/fbjs-scripts/node/check-dev-engines.js package.json&quot;,</span><br><span class="line">  &quot;test&quot;: &quot;jest&quot;,</span><br><span class="line">  &quot;flow&quot;: &quot;flow&quot;,</span><br><span class="line">  &quot;prettier&quot;: &quot;node ./scripts/prettier/index.js write&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>可见 build 是使用的 grunt 打包</p>
<h1 id="gruntfile任务总览"><a href="#gruntfile任务总览" class="headerlink" title="gruntfile任务总览:"></a>gruntfile任务总览:</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">&quot;build&quot;</span>, [</span><br><span class="line">  <span class="string">&quot;delete-build-modules&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build-modules&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version-check&quot;</span>,</span><br><span class="line">  <span class="string">&quot;browserify:basic&quot;</span>,</span><br><span class="line">  <span class="string">&quot;browserify:addons&quot;</span>,</span><br><span class="line">  <span class="string">&quot;browserify:min&quot;</span>,</span><br><span class="line">  <span class="string">&quot;browserify:addonsMin&quot;</span>,</span><br><span class="line">  <span class="string">&quot;browserify:dom&quot;</span>,</span><br><span class="line">  <span class="string">&quot;browserify:domMin&quot;</span>,</span><br><span class="line">  <span class="string">&quot;browserify:domServer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;browserify:domServerMin&quot;</span>,</span><br><span class="line">  <span class="string">&quot;browserify:domFiber&quot;</span>,</span><br><span class="line">  <span class="string">&quot;browserify:domFiberMin&quot;</span>,</span><br><span class="line">  <span class="string">&quot;npm-react:release&quot;</span>,</span><br><span class="line">  <span class="string">&quot;npm-react:pack&quot;</span>,</span><br><span class="line">  <span class="string">&quot;npm-react-dom:release&quot;</span>,</span><br><span class="line">  <span class="string">&quot;npm-react-dom:pack&quot;</span>,</span><br><span class="line">  <span class="string">&quot;npm-react-test:release&quot;</span>,</span><br><span class="line">  <span class="string">&quot;npm-react-test:pack&quot;</span>,</span><br><span class="line">  <span class="string">&quot;compare_size&quot;</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>如果熟悉 grunt,会很清楚这个 build 实际上是下面数组里面所有任务的集合，这里挨个分解一下每一行的任务</p>
<h2 id="delete-build-modules"><a href="#delete-build-modules" class="headerlink" title="delete-build-modules"></a>delete-build-modules</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">&quot;delete-build-modules&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Use gulp here.</span></span><br><span class="line">  spawnGulp([<span class="string">&quot;react:clean&quot;</span>], <span class="literal">null</span>, <span class="built_in">this</span>.async());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里调用了一个函数 spawnGulp</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawnGulp</span>(<span class="params">args, opts, done</span>) </span>&#123;</span><br><span class="line">  grunt.util.spawn(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// This could be more flexible (require.resolve &amp; lookup bin in package)</span></span><br><span class="line">      <span class="comment">// but if it breaks we&#x27;ll fix it then.</span></span><br><span class="line">      cmd: path.join(<span class="string">&quot;node_modules&quot;</span>, <span class="string">&quot;.bin&quot;</span>, GULP_EXE),</span><br><span class="line">      args: args,</span><br><span class="line">      opts: <span class="built_in">Object</span>.assign(&#123; <span class="attr">stdio</span>: <span class="string">&quot;inherit&quot;</span> &#125;, opts)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err, result, code</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        grunt.fail.fatal(<span class="string">&quot;Something went wrong running gulp: &quot;</span>, result);</span><br><span class="line">      &#125;</span><br><span class="line">      done(code === <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>grunt.util.spawn</strong> 是 grunt 一个 api,它可以创建一个子进程，它的 API 比较简单，<code>grunt.util.spawn(opts, callback)</code>,执行一个命令(opts 里面配置)，当这个命令执行完毕退出时候会执行 callback。<br><code>this.async()</code>则是 grunt 内部设定异步的一个方式,通过这种方式 grunt 才会知道这是一个异步任务。<br>综上，<code>spawnGulp(['react:clean'], null, this.async())</code>实际上是在对 grunt 说，『调用一个子进程，执行’gulp react:clean’，并等待它执行完毕，如果抛错就中断整个 grunt 任务并抛出错误。』<br>gulp 任务的配置文件是 gulpfile,里面定义的任务如下，很容易明白，这是一个删除各个库类 lib 文件的任务，不需要说太多。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">&quot;react:clean&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> del([</span><br><span class="line">    paths.react.lib,</span><br><span class="line">    paths.reactDOM.lib,</span><br><span class="line">    paths.reactNative.lib,</span><br><span class="line">    paths.reactShallowRenderer.lib,</span><br><span class="line">    paths.reactTestRenderer.lib</span><br><span class="line">  ]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="build-modules"><a href="#build-modules" class="headerlink" title="build-modules"></a>build-modules</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">&quot;build-modules&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  spawnGulp([<span class="string">&quot;react:modules&quot;</span>], <span class="literal">null</span>, <span class="built_in">this</span>.async());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个和 1 同理，只不过任务换成了 gulp react:modules</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">&quot;react:modules&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> merge(</span><br><span class="line">    gulp</span><br><span class="line">      .src(paths.react.src)</span><br><span class="line">      .pipe(babel(babelOptsReact))</span><br><span class="line">      .pipe(stripProvidesModule())</span><br><span class="line">      .pipe(flatten())</span><br><span class="line">      .pipe(gulp.dest(paths.react.lib)),</span><br><span class="line">    gulp</span><br><span class="line">      .src(paths.reactDOM.src)</span><br><span class="line">      .pipe(babel(babelOptsReactDOM))</span><br><span class="line">      .pipe(stripProvidesModule())</span><br><span class="line">      .pipe(flatten())</span><br><span class="line">      .pipe(gulp.dest(paths.reactDOM.lib)),</span><br><span class="line">    gulp</span><br><span class="line">      .src(paths.reactNative.src)</span><br><span class="line">      .pipe(babel(babelOptsReactNative))</span><br><span class="line">      .pipe(stripProvidesModule())</span><br><span class="line">      .pipe(flatten())</span><br><span class="line">      .pipe(gulp.dest(paths.reactNative.lib)),</span><br><span class="line">    gulp</span><br><span class="line">      .src(paths.reactShallowRenderer.src)</span><br><span class="line">      .pipe(stripProvidesModule())</span><br><span class="line">      .pipe(babel(babelOptsReactShallowRenderer))</span><br><span class="line">      .pipe(flatten())</span><br><span class="line">      .pipe(gulp.dest(paths.reactShallowRenderer.lib)),</span><br><span class="line">    gulp</span><br><span class="line">      .src(paths.reactTestRenderer.src)</span><br><span class="line">      .pipe(stripProvidesModule())</span><br><span class="line">      .pipe(babel(babelOptsReactTestRenderer))</span><br><span class="line">      .pipe(flatten())</span><br><span class="line">      .pipe(gulp.dest(paths.reactTestRenderer.lib))</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个任务是 gulpfile 的核心部分，gulpfile291 行代码里面 90%都是它的配置、和相关预定义。这几个任务主要的就是 babel(options)、stripProvidesModule、flatten<br>这里先找其中第一个 options 看看，这五个 options 整体结构都雷同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> babelOptsReact = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    devExpressionWithCodes, <span class="comment">// this pass has to run before `rewrite-modules`</span></span><br><span class="line">    [babelPluginModules, &#123; <span class="attr">map</span>: moduleMapReact &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以很容易理解这个代码的意思，实质上就是运行 babel,只不过给每个 bable 传入的 plugins 都不一样而已。这里看看这个 devExpressionWithCodes 文件，它指向了 scripts/error-codes/dev-expression-with-codes.js，这里看看这个文件的内容，这里核心一点的地方就是需要对 babel 的 <a href="https://babeljs.io/docs/plugins/">plugins</a> 有所了解.<br>官方的简介里面提及，babel 是一个编译器，在高层级设计上，有三个运行阶段：parsing, transforming, and generation，plugins 这个东西会影响 transforming 这个环节。<br>根据官方页面的#plugin-development 提及的，来到<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md">babel-handbook 的中文版 plugins 引导页面</a>。<br>scripts/error-codes/dev-expression-with-codes.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> evalToString = <span class="built_in">require</span>(<span class="string">&quot;./evalToString&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> existingErrorMap = <span class="built_in">require</span>(<span class="string">&quot;./codes.json&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> invertObject = <span class="built_in">require</span>(<span class="string">&quot;./invertObject&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> errorMap = invertObject(existingErrorMap);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">babel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> t = babel.types;</span><br><span class="line">  <span class="keyword">var</span> SEEN_SYMBOL = <span class="built_in">Symbol</span>(<span class="string">&quot;dev-expression-with-codes.seen&quot;</span>);</span><br><span class="line">  <span class="comment">// Generate a hygienic identifier</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getProdInvariantIdentifier</span>(<span class="params">path, localState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!localState.prodInvariantIdentifier) &#123;</span><br><span class="line">      localState.prodInvariantIdentifier = path.scope.generateUidIdentifier(</span><br><span class="line">        <span class="string">&quot;prodInvariant&quot;</span></span><br><span class="line">      );</span><br><span class="line">      path.scope.getProgramParent().push(&#123;</span><br><span class="line">        id: localState.prodInvariantIdentifier,</span><br><span class="line">        init: t.callExpression(t.identifier(<span class="string">&quot;require&quot;</span>), [</span><br><span class="line">          t.stringLiteral(<span class="string">&quot;reactProdInvariant&quot;</span>)</span><br><span class="line">        ])</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> localState.prodInvariantIdentifier;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> DEV_EXPRESSION = t.binaryExpression(</span><br><span class="line">    <span class="string">&quot;!==&quot;</span>,</span><br><span class="line">    t.memberExpression(</span><br><span class="line">      t.memberExpression(t.identifier(<span class="string">&quot;process&quot;</span>), t.identifier(<span class="string">&quot;env&quot;</span>), <span class="literal">false</span>),</span><br><span class="line">      t.identifier(<span class="string">&quot;NODE_ENV&quot;</span>),</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    ),</span><br><span class="line">    t.stringLiteral(<span class="string">&quot;production&quot;</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    pre: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.prodInvariantIdentifier = <span class="literal">null</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      Identifier: &#123;</span><br><span class="line">        enter: <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// Do nothing when testing</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&quot;test&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Replace __DEV__ with process.env.NODE_ENV !== &#x27;production&#x27;</span></span><br><span class="line">          <span class="keyword">if</span> (path.isIdentifier(&#123; <span class="attr">name</span>: <span class="string">&quot;__DEV__&quot;</span> &#125;)) &#123;</span><br><span class="line">            path.replaceWith(DEV_EXPRESSION);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      CallExpression: &#123;</span><br><span class="line">        exit: <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> node = path.node;</span><br><span class="line">          <span class="comment">// Ignore if it&#x27;s already been processed</span></span><br><span class="line">          <span class="keyword">if</span> (node[SEEN_SYMBOL]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Insert `var PROD_INVARIANT = require(&#x27;reactProdInvariant&#x27;);`</span></span><br><span class="line">          <span class="comment">// before all `require(&#x27;invariant&#x27;)`s.</span></span><br><span class="line">          <span class="comment">// NOTE it doesn&#x27;t support ES6 imports yet.</span></span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            path.get(<span class="string">&quot;callee&quot;</span>).isIdentifier(&#123; <span class="attr">name</span>: <span class="string">&quot;require&quot;</span> &#125;) &amp;&amp;</span><br><span class="line">            path.get(<span class="string">&quot;arguments&quot;</span>)[<span class="number">0</span>] &amp;&amp;</span><br><span class="line">            path.get(<span class="string">&quot;arguments&quot;</span>)[<span class="number">0</span>].isStringLiteral(&#123; <span class="attr">value</span>: <span class="string">&quot;invariant&quot;</span> &#125;)</span><br><span class="line">          ) &#123;</span><br><span class="line">            node[SEEN_SYMBOL] = <span class="literal">true</span>;</span><br><span class="line">            getProdInvariantIdentifier(path, <span class="built_in">this</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.get(<span class="string">&quot;callee&quot;</span>).isIdentifier(&#123; <span class="attr">name</span>: <span class="string">&quot;invariant&quot;</span> &#125;)) &#123;</span><br><span class="line">            <span class="comment">// Turns this code:</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// invariant(condition, argument, &#x27;foo&#x27;, &#x27;bar&#x27;);</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// into this:</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// if (!condition) &#123;</span></span><br><span class="line">            <span class="comment">//   if (&quot;production&quot; !== process.env.NODE_ENV) &#123;</span></span><br><span class="line">            <span class="comment">//     invariant(false, argument, &#x27;foo&#x27;, &#x27;bar&#x27;);</span></span><br><span class="line">            <span class="comment">//   &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//     PROD_INVARIANT(&#x27;XYZ&#x27;, &#x27;foo&#x27;, &#x27;bar&#x27;);</span></span><br><span class="line">            <span class="comment">//   &#125;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// where</span></span><br><span class="line">            <span class="comment">// - `XYZ` is an error code: a unique identifier (a number string)</span></span><br><span class="line">            <span class="comment">//   that references a verbose error message.</span></span><br><span class="line">            <span class="comment">//   The mapping is stored in `scripts/error-codes/codes.json`.</span></span><br><span class="line">            <span class="comment">// - `PROD_INVARIANT` is the `reactProdInvariant` function that always throws with an error URL like</span></span><br><span class="line">            <span class="comment">//   [http://facebook.github.io/react/docs/error-decoder.html?invariant=XYZ&amp;args[\]=foo&amp;args[]=bar](http://facebook.github.io/react/docs/error-decoder.html?invariant=XYZ&amp;args%5B%5D=foo&amp;args%5B%5D=bar)</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Specifically this does 3 things:</span></span><br><span class="line">            <span class="comment">// 1. Checks the condition first, preventing an extra function call.</span></span><br><span class="line">            <span class="comment">// 2. Adds an environment check so that verbose error messages aren&#x27;t</span></span><br><span class="line">            <span class="comment">//    shipped to production.</span></span><br><span class="line">            <span class="comment">// 3. Rewrites the call to `invariant` in production to `reactProdInvariant`</span></span><br><span class="line">            <span class="comment">//   - `reactProdInvariant` is always renamed to avoid shadowing</span></span><br><span class="line">            <span class="comment">// The generated code is longer than the original code but will dead</span></span><br><span class="line">            <span class="comment">// code removal in a minifier will strip that out.</span></span><br><span class="line">            <span class="keyword">var</span> condition = node.arguments[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> errorMsgLiteral = evalToString(node.arguments[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">var</span> prodErrorId = errorMap[errorMsgLiteral];</span><br><span class="line">            <span class="keyword">if</span> (prodErrorId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">              <span class="comment">// The error cannot be found in the map.</span></span><br><span class="line">              node[SEEN_SYMBOL] = <span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;test&quot;</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(</span><br><span class="line">                  <span class="string">&#x27;Error message &quot;&#x27;</span> +</span><br><span class="line">                    errorMsgLiteral +</span><br><span class="line">                    <span class="string">&#x27;&quot; cannot be found. The current React version &#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;and the error map are probably out of sync. &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Please run `gulp react:extract-errors` before building React.&quot;</span></span><br><span class="line">                );</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> devInvariant = t.callExpression(</span><br><span class="line">              node.callee,</span><br><span class="line">              [</span><br><span class="line">                t.booleanLiteral(<span class="literal">false</span>),</span><br><span class="line">                t.stringLiteral(errorMsgLiteral)</span><br><span class="line">              ].concat(node.arguments.slice(<span class="number">2</span>))</span><br><span class="line">            );</span><br><span class="line">            devInvariant[SEEN_SYMBOL] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">var</span> localInvariantId = getProdInvariantIdentifier(path, <span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">var</span> prodInvariant = t.callExpression(</span><br><span class="line">              localInvariantId,</span><br><span class="line">              [t.stringLiteral(prodErrorId)].concat(node.arguments.slice(<span class="number">2</span>))</span><br><span class="line">            );</span><br><span class="line">            prodInvariant[SEEN_SYMBOL] = <span class="literal">true</span>;</span><br><span class="line">            path.replaceWith(</span><br><span class="line">              t.ifStatement(</span><br><span class="line">                t.unaryExpression(<span class="string">&quot;!&quot;</span>, condition),</span><br><span class="line">                t.blockStatement([</span><br><span class="line">                  t.ifStatement(</span><br><span class="line">                    DEV_EXPRESSION,</span><br><span class="line">                    t.blockStatement([t.expressionStatement(devInvariant)]),</span><br><span class="line">                    t.blockStatement([t.expressionStatement(prodInvariant)])</span><br><span class="line">                  )</span><br><span class="line">                ])</span><br><span class="line">              )</span><br><span class="line">            );</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.get(<span class="string">&quot;callee&quot;</span>).isIdentifier(&#123; <span class="attr">name</span>: <span class="string">&quot;warning&quot;</span> &#125;)) &#123;</span><br><span class="line">            <span class="comment">// Turns this code:</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// warning(condition, argument, argument);</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// into this:</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// if (&quot;production&quot; !== process.env.NODE_ENV) &#123;</span></span><br><span class="line">            <span class="comment">//   warning(condition, argument, argument);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// The goal is to strip out warning calls entirely in production. We</span></span><br><span class="line">            <span class="comment">// don&#x27;t need the same optimizations for conditions that we use for</span></span><br><span class="line">            <span class="comment">// invariant because we don&#x27;t care about an extra call in __DEV__</span></span><br><span class="line">            node[SEEN_SYMBOL] = <span class="literal">true</span>;</span><br><span class="line">            path.replaceWith(</span><br><span class="line">              t.ifStatement(</span><br><span class="line">                DEV_EXPRESSION,</span><br><span class="line">                t.blockStatement([t.expressionStatement(node)])</span><br><span class="line">              )</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 DEV_EXPRESSION 实质上是指：process.evn.NODE_ENV !== ‘product’<br>visitor.Identifier.enter 主要逻辑则是遇到 name 为<strong>DEV</strong>的 Identifier 时时替换为 process.evn.NODE_ENV !== ‘product’<br>可能这样说比较绕，通俗点说就是全局替换遇到的<strong>DEV</strong> 为 process.evn.NODE_ENV !== ‘product’<br>类似的, visitor.CallExpression.exit 则是函数执行节点退出时候被执行的函数，常规的，举个例子，test(-8)解析成 AST 后，时这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">&quot;ExpressionStatement&quot;</span>,</span><br><span class="line">    expression: &#123;</span><br><span class="line">        type: <span class="string">&quot;CallExpression&quot;</span>,</span><br><span class="line">        callee: &#123;</span><br><span class="line">          type: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">          name: <span class="string">&quot;test&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">arguments</span>: [&#123;</span><br><span class="line">          type: <span class="string">&quot;UnaryExpression&quot;</span>,</span><br><span class="line">          operator: <span class="string">&quot;-&quot;</span>,</span><br><span class="line">          prefix: <span class="literal">true</span>,</span><br><span class="line">          <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            type: <span class="string">&quot;NumericLiteral&quot;</span>,</span><br><span class="line">            value: <span class="number">8</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了换个例子，继续下面的分析也就会顺利很多。不过考虑到代码里面已经有非常详尽的功能注释，所以这里暂时对 API 关键词做记录，但是暂时不再深究如何做到。</p>
<p>保留关键词：<br><strong>prodInvariantIdentifier</strong></p>
<p><strong>getProgramParent</strong></p>
<p><strong>generateUidIdentifier</strong></p>
<p>然后 <strong>visitor.CallExpression.exit</strong> 这块，主要功能如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 功能一</span><br><span class="line"><span class="comment">// 插入 `var PROD_INVARIANT = require(&#x27;reactProdInvariant&#x27;);`</span></span><br><span class="line"><span class="comment">// 到所有的 `require(&#x27;invariant&#x27;)`前面.</span></span><br><span class="line"># 功能二</span><br><span class="line"><span class="comment">// 转换类似这种调用 invariant(condition, argument, &#x27;foo&#x27;, &#x27;bar&#x27;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 为下面这种形式:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (!condition) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;production&quot;</span> !== process.env.NODE_ENV) &#123;</span><br><span class="line">    	invariant(<span class="literal">false</span>, argument, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	PROD_INVARIANT(<span class="string">&#x27;XYZ&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 功能三</span><br><span class="line"><span class="comment">// 转换 warning(condition, argument, argument);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 为下方代码:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;production&quot;</span> !== process.env.NODE_ENV) &#123;</span><br><span class="line">	warning(condition, argument, argument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体归纳一下，这个其实就是对两个函数进行转译过程.<br><strong>功能一</strong>确保后面调用 <strong>invariant</strong> 时候(被功能二转译所以需要用到 PROD_INVARIANT)功能二可以顺利执行<br><strong>功能二</strong>在生产模式执行 PROD_INVARIANT 在非生产执行 invariant，两者的区别是一个传递 errorId 到线上看报错，一个本地看<br><strong>功能三</strong>类似，在非生产显示 warning，在生产模式去掉<br>接下来是[babelPluginModules, {map: moduleMapReact}],，这个 babelPluginModules 指向/node_modules/fbjs-scripts/babel-6/rewrite-modules.js, map 则时传入的参数。</p>
<p>moduleMapReact 定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleMapBase = <span class="built_in">Object</span>.assign(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;object-assign&quot;</span>: <span class="string">&quot;object-assign&quot;</span>,</span><br><span class="line">    <span class="string">&quot;create-react-class&quot;</span>: <span class="string">&quot;create-react-class&quot;</span>,</span><br><span class="line">    <span class="string">&quot;create-react-class/factory&quot;</span>: <span class="string">&quot;create-react-class/factory&quot;</span>,</span><br><span class="line">    <span class="string">&quot;prop-types&quot;</span>: <span class="string">&quot;prop-types&quot;</span>,</span><br><span class="line">    <span class="string">&quot;prop-types/factory&quot;</span>: <span class="string">&quot;prop-types/factory&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;fbjs/module-map&quot;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> moduleMapReact = <span class="built_in">Object</span>.assign(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Addons needs to reach into DOM internals</span></span><br><span class="line">    ReactDOM: <span class="string">&quot;react-dom/lib/ReactDOM&quot;</span>,</span><br><span class="line">    ReactInstanceMap: <span class="string">&quot;react-dom/lib/ReactInstanceMap&quot;</span>,</span><br><span class="line">    ReactTestUtils: <span class="string">&quot;react-dom/lib/ReactTestUtils&quot;</span>,</span><br><span class="line">    ReactPerf: <span class="string">&quot;react-dom/lib/ReactPerf&quot;</span>,</span><br><span class="line">    getVendorPrefixedEventName: <span class="string">&quot;react-dom/lib/getVendorPrefixedEventName&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  moduleMapBase</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>rewrite-modules.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Rewrites module string literals according to the `map` and `prefix` options.</span></span><br><span class="line"><span class="comment">* This allows other npm packages to be published and used directly without</span></span><br><span class="line"><span class="comment">* being a part of the same build.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapModule</span>(<span class="params">state, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> moduleMap = state.opts.map || &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (moduleMap.hasOwnProperty(<span class="built_in">module</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> moduleMap[<span class="built_in">module</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Jest understands the haste module system, so leave modules intact.</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> modulePrefix = state.opts.prefix;</span><br><span class="line">    <span class="keyword">if</span> (modulePrefix == <span class="literal">null</span>) &#123;</span><br><span class="line">      modulePrefix = <span class="string">&#x27;./&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modulePrefix + <span class="built_in">module</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArguments</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> args = path.get(<span class="string">&#x27;arguments&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (args &amp;&amp; args.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>].node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jestMethods = [</span><br><span class="line">    <span class="string">&#x27;dontMock&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;genMockFromModule&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;mock&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;setMock&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;unmock&#x27;</span>,</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isJestProperty</span>(<span class="params">t, property</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t.isIdentifier(property) &amp;&amp; jestMethods.indexOf(property.name) !== -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">babel</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> t = babel.types;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Transforms `require(&#x27;Foo&#x27;)` and `require.requireActual(&#x27;Foo&#x27;)`.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transformRequireCall</span>(<span class="params">path, state</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> calleePath = path.get(<span class="string">&#x27;callee&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !t.isIdentifier(calleePath.node, &#123;<span class="attr">name</span>: <span class="string">&#x27;require&#x27;</span>&#125;) &amp;&amp;</span><br><span class="line">      !(</span><br><span class="line">        t.isMemberExpression(calleePath.node) &amp;&amp;</span><br><span class="line">        t.isIdentifier(calleePath.node.object, &#123;<span class="attr">name</span>: <span class="string">&#x27;require&#x27;</span>&#125;) &amp;&amp;</span><br><span class="line">        t.isIdentifier(calleePath.node.property, &#123;<span class="attr">name</span>: <span class="string">&#x27;requireActual&#x27;</span>&#125;)</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> args = path.get(<span class="string">&#x27;arguments&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!args.length) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> moduleArg = args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (moduleArg.node.type === <span class="string">&#x27;StringLiteral&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> <span class="built_in">module</span> = mapModule(state, moduleArg.node.value);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">module</span>) &#123;</span><br><span class="line">        moduleArg.replaceWith(t.stringLiteral(<span class="built_in">module</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Transforms either individual or chained calls to `jest.dontMock(&#x27;Foo&#x27;)`,</span></span><br><span class="line"><span class="comment">* `jest.mock(&#x27;Foo&#x27;)`, and `jest.genMockFromModule(&#x27;Foo&#x27;)`.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transformJestHelper</span>(<span class="params">path, state</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> calleePath = path.get(<span class="string">&#x27;callee&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> args = path.get(<span class="string">&#x27;arguments&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!args.length) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> moduleArg = args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      moduleArg.node.type === <span class="string">&#x27;StringLiteral&#x27;</span> &amp;&amp;</span><br><span class="line">      calleePath.node &amp;&amp;</span><br><span class="line">      isJestProperty(t, calleePath.node.property)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">var</span> <span class="built_in">module</span> = mapModule(state, moduleArg.node.value);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">module</span>) &#123;</span><br><span class="line">        moduleArg.replaceWith(t.stringLiteral(<span class="built_in">module</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> jestIdentifier = &#123;</span><br><span class="line">    <span class="function"><span class="title">Identifier</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.[node.name](http:<span class="comment">//node.name) === &#x27;jest&#x27;) &#123;</span></span><br><span class="line">        <span class="built_in">this</span>.isJest = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transformJestCall</span>(<span class="params">path, state</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> params = &#123;<span class="attr">isJest</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">    path.traverse(jestIdentifier, params);</span><br><span class="line">    <span class="keyword">if</span> (params.isJest) &#123;</span><br><span class="line">      transformJestHelper(path, state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      CallExpression: &#123;</span><br><span class="line">        <span class="function"><span class="title">exit</span>(<span class="params">path, state</span>)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (path.node.seen) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          transformRequireCall(path, state);</span><br><span class="line">          transformJestCall(path, state);</span><br><span class="line">          path.node.seen = <span class="literal">true</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>transformRequireCall</strong> 很容易理解，根据 map 重写模块的引用，比如将 require(‘Promise’) 转译成 require(‘fbjs/lib/Promise’)等。而且注释也有标明<code>Transforms require(&#39;Foo&#39;)</code> and <code>require.requireActual(&#39;Foo&#39;)</code><br>transformJestHelper 类似 transformRequireCall，只不过时对 jest 的调用做一些替换，如果 map 里面有那么和 transformRequireCall 一样替换掉<br>到这里 bable(options)就到此结束了，不过最后还是总结这个环节做的事情</p>
<ul>
<li><p>处理<strong>DEV</strong>、invariant、warning 这三个变量、函数调用等的转译</p>
</li>
<li><p>替换 require、require.requireActual、jest 环节包名的重写(<strong>rewrite</strong>)<br>接下来是 stripProvidesModule(node_modules/fbjs-scripts/gulp/strip-provides-module.js)</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gutil = <span class="built_in">require</span>(<span class="string">&quot;gulp-util&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> through = <span class="built_in">require</span>(<span class="string">&quot;through2&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> PM_REGEXP = <span class="built_in">require</span>(<span class="string">&quot;./shared/provides-module&quot;</span>).regexp;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">transform</span>(<span class="params">file, enc, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (file.isNull()) &#123;</span><br><span class="line">      cb(<span class="literal">null</span>, file);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (file.isStream()) &#123;</span><br><span class="line">      cb(<span class="keyword">new</span> gutil.PluginError(<span class="string">&quot;module-map&quot;</span>, <span class="string">&quot;Streaming not supported&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Get the @providesModule piece out of the file and save that.</span></span><br><span class="line">    <span class="keyword">var</span> contents = file.contents.toString().replace(PM_REGEXP, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    file.contents = <span class="keyword">new</span> Buffer(contents);</span><br><span class="line">    <span class="built_in">this</span>.push(file);</span><br><span class="line">    cb();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> through.obj(transform);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数本身很简单，用途时将代码注释中包含的@providesModule 这一行删除掉。<br>flatten()这个的话可能是最好理解的。直接看 gulp-flatten 官方文档基本可以秒懂，就是去除文件中间路径，将指定目录遍历所有下级文件都归集到一起方便放到一个指定目录用的。<br>到这里 gulp 的 build 环节就分析完毕了，但是还是做一个最后的总结。<br>当代码执行下面代码时候</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp</span><br><span class="line">      .src(paths.react.src)</span><br><span class="line">      .pipe(babel(babelOptsReact))</span><br><span class="line">      .pipe(stripProvidesModule())</span><br><span class="line">      .pipe(flatten())</span><br><span class="line">      .pipe(gulp.dest(paths.react.lib)),</span><br></pre></td></tr></table></figure>

<p>一共发生了这些事情:</p>
<ul>
<li>babel 环节<ul>
<li>替换<strong>DEV</strong>,替换 invariant、warning</li>
<li>根据 Alias 文件产生的 Map 文件(主要是 Alias 映射关系维护)，更新 require 环节的引用路径 2.删除注释中的@providesModule(这个主要时用来生成之前提到的 Map 文件，是一套维护 Map 系统) 3.扁平化，将目标 src 文件处理好后全部放到目的文件夹<br>至此我们的 gruntFile 里面的 build-modules 任务已经分析完毕。<br>接下来是 version-check,这个也是一个 gulp 任务的引用，根据 getTask 定义</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTask</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">`./gulp/tasks/<span class="subst">$&#123;name&#125;</span>`</span>)(gulp, plugins);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该任务位于 gulp/tasks/version-check.js<br>核心代码是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reactVersion = <span class="built_in">require</span>(<span class="string">&quot;../../package.json&quot;</span>).version;</span><br><span class="line"><span class="keyword">var</span> versions = &#123;</span><br><span class="line">  <span class="string">&quot;packages/react/package.json&quot;</span>: <span class="built_in">require</span>(<span class="string">&quot;../../packages/react/package.json&quot;</span>)</span><br><span class="line">    .version,</span><br><span class="line">  <span class="string">&quot;packages/react-dom/package.json&quot;</span>: <span class="built_in">require</span>(<span class="string">&quot;../../packages/react-dom/package.json&quot;</span>)</span><br><span class="line">    .version,</span><br><span class="line">  <span class="string">&quot;packages/react-test-renderer/package.json&quot;</span>: <span class="built_in">require</span>(<span class="string">&quot;../../packages/react-test-renderer/package.json&quot;</span>)</span><br><span class="line">    .version,</span><br><span class="line">  <span class="string">&quot;src/ReactVersion.js&quot;</span>: <span class="built_in">require</span>(<span class="string">&quot;../../src/ReactVersion&quot;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> allVersionsMatch = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">Object</span>.keys(versions).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> version = versions[name];</span><br><span class="line">  <span class="keyword">if</span> (version !== reactVersion) &#123;</span><br><span class="line">    allVersionsMatch = <span class="literal">false</span>;</span><br><span class="line">    gutil.log(</span><br><span class="line">      gutil.colors.red(</span><br><span class="line">        <span class="string">&quot;%s version does not match package.json. Expected %s, saw %s.&quot;</span></span><br><span class="line">      ),</span><br><span class="line">      name,</span><br><span class="line">      reactVersion,</span><br><span class="line">      version</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (!allVersionsMatch) &#123;</span><br><span class="line">  process.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用很明显，确保 package 目录下的 react、react-dom、react-test-renderer 和 src/ReactVersion 以及根目录下 package.json 版本号完全一致。</p>
<h2 id="browserify"><a href="#browserify" class="headerlink" title="browserify"></a>browserify</h2><p>接下来是系列 browserify 的任务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;browserify:basic&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;browserify:addons&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;browserify:min&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;browserify:addonsMin&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;browserify:dom&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;browserify:domMin&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;browserify:domServer&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;browserify:domServerMin&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;browserify:domFiber&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;browserify:domFiberMin&#x27;</span>,</span><br></pre></td></tr></table></figure>

<p>这些配置在 grunt/config/browserify.js,这些 basic，addons 任务都是一个套路，代码相似就不重复记录了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> basic = &#123;</span><br><span class="line">  entries: [</span><br><span class="line">      <span class="string">&#x27;./build/node_modules/react/lib/ReactUMDEntry.js&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  outfile: <span class="string">&#x27;./build/react.js&#x27;</span>,</span><br><span class="line">  debug: <span class="literal">false</span>,</span><br><span class="line">  standalone: <span class="string">&#x27;React’, // 全局导出时候的库名称</span></span><br><span class="line"><span class="string">  // Apply as global transform so that we also envify fbjs and any other deps</span></span><br><span class="line"><span class="string">  globalTransforms: [envifyDev],</span></span><br><span class="line"><span class="string">  plugins: [collapser],</span></span><br><span class="line"><span class="string">  after: [derequire, simpleBannerify],</span></span><br><span class="line"><span class="string">  // 其他还有一些 after</span></span><br><span class="line"><span class="string">  // [wrapperify, minify, bannerify, simpleBannerify]</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>这里大概有几个包需要简单说一下<br>loose-envify 这是一个替换用的包，类似 envify，效果如下，不解释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&quot;development&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;development only&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//after</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;production&quot;</span> === <span class="string">&quot;development&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;development only&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bundle-collapser(collapser)也是一个替换用的包，可以将 require(‘helloword’)转换成类似 require(1)这种极短的引用<br>wrapperify 将库包裹成 UMD 规范<br>minify 压缩代码<br>simpleBannerify、bannerify 给代码文件 Header 包括开源协议和一系列作者信息等等<br>总体大致的流程就是这个对象设置了入口文件、出口文件，然后打包过程中进行一系列替换、封装 UMD、添加文件头、压缩等优化操作，弄清楚每个引用代表的功能，整个过程很明晰。<br>接下来就是 npm 这块的任务了</p>
<h2 id="release-amp-amp-pack"><a href="#release-amp-amp-pack" class="headerlink" title="release &amp;&amp; pack"></a>release &amp;&amp; pack</h2><p>‘npm-react:release’,<br>‘npm-react:pack’,<br>‘npm-react-dom:release’,<br>‘npm-react-dom:pack’,<br>‘npm-react-test:release’,<br>‘npm-react-test:pack’,<br>这些任务的流程基本一样，所以只已 npm-react 为记录，其中 npm-react:release 的任务主要代码是:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildRelease</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// delete build/react-core for fresh start</span></span><br><span class="line">  <span class="keyword">if</span> (grunt.file.exists(dest)) &#123;</span><br><span class="line">    grunt.file.delete(dest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// mkdir -p build/react-core/lib</span></span><br><span class="line">  grunt.file.mkdir(lib);</span><br><span class="line">  <span class="comment">// Copy npm-react/*_/_ to build/npm-react</span></span><br><span class="line">  <span class="comment">// and build/modules/*_/_ to build/react-core/lib</span></span><br><span class="line">  <span class="keyword">var</span> mappings = [].concat(</span><br><span class="line">    grunt.file.expandMapping(<span class="string">&quot;**/*&quot;</span>, dest, &#123; <span class="attr">cwd</span>: src &#125;),</span><br><span class="line">    grunt.file.expandMapping(<span class="string">&quot;**/*&quot;</span>, lib, &#123; <span class="attr">cwd</span>: modSrc &#125;),</span><br><span class="line">    grunt.file.expandMapping(<span class="string">&quot;LICENSE&quot;</span>, dest)</span><br><span class="line">  );</span><br><span class="line">  mappings.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mapping</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mappingSrc = mapping.src[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> mappingDest = mapping.dest;</span><br><span class="line">    <span class="keyword">if</span> (grunt.file.isDir(mappingSrc)) &#123;</span><br><span class="line">      grunt.file.mkdir(mappingDest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      grunt.file.copy(mappingSrc, mappingDest);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// Make built source available inside npm package</span></span><br><span class="line">  grunt.file.mkdir(dist);</span><br><span class="line">  distFiles.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    grunt.file.copy(<span class="string">&quot;build/&quot;</span> + file, dist + file);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// modify build/react-core/package.json to set version ##</span></span><br><span class="line">  <span class="keyword">var</span> pkg = grunt.file.readJSON(dest + <span class="string">&quot;package.json&quot;</span>);</span><br><span class="line">  pkg.version = grunt.config.data.pkg.version;</span><br><span class="line">  grunt.file.write(dest + <span class="string">&quot;package.json&quot;</span>, <span class="built_in">JSON</span>.stringify(pkg, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体来讲这个任务虽然挂着 buildRelease 的名头实际上他就是一个做复制粘贴的苦力活儿，主要 build 任务在 build:modules 已经做完了，这里仅仅说一下它做了什么，然后就是怎么做的。 </p>
<ul>
<li>复制 packages/react/里面所有文件到 build/packages/react/目录 </li>
<li>复制 build/node_modules/react/lib/里面所有文件到 build/packages/react/lib/目录 </li>
<li>复制 build:modules 打包好的 react.js、react-addons.js 和它们的 min 文件到 build/packages/react/dist/目录 </li>
<li>修改 package.json 里面的版本号</li>
</ul>
<p>然后是 npm-react:pack 相关的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">packRelease</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> done = <span class="built_in">this</span>.async();</span><br><span class="line">  <span class="keyword">var</span> spawnCmd = &#123;</span><br><span class="line">    cmd: <span class="string">&quot;npm&quot;</span>,</span><br><span class="line">    args: [<span class="string">&quot;pack&quot;</span>, <span class="string">&quot;packages/react&quot;</span>],</span><br><span class="line">    opts: &#123;</span><br><span class="line">      cwd: <span class="string">&quot;build/&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  grunt.util.spawn(spawnCmd, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buildSrc = <span class="string">&quot;build/react-&quot;</span> + grunt.config.data.pkg.version + <span class="string">&quot;.tgz&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> buildDest = <span class="string">&quot;build/packages/react.tgz&quot;</span>;</span><br><span class="line">    fs.rename(buildSrc, buildDest, done);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spawnCmd 这个相当于时执行一个命令: <code>cd build/ && npm pack package/react</code><br>pack 是 npm 工具内建的一个命令 打包 npm 包生成<name>-<version>.tgz 格式压缩包<br>下面代码则是执行完毕生成了<name>-<version>.tgz 格式压缩包后重命名为 react.tgz</p>
]]></content>
      <tags>
        <tag>react gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>typescript笔记</title>
    <url>/2018/01/15/typescript-notes/</url>
    <content><![CDATA[<h1 id="Typescript的类型"><a href="#Typescript的类型" class="headerlink" title="Typescript的类型"></a>Typescript的类型</h1><p>截至目前版本(TypeScript 2.6), Typescript类型有以下几种:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>布尔值</td>
</tr>
<tr>
<td>number</td>
<td>数字</td>
</tr>
<tr>
<td>string</td>
<td>字符串</td>
</tr>
<tr>
<td>array</td>
<td>数组</td>
</tr>
<tr>
<td>Tuple</td>
<td>元组类型允许表示一个已知元素数量和类型的数组</td>
</tr>
<tr>
<td>enum</td>
<td>枚举，给数字集合更好的命名，默认从0开始</td>
</tr>
<tr>
<td>any</td>
<td>任意类型</td>
</tr>
<tr>
<td>void</td>
<td>可以看成any的对立面，这个常在没有返回的函数那里看到，它表示没有任何类型</td>
</tr>
<tr>
<td>Null 和 Undefined</td>
<td>TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null</td>
</tr>
<tr>
<td>Never</td>
<td>表示的是那些永不存在的值的类型，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型</td>
</tr>
</tbody></table>
<p>目前来说文档算是对类型讲的比较清楚</p>
<h1 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h1><h2 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h2><p>区别在于let声明以后可以更改，而const不能。根据最小权限原则，除非你计划更改，那么就用const。</p>
<h2 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h2><p>简单说，就是对函数的输入和输出进行一个约束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1: number, num2: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口我个人认为是typescript用的最多的东西之一，但是可能也是常规使用ts最容易遇到问题的地方之一，正常来讲我感觉说它最难应该也没啥问题？不过接口是在类型系统的基础上建立的，它的作用是对数据的结构体进行校验，而ts里面常规的类型系统，一般的类型校验都是对值或者函数的校验。</p>
<p>接口这里个人感觉是一个熟能生巧的东西。</p>
<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Person&#123;</span><br><span class="line">  name: <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">person: Person</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;persion.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可选属性-amp-amp-只读属性"><a href="#可选属性-amp-amp-只读属性" class="headerlink" title="可选属性 &amp;&amp; 只读属性"></a>可选属性 &amp;&amp; 只读属性</h2><p>上面的实际上只是最简单的接口的例子，实际上应用的时候不会这样简单。<br>常见的场景就是有些属性有些对象有有些却没有有，这时候如果全部如上面那么写就会抛错。可选属性是写ts时候面临的第一个困惑我认为。<br>套用一下官方的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，color和width就都不是必须的了。可以根据情况来选择传不传。<br>另外就是只读属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">    readonly y: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1: Point = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line">p1.x = <span class="number">5</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<h2 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h2><p>接口默认是一种严格的校验，当一个数据结构符合一个接口时候(而不做特殊处理)，他的意思是严格的符合，不可以带『私货』。<br>所以说如下接口使用时候，可以给createSquare传{color:”xxxx”},可以传{width: 10}，也可以两个都传，但是不可以再加一个height;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">    color?: string;</span><br><span class="line">    width?: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: string; area: number &#125; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理的，如下代码也是会抛错的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a: SquareConfig = &#123;<span class="attr">color</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">10</span>&#125;;</span><br><span class="line">a.height = <span class="number">10</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>此时可以加上<a href="#%E5%8F%AF%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B-%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D">引索签名</a>来解决这个问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">    color?: string;</span><br><span class="line">    width?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时可以给它传递任何类型的属性了，就像常规的的js对象一样。</p>
<h2 id="函数接口-可调用签名"><a href="#函数接口-可调用签名" class="headerlink" title="函数接口(可调用签名)"></a>函数接口(可调用签名)</h2><p>上面的接口相关都是用来描述一个对象，一个数据结构是怎样的，但是没有说，一个函数该如何用接口描述；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  (source: string, <span class="attr">subString</span>: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src, sub</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">    <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数接口这里定义还是比较简单，核心还是 <code>(source: string, subString: string): boolean;</code>, 冒号前面那块是参数，冒号后面则是返回值的类型。<br>这里有几个要点可以关注一下</p>
<ul>
<li>函数在声明时候设好了接口以后， 参数名不需要与接口里定义的名字相匹配，它是挨个匹配类型，而不是根据参数名</li>
<li>定义了接口以后，函数定义时候， src, sub 参数这里可以不设置类型，而是通过ts自动推导出来。</li>
</ul>
<h2 id="可索引的类型-索引签名"><a href="#可索引的类型-索引签名" class="headerlink" title="可索引的类型(索引签名)"></a>可索引的类型(索引签名)</h2><p>除了描述对象、函数，接口也可以描述可引索的类型。这是一个名为索引签名的东西实现的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">  [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray;</span><br><span class="line">myArray = [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Fred&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr: string = myArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>如上，这种签名如果只是为了处理数组，显然这是这没啥用的，因为不如 <code>let myArray: string[] = ["Bob", "Fred"];</code>好用也不如其整洁。我个人认为索引签名其实还是如上面提到的<a href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5">额外的属性检查</a>这块的作用更大一些。</p>
<h2 id="Class约束"><a href="#Class约束" class="headerlink" title="Class约束"></a>Class约束</h2><p>类的约束有两种情况：</p>
<ul>
<li>静态部分</li>
<li>实例部分</li>
</ul>
<h3 id="静态部分"><a href="#静态部分" class="headerlink" title="静态部分"></a>静态部分</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">h: number, m: number</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例部分"><a href="#实例部分" class="headerlink" title="实例部分"></a>实例部分</h3><p>实例部分和静态部分接口是不通用的，实例这块最大的问题是构造器签名这块。<br>那么什么是一个『构造器签名』呢？如下代码，这就是一个很常规的构造器签名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (hour: number, <span class="attr">minute</span>: number): ClockInterface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说它和静态类型不能公用接口的意思是，构造器签名在类中，是不可implementable的。如下代码，就会抛出错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (hour: number, <span class="attr">minute</span>: number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">ClockConstructor</span> </span>&#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">h: number, m: number</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，正常情况需要两个签名才能完整定义实例部分，整个环节简单的描述就是定义静态接口和构造器接口，然后新增一个类工厂用其传入构造器并返回实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (hour: number, <span class="attr">minute</span>: number): ClockInterface;</span><br><span class="line">&#125;</span><br><span class="line">interface ClockInterface &#123;</span><br><span class="line">    tick();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params">ctor: ClockConstructor, hour: number, minute: number</span>): <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DigitalClock</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">h: number, m: number</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="title">tick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;beep beep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> digital = createClock(DigitalClock, <span class="number">12</span>, <span class="number">17</span>);</span><br></pre></td></tr></table></figure>
<p>这里官方的例子还是看得比较明晰，静态类型、构造器签名、还有工厂类，各司其职。不过可能还是有些人不喜欢这种写法，毕竟添加一个工厂类，也是麻烦的一种。</p>
<p>此时，如果是在写npm包可以使用 d.ts 文件声明来处理这种情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">declare <span class="keyword">var</span> DigitalClock &#123;</span><br><span class="line">  <span class="keyword">new</span>(h: number, <span class="attr">m</span>: number): DigitalClock;</span><br><span class="line">  tick: ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不过思考之后觉得其实不使用构造器签名，其实问题也不大，因为构造器返回的还是构造好的实例，这个实例会依从静态类型那块的签名，传入的参数这里的类型校验是可以直接定义好的。</strong></p>
<h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">    color: string;</span><br><span class="line">&#125;</span><br><span class="line">interface PenStroke &#123;</span><br><span class="line">    penWidth: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">    sideLength: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>个人认为Typescript里面函数算是比较简单的一块。这里面需要注意的有:</p>
<ul>
<li>可选参数 &amp; 默认值</li>
<li>动态参数个数(剩余参数)</li>
<li>重载</li>
</ul>
<h2 id="可选参数-amp-默认值"><a href="#可选参数-amp-默认值" class="headerlink" title="可选参数 &amp; 默认值"></a>可选参数 &amp; 默认值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, lastName?: string</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, lastName = <span class="string">&quot;Smith&quot;</span></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>此时第一行的参数lastName是可选的，而第二行lastName设置了初始值”Smith”，同时它也是可选值。</p>
<h2 id="动态参数个数-剩余参数"><a href="#动态参数个数-剩余参数" class="headerlink" title="动态参数个数(剩余参数)"></a>动态参数个数(剩余参数)</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, ...restOfName: string[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + restOfName.join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>个人认为函数的重载实在很常见，尤其是非常流行的 lodash和 jQuery里面的api里面就重载得非常厉害。<br>举个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LngLat2Address</span>(<span class="params">x: string</span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LngLat2Address</span>(<span class="params">x: &#123;lng: number, lat: number&#125;</span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LngLat2Address</span>(<span class="params">x</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> address1 = LngLat2Address(<span class="string">&quot;113,23&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> address2 = LngLat2Address(&#123;<span class="attr">lng</span>: <span class="number">111</span>, <span class="attr">lat</span>: <span class="number">23</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>如上面这段代码，它同时接受字符串和对象形式的经纬度，并转换为地址(过程代码略)，返回类型固定为string(实际上也可以返回不同的类型)。</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型可以说是玩好TypeScript一个必须上的台阶。初步使用Ts时候不熟泛型也没啥问题，但是到了后面泛型其实也非常重要，因为它可以大大减少你重复自己的代码，减少写出重复的代码导致不好维护的问题。<br>简单的例子，比如常见的开发时候很多时候会请求一个列表展示，这里最简要的举个例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface User&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserList</span>(<span class="params">cb: (Users: User[]) =&gt; <span class="keyword">void</span> <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">&#x27;abc.com/api/users&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    success: （&#123;data&#125;: any）=&gt; &#123;</span><br><span class="line">      cb(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">interface Role&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  level: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRoleList</span>(<span class="params">cb: (Roles: Role[]) =&gt; <span class="keyword">void</span> <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">&#x27;abc.com/api/roles&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    success: （&#123;data&#125;: any）=&gt; &#123;</span><br><span class="line">      cb(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很常规的需求，请求用户和角色列表。这里除了User和Role内部数据不一样其他都是一样，那么有没有办法可以避免写出重复度如此高的代码呢？很显然，这是可以的，这里就是泛型的意义之所在(提高复用性，不要重复自己)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getList</span>&lt;<span class="title">T</span>&gt;(<span class="params">url: string, cb: (T[]) =&gt; <span class="keyword">void</span> <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url,</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    success: （&#123;data&#125;: any）=&gt; &#123;</span><br><span class="line">      cb(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时就可以直接使用 getUserList和 getRolesList</span></span><br><span class="line">getList&lt;User&gt;(<span class="string">&#x27;abc.com/api/users&#x27;</span>, <span class="function">(<span class="params">User[]</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;);</span><br><span class="line">getList&lt;Role&gt;(<span class="string">&#x27;abc.com/api/roles&#x27;</span>, <span class="function">(<span class="params">Role[]</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><p>文档上高级类型看起来有很多。。。不过我这边用到过的也不多。。。这里就按自己相对熟悉一些的记录一下。</p>
<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>常见是一个函数同时可以接受 number和 string形式的参数，那么此时除了给它设为any之外，另一个方案就是设置为联合类型:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params">s: number | string</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span> + s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><p>和联合类型很类似，不过交叉类型应该是对象形式的数据的联合。比如{a:1}, {b:2},的交叉，成为{a: 1, b: 2};<br>extend函数大家应该都用过，具体里面实现不表，它的定义应该是这样的，这就是一个非常典型的交叉类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型保护与区分类型"><a href="#类型保护与区分类型" class="headerlink" title="类型保护与区分类型"></a>类型保护与区分类型</h2><p>目前这个还没遇到过，不过觉得很有意思就记录一下，以便后面慢慢体会。<br>首先, 如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Bird &#123;</span><br><span class="line">    fly();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line">interface Fish &#123;</span><br><span class="line">    swim();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line">pet.layEggs(); <span class="comment">// okay</span></span><br><span class="line">pet.swim();    <span class="comment">// errors</span></span><br></pre></td></tr></table></figure>
<p>所以上面这段代码就会在ts编译阶段就抛错，但是从业务逻辑环节来讲，这显然是很不合理的。但是换ts编译器的角度来说，这个到底抛错不抛错，也确实是个问题。——所以这里有了类型保护这个东西。<br>为了让上面代码运行，加入一个类型断言</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"><span class="keyword">if</span> ((&lt;Fish&gt;pet).swim) &#123;</span><br><span class="line">    (&lt;Fish&gt;pet).swim();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (&lt;Bird&gt;pet).fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这里反复判断的比较多，那么就需要用到自定义类型保护了，这样方便重用代码和保持代码清洁(毕竟这种格式我个人觉得也是很难看)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isFish(pet)） &#123;</span><br><span class="line">    pet.swim();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有格式上的注意事项， pet is Fish是类型谓词，这里pet必须和签名里面参数的名称保持一致。</p>
<h2 id="Index-types-amp-amp-Mapped-types"><a href="#Index-types-amp-amp-Mapped-types" class="headerlink" title="Index types &amp;&amp; Mapped types"></a>Index types &amp;&amp; Mapped types</h2><p>这两个大概是我个人认为比较具有黑魔法的地方，可能是在javascript里面数组和对象承担了太多责任，所以对它们的约束太灵活多变导致的。</p>
<p>在这两个类型之间，个人私底下还是觉得可能是 <code>K extends keyof T</code> 和 <code>K in keyof T</code> 之间的区别</p>
<h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    location: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type P1 = keyof Person; <span class="comment">// &quot;name&quot; | &quot;age&quot; | &quot;location&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以看到keyof返回了一个联合类型 这个联合类型的值是Person的key的组合</p>
<h3 id="Index-types-amp-amp-extends-keyof"><a href="#Index-types-amp-amp-extends-keyof" class="headerlink" title="Index types &amp;&amp; extends keyof"></a>Index types &amp;&amp; extends keyof</h3><p>就<code>extends keyof</code>而言，可能官方例子的getProperty是一个非常好的理解途径</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, name: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o[name]; <span class="comment">// o[name] is of type T[K]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> name: string = getProperty(person, <span class="string">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这里<code>K extends keyof T</code>断言了T内部的一个键名,只有T内部有的属性,才能检查通过</p>
<h3 id="Mapped-types-amp-amp-in-keyof"><a href="#Mapped-types-amp-amp-in-keyof" class="headerlink" title="Mapped types &amp;&amp; in keyof"></a>Mapped types &amp;&amp; in keyof</h3><p>而<code>in keyof</code>呢，ts的es5标准库里面的Partial可能是一个非常好的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type Partial&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PersonPartial = Partial&lt;Person&gt;</span><br><span class="line"><span class="comment">// 相当于:</span></span><br><span class="line"><span class="comment">// interface Person &#123;</span></span><br><span class="line"><span class="comment">//     name?: string;</span></span><br><span class="line"><span class="comment">//     age?: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>这里<code>索引签名</code>和<code>in keyof</code>的配合就将Person整体遍历了一次, 返回了一个继承它的、新的属性名和选的接口。</p>
]]></content>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>ignite-note</title>
    <url>/2017/08/13/ignite-note/</url>
    <content><![CDATA[<h1 id="Ignite简介"><a href="#Ignite简介" class="headerlink" title="Ignite简介"></a>Ignite简介</h1><p>Ignite是一个基于ReactNative的手脚架和基础代码的生成工具, 使用它可以从0开始构建一个ReactNative的项目，并且可以为生成基础项目、为项目添加plugins，以及自动生成新页面和对应redux和相关sagas代码并自动插入到router等地方而不需要手动复制。</p>
<p>关于Ignite相关教程实际上早就想写一下，之前6月初通过Google搜索一直没有找到比较好用的step by step教程，然而到现在了暂时也还是没看到。索性我自己写一个吧。</p>
<h1 id="安装和命令行的使用一瞥"><a href="#安装和命令行的使用一瞥" class="headerlink" title="安装和命令行的使用一瞥"></a>安装和命令行的使用一瞥</h1><p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g ignite-cli</span><br></pre></td></tr></table></figure>
<p>初始化新项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ignite new PizzaApp</span><br></pre></td></tr></table></figure>
<p>添加和移除plugins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ignite add maps</span><br><span class="line">$ ignite add vector-icons</span><br><span class="line">$ ignite add i18n</span><br><span class="line">$ ignite remove i18n</span><br></pre></td></tr></table></figure>
<p>自动构建代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ignite generate screen PizzaLocationList</span><br><span class="line">$ ignite generate component PizzaLocation</span><br><span class="line">$ ignite generate map StoreLocator</span><br><span class="line">$ ignite generate redux home</span><br><span class="line">$ ignite generate saga home</span><br></pre></td></tr></table></figure>
<p>前面的可能只需要知道就可以了，但是ignite generate这个命令很值得一说，因为项目开发过程中使用它可以提高很多效率避免了很多手动copy过程。</p>
<ul>
<li>ignite generate screen 在App/Containers页面生成一个Container，这个相当于HTML里面的一个页面。</li>
<li>ignite generate component 在App/Components页面生成一个组件</li>
<li>ignite generate map 生成地图，这个暂时没用过</li>
<li>ignite generate redux 生成redux</li>
<li>ignite generate sagas 生成sagas</li>
</ul>
<p>其次是运行环境要求<br>ignite需要先配置好<a href="https://reactnative.cn/docs/0.48/getting-started.html#content">reactNative的运行环境</a>和node环境(node7.6+, 看文档8.0+有点小问题，所以最好还是用7.6+吧)。</p>
<h1 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h1><p>在用Ignite开始做项目之前我们需要先了解一下它的结构和运行机制。<br>我们先初始化一个Demo项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ignite new Demo</span><br><span class="line"></span><br><span class="line">🔥 igniting app Demo</span><br><span class="line">✔ using the Infinite Red boilerplate v2 (code name &#39;Andross&#39;)</span><br><span class="line">✔ added React Native 0.47.2 in 193.29s</span><br><span class="line">? Would you like Ignite Development Screens? No</span><br><span class="line">? What vector icon library will you use? react-native-vector-icons</span><br><span class="line">? What internationalization library will you use? none</span><br><span class="line">? What animation library will you use? react-native-animatable</span><br><span class="line">✔ added ignite-ir-boilerplate in 171.26s</span><br><span class="line">✔ added ignite-vector-icons in 29.13s</span><br><span class="line">✔ added ignite-animatable in 27.4s</span><br><span class="line">✔ added ignite-standard in 64.23s</span><br><span class="line">✔ configured git</span><br><span class="line">✔ ignited Demo in 604.97s</span><br></pre></td></tr></table></figure>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>先看看第一层目录，它是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── App</span><br><span class="line">├── README.md</span><br><span class="line">├── Tests</span><br><span class="line">├── android</span><br><span class="line">├── app.json</span><br><span class="line">├── ignite</span><br><span class="line">├── index.android.js</span><br><span class="line">├── index.ios.js</span><br><span class="line">├── ios</span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">├── storybook</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure>
<p>所有的业务逻辑大抵都在App里面，所以重点说App里面的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Components 组件</span><br><span class="line">│   ├── SearchBar.js</span><br><span class="line">│   └── Styles</span><br><span class="line">├── Config 配置</span><br><span class="line">│   ├── AppConfig.js</span><br><span class="line">│   ├── DebugConfig.js</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── ReactotronConfig.js</span><br><span class="line">│   ├── ReduxPersist.js</span><br><span class="line">│   └── index.js</span><br><span class="line">├── Containers 容器&amp;页面</span><br><span class="line">│   ├── App.js</span><br><span class="line">│   ├── LaunchScreen.js</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── RootContainer.js</span><br><span class="line">│   └── Styles</span><br><span class="line">├── Fixtures 数据mock的本地json</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── gantman.json</span><br><span class="line">│   ├── rateLimit.json</span><br><span class="line">│   ├── root.json</span><br><span class="line">│   └── skellock.json</span><br><span class="line">├── Images 图片</span><br><span class="line">├── Lib 库</span><br><span class="line">│   └── README.md</span><br><span class="line">├── Navigation 导航、router react-navigation</span><br><span class="line">│   ├── AppNavigation.js</span><br><span class="line">│   ├── ReduxNavigation.js</span><br><span class="line">│   └── Styles</span><br><span class="line">├── Redux</span><br><span class="line">│   ├── StartupRedux.js</span><br><span class="line">│   └── index.js</span><br><span class="line">├── Sagas</span><br><span class="line">│   ├── GithubSagas.js</span><br><span class="line">│   ├── StartupSagas.js</span><br><span class="line">│   └── index.js</span><br><span class="line">├── Services 服务 主要是ajax,数据mock，持久化相关的逻辑层</span><br><span class="line">│   ├── Api.js</span><br><span class="line">│   ├── ExamplesRegistry.js</span><br><span class="line">│   ├── FixtureApi.js</span><br><span class="line">│   ├── ImmutablePersistenceTransform.js</span><br><span class="line">│   └── RehydrationServices.js</span><br><span class="line">├── Themes 主题</span><br><span class="line">│   ├── ApplicationStyles.js</span><br><span class="line">│   ├── Colors.js</span><br><span class="line">│   └── index.js</span><br><span class="line">└── Transforms</span><br><span class="line">    ├── ConvertFromKelvin.js</span><br><span class="line">    └── README.md</span><br></pre></td></tr></table></figure>
<p>这里仅保留大致结构，很多文件对展示结构无关紧要就删掉了，实际上还有很多图片、组件等等。这里仅做原理的分析。<br>Ignite提供的框架做了很多工作，它提供的功能包括: 主题、国际化、redux、redux-sagas、数据本地模拟、数据持久化(redux-persist)、测试、Reactotron调试等等。</p>
<p>由于这是一片step by step的教程式的笔记，所以主要从使用的角度做分析，不做过于复杂的分析。这个结构实际上依然是MVC结构，其中M用Redux实现、V用react-native实现、C用Sagas实现。简单说，reactNative负责了页面，redux负责向页面传递数据，而sogas则负责业务逻辑并更改redux最终实现页面的变更。</p>
<h2 id="配置Ignite"><a href="#配置Ignite" class="headerlink" title="配置Ignite"></a>配置Ignite</h2><p>这里对一些前期需要知道的文件做简要介绍。</p>
<p>首先是Config/DebugConfig.js，任何程序编写过程都无法跳过debug环节，对一个新程序的编写也必然需要debug来查看内部数据变化，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*file:Config&#x2F;DebugConfig.js*&#x2F;</span><br><span class="line">useFixtures: true, &#x2F;&#x2F; 使用本地数据，这里设为true让我们可以在没有后端支持的情况实现数据mock</span><br><span class="line">ezLogin: false, &#x2F;&#x2F; 暂时还不知道这个ezlogin干嘛的</span><br><span class="line">yellowBox: __DEV__, &#x2F;&#x2F; 黄屏警告 开发模式默认打开</span><br><span class="line">reduxLogging: __DEV__, &#x2F;&#x2F; redux-logging当redux变更时打log 开发模式默认打开</span><br><span class="line">includeExamples: __DEV__, &#x2F;&#x2F; 载入初始的includeExamples 开发模式默认打开</span><br><span class="line">useReactotron: __DEV__ &#x2F;&#x2F; 使用useReactotron 开发模式默认打开</span><br></pre></td></tr></table></figure>
<p>这里我们打开useFixtures设为true即可。</p>
<h2 id="Ignite的Sagas"><a href="#Ignite的Sagas" class="headerlink" title="Ignite的Sagas"></a>Ignite的Sagas</h2><p>接下来是C层了解下这里怎么处理的。打开Sagas/index.js,里面的内容不算复杂。需要关注的代码就三行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">const api &#x3D; DebugConfig.useFixtures ? FixtureAPI : API.create()</span><br><span class="line">...</span><br><span class="line">takeLatest(StartupTypes.STARTUP, startup)</span><br><span class="line">takeLatest(GithubTypes.USER_REQUEST, getUserAvatar, api)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里注意到api变量, 这里是设置数据mock的关键地方, 当useFixtures设为true的时候使用FixtureAPI否则使用API.create(),这里api可以视为一个代理, 这也决定了FixtureAPI和API.create()实际上返回的数据具有相同的数据结构。</p>
<p>然后就是takeLatest这个辅助函数的事情了<br>Saga 辅助函数其实有两个,takeEvery也可以从import那里加上:</p>
<ul>
<li><strong>takeEvery</strong> :允许多个 fetchData实例同时启动。在某个特定时刻，我们可以启动一个新的 fetchData任务， 尽管之前还有一个或多个 fetchData尚未结束。我认为这个函数非常适合一次性从服务器拉取多个数据，然后放到redux保存备用。</li>
<li><strong>takeLatest</strong> :只允许执行一个 fetchData任务。并且这个任务是最后被启动的那个。 如果之前已经有一个任务在执行，那之前的这个任务会自动被取消。</li>
</ul>
<p>这里唯一需要说下的takeLatest参数问题了, takeLatest接受三个参数，第一个是ReduxAction, 第二个是这个ReduxAction触发的异步函数，第三个参数是可选的。当第三个参数存在，传入这个异步函数的第一个参数是传入的第三个实参，第二个是action, 如果不存在第一个就是action。就像这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function * startup (action) &#123;&#125;</span><br><span class="line">function * getUserAvatar (api, action) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这里再简单分析下数据获取的问题，参考Sagas/GithubSagas.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Sagas&#x2F;GithubSagas.js</span><br><span class="line">import &#123; call, put &#125; from &#39;redux-saga&#x2F;effects&#39;</span><br><span class="line">import &#123; path &#125; from &#39;ramda&#39;</span><br><span class="line">import GithubActions from &#39;..&#x2F;Redux&#x2F;GithubRedux&#39;</span><br><span class="line"></span><br><span class="line">export function * getUserAvatar (api, action) &#123;</span><br><span class="line">  const &#123; username &#125; &#x3D; action</span><br><span class="line">  &#x2F;&#x2F; make the call to the api</span><br><span class="line">  const response &#x3D; yield call(api.getUser, username)</span><br><span class="line"></span><br><span class="line">  if (response.ok) &#123;</span><br><span class="line">    const firstUser &#x3D; path([&#39;data&#39;, &#39;items&#39;], response)[0]</span><br><span class="line">    const avatar &#x3D; firstUser.avatar_url</span><br><span class="line">    &#x2F;&#x2F; do data conversion here if needed</span><br><span class="line">    yield put(GithubActions.userSuccess(avatar))</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    yield put(GithubActions.userFailure())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中action是之前的state数据, 后面的则是直接根据异步获取的数据执行对应redux的Action。<br>接下来看看api.getUser相关，这里是获取数据的方法，我们看看里面是如何获取数据的。上面说过，这里获取数据有两个地方，一个是真实的一个mock的，我们先看真实的数据获取。</p>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>真实的数据获取使用apisauce包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实例化</span><br><span class="line">const create &#x3D; (baseURL &#x3D; &#39;https:&#x2F;&#x2F;api.github.com&#x2F;&#39;) &#x3D;&gt; &#123;  </span><br><span class="line">  const api &#x3D; apisauce.create(&#123;</span><br><span class="line">    &#x2F;&#x2F; base URL is read from the &quot;constructor&quot;</span><br><span class="line">    baseURL,</span><br><span class="line">    &#x2F;&#x2F; here are some default headers</span><br><span class="line">    headers: &#123;</span><br><span class="line">      &#39;Cache-Control&#39;: &#39;no-cache&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 10 second timeout...</span><br><span class="line">    timeout: 10000</span><br><span class="line">  &#125;)</span><br><span class="line">  const getRate &#x3D; () &#x3D;&gt; api.get(&#39;rate_limit’)</span><br><span class="line">  return &#123;</span><br><span class="line">    getRate</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">  create</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是不算复杂的实例化，创建一个数据获取接口，设定了url， baseURL, httpHeader, 以及超时时间。<br>一些使用例子, 更多的例子可以直接查阅<a href="https://github.com/skellock/apisauce">apisauce文档</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const api &#x3D; create(&#123;baseURL: &#39;https:&#x2F;&#x2F;api.github.com&#39;&#125;)</span><br><span class="line">const api &#x3D; create(&#123;baseURL: &#39;https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;v3&#39;&#125;)</span><br><span class="line">const api &#x3D; create(&#123;</span><br><span class="line">  baseURL: &#39;...&#39;,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &#39;X-API-KEY&#39;: &#39;123&#39;,</span><br><span class="line">    &#39;X-MARKS-THE-SPOT&#39;: &#39;yarrrrr&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const api &#x3D; create(&#123;baseURL: &#39;...&#39;, timeout: 30000&#125;) &#x2F;&#x2F; 30 seconds</span><br><span class="line">api.get(&#39;&#x2F;repos&#x2F;skellock&#x2F;apisauce&#x2F;commits&#39;)</span><br><span class="line">api.head(&#39;&#x2F;me&#39;)</span><br><span class="line">api.delete(&#39;&#x2F;users&#x2F;69&#39;)</span><br><span class="line">api.post(&#39;&#x2F;todos&#39;, &#123;note: &#39;jump around&#39;&#125;, &#123;headers: &#123;&#39;x-ray&#39;: &#39;machine&#39;&#125;&#125;)</span><br><span class="line">api.patch(&#39;&#x2F;servers&#x2F;1&#39;, &#123;live: false&#125;)</span><br><span class="line">api.put(&#39;&#x2F;servers&#x2F;1&#39;, &#123;live: true&#125;)</span><br><span class="line">api.link(&#39;&#x2F;images&#x2F;my_dog.jpg&#39;, &#123;&#125;, &#123;headers: &#123;Link: &#39;&lt;http:&#x2F;&#x2F;example.com&#x2F;profiles&#x2F;joe&gt;; rel&#x3D;&quot;tag&quot;&#39;&#125;&#125;)</span><br><span class="line">api.unlink(&#39;&#x2F;images&#x2F;my_dog.jpg&#39;, &#123;&#125;, &#123;headers: &#123;Link: &#39;&lt;http:&#x2F;&#x2F;example.com&#x2F;profiles&#x2F;joe&gt;; rel&#x3D;&quot;tag&quot;&#39;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>而mock的就更简单了, 直接就是就是写死的对象，里面包含若干方法，返回写死的数据。</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>调试使用Reactotron, 为了使用它我们可以下载它的<a href="https://github.com/infinitered/reactotron/blob/master/docs/installing.md">客户端</a>,使用它不进可以直接console数据到面板，同时可以直接修改redux状态反馈到reactNative的UI层上。关于它的使用，在startup里面有几个例子，已经足够使用了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.tron.log(&#39;Hello, I\&#39;m an example of how to log via Reactotron.&#39;)</span><br><span class="line">console.tron.log(&#123;</span><br><span class="line">  message: &#39;pass objects for better logging&#39;,</span><br><span class="line">  someGeneratorFunction: selectAvatar</span><br><span class="line">&#125;)</span><br><span class="line">console.tron.display(&#123;</span><br><span class="line">  name: &#39;🔥 IGNITE 🔥&#39;,</span><br><span class="line">  preview: &#39;You should totally expand this&#39;,</span><br><span class="line">  value: &#123;</span><br><span class="line">    &#39;💃&#39;: &#39;Welcome to the future!&#39;,</span><br><span class="line">    subObject,</span><br><span class="line">    someInlineFunction: () &#x3D;&gt; true,</span><br><span class="line">    someGeneratorFunction: startup,</span><br><span class="line">    someNormalFunction: selectAvatar</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="简单写个Demo-App"><a href="#简单写个Demo-App" class="headerlink" title="简单写个Demo App"></a>简单写个Demo App</h1><h2 id="LaunchScreen"><a href="#LaunchScreen" class="headerlink" title="LaunchScreen"></a>LaunchScreen</h2><p>正常app启动是这样的splash页面-&gt;LaunchPage(常见的就是滑屏简介)-&gt;主页。splash页面比较折腾，而且在很多博客都有说道，这里我们开始写一个LaunchPage页面作为开始。<br>首先我找了3个图片。放到了Images/目录备用 分别命名为launch1.png、launch2.png、launch3.png(仅项目展示使用，版权归作者所有-虽然我也不知道版权是谁的。。。)，然后安装swiper组件 <code>npm i react-native-swiper --save</code></p>
<p>最后修改一下LaunchScreen.js和最后修改一下LaunchScreenStyle.js</p>
<script src="https://gist.github.com/que01/bf1313201f202bd9e788c8e226d65e5f.js"></script>

<p>如上, 这样我们的LaunchScreen页面就算写好了。这里唯一需要写的就是flex布局问题。我在这里留了文本的位置，如果不需要完全可以删除只显示图片。</p>
<h2 id="基本页面"><a href="#基本页面" class="headerlink" title="基本页面"></a>基本页面</h2><p>这里打算做3个基本页面 Home OrderList MeInfo<br>Home页面这里来实践一把数据对接。不过在这之前我们需要先建立页面，然后处理一下导航, 使LaunchScreen可以跳到Home页面。</p>
<p>建立页面并处理redux和sagas</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ignite generate screen home</span><br><span class="line">ignite generate redux home</span><br><span class="line">ignite generate saga home</span><br></pre></td></tr></table></figure>
<p>这样，相关文件建立就结束了。接下来处理导航。常规的导航，实际上可以直接 <code>this.props.navigation.navigate('HomeScreen')</code>,不过这样的问题是返回会返回到LaunchScreen，这样就很不合理了。所以做些简要处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; NavigationActions &#125; from &#39;react-navigation&#39;</span><br><span class="line"></span><br><span class="line">const resetAction &#x3D; NavigationActions.reset(&#123;</span><br><span class="line">  index: 0,</span><br><span class="line">  actions: [</span><br><span class="line">    NavigationActions.navigate(&#123; routeName: &#39;HomeScreen&#39;&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 执行: this.props.navigation.dispatch(resetAction)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样，我们就可以跳转到HomeScreen了，不过现在HomeScreen只有孤零零的’HomeScreen’字样。我们先加一下导航条。</p>
<p>处理一下AppNavigation.js<br>主要是3个地方的修改：</p>
<ol>
<li>引入react 和 Icon组件</li>
<li>将headerMode改成screen</li>
<li>修改navigationOptions<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">navigationOptions: (&#123;navigation&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  let &#123;goBack, navigate&#125; &#x3D; navigation;</span><br><span class="line">  return &#123;</span><br><span class="line">    headerStyle: styles.header,</span><br><span class="line">    headerTitleStyle: styles.headerTitleStyle,</span><br><span class="line">    headerLeft: &lt;Icon name&#x3D;&quot;chevron-left&quot; onPress&#x3D;&#123;()&#x3D;&gt;&#123;goBack()&#125;&#125; size&#x3D;&#123;24&#125; color&#x3D;&quot;#fff&quot; style&#x3D;&#123;&#123;marginLeft: 20&#125;&#125; &#x2F;&gt;,</span><br><span class="line">    headerRight: &lt;Icon name&#x3D;&quot;home&quot; onPress&#x3D;&#123;()&#x3D;&gt;&#123;navigate(&#39;HomeScreen&#39;)&#125;&#125; size&#x3D;&#123;24&#125; color&#x3D;&quot;#fff&quot; style&#x3D;&#123;&#123;marginRight: 20&#125;&#125; &#x2F;&gt;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这样，加上headerTitleStyle样式后，此时app就可以显示顶部导航条了。<br>现在项目是这样的<br><img src="/images/reactnative-swiper.gif"><br>接下来我们给它加一个Tabbar：<code>ignite generate component TabBar</code><br>关于这个Tabbar我们使用react-native-tabs来做——当然，即使自己做一个这个也不算复杂，不过这里为了方便尽量都用现有的组件。<br>tabbar.js的主要代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onSelect (el) &#123;</span><br><span class="line">  if (el.props.name &#x3D;&#x3D;&#x3D; this.state.page) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.setState(&#123;page: el.props.name&#125;)</span><br><span class="line">    console.tron.log(el.props.name)</span><br><span class="line">    this.props.navTo(el.props.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">render () &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Tabs selected&#x3D;&#123;this.state.page&#125; style&#x3D;&#123;&#123; backgroundColor: &#39;white&#39; &#125;&#125; selectedStyle&#x3D;&#123;&#123; color: &#39;#4F8EF7&#39; &#125;&#125; onSelect&#x3D;&#123;this.onSelect.bind(this)&#125;&gt;</span><br><span class="line">      &lt;Text name&#x3D;&#39;HomeScreen&#39; style&#x3D;&#123;styles.textAlignCenter&#125; selectedIconStyle&#x3D;&#123;TabStyles&#125;&gt;</span><br><span class="line">        &lt;Icon name&#x3D;&#39;ios-book-outline&#39; size&#x3D;&#123;30&#125; color&#x3D;&#39;#000&#39; &#x2F;&gt;&#123;&#39;\n&#39;&#125;首页</span><br><span class="line">      &lt;&#x2F;Text&gt;</span><br><span class="line">      &lt;Text name&#x3D;&#39;OrderListScreen&#39; style&#x3D;&#123;styles.textAlignCenter&#125; selectedIconStyle&#x3D;&#123;TabStyles&#125;&gt;</span><br><span class="line">        &lt;Icon name&#x3D;&#39;ios-paper-outline&#39; size&#x3D;&#123;30&#125; color&#x3D;&#39;#000&#39; &#x2F;&gt;&#123;&#39;\n&#39;&#125;订单</span><br><span class="line">      &lt;&#x2F;Text&gt;</span><br><span class="line">      &lt;Text name&#x3D;&#39;MeInfoScreen&#39; style&#x3D;&#123;styles.textAlignCenter&#125; selectedIconStyle&#x3D;&#123;TabStyles&#125;&gt;</span><br><span class="line">        &lt;Icon name&#x3D;&#39;ios-person-outline&#39; size&#x3D;&#123;30&#125; color&#x3D;&#39;#000&#39; &#x2F;&gt;&#123;&#39;\n&#39;&#125;我的</span><br><span class="line">      &lt;&#x2F;Text&gt;</span><br><span class="line">    &lt;&#x2F;Tabs&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>为了达到切换效果，我们再加两个Screen：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ignite generate screen orderList</span><br><span class="line">ignite generate screen meInfo</span><br></pre></td></tr></table></figure>
<p>并为这两个页面添加Tabbar等操作(实际上可以直接单页tab切换，不过此处暂时不考虑那么多)，做好之后(具体代码可以直接爬git的提交记录)，现在tab切换是这样的：<br><img src="/images/reac-native-tabs.gif"></p>
<h2 id="数据对接"><a href="#数据对接" class="headerlink" title="数据对接"></a>数据对接</h2><p>简单完善下Home, 我们来做个非常普遍的2行4列图标，效果图是这样<br><img src="/images/react-native-home.png"><br>这里主要就是flex布局，所以怎么布局这里不做讲解，只是贴出一下代码方便说数据对接这块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const menus &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &#39;美食1&#39;,</span><br><span class="line">    &quot;icon&quot;: &#39;https:&#x2F;&#x2F;img.la&#x2F;333&#x2F;fff&#x2F;60x60&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br><span class="line">&lt;View style&#x3D;&#123;styles.menuItemWrapper&#125;&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    menus.map((&#123;name, icon&#125;,i)&#x3D;&gt;(</span><br><span class="line">      &lt;TouchableOpacity style&#x3D;&#123;styles.menuItem&#125; key&#x3D;&#123;&#96;icon-$&#123;i&#125;&#96;&#125;&gt;</span><br><span class="line">        &lt;Image source&#x3D;&#123;&#123;uri: icon&#125;&#125; style&#x3D;&#123;styles.menuItemIcon&#125;&#x2F;&gt;</span><br><span class="line">        &lt;Text&gt;&#123;name&#125;&lt;&#x2F;Text&gt;</span><br><span class="line">      &lt;&#x2F;TouchableOpacity&gt;</span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>

<p>假设最终接口返回数据格式是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  code: 200,</span><br><span class="line">  message: &#39;success&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    menus: [&#123;name: &quot;xxx&quot;, icon: &quot;xxx&quot;&#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改sagas/HomeSages.js， 将 <code>response.ok</code> 改成 <code>+response.code === 200</code>, 添加Fixtrues/home.json文件，内部填写上面的数据结构。这里因为没有后端所以直接mock本地数据，修改完毕后，更改Services/FixtrueApi.js<br>添加gethome函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gethome: (data) &#x3D;&gt; &#123;</span><br><span class="line">  const initData &#x3D; require(&#39;..&#x2F;Fixtures&#x2F;home.json&#39;)</span><br><span class="line">  return &#123;...initData&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据数据结构完善一下HomeRedux.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; Types, Creators &#125; &#x3D; createActions(&#123;</span><br><span class="line">  ...</span><br><span class="line">  homeSuccess: [&#39;data&#39;], &#x2F;&#x2F; 默认是payload</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; successful api lookup</span><br><span class="line">export const success &#x3D; (state, action) &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; data &#125; &#x3D; action &#x2F;&#x2F; 默认是payload</span><br><span class="line">  return state.merge(&#123; fetching: false, error: null, data &#125;) &#x2F;&#x2F; 默认是payload</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>注册sagas(mapDispatchToProps需要), 修改sagas/index.js文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* ------------- Types ------------- *&#x2F;</span><br><span class="line">import &#123; HomeTypes&#125; from &#39;..&#x2F;Redux&#x2F;HomeRedux&#39;</span><br><span class="line">&#x2F;* ------------- Sagas ------------- *&#x2F;</span><br><span class="line">import &#123; getHome &#125; from &#39;.&#x2F;HomeSagas&#39;</span><br><span class="line">&#x2F;* ------------- Connect Types To Sagas ------------- *&#x2F;</span><br><span class="line">takeLatest(HomeTypes.HOME_REQUEST, getHome, api)</span><br></pre></td></tr></table></figure>
<p>注册Redux(mapStateToProps需要), 修改redux/index.j文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const rootReducer &#x3D; combineReducers(&#123;</span><br><span class="line">  nav: require(&#39;.&#x2F;NavigationRedux&#39;).reducer,</span><br><span class="line">  github: require(&#39;.&#x2F;GithubRedux&#39;).reducer,</span><br><span class="line">  search: require(&#39;.&#x2F;SearchRedux&#39;).reducer,</span><br><span class="line">  homeInitData: require(&#39;.&#x2F;HomeRedux&#39;).reducer,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>引入homeRedux，并更新HomeScreen页面mapStateToProps和mapDispatchToProps，并在componentDidMount内部执行获取数据的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import homeAction from &#39;..&#x2F;Redux&#x2F;HomeRedux&#39;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">componentDidMount () &#123;</span><br><span class="line">  this.props.fetchData()</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">const mapStateToProps &#x3D; (&#123;homeInitData&#125;) &#x3D;&gt; &#123; &#x2F;&#x2F; 这个在redux那里定义</span><br><span class="line">  return &#123;</span><br><span class="line">    initData: homeInitData.data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps &#x3D; (dispatch) &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    fetchData: () &#x3D;&gt; dispatch(homeAction.homeRequest())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，将HomeScreen内部写死的menus删除，并将menus.map设为this.props.initData.menus.map, 这个流程就算结束了。</p>
<p>当然，如果有线上的服务器，不要忘记最后联调阶段，需要关闭useFixtures选项，并在Services/Api.js里面填充对应的逻辑，例如此处，需要在这里加gethome函数并返回指定的数据。</p>
<p>最后的成品截图<br><img src="/images/react-native-demo.gif"></p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>到这里Ignite最基础的使用已经完毕了，作为入门我个人认为已经足够。项目代码我已传至<a href="https://github.com/que01/reactNativeDemo">Github</a>,如果有需要可以自行检出取用。</p>
]]></content>
      <tags>
        <tag>reactNative</tag>
      </tags>
  </entry>
  <entry>
    <title>js框架读书笔记和思考(一)</title>
    <url>/2017/02/20/framework1/</url>
    <content><![CDATA[<h1 id="在最前"><a href="#在最前" class="headerlink" title="在最前"></a>在最前</h1><br>
I dreamed a dream in time gone by,
When hope was high.
And life worth living,
I dreamed that love would never die.
...

<p>我相信程序员都会有一个框架的梦, 这个梦无论出于怎样原因最终搁浅也好，放弃也好, 半途而废也罢。但是便如歌词里面的那句: I dreamed a dream in time gone by.此刻迷梦正甜，起码要些许努力。这是一堆读书笔记里面的第一篇。to:《Javascript框架设计·司徒正美》</p>
<p>我曾错过那些刀耕火种的年代，错过了亲手去抚摸体会那些浏览器兼容的痛苦的年代，但是，这也是最好的年代, 入行时候有jQuery带路跳过那些坑逼兼容, 想学MVC时候有架构清晰的backbone，想做工程化时候有gulp，想玩模块化的时候webpack横空出世，想数据驱动UI时候angularJS风靡，想组件化时候vue、react生态渐丰。</p>
<p>但是还是错过了很多的感觉，所以有了这些文章，司徒正美的这本书早些时候买的时候没有过重视，因为老是觉得不够清晰，那时候痴迷于猫头鹰那本动物书，大抵有种迷信的感觉。回过头来看看，内容其实真没有辜负书名。</p>
<h1 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h1><ul>
<li>种子模块</li>
<li>模块加载系统</li>
<li>语言模块</li>
<li>浏览器探嗅与特征侦测</li>
<li>类工厂</li>
<li>选择器引擎</li>
<li>节点模块</li>
<li>数据缓存系统</li>
<li>样式模块</li>
<li>属性模块</li>
<li>事件系统</li>
<li>异步处理</li>
<li>数据交互模块</li>
<li>动画引擎</li>
<li>插件化</li>
<li>MVVM</li>
</ul>
<h1 id="种子模块"><a href="#种子模块" class="headerlink" title="种子模块"></a>种子模块</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>  《Javascript框架设计》中提到了很多库,Prototype,mootools,Base2,YUI,dojo,Mochikit,jQuery等，不过大抵由于年代久远，个人听过的仅限Prototype,mootools,YUI和dojo——并且一个都没有用过(当然,不算jQuery)。</p>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>命名空间的选择大致上存在两种选择:</p>
<ul>
<li>一种是直接扩展(污染或者覆写)全局变量或者方法,</li>
<li>而另外一种是使用定义一个全局变量(类型多是对象),以它为根逐步拓展为整个框架或者库。</li>
</ul>
<p>文中提到一个之前没有考虑过的说法是jQuery另辟蹊径,使用了函数作为命名空间，这点就突然让我有点惊讶，因为突然想起基本从业以来似乎读过源码的框架比如jQuery,backbone似乎都是构造函数作为命名空间。</p>
<p>所以赶紧去看了看YUI的命名空间——记忆里YUI是<code>YUI()</code>开头的。<br>下面代码来自YUI的 <a href="https://github.com/yui/yui3/wiki/Quick-Start">Quick Start</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// Create a YUI sandbox on your page.</span></span><br><span class="line">  YUI().use(<span class="string">&#x27;node&#x27;</span>, <span class="string">&#x27;event&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">Y</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// The Node and Event modules are loaded and ready to use.</span></span><br><span class="line">      <span class="comment">// Your code goes here!</span></span><br><span class="line">  &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>——很显然YUI3已经和jQuery一个套路是函数了。<br>不甘心又跑去看YUI2的代码了。打开核心的js文件 <a href="https://github.com/yui/yui2/blob/master/src/yahoo/js/YAHOO.js">YAHOO.js</a>,头部的注释似乎像我说了很多事:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The YAHOO object is the single global object used by YUI Library.  It</span></span><br><span class="line"><span class="comment"> * contains utility function for setting up namespaces, inheritance, and</span></span><br><span class="line"><span class="comment"> * logging.  YAHOO.util, YAHOO.widget, and YAHOO.example are namespaces</span></span><br><span class="line"><span class="comment"> * created automatically for and used by the library.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@module <span class="variable">yahoo</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title  </span>YAHOO Global</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>看着YUI2文档上的那句:</p>
<blockquote class="blockquote-center"><p>YUI 2 has been deprecated as of 2011. This site acts as an archive for files and documentation.</p>
</blockquote>
<p>它似乎在向我说那些错过的岁月。</p>
<p>——所以说司徒正美到底没说错，YUI的命名空间确实是个对象,唯一错的,是这个这个时间。</p>
<h3 id="冲突处理noConflict"><a href="#冲突处理noConflict" class="headerlink" title="冲突处理noConflict"></a>冲突处理noConflict</h3><p>大抵是jQuery教会了我设计框架时候得有一个函数叫做noConflict。<br>跑去jquery代码里面扒出来这个。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map over jQuery in case of overwrite</span></span><br><span class="line">_jQuery = <span class="built_in">window</span>.jQuery,</span><br><span class="line"><span class="comment">// Map over the $ in case of overwrite</span></span><br><span class="line">_$ = <span class="built_in">window</span>.$;</span><br><span class="line">jQuery.noConflict = <span class="function"><span class="keyword">function</span>(<span class="params"> deep </span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( <span class="built_in">window</span>.$ === jQuery ) &#123;</span><br><span class="line">		<span class="built_in">window</span>.$ = _$;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( deep &amp;&amp; <span class="built_in">window</span>.jQuery === jQuery ) &#123;</span><br><span class="line">		<span class="built_in">window</span>.jQuery = _jQuery;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> jQuery;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很显然,noConflict作用有三种:</p>
<ul>
<li>deep空着只清除$保留jQuery</li>
<li>deep传true清除jQuery和$</li>
<li>返回jQuery构造函数以便用户赋值给变量</li>
</ul>
<p>思路说出来其实就容易理解得多了。</p>
<h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><p>对象扩展个人用过最常见的是$.extend();<br>如书上所说，最简单的extend代码是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">dest,source</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> property <span class="keyword">in</span> source)&#123;</span><br><span class="line">    dest[property] = source[property]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是文中也谈到了for…in遍历原型的兼容问题。这里也记录一下相关for…in遍历原型的原因。<br>for…in会遍历所有可枚举的属性(除非该属性名是一个 Symbol)。<br>|-&gt;可枚举属性是指那些内部 “可枚举([[Enumerable]])” 标志设置为true的属性<br>|--&gt;对于通过直接的赋值和属性初始化的属性，该标识值默认为即为true，对于通过Object.defineProperty等定义的属性，该标识值默认为false。</p>
<p>extend方法实现基础原理就是上面最简陋版本的加强版——允许合并、是否覆写同名属性&amp;深拷贝。</p>
<h2 id="数组化"><a href="#数组化" class="headerlink" title="数组化"></a>数组化</h2><p>数组化函数存在的意义是存在很多类数组对象，它们很像是数组，但是却不能使用数组相对完善的api，这个是一个很大的遗憾。<br>常见的有:</p>
<ul>
<li>function内部的arguments</li>
<li>document.forms</li>
<li>from.elements</li>
<li>document.links</li>
<li>slect.options</li>
<li>document.getElementByName</li>
<li>docuemnt.getElementByTagName</li>
<li>childNodes</li>
<li>children</li>
</ul>
<p>最常见的转换方式是Array.prototype.slice.apply(obj)。不过书中提及这里存在的旧版IE的兼容问题是HTMLCollection、NodeList不是Object的子类所以就没法用Array.prototype.slice.apply(obj)了。</p>
<p>作者举了很多例子展示诸多框架在这里的实现。核心的思想其实就一个: 创建类数组等长度的数组，递减类数组的length并赋值类数组值到真数组上，最后返回这个真实的数组。<br>根据这个思路我自己写个最简单的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeArray</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = array.length,arr = <span class="keyword">new</span> <span class="built_in">Array</span>(length);</span><br><span class="line">  <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">    arr[length] = array[length];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型的判定"><a href="#类型的判定" class="headerlink" title="类型的判定"></a>类型的判定</h2><p>Javascript有7种数据类型:string,number,boolean,undefined,null,symbol,object;其中前面6中是简单类型,object是复杂类型。<br>简单类型是可以通过typeof来判断的。<br>书上说了很多typeof在低版本浏览器下的bug存在，但是个人认为这里需要注意暂时是两个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">&#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">&#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后是isNaN存在文中所说到的，字符串和ojbect它也会返回true。不过,在我使用的Chrome 55.0.2883.75 (64-bit)上,isNaN已经修复传入字符串返回true的问题。</p>
<p>isXXX系列函数有太多奇技淫巧的感觉。个人觉得有必要了解熟记常用的，但是如果如果可以背下常见的isXXX函数其实会使代码更加健壮。<br>但是出于简单便于记忆来说，type函数是最简单可靠的——如果它不遇到旧浏览器各种历史bug的话。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>,-<span class="number">1</span>).toLowerCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="domReady"><a href="#domReady" class="headerlink" title="domReady"></a>domReady</h2><p><a href="https://github.com/ded/domready">domready</a>,就这一个地址吧，domReady，简直就是一个代码的hack集合…</p>
<h1 id="模块加载系统"><a href="#模块加载系统" class="headerlink" title="模块加载系统"></a>模块加载系统</h1><p>模块加载系统是一个成体系的库所必须要具备的。目前来说市面上常见的模块规范有AMD,CMD,CommonJS,UMD。其中,CMD是seaJs的模块规范，其作者玉伯也说是时候给他一个树墓碑了，而UMD其实就是AMD+CommonJS+Golbal全局的兼容方案。所以就目前来说，如果不是打算新建立一个自己的规范，那么只需要考虑AMD和CommonJS就够了。</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD是异步加载模块的意思，最出名的实现就是requireJS。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模块开发</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * id       模块id</span></span><br><span class="line"><span class="comment"> * deps     依赖模块数组</span></span><br><span class="line"><span class="comment"> * callback 模块定义它包含若干参数，和deps里面的顺序一致</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">define(id, deps, callback)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块引用</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deps 依赖数组</span></span><br><span class="line"><span class="comment"> * callback 业务逻辑 它包含若干参数，依次对应deps中的依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">require</span>(deps, callback)</span><br></pre></td></tr></table></figure>
<p>上面那个只有用法也不太好理解，下面是在网上找到一个简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="string">&#x27;myModule&#x27;</span>,</span><br><span class="line">    [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">    <span class="comment">// 模块定义函数</span></span><br><span class="line">    <span class="comment">// 依赖项（foo 和 bar）被映射为函数的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"> foo, bar </span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 返回一个定义了模块导出接口的值</span></span><br><span class="line">        <span class="comment">// （也就是我们想要导出后进行调用的功能）</span></span><br><span class="line">        <span class="comment">// 在这里创建模块</span></span><br><span class="line">        <span class="keyword">var</span> myModule = &#123;</span><br><span class="line">            doStuff:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;Yay! Stuff&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myModule;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 假设 &#x27;foo&#x27; 和 &#x27;bar&#x27; 是两个外部模块</span></span><br><span class="line"><span class="comment">// 在本例中，这两个模块被加载后的 &#x27;exports&#x27; 被当做两个参数传递到了回调函数中</span></span><br><span class="line"><span class="comment">// 所以可以像这样来访问他们</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params"> foo, bar </span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这里写其余的代码</span></span><br><span class="line">        foo.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>根据这里的初步使用和逻辑，我们尝试对AMD加载器做一些实现上的考虑。</p>
<p>  <del>1. 模块加载器的目标是js，如果扩展一下还可以扩展到css,当异步获取资源时候必须考虑到js和css很有可能是它站资源，所以不能用ajax(这是书中观点，不过个人窃以为如果约定只能载入自己的资源或者兼容ajax和script标签也挺好)。</del><br>  <del>2. 以js为例，实现过程中应该使用动态插入script标签的办法来处理相关js资源</del><br>  <del>3. src要求获取资源的路径，所以需要一个获取实际路径的方法。</del></p>
<p><span style="color: red">宏观方面：</span><br>  需要初步理清 require 和 define 到底是怎么里应外合的。如果这样说不够明晰那么先理出以下 API 思路上的东西再深入</p>
<ol>
<li><p>首先使用define写一个模块，如上文的那个简单的myModule模块依赖了foo、bar，然后是模块的主体函数(函数是最重要的场景因此这里姑且认为一定是函数)。</p>
</li>
<li><p>然后是require, 它接受deps数组，然后执行调用。它是 AMD 加载器的核心——模块的载入的各种细节都是在这里处理，载入成功后的操作也是在这里执行。</p>
</li>
<li><p>那么现在可以思考: 当 require 载入了 js 模块文件(define包裹的)，并开始执行define函数(这个函数不管怎样一定是挂在 window 下的全局函数)，内部会怎样处理这些参数呢？</p>
<p>反复看require 和 define 的API 设计，是否可以看到它们惊人的相像？是的，其实它们就是这样设计起来的: require是核心，它处理了90%的模块加载细节和一堆乱糟糟的东西——<strong>总之，你只需要知道它能把依赖处理好并执行你的后续代码即可</strong>。而define则是助攻，它接受的参数核心里面包括 deps依赖和模块主体，实际上它基本上最核心的只是把自己接受的参数根据情况略作修改传给了 require 而已——干活的还是 require。<strong>一句话说明define和require的关系: define其实是个光杆司令，require是那个唯一的小兵, 活儿来了之后define略作批示然后活儿还是派require去干去了。</strong>(当然，如果不使用匿名模块，而是定义了模块id的话，实际上 require 也调用到了 define)</p>
</li>
</ol>
<p><span style="color: red">微观方面：</span></p>
<ol>
<li>模块加载器的目标是js，如果扩展一下还可以扩展到css,当异步获取资源时候必须考虑到js和css很有可能是它站资源，所以不能用ajax(这是书中观点，不过个人窃以为如果约定只能载入自己的资源或者兼容ajax和script标签也挺好)。</li>
<li>以js为例，实现过程中应该使用动态插入script标签的办法来处理相关js资源</li>
<li>src要求获取资源的路径，所以需要一个获取实际路径的方法。</li>
</ol>
<p>等等这些，暂时就按书中思路来吧。</p>
<h2 id="实现一个加载器的技术细节"><a href="#实现一个加载器的技术细节" class="headerlink" title="实现一个加载器的技术细节"></a>实现一个加载器的技术细节</h2><h3 id="获取basePath"><a href="#获取basePath" class="headerlink" title="获取basePath"></a>获取basePath</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBasePath</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nodes = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;script&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.VBArray)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,node;node=nodes[i++];)&#123;</span><br><span class="line">      <span class="keyword">if</span>(node.readyState === <span class="string">&#x27;interactive&#x27;</span>)&#123; <span class="keyword">break</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    node = nodes[nodes.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> src = <span class="built_in">document</span>.querySelector ? node.src : node.getAttribute(<span class="string">&quot;src&quot;</span>, <span class="number">4</span>)</span><br><span class="line">  <span class="keyword">return</span> src.replace(<span class="regexp">/[?#].*/</span>, <span class="string">&quot;&quot;</span>).slice(<span class="number">0</span>,src.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要思路:</p>
<ul>
<li>加载器应该是最后一个script标签所在的文件,所以获取nodes[nodes.length - 1]</li>
<li>如果是现代浏览器返回node.src,否则使用node.getAttribute(“src”, 4)获取src</li>
</ul>
<p>这段代码主要是兼容上不太好理解。诸如VBArray、readyState、getAttribute第二个参数个人从没用过。。。这里记录一下相关知识点</p>
<ol>
<li><p>VBArray用来判断IE可以理解</p>
</li>
<li><p>readyState:<a href="https://social.msdn.microsoft.com/Search/en-US?query=readyState&pgArea=header&emptyWatermark=true&ac=4">微软私有属性</a>可以查看资源加载情况(document.image,xhr,script等有这个属性)。</p>
<p>它有五种取值:<br> uninitialized 默认状态<br> loading 下载开始<br> loaded 下载完成<br> interactive 下载完成但尚不可用<br> complete 所有数据已经准备好</p>
</li>
<li><p>getAttribute在ie里面有些棘手，IE7以及之前的版本版本接受两个参数。下面是第二个参数:</p>
</li>
</ol>
<ul>
<li>0，默认值，特性名称大小写不敏感，并根据需要转化特性值（例如把href转成完整的URL）。</li>
<li>1，特性名称大小写敏感。</li>
<li>2，返回特性值的字符串值，即不做任何转换。</li>
<li>4，返回完整的URL对象，仅针对返回URL的特性，如href、background等。</li>
</ul>
<h3 id="require函数细节"><a href="#require函数细节" class="headerlink" title="require函数细节"></a>require函数细节</h3><p>首先需要明确require作用: 它的作用最直接点说，是<b>载入模块并执行指定回调</b>。<br>看书之前个人想的require在使用用法上的主要是3块：</p>
<ul>
<li>获取每个模块的src路径</li>
<li>插入script标签并监控加载状况+缓存js+使用闭包将每个js隔离</li>
<li>执行callback回调<br>不过看完相关总结，发现自己漏掉了重要的一环就是require需要分析依赖文件队列，然后判断是不是要script引入。进一步说，require函数会分析整个模块的依赖树。</li>
</ul>
<p>现在构建一下require函数的实现需求,无非4点:</p>
<blockquote>
<p>获得文件路径 -&gt; 分析依赖&amp;判断是否载入 -&gt; 载入 -&gt; 执行回调</p>
</blockquote>
<p>当然，如果真的去实现一个可用的加载器不是一件简单的事情。依赖树的处理，js的加载，以及各种牵一发动全身的东西，关于实践我将会在后面补上。但是从整体上思考全局，这就是require的要点了。</p>
<h3 id="define函数细节"><a href="#define函数细节" class="headerlink" title="define函数细节"></a>define函数细节</h3><p><del>如果说require是调用模块用的，那么define就是响应这个调用的「内鬼」。<br>关于这个函数的调用个人从书籍上看了好一会细节，不过所获不多。个人考虑到的是这个函数和对应的require其实是钥匙与锁的关系，大抵只有深入去了解require函数的细节后，才会对define的细节有深入的理解。<br>这里等待补充作业&amp;细节。</del></p>
<p>看了下 define 的源码，理清了它和 require 的关系，在宏观分析上做了分析，所以这里就主要说细节上的东西。</p>
]]></content>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>bye-bye-2016</title>
    <url>/2016/12/31/bye-bye-2016/</url>
    <content><![CDATA[<h1 id="The-Begin"><a href="#The-Begin" class="headerlink" title="The Begin"></a>The Begin</h1><br>
新年的钟声又将敲响了。
早在14年时候，那时候我就总觉得是不是到17了？那时候想想其实觉得自己太可笑，怎么会有如此荒缪的错觉。

<p>时间此刻有一种仿徨的感觉。<br>想起14年那个冬天。那年冬天在武汉到处跑着面试，屡屡受挫。那时候大抵真怀疑过方向，光谷那边一个大厦挂着招开发的皮在那里招往QQ发贵金属交易的面试我居然耐心等他说完。</p>
<p>后来在不满500米地方找到工作时候，顿觉这个世界真的是很小，你拒绝这里，说不准，就是那里——大抵是你在这里，便也只是能在这里。</p>
<p>所以后来又决定离开武汉往外面去看看。</p>
<p>5月30的硬卧——那是我辈子我第一次坐火车。离开武汉前往深圳,一路GPS看现在在哪儿哪儿。</p>
<p>6.1当天8点20到的罗湖，晚点20分钟。在堂哥家里坐下的时候，瓢泼的大雨，让我知道这里已经不是武汉。</p>
<p>武汉带来的周黑鸭和车厘子，被堂哥的女儿小茉不客气的霸占，然而这小家伙如此的怕生——城市长大的孩子，是不是一直是这样的孤独&amp;缺乏安全？</p>
<p>现在想想，有些可惜那盒车厘子。感谢5.30时候，小默你那天来送我上火车。人群里的身影娇小，进站那须臾，就看不着身影了。</p>
<p>你说，本来还有一瓶优益C，可惜买水果时候忘在水果摊了。大抵那时候你是喜欢优益C的。再后来，我问你要不要优益C时候，你和我说，要纯甄。</p>
<p>优益C后来我专门跑去买过一瓶，那口感，确实不怎么给力。</p>
<p>有感于在学校那会儿的物质贫匮，有感于在学校那会儿的诚挚。</p>
<p>当然， And You。</p>
<p>你说，这凡尘，仿徨、怀疑、诚挚、变幻，诸多情感，是不是很无味很无聊？然而幸好还有这回忆，让彼此有勇气走向更远。</p>
<blockquote class="blockquote-center"><p>少无适俗韵，性本爱丘山。<br>误入尘网中，一去三十年。</p>
</blockquote>

<h1 id="The-Halfway"><a href="#The-Halfway" class="headerlink" title="The Halfway"></a>The Halfway</h1><br>
恩，我曾经想做一个作家。

<p>后来我成为一个程序猿。</p>
<p>漂泊异乡，码梦为生。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> theGoalFor2017 = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WhatDoYouNeed</span> (<span class="params">goal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> MoneyForMaYun = <span class="number">9007199254740992</span></span><br><span class="line">  goal.Money = ( MoneyForMaYun + <span class="number">0</span> ) / <span class="number">2</span></span><br><span class="line">  goal.Happiness = goal.Achievement = <span class="number">9007199254740992</span> &amp;&amp;</span><br><span class="line">  goal.Sad = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">MoneyForMaYun(theGoalFor2017)</span><br></pre></td></tr></table></figure>

<h1 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h1><p>I dreamed a dream in time gone by,<br>When hope was high.<br>And life worth living,<br>I dreamed that love would never die.<br>…<br>愿，新年快乐！</p>
]]></content>
      <tags>
        <tag>给过去</tag>
      </tags>
  </entry>
  <entry>
    <title>基于dva-cli&amp;antd的react项目实战</title>
    <url>/2016/11/20/dva-react/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近因为业务需要需要尽快做一个系统并部署上线。作为前端负责人虽然时间很赶，但是也只好硬着头皮上了。考虑到项目健壮性、紧急性以及后期维护，最后的选择是用dva-cli做手脚架，antd作为UI库来做这个系统。<br>并且，由于考虑到按照当前情况，前期后端接口不太可能跟得上前端进度，所以此时数据mock就显得非常重要了。并且作为一个前后端彻底分离的项目，rap在这里可以充分发挥其作用——数据mock、接口协定、文档生成。</p>
<div style="color: red;">
------------2018.11.5日修
这篇文章到今天实际上改改还是可以用。不过考虑到rap1已经事实上无人维护频繁抛错所以数据可能会出不来。
加之现在Typescript已经非常流行好用。所以又重新整理了一篇。[typescript在redux-react项目中的应用](/2018/11/05/2018-11-5-typescript-redux-starter/)。
所谓上承下启，这篇依然保留，新的代码依然还是走的这篇一样的demo，但是建议采用的新的typescript方案，不过这之前 这篇文章建议还是参考看看。
并且新的项目react升级到16 react-router和wepack都升级到4。
</div>
# 目标概览
![dashboard](/images/dashboard.png)
本文不是讲如何做出一个一模一样的app，而是讲如何去实现基础的逻辑

<h1 id="代码和预览"><a href="#代码和预览" class="headerlink" title="代码和预览"></a>代码和预览</h1><p>相关代码已经托管到github,<a href="https://github.com/que01/dva-demo">dva-demo</a>。同时,存在一个在线预览地址,因为rap不支持https,所以只好为gp-pages绑定了自定义域名,router因为没有配置IndexRoute,所以菜单一1需要点击才会生效,<a href="http://github.que01.top/">点此前往</a></p>
<h1 id="安装和初始化项目"><a href="#安装和初始化项目" class="headerlink" title="安装和初始化项目"></a>安装和初始化项目</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g dva-cli</span><br></pre></td></tr></table></figure>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目:"></a>初始化项目:</h2><ul>
<li>新目录中进行初始化: <code>dva new myApp</code></li>
<li>已有目录中初始化: <code>mkdir myApp && cd myApp && dva init </code></li>
</ul>
<h2 id="手脚架代码自动生成"><a href="#手脚架代码自动生成" class="headerlink" title="手脚架代码自动生成"></a>手脚架代码自动生成</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dva g route product-list <span class="comment">#添加router</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dva g model products     <span class="comment">#添加model</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dva g component title    <span class="comment">#添加模块</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dva g component title --no-css <span class="comment">#添加模块但是不生成css文件</span></span></span><br></pre></td></tr></table></figure>

<h2 id="antd集成"><a href="#antd集成" class="headerlink" title="antd集成"></a>antd集成</h2><p>dva-cli只是一个项目的宏观架构，内部默认并没有整合antd,所以需要手动整合进来。<br>首先: <code>npm install antd --save</code><br>然后安装webpack插件对antd按需加载: <code>npm install babel-plugin-import --save-dev</code><br>PS:如果使用了这个插件实际上并不需要手动安装antd,它会自动安装缺失的package<br>最后,修改 webpack.config.js文件(添加line40-43)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;atool-build/lib/webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">webpackConfig, env</span>) </span>&#123;</span><br><span class="line">  webpackConfig.babel.plugins.push(<span class="string">&#x27;transform-runtime&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Support hmr</span></span><br><span class="line">  <span class="keyword">if</span> (env === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">    webpackConfig.devtool = <span class="string">&#x27;#eval&#x27;</span>;</span><br><span class="line">    webpackConfig.babel.plugins.push(<span class="string">&#x27;dva-hmr&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    webpackConfig.babel.plugins.push(<span class="string">&#x27;dev-expression&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t extract common.js and common.css</span></span><br><span class="line">  webpackConfig.plugins = webpackConfig.plugins.filter(<span class="function"><span class="keyword">function</span>(<span class="params">plugin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(plugin <span class="keyword">instanceof</span> webpack.optimize.CommonsChunkPlugin);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Support CSS Modules</span></span><br><span class="line">  <span class="comment">// Parse all less files as css module.</span></span><br><span class="line">  webpackConfig.module.loaders.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">loader, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> loader.test === <span class="string">&#x27;function&#x27;</span> &amp;&amp; loader.test.toString().indexOf(<span class="string">&#x27;\\.less$&#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      loader.include = <span class="regexp">/node_modules/</span>;</span><br><span class="line">      loader.test = <span class="regexp">/\.less$/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (loader.test.toString() === <span class="string">&#x27;/\\.module\\.less$/&#x27;</span>) &#123;</span><br><span class="line">      loader.exclude = <span class="regexp">/node_modules/</span>;</span><br><span class="line">      loader.test = <span class="regexp">/\.less$/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> loader.test === <span class="string">&#x27;function&#x27;</span> &amp;&amp; loader.test.toString().indexOf(<span class="string">&#x27;\\.css$&#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      loader.include = <span class="regexp">/node_modules/</span>;</span><br><span class="line">      loader.test = <span class="regexp">/\.css$/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (loader.test.toString() === <span class="string">&#x27;/\\.module\\.css$/&#x27;</span>) &#123;</span><br><span class="line">      loader.exclude = <span class="regexp">/node_modules/</span>;</span><br><span class="line">      loader.test = <span class="regexp">/\.css$/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  webpackConfig.babel.plugins.push([<span class="string">&#x27;import&#x27;</span>, &#123;</span><br><span class="line">      libraryName: <span class="string">&#x27;antd&#x27;</span>,</span><br><span class="line">      style: <span class="string">&#x27;css&#x27;</span>,</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> webpackConfig;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>至此，antd就集成完毕了。</p>
<p>这里来验证一下是否安装成功：<br>这里看router.js也就是路由文件里面关键的几句:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> IndexPage <span class="keyword">from</span> <span class="string">&#x27;./routes/IndexPage&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; history &#125;</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">       &lt;Route path=<span class="string">&quot;/&quot;</span> component=&#123;IndexPage&#125; /&gt;</span><br><span class="line">     &lt;/Router&gt;</span><br><span class="line">   );</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>显然，根目录指向了routes/IndexPage，我们去里面修改试试:<br>目标是下面组件可以显示出来:<br><img src="/images/login.png" width=300 alt=""></p>
<p>修改IndexPage.js,主要将官网的示例代码复制替换原来的就好了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;dva&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">&#x27;dva/router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./IndexPage.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Form, Icon, Input, Button, Checkbox &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FormItem = Form.Item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NormalLoginForm = Form.create()(React.createClass(&#123;</span><br><span class="line">  <span class="function"><span class="title">handleSubmit</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">this</span>.props.form.validateFields(<span class="function">(<span class="params">err, values</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Received values of form: &#x27;</span>, values);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; getFieldDecorator &#125; = <span class="built_in">this</span>.props.form;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">	  &lt;div style=&#123;&#123;<span class="attr">width</span>:<span class="string">&#x27;400px&#x27;</span>,<span class="attr">margin</span>:<span class="string">&quot;0 auto&quot;</span>&#125;&#125;&gt;</span><br><span class="line">		  &lt;Form onSubmit=&#123;<span class="built_in">this</span>.handleSubmit&#125; className=<span class="string">&quot;login-form&quot;</span>&gt;</span><br><span class="line">			&lt;FormItem&gt;</span><br><span class="line">			  &#123;getFieldDecorator(<span class="string">&#x27;userName&#x27;</span>, &#123;</span><br><span class="line">				rules: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;Please input your username!&#x27;</span> &#125;],</span><br><span class="line">			  &#125;)(</span><br><span class="line">				&lt;Input addonBefore=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> /&gt;</span></span>&#125; placeholder=<span class="string">&quot;Username&quot;</span> /&gt;</span><br><span class="line">			  )&#125;</span><br><span class="line">			&lt;/FormItem&gt;</span><br><span class="line">			&lt;FormItem&gt;</span><br><span class="line">			  &#123;getFieldDecorator(<span class="string">&#x27;password&#x27;</span>, &#123;</span><br><span class="line">				rules: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;Please input your Password!&#x27;</span> &#125;],</span><br><span class="line">			  &#125;)(</span><br><span class="line">				&lt;Input addonBefore=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">type</span>=<span class="string">&quot;lock&quot;</span> /&gt;</span></span>&#125; type=<span class="string">&quot;password&quot;</span> placeholder=<span class="string">&quot;Password&quot;</span> /&gt;</span><br><span class="line">			  )&#125;</span><br><span class="line">			&lt;/FormItem&gt;</span><br><span class="line">			&lt;FormItem&gt;</span><br><span class="line">			  &#123;getFieldDecorator(<span class="string">&#x27;remember&#x27;</span>, &#123;</span><br><span class="line">				valuePropName: <span class="string">&#x27;checked&#x27;</span>,</span><br><span class="line">				initialValue: <span class="literal">true</span>,</span><br><span class="line">			  &#125;)(</span><br><span class="line">				&lt;Checkbox&gt;Remember me&lt;/Checkbox&gt;</span><br><span class="line">			  )&#125;</span><br><span class="line">			  &lt;a className=<span class="string">&quot;login-form-forgot&quot;</span>&gt;Forgot password&lt;/a&gt;</span><br><span class="line">			  &lt;Button type=<span class="string">&quot;primary&quot;</span> htmlType=<span class="string">&quot;submit&quot;</span> className=<span class="string">&quot;login-form-button&quot;</span>&gt;</span><br><span class="line">				Log <span class="keyword">in</span></span><br><span class="line">			  &lt;/Button&gt;</span><br><span class="line">			  Or &lt;a&gt;register now!&lt;/a&gt;</span><br><span class="line">			&lt;/FormItem&gt;</span><br><span class="line">		  &lt;/Form&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect()(NormalLoginForm) ;</span><br></pre></td></tr></table></figure>
<p>最后运行结果成功，图基本如上就不再发。</p>
<h1 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h1><p>接下来我们简单的按照项目图做个原型来一点点实现,本文项目中Antd组件相关代码,为了方便学习和讲解，全部直接或者轻微修改自官方文档。</p>
<h2 id="栅格"><a href="#栅格" class="headerlink" title="栅格"></a>栅格</h2><p>删除IndexPage内部所有的测试代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;dva&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">&#x27;dva/router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./IndexPage.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Row, Col &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;Row style=&#123;&#123;<span class="attr">width</span>:<span class="string">&#x27;1000px&#x27;</span>,<span class="attr">margin</span>:<span class="string">&#x27;0 auto&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">        &lt;Col span=&#123;<span class="number">6</span>&#125;&gt;col-<span class="number">12</span>&lt;/Col&gt;</span><br><span class="line">        &lt;Col span=&#123;<span class="number">18</span>&#125;&gt;内容区域&lt;/Col&gt;</span><br><span class="line">      &lt;/Row&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect()(App) ;</span><br></pre></td></tr></table></figure>
<h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><p>新建components/Silder.js文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Menu, Icon &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> SubMenu = Menu.SubMenu;</span><br><span class="line"><span class="keyword">const</span> MenuItemGroup = Menu.ItemGroup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Sider = React.createClass(&#123;</span><br><span class="line">  <span class="function"><span class="title">getInitialState</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      current: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click &#x27;</span>, e);</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      current: e.key,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Menu onClick=&#123;<span class="built_in">this</span>.handleClick&#125;</span><br><span class="line">        style=&#123;&#123; <span class="attr">width</span>: <span class="number">240</span> &#125;&#125;</span><br><span class="line">        defaultOpenKeys=&#123;[<span class="string">&#x27;sub1&#x27;</span>]&#125;</span><br><span class="line">        selectedKeys=&#123;[<span class="built_in">this</span>.state.current]&#125;</span><br><span class="line">        mode=<span class="string">&quot;inline&quot;</span></span><br><span class="line">      &gt;</span><br><span class="line">        &lt;SubMenu key=<span class="string">&quot;sub1&quot;</span> title=&#123;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">type</span>=<span class="string">&quot;mail&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单一<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">            &lt;Menu.Item key=<span class="string">&quot;3&quot;</span>&gt;菜单一<span class="number">1</span>&lt;/Menu.Item&gt;</span><br><span class="line">            &lt;Menu.Item key=<span class="string">&quot;4&quot;</span>&gt;菜单一<span class="number">2</span>&lt;/Menu.Item&gt;</span><br><span class="line">        &lt;/SubMenu&gt;</span><br><span class="line">        &lt;SubMenu key=<span class="string">&quot;sub2&quot;</span> title=&#123;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">type</span>=<span class="string">&quot;appstore&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单二<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">&quot;5&quot;</span>&gt;菜单二<span class="number">1</span>&lt;/Menu.Item&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">&quot;6&quot;</span>&gt;菜单二<span class="number">2</span>&lt;/Menu.Item&gt;</span><br><span class="line">        &lt;/SubMenu&gt;</span><br><span class="line">        &lt;SubMenu key=<span class="string">&quot;sub4&quot;</span> title=&#123;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">type</span>=<span class="string">&quot;setting&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单三<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">&quot;9&quot;</span>&gt;菜单三<span class="number">1</span>&lt;/Menu.Item&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">&quot;10&quot;</span>&gt;菜单三<span class="number">2</span>&lt;/Menu.Item&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">&quot;11&quot;</span>&gt;菜单三<span class="number">3</span>&lt;/Menu.Item&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">&quot;12&quot;</span>&gt;菜单三<span class="number">4</span>&lt;/Menu.Item&gt;</span><br><span class="line">        &lt;/SubMenu&gt;</span><br><span class="line">      &lt;/Menu&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Sider</span><br></pre></td></tr></table></figure>
<p>修改IndexPage,import之,并在左侧的Col内部插入这个Silder</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> Silder <span class="keyword">from</span> <span class="string">&#x27;../components/Silder&#x27;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">        &lt;Col span=&#123;<span class="number">6</span>&#125;&gt;<span class="xml"><span class="tag">&lt;<span class="name">Silder</span> /&gt;</span></span>&lt;/Col&gt;</span><br><span class="line">        &lt;Col span=&#123;<span class="number">18</span>&#125;&gt;内容区域&lt;/Col&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>现在项目是这样的：<br><img src="/images/initApp.png" alt="initApp"></p>
<h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><p>做完这些之后我们需要开始做些路由配置了。简单点说,点击每个菜单时候，刷新右侧内容区域内容。</p>
<p>首先理清一下逻辑:</p>
<ol>
<li>默认的IndexPage内容区域需要默认内容</li>
<li>点击菜单后仅仅局部刷新右侧内容区域</li>
<li>点击刷新需要做一下相关配置</li>
</ol>
<p>针对第一和第二，我们来对右侧Col做一下配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Col span=&#123;<span class="number">18</span>&#125;&gt;</span><br><span class="line">  &#123;<span class="built_in">this</span>.props.children||<span class="string">&#x27;内容区域&#x27;</span>&#125;</span><br><span class="line">&lt;/Col&gt;</span><br></pre></td></tr></table></figure>
<p>然后我们新建以下文件：1-1.js、1-2.js、2-1.js、2-2.js、3-1.js、3-2.js、3-3.js、3-4.js,文件放到routes目录下，内容基本如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> Option = <span class="function">(<span class="params">props</span>)=&gt;</span>(</span><br><span class="line">  &lt;div&gt;菜单一<span class="number">1</span>&lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Option</span><br></pre></td></tr></table></figure>
<p>然后修改router.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; history &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Router hjsistory=&#123;history&#125;&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/&quot;</span> component=&#123;IndexPage&#125;&gt;</span><br><span class="line">        &#123;<span class="comment">/* 添加一个路由，嵌套进我们想要嵌套的 UI 里 */</span>&#125;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;11&quot;</span> component=&#123;<span class="built_in">require</span>(<span class="string">&#x27;./routes/1-1.js&#x27;</span>)&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;12&quot;</span> component=&#123;<span class="built_in">require</span>(<span class="string">&#x27;./routes/1-2.js&#x27;</span>)&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;21&quot;</span> component=&#123;<span class="built_in">require</span>(<span class="string">&#x27;./routes/2-1.js&#x27;</span>)&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;22&quot;</span> component=&#123;<span class="built_in">require</span>(<span class="string">&#x27;./routes/2-2.js&#x27;</span>)&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;31&quot;</span> component=&#123;<span class="built_in">require</span>(<span class="string">&#x27;./routes/3-1.js&#x27;</span>)&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;32&quot;</span> component=&#123;<span class="built_in">require</span>(<span class="string">&#x27;./routes/3-2.js&#x27;</span>)&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;33&quot;</span> component=&#123;<span class="built_in">require</span>(<span class="string">&#x27;./routes/3-3.js&#x27;</span>)&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;34&quot;</span> component=&#123;<span class="built_in">require</span>(<span class="string">&#x27;./routes/3-4.js&#x27;</span>)&#125; /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后给左侧菜单加点击切换路由效果,也就是Link标签<br>修改Silder.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">&#x27;dva/router&#x27;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Menu onClick=&#123;<span class="built_in">this</span>.handleClick&#125;</span><br><span class="line">        style=&#123;&#123; <span class="attr">width</span>: <span class="number">240</span> &#125;&#125;</span><br><span class="line">        defaultOpenKeys=&#123;[<span class="string">&#x27;sub1&#x27;</span>]&#125;</span><br><span class="line">        selectedKeys=&#123;[<span class="built_in">this</span>.state.current]&#125;</span><br><span class="line">        mode=<span class="string">&quot;inline&quot;</span></span><br><span class="line">      &gt;</span><br><span class="line">        &lt;SubMenu key=<span class="string">&quot;sub1&quot;</span> title=&#123;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">type</span>=<span class="string">&quot;mail&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单一<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">&quot;1&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;11&quot;</span>&gt;</span>菜单一1<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/Menu.Item&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">&quot;2&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;12&quot;</span>&gt;</span>菜单一2<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/Menu.Item&gt;</span><br><span class="line">        &lt;/SubMenu&gt;</span><br><span class="line">        &lt;SubMenu key=<span class="string">&quot;sub2&quot;</span> title=&#123;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">type</span>=<span class="string">&quot;appstore&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单二<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">&quot;3&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;21&quot;</span>&gt;</span>菜单二1<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/Menu.Item&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">&quot;4&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;22&quot;</span>&gt;</span>菜单二2<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/Menu.Item&gt;</span><br><span class="line">        &lt;/SubMenu&gt;</span><br><span class="line">        &lt;SubMenu key=<span class="string">&quot;sub4&quot;</span> title=&#123;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">type</span>=<span class="string">&quot;setting&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单三<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">&quot;5&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;31&quot;</span>&gt;</span>菜单三1<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/Menu.Item&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">&quot;6&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;32&quot;</span>&gt;</span>菜单三2<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/Menu.Item&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">&quot;7&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;33&quot;</span>&gt;</span>菜单三3<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/Menu.Item&gt;</span><br><span class="line">          &lt;Menu.Item key=<span class="string">&quot;8&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;34&quot;</span>&gt;</span>菜单三4<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/Menu.Item&gt;</span><br><span class="line">        &lt;/SubMenu&gt;</span><br><span class="line">      &lt;/Menu&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>至此,我们的APP基本有那么一个样子了。</p>
<h2 id="加个面包屑"><a href="#加个面包屑" class="headerlink" title="加个面包屑"></a>加个面包屑</h2><p>作为后台系统面包屑还是必不可少,而且面包屑作为全局共用组件,需要在不同路由下显示不同的路径,所以非常适合用来讲解如何进行组件之间进行通讯——每个内容区域和面包屑都是独立的,但是内容区域内部需要向面包屑通知新的路径数据。</p>
<p>最简单的面包屑是一个写死的面包屑,做如下修改：<br>IndexPage.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> &#123; Row, Col, Breadcrumb &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&lt;Row style=&#123;&#123;<span class="attr">width</span>:<span class="string">&#x27;1000px&#x27;</span>,<span class="attr">margin</span>:<span class="string">&#x27;0 auto&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">  &lt;Col span=&#123;<span class="number">24</span>&#125;&gt;</span><br><span class="line">    &lt;Breadcrumb&gt;</span><br><span class="line">      &lt;Breadcrumb.Item&gt;Home&lt;/Breadcrumb.Item&gt;</span><br><span class="line">      &lt;Breadcrumb.Item&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Application Center<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Breadcrumb.Item&gt;</span><br><span class="line">      &lt;Breadcrumb.Item&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Application List<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Breadcrumb.Item&gt;</span><br><span class="line">      &lt;Breadcrumb.Item&gt;An Application&lt;/Breadcrumb.Item&gt;</span><br><span class="line">    &lt;/Breadcrumb&gt;</span><br><span class="line">  &lt;/Col&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>不过显然没有数据驱动的面包屑没有任何意义，现在来改一下，实现数据驱动。<br>新建components/breadcrumb.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Breadcrumb &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">&#x27;dva/router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> breadcrumb = <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Breadcrumb&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        props.data.map(<span class="function">(<span class="params">v,i</span>)=&gt;</span>(</span><br><span class="line">          &lt;Breadcrumb.Item key=&#123;i&#125;&gt;</span><br><span class="line">            &#123;v.path?(<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;v.path&#125;</span>&gt;</span>&#123;v.name&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>):v.name&#125;</span><br><span class="line">          &lt;/Breadcrumb.Item&gt;</span><br><span class="line">        ))</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/Breadcrumb&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> breadcrumb;</span><br></pre></td></tr></table></figure>

<p>然后修改IndexPage.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> CustomBreadcrumb <span class="keyword">from</span> <span class="string">&#x27;../components/breadcrumb&#x27;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> breadcrumbData = [</span><br><span class="line">    &#123;</span><br><span class="line">      name:<span class="string">&#x27;首页&#x27;</span>,</span><br><span class="line">      path:<span class="string">&#x27;/&#x27;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      name:<span class="string">&#x27;菜单21&#x27;</span>,</span><br><span class="line">      path:<span class="string">&#x27;/21&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&lt;Col span=&#123;<span class="number">24</span>&#125;&gt;</span><br><span class="line">  &lt;CustomBreadcrumb data=&#123;breadcrumbData&#125; /&gt;</span><br><span class="line">&lt;/Col&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>至此,数据驱动面包屑完工。下一步要处理组件通讯了。也就是在1-1.js这些文件中驱动面包屑动态改变，而不是写死在IndexPage.js</p>
<p>首先我们先建立一个model文件，执行 <code>dva g model common</code>，它会在models下建立一个common.js,并注入到index.js。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.model(<span class="built_in">require</span>(<span class="string">&quot;./models/common&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>现在我们来修改这个文件，将它和面包屑关联起来。<br>修改models/common.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespace: <span class="string">&#x27;common&#x27;</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    breadcrumb:[</span><br><span class="line">      &#123;</span><br><span class="line">        name:<span class="string">&#x27;首页&#x27;</span>,</span><br><span class="line">        path:<span class="string">&#x27;/&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="function"><span class="title">changeBreadcrumb</span>(<span class="params">state,&#123; payload: breadcrumb &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, ...breadcrumb&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: &#123;&#125;,</span><br><span class="line">  subscriptions: &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是面包屑的主要数据逻辑。然后将它和面包屑关联起来:修改IndexPage.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &lt;Col span=&#123;<span class="number">24</span>&#125;&gt;</span><br><span class="line">    &lt;CustomBreadcrumb data=&#123;<span class="built_in">this</span>.props.common.breadcrumb&#125; /&gt;</span><br><span class="line">  &lt;/Col&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">&#123; common &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;common&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(App);</span><br></pre></td></tr></table></figure>
<p>至此，我们的的关联就做好了。现在去往1-1.js这些文件(其他文件同理不在赘述)，进行通讯，使其动态改变。因为需要使用到生命周期，所以之前用到stateless写法要改动一下。并且因为需要通讯,所以需要使用redux连接一下。<br>1-1.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123; connect &#125; from &#39;dva&#39;;</span><br><span class="line">class Option extends React.Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (&lt;div&gt;菜单一1&lt;&#x2F;div&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    const breadcrumbData &#x3D; &#123;</span><br><span class="line">      breadcrumb:[</span><br><span class="line">        &#123;</span><br><span class="line">          name:&#39;首页&#39;,</span><br><span class="line">          path:&#39;&#x2F;&#39;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          name:&#39;菜单一1&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">    this.props.dispatch(&#123;</span><br><span class="line">      type:&#39;common&#x2F;changeBreadcrumb&#39;,</span><br><span class="line">      payload:breadcrumbData</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function mapStateToProps(&#123; common &#125;) &#123;</span><br><span class="line">  return &#123;common&#125;;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(mapStateToProps)(Option);</span><br></pre></td></tr></table></figure>
<p>到此,我们的app目前是这样子的:<br><img src="/images/breaccrumb.png"><br>虽然它仍旧非常简陋,但是如你所见,虽然他不太好看,但是一个可以作画的画板已经准备好了。它已经可以在点击菜单的时候局部更新内容区域并更新面包屑了。</p>
<h2 id="做个列表页"><a href="#做个列表页" class="headerlink" title="做个列表页"></a>做个列表页</h2><p>画布既然已经铺好，接下来我们往上面做点画。这里做个最最常见的的列表。<br>修改1-1.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123; connect &#125; from &#39;dva&#39;;</span><br><span class="line">import &#123;Table,Icon&#125; from &#39;antd&#39;;</span><br><span class="line"></span><br><span class="line">const columns &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    title: &#39;Name&#39;,</span><br><span class="line">    dataIndex: &#39;name&#39;,</span><br><span class="line">    key: &#39;name&#39;,</span><br><span class="line">    render: text &#x3D;&gt; &lt;a href&#x3D;&quot;#&quot;&gt;&#123;text&#125;&lt;&#x2F;a&gt;,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    title: &#39;Age&#39;,</span><br><span class="line">    dataIndex: &#39;age&#39;,</span><br><span class="line">    key: &#39;age&#39;,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    title: &#39;Address&#39;,</span><br><span class="line">    dataIndex: &#39;address&#39;,</span><br><span class="line">    key: &#39;address&#39;,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    title: &#39;Action&#39;,</span><br><span class="line">    key: &#39;action&#39;,</span><br><span class="line">    render: (text, record) &#x3D;&gt; (</span><br><span class="line">      &lt;span&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;#&quot;&gt;Action 一 &#123;record.name&#125;&lt;&#x2F;a&gt;</span><br><span class="line">        &lt;span className&#x3D;&quot;ant-divider&quot; &#x2F;&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;#&quot;&gt;Delete&lt;&#x2F;a&gt;</span><br><span class="line">        &lt;span className&#x3D;&quot;ant-divider&quot; &#x2F;&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;#&quot; className&#x3D;&quot;ant-dropdown-link&quot;&gt;</span><br><span class="line">          More actions&lt;Icon type&#x3D;&quot;down&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    ),</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const data &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    key: &#39;1&#39;,</span><br><span class="line">    name: &#39;John Brown&#39;,</span><br><span class="line">    age: 32,</span><br><span class="line">    address: &#39;New York No. 1 Lake Park&#39;,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    key: &#39;2&#39;,</span><br><span class="line">    name: &#39;Jim Green&#39;,</span><br><span class="line">    age: 42,</span><br><span class="line">    address: &#39;London No. 1 Lake Park&#39;,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    key: &#39;3&#39;,</span><br><span class="line">    name: &#39;Joe Black&#39;,</span><br><span class="line">    age: 32,</span><br><span class="line">    address: &#39;Sidney No. 1 Lake Park&#39;,</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">class Option extends React.Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (&lt;Table columns&#x3D;&#123;columns&#125; dataSource&#x3D;&#123;data&#125; &#x2F;&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    const breadcrumbData &#x3D; &#123;</span><br><span class="line">      breadcrumb:[</span><br><span class="line">        &#123;</span><br><span class="line">          name:&#39;首页&#39;,</span><br><span class="line">          path:&#39;&#x2F;&#39;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          name:&#39;菜单一1&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">    this.props.dispatch(&#123;</span><br><span class="line">      type:&#39;common&#x2F;changeBreadcrumb&#39;,</span><br><span class="line">      payload:breadcrumbData</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function mapStateToProps(&#123; common &#125;) &#123;</span><br><span class="line">  return &#123;common&#125;;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(mapStateToProps)(Option);</span><br></pre></td></tr></table></figure>
<p>现在它是这样的：<br><img src="/images/option1-list.png" alt="option"></p>
<h2 id="数据mock"><a href="#数据mock" class="headerlink" title="数据mock"></a>数据mock</h2><p>到这里就要开始联调了。毕竟这个Table不能老是假数据，而且如果老用假数据也不太好测试翻页功能。所以这里上rap了。</p>
<p>首先，给出一下rap的数据详情看看<br><img src="/images/rap.png" alt="rap"><br>简单说一下这个接口的主要逻辑设计逻辑:</p>
<ol>
<li>请求参数包括页数页每页条数</li>
<li>返回的json中data.info包含必须的数据分页数据,包括第几页，每页条数，和总数据数</li>
<li>data.results则是一个对象数组,包含需要展示的数据。</li>
</ol>
<h3 id="拦截请求"><a href="#拦截请求" class="headerlink" title="拦截请求"></a>拦截请求</h3><p>接下来来我们做一些配置，用来将rap相关的数据配置化，不要写死。在项目根目录建立配置文件 <code>cd src && mkdir config && touch config/config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  rapHost:<span class="string">&#x27;http://rap.taobao.org/mockjs/5889/&#x27;</span>,</span><br><span class="line">  rapFlag:<span class="literal">false</span>,</span><br><span class="line">  onlinePath:<span class="string">&#x27;/api/&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> config</span><br></pre></td></tr></table></figure>
<p>其中rapHost是rap的地址，这个可以参考rap文档找出。rapFlag则用来标志是否rap的mock请求，如果不是则请求真实的地址,至于onlinePath则是加载真实地址前的前缀，例如要请求真实接口/aboutus,实际会请求/api/aboutUs——之所以这样，是为了方便配置nginx反向代理时候进行路由匹配。</p>
<p>dva-cli的utils目录内有个封装好的request.js用来做请求类，不过它并不支持rap，所以需要改造一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fetch <span class="keyword">from</span> <span class="string">&#x27;dva/fetch&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> safeeval <span class="keyword">from</span> <span class="string">&#x27;safe-eval&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">&#x27;mockjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseText</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.text();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkStatus</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (response.status &gt;= <span class="number">200</span> &amp;&amp; response.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(response.statusText);</span><br><span class="line">  error.response = response;</span><br><span class="line">  <span class="keyword">throw</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Requests a URL, returning a promise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;string&#125;</span> </span>url       The URL we want to request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;object&#125;</span> </span>[options] The options we want to pass to &quot;fetch&quot;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;boolean&#125;</span> </span>rap       是否是rap请求 true是 false 否</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;object&#125;</span>           </span>An object containing either &quot;data&quot; or &quot;err&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url, options,rap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!rap)&#123;rap = <span class="literal">false</span>;&#125;</span><br><span class="line">  <span class="keyword">return</span> fetch(url, options)</span><br><span class="line">    .then(checkStatus)</span><br><span class="line">    .then(parseText)</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(rap)&#123;</span><br><span class="line">        <span class="keyword">return</span> Mock.mock(safeeval(data))</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> safeeval(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> (&#123; err &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要修改的是parseJSON函数，将它从response.json()变成了response.text().并添加了mockjs对rap返回的mock模板进行解析(虽然rap可以直接返回数据而不是模板,不过据官方旺旺群里的说法,这个后期会被废弃)。</p>
<p>这样request.js已经可以用了，不过鉴于fetch参数比较多，默认还不带cookie没法使用session了,这样基于session的后端权限体系基本就废了,作为管理平台这显然是无法接受的。所以在它基础上再加一层。新建utils/query.js文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;../utils/request&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> qs ,&#123; parse &#125; <span class="keyword">from</span> <span class="string">&#x27;qs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> FormdataWrapper <span class="keyword">from</span> <span class="string">&#x27;object-to-formdata&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> merge <span class="keyword">from</span> <span class="string">&#x27;merge-object&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;rapHost, onlinePath&#125; <span class="keyword">from</span> <span class="string">&#x27;../config/config&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cookieTrue = &#123;</span><br><span class="line">  credentials: <span class="string">&#x27;include&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> jsonConf = &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params">smarturl,flag</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    <span class="keyword">return</span> rapHost + <span class="string">&#x27;/&#x27;</span> + smarturl;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> onlinePath + smarturl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">POST</span>(<span class="params">url,params,rapFlag,isJson</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(isJson == <span class="literal">undefined</span>)&#123;isJson = <span class="literal">false</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> request( getUrl(url,rapFlag),rapFlag?&#123;  <span class="comment">//如果为rap请求 就去掉 credentials: &#x27;include&#x27;来允许跨域</span></span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    body:isJson?<span class="built_in">JSON</span>.stringify(params):FormdataWrapper(params),</span><br><span class="line">  &#125;:merge(&#123;</span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    body:isJson?<span class="built_in">JSON</span>.stringify(params):FormdataWrapper(params),</span><br><span class="line">  &#125;,isJson?merge(jsonConf,cookieTrue):cookieTrue),rapFlag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">GET</span>(<span class="params">url,params,rapFlag</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request( getUrl(url,rapFlag) + <span class="string">`?<span class="subst">$&#123;qs.stringify(params)&#125;</span>`</span>,rapFlag?&#123;</span><br><span class="line">    method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  &#125;:merge(&#123;</span><br><span class="line">    method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  &#125;,cookieTrue),rapFlag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  POST,GET</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个封装在post请求时候可以发送formdata和json,并且发送真实请求时候(rapFlag在部署打包时候需要改成false)会带上cookie以方便后端实现基于session的权限校验，并且由于此处的async,所以可以做一些处理后，可以同步代码一样使用。另外由于用了webpack插件,这里用到的npm包都不需要手动安装。<br>现在，可以这样使用fetch做请求了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; code,data &#125; &#x3D; yield POST(&#39;user&#x2F;1&#39;,&#123;disable:false&#125;,false)</span><br></pre></td></tr></table></figure>
<p>请求类封装完毕，现在可以使用model将模块和rap对接起来了。运行<code>dva g model 11</code></p>
<p style="color:red">
注:当我写完本文再去看dva文档时候我最后发现dva-cli实际上已经提供了更好的方案选择，那就是dora-plugin-proxy，使用dora-plugin-proxy确实会让代码更加干净。但是限于当时没有时间折腾,所以当时也没有能使用这个方案。但是写这篇文章时候，我已经开始在项目中使用它来替代上面的拦截方案。下面是记录。
</p>
首先需要说明的这里撤回了上文说到的request.js文件的改动，因为这里不在需要了。
而query.js文件，现在是这样的。只是简单的去除了rapFlag。
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">POST</span>(<span class="params">url,params,isJson</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(isJson == <span class="literal">undefined</span>)&#123;isJson = <span class="literal">false</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> request( url,merge(&#123;</span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    body:isJson?<span class="built_in">JSON</span>.stringify(params):FormdataWrapper(params),</span><br><span class="line">  &#125;,isJson?merge(jsonConf,cookieTrue):cookieTrue),rapFlag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">GET</span>(<span class="params">url,params</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request( url + <span class="string">`?<span class="subst">$&#123;qs.stringify(params)&#125;</span>`</span>,merge(&#123;</span><br><span class="line">    method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  &#125;,cookieTrue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
接下来我们修改mock/example.js
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> safeeval = <span class="built_in">require</span>(<span class="string">&#x27;safe-eval&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> mockjs = <span class="built_in">require</span>(<span class="string">&#x27;mockjs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> Host = <span class="string">&#x27;http://rap.taobao.org/mockjs/5889&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockMapFun</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">  co(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> response = <span class="keyword">yield</span> fetch(Host + req.url);</span><br><span class="line">      <span class="keyword">var</span> mockTpl = <span class="keyword">yield</span> response.text();</span><br><span class="line">      res.json( mockjs.mock(safeeval(mockTpl))[<span class="string">&#x27;data&#x27;</span>] );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">&#x27;GET /member/list&#x27;</span>: mockMapFun</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
co和fetch配合使用让它更加接近于同步的写法。然后使用res.json返回了mockjs解析模板后的数据。

<p>当然,写了两个方案,当然是自己的更挫一些,不过因为还是有参考价值就不再删除了。如果对这里有混乱，请直接爬代码。毕竟就不到50行代码量。</p>
<h3 id="连接组件"><a href="#连接组件" class="headerlink" title="连接组件"></a>连接组件</h3><p>编辑这个models/11.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; GET &#125; from &#39;..&#x2F;utils&#x2F;query&#39;</span><br><span class="line">import &#123; rapFlag, onlinePath &#125; from &#39;..&#x2F;config&#x2F;config&#39;;</span><br><span class="line">const API &#x3D; &#39;member&#x2F;list&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  namespace: &#39;test&#39;,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list:&#123;</span><br><span class="line">      data:[],</span><br><span class="line">      loading:true,</span><br><span class="line">    &#125;,</span><br><span class="line">    pagination:&#123;</span><br><span class="line">      current:1,</span><br><span class="line">      pageSize:10,</span><br><span class="line">      total:null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    fetchList(state, action) &#123;</span><br><span class="line">      return &#123; ...state, ...action.payload &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: &#123;</span><br><span class="line">    *fetchRemote(&#123; payload &#125;, &#123; call, put &#125;) &#123;</span><br><span class="line">      let &#123;current,pageSize&#125; &#x3D; payload;</span><br><span class="line">      let &#123; data &#125; &#x3D; yield call(GET,API,&#123;</span><br><span class="line">        pageNum:current,</span><br><span class="line">        pageSize:pageSize,</span><br><span class="line">      &#125;,rapFlag);</span><br><span class="line">      if (data) &#123;</span><br><span class="line">        yield put(&#123;</span><br><span class="line">          type: &#39;fetchList&#39;,</span><br><span class="line">          payload: &#123;</span><br><span class="line">            list: &#123;</span><br><span class="line">              data:data.results,</span><br><span class="line">              loading:false</span><br><span class="line">            &#125;,</span><br><span class="line">            pagination: data.info</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  subscriptions: &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于Effects,可以参考此处<a href="https://github.com/dvajs/dva-docs/blob/master/v1/zh-cn/tutorial/07-%E6%B7%BB%E5%8A%A0Effects.md">官方文档</a><br>然后将它和1-1.js对应模块对接起来，进行部分修改：<br>1-1.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123; connect &#125; from &#39;dva&#39;;</span><br><span class="line">import &#123;Table,Icon&#125; from &#39;antd&#39;;</span><br><span class="line"></span><br><span class="line">const columns &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    title: &#39;Name&#39;,</span><br><span class="line">    dataIndex: &#39;name&#39;,</span><br><span class="line">    key: &#39;name&#39;,</span><br><span class="line">    render: text &#x3D;&gt; &lt;a href&#x3D;&quot;#&quot;&gt;&#123;text&#125;&lt;&#x2F;a&gt;,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    title: &#39;Age&#39;,</span><br><span class="line">    dataIndex: &#39;age&#39;,</span><br><span class="line">    key: &#39;age&#39;,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    title: &#39;Address&#39;,</span><br><span class="line">    dataIndex: &#39;address&#39;,</span><br><span class="line">    key: &#39;address&#39;,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    title: &#39;LastLogin&#39;,</span><br><span class="line">    dataIndex: &#39;lastLogin&#39;,</span><br><span class="line">    key: &#39;lastLogin&#39;,</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">class Option extends React.Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    let &#123;data,loading&#125; &#x3D; this.props.test.list;</span><br><span class="line">    let pagination &#x3D; this.props.test.pagination;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Table</span><br><span class="line">        columns&#x3D;&#123;columns&#125;</span><br><span class="line">        dataSource&#x3D;&#123;data&#125;</span><br><span class="line">        pagination&#x3D;&#123;pagination&#125;</span><br><span class="line">        onChange&#x3D;&#123;this.handleTableChange.bind(this)&#125;</span><br><span class="line">        loading&#x3D;&#123;loading&#125;</span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  handleTableChange(pagination, filters, sorter)&#123;</span><br><span class="line">    this.props.dispatch(&#123;</span><br><span class="line">      type:&#39;test&#x2F;changePage&#39;,</span><br><span class="line">      payload:&#123;</span><br><span class="line">        pagination:&#123;</span><br><span class="line">          current:pagination.current,</span><br><span class="line">          pageSize:pagination.pageSize,</span><br><span class="line">          showQuickJumper: true,</span><br><span class="line">          loading:true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    this.fetch(pagination.current)</span><br><span class="line">  &#125;</span><br><span class="line">  fetch(current)&#123;</span><br><span class="line">    &#x2F;&#x2F; 更新列表</span><br><span class="line">    this.props.dispatch(&#123;</span><br><span class="line">      type:&#39;test&#x2F;fetchRemote&#39;,</span><br><span class="line">      payload:&#123;</span><br><span class="line">        current:current,</span><br><span class="line">        pageSize:10,</span><br><span class="line">        loading:false,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    const breadcrumbData &#x3D; &#123;</span><br><span class="line">      breadcrumb:[</span><br><span class="line">        &#123;</span><br><span class="line">          name:&#39;首页&#39;,</span><br><span class="line">          path:&#39;&#x2F;&#39;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          name:&#39;菜单一1&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">    this.props.dispatch(&#123;</span><br><span class="line">      type:&#39;common&#x2F;changeBreadcrumb&#39;,</span><br><span class="line">      payload:breadcrumbData</span><br><span class="line">    &#125;);</span><br><span class="line">    this.fetch(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function mapStateToProps(&#123; common,test &#125;) &#123;</span><br><span class="line">  return &#123;common,test&#125;;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(mapStateToProps)(Option);</span><br></pre></td></tr></table></figure>

<h1 id="代码打包部署"><a href="#代码打包部署" class="headerlink" title="代码打包部署"></a>代码打包部署</h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>经过上文一些讲解，基本上构建简单的react项目已经没有问题了。所以接下来讲一下代码部署。</p>
<p>react-router本身支持两中路由，一种基于hashchange的路由，类似<code><a href="http://www.que01.top/#/11">www.que01.top/#/11</a></code>,但是也支持传统的路由类似<code><a href="http://www.que01.top/11">www.que01.top/11</a></code></p>
<p>虽然hashchange部署更简单，但是作为一个「有追求」的开发者，我们应该在条件允许的情况下，毫不犹豫的使用后者。</p>
<p>但是这需要服务器端配置。以nginx配置为例：<br>nginx.conf,关键部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">        listen 8888;</span><br><span class="line">        server_name &quot;&quot;;</span><br><span class="line">        root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;dist;</span><br><span class="line"></span><br><span class="line">        gzip_static on;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">          try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       location &#x2F;api &#123;</span><br><span class="line">            proxy_set_header  X-Real-IP  $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend:800&#x2F;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中,root是项目部署的目录,<code>try_files $uri $uri/ /index.html;</code>这段的意思是,如果请求资源/about,首先在服务器上查找/about资源,如果没有，继续查找/about/index.html资源，如果还是没有，最后返回index.html资源。</p>
<p>至于<code>location /api</code>这段，是一个反向代理。将它映射到真实的后端路径即可。这里就是之前为什么要在config.js内部配置一个onlinePath的原因。她需要同这里的反向代理的路由一致。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>关于打包，直接运行<code>npm run build</code>即可，不过默认的打包是不带文件指纹的，为了实现强缓存，我们修改package.json,如下代码，修改build,为build命令添加–hash选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;dora --plugins \&quot;proxy,webpack,webpack-hmr\&quot;&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;atool-build --hash&quot;,</span><br><span class="line">  &quot;test&quot;: &quot;atool-test-mocha .&#x2F;src&#x2F;**&#x2F;*-test.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这个选项仅仅是用来生成文件指纹,index.html内部的html依然引入的是没有指纹的文件，直接这样打包会导致内部引入的资源404，所以要对webpack配置文件改动一番。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (env === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">  webpackConfig.devtool = <span class="string">&#x27;#eval&#x27;</span>;</span><br><span class="line">  webpackConfig.babel.plugins.push([<span class="string">&#x27;dva-hmr&#x27;</span>, &#123;</span><br><span class="line">    entries: [</span><br><span class="line">      <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">  &#125;]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  webpackConfig.babel.plugins.push(<span class="string">&#x27;dev-expression&#x27;</span>);</span><br><span class="line">  webpackConfig.plugins.push(</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      inject: <span class="literal">false</span>,</span><br><span class="line">      template: <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-template&#x27;</span>),</span><br><span class="line">      title: <span class="string">&#x27;Dva Demo&#x27;</span>,</span><br><span class="line">      appMountId: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        removeComments: <span class="literal">true</span>,</span><br><span class="line">        collapseWhitespace: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      links:[<span class="string">&#x27;//at.alicdn.com/t/font_xxxxxxxx.css&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>主要的改动就是html-webpack-template这个插件的引入,改动后，手动安装一下插件 <code>npm i html-webpack-template html-webpack-plugin --save-dev</code></p>
<p>这个配置用途就是动态注入css和js,这个只依靠html-webpack-plugin就可以实现,不过html-webpack-template基于html-webpack-plugin,并且让可配置性更好了。例如可以配置links,全局引入字体图标(这个项目里面用到很多),当然,频繁修改这个修改任务文件里面的links可不是什么好主意,所以你完全可以将这个抽出来放到config/config.js里面去——随你喜欢。</p>
<h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><p>按上面的做完配置之后基本就没什么需要弄的了。但是还有个对中型和大型项目非常重要的一点，那就是按需加载——大抵你不会希望访问一下/aboutUs这个路由，就需要下载整个/allInOne的js代码；还有就是commonChunk代码抽离——你也不会希望明明可以公用的代码，在每一个路由里面都重复打包一次,这会导致项目体积虚胖和流量浪费，同时这也意味这更慢的打开速度。</p>
<p>首先我们将react-router配置改一下，让它按需加载而不是将所有路由代码都打包到一个里面去。<br>src/router.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> r11 = <span class="function">(<span class="params">location, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">require</span>.ensure([<span class="string">&#x27;./routes/1-1&#x27;</span>], <span class="function"><span class="params">require</span> =&gt;</span> &#123;callback(<span class="literal">null</span>,</span><br><span class="line">    )&#125;, <span class="string">&#x27;11&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&lt;Router hjsistory=&#123;history&#125;&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/&quot;</span> component=&#123;IndexPage&#125;&gt;</span><br><span class="line">    &#123;<span class="comment">/* 添加一个路由，嵌套进我们想要嵌套的 UI 里 */</span>&#125;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;11&quot;</span> getComponent=&#123;r11&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;12&quot;</span> getComponent=&#123;r12&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;21&quot;</span> getComponent=&#123;r21&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;22&quot;</span> getComponent=&#123;r22&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;31&quot;</span> getComponent=&#123;r31&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;32&quot;</span> getComponent=&#123;r32&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;33&quot;</span> getComponent=&#123;r33&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;34&quot;</span> getComponent=&#123;r34&#125; /&gt;</span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line">&lt;/Router&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><code>require.ensure</code>这个是依赖webpack的代码切片,而<code><Route path="11" getComponent=&#123;r11&#125; /></code>这个里面的getComponent,则是react-router内部的异步接口。结合这两个，至此,代码就可以按照路由进行按需加载了。接下来我们把react作为commonChunk抽出来,这样会显著缩小部署体积——项目越大就会越明显。</p>
<p>这里的r11定义得看起来有些愚蠢,然而require这个函数有些特殊,无法向它内部传递变量,到目前为止,也只好这样了。</p>
<p>抽出公共代码其实还是很容易。dva-cli内部实际上已经留下了这个接口。<br>修改package.json,添加common对象,如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;entry&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;.&#x2F;src&#x2F;index.js&quot;,</span><br><span class="line">    &quot;common&quot;: [</span><br><span class="line">      &quot;react&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>到此,一个基于dva-cli的react项目,从基础骨架、组件通讯、ajax异步请求数据、数据mock、按需加载、公共代码抽离、打包部署，都完毕了。本文页到此也就完整了。</p>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose实战笔记</title>
    <url>/2016/11/15/docker-compose/</url>
    <content><![CDATA[<h1 id="docker-compose概念"><a href="#docker-compose概念" class="headerlink" title="docker-compose概念"></a>docker-compose概念</h1><p>Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速在集群中部署分布式应用。</p>
<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p>本文算不上教程，主要是记录一下个人在这块的实践，防止哪天忘了，翻翻博客还能找的回。不过不排除有人需要详细的成体系的教程，这个放个地址 。</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="Gitlab"><a href="#Gitlab" class="headerlink" title="Gitlab"></a>Gitlab</h2><p>svn在阿里云,而且磁盘满了有时候都没法提交，备份也没法备份，最后决定把版本控制迁回来，使用git-svn转换以后，最终把svn替换为git。所以要搭建一个gitlab服务器。前任团队的坑。。。<br>docker-compose.yml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;2&#39;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    restart: always</span><br><span class="line">    image: sameersbn&#x2F;redis:latest</span><br><span class="line">    command:</span><br><span class="line">    - --loglevel warning</span><br><span class="line">    volumes:</span><br><span class="line">    - &#x2F;srv&#x2F;docker&#x2F;gitlab&#x2F;redis:&#x2F;var&#x2F;lib&#x2F;redis:Z</span><br><span class="line"></span><br><span class="line">  postgresql:</span><br><span class="line">    restart: always</span><br><span class="line">    image: sameersbn&#x2F;postgresql:9.5-1</span><br><span class="line">    volumes:</span><br><span class="line">    - &#x2F;srv&#x2F;docker&#x2F;gitlab&#x2F;postgresql:&#x2F;var&#x2F;lib&#x2F;postgresql:Z</span><br><span class="line">    environment:</span><br><span class="line">    - DB_USER&#x3D;gitlab</span><br><span class="line">    - DB_PASS&#x3D;password</span><br><span class="line">    - DB_NAME&#x3D;gitlabhq_production</span><br><span class="line">    - DB_EXTENSION&#x3D;pg_trgm</span><br><span class="line"></span><br><span class="line">  gitlab:</span><br><span class="line">    restart: always</span><br><span class="line">    image: sameersbn&#x2F;gitlab:8.11.5</span><br><span class="line">    depends_on:</span><br><span class="line">    - redis</span><br><span class="line">    - postgresql</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;10080:80&quot;</span><br><span class="line">    - &quot;10022:22&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - &#x2F;srv&#x2F;docker&#x2F;gitlab&#x2F;gitlab:&#x2F;home&#x2F;git&#x2F;data:Z</span><br><span class="line">    environment:</span><br><span class="line">    - DEBUG&#x3D;false</span><br><span class="line"></span><br><span class="line">    - DB_ADAPTER&#x3D;postgresql</span><br><span class="line">    - DB_HOST&#x3D;postgresql</span><br><span class="line">    - DB_PORT&#x3D;5432</span><br><span class="line">    - DB_USER&#x3D;gitlab</span><br><span class="line">    - DB_PASS&#x3D;password</span><br><span class="line">    - DB_NAME&#x3D;gitlabhq_production</span><br><span class="line"></span><br><span class="line">    - REDIS_HOST&#x3D;redis</span><br><span class="line">    - REDIS_PORT&#x3D;6379</span><br><span class="line"></span><br><span class="line">    - TZ&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">    - GITLAB_TIMEZONE&#x3D;Kolkata</span><br><span class="line"></span><br><span class="line">    - GITLAB_HTTPS&#x3D;false</span><br><span class="line">    - SSL_SELF_SIGNED&#x3D;false</span><br><span class="line"></span><br><span class="line">    - GITLAB_HOST&#x3D;116.7.245.195</span><br><span class="line">    - GITLAB_PORT&#x3D;10080</span><br><span class="line">    - GITLAB_SSH_PORT&#x3D;10022</span><br><span class="line">    - GITLAB_RELATIVE_URL_ROOT&#x3D;</span><br><span class="line">    - GITLAB_SECRETS_DB_KEY_BASE&#x3D;safausdlfjkj23k4jkljslkdfjlkjasdlkfu8u234ioj23krjlsdfjasdfjkasdfk</span><br><span class="line">    - GITLAB_SECRETS_SECRET_KEY_BASE&#x3D;sadfkljiwfjsnscjksdhfuwehnfnsaldfjh3rhljsdkfjlksajdf</span><br><span class="line">    - GITLAB_SECRETS_OTP_KEY_BASE&#x3D;asfdlaxzcvnhwefhweoicnmcsflncnzmxbvsdajkfasdsdnfkjhsadfj</span><br><span class="line"></span><br><span class="line">    - GITLAB_ROOT_PASSWORD&#x3D;edeh123456</span><br><span class="line">    - GITLAB_ROOT_EMAIL&#x3D;que01@foxmail.com</span><br><span class="line"></span><br><span class="line">    - GITLAB_NOTIFY_ON_BROKEN_BUILDS&#x3D;true</span><br><span class="line">    - GITLAB_NOTIFY_PUSHER&#x3D;false</span><br><span class="line"></span><br><span class="line">    - GITLAB_EMAIL&#x3D;notifications@example.com</span><br><span class="line">    - GITLAB_EMAIL_REPLY_TO&#x3D;noreply@example.com</span><br><span class="line">    - GITLAB_INCOMING_EMAIL_ADDRESS&#x3D;reply@example.com</span><br><span class="line"></span><br><span class="line">    - GITLAB_BACKUP_SCHEDULE&#x3D;daily</span><br><span class="line">    - GITLAB_BACKUP_TIME&#x3D;01:00</span><br><span class="line"></span><br><span class="line">    - SMTP_ENABLED&#x3D;false</span><br><span class="line">    - SMTP_DOMAIN&#x3D;www.example.com</span><br><span class="line">    - SMTP_HOST&#x3D;smtp.gmail.com</span><br><span class="line">    - SMTP_PORT&#x3D;587</span><br><span class="line">    - SMTP_USER&#x3D;mailer@example.com</span><br><span class="line">    - SMTP_PASS&#x3D;password</span><br><span class="line">    - SMTP_STARTTLS&#x3D;true</span><br><span class="line">    - SMTP_AUTHENTICATION&#x3D;login</span><br><span class="line"></span><br><span class="line">    - IMAP_ENABLED&#x3D;false</span><br><span class="line">    - IMAP_HOST&#x3D;imap.gmail.com</span><br><span class="line">    - IMAP_PORT&#x3D;993</span><br><span class="line">    - IMAP_USER&#x3D;mailer@example.com</span><br><span class="line">    - IMAP_PASS&#x3D;password</span><br><span class="line">    - IMAP_SSL&#x3D;true</span><br><span class="line">    - IMAP_STARTTLS&#x3D;false</span><br><span class="line"></span><br><span class="line">    - OAUTH_ENABLED&#x3D;false</span><br><span class="line">    - OAUTH_AUTO_SIGN_IN_WITH_PROVIDER&#x3D;</span><br><span class="line">    - OAUTH_ALLOW_SSO&#x3D;</span><br><span class="line">    - OAUTH_BLOCK_AUTO_CREATED_USERS&#x3D;true</span><br><span class="line">    - OAUTH_AUTO_LINK_LDAP_USER&#x3D;false</span><br><span class="line">    - OAUTH_AUTO_LINK_SAML_USER&#x3D;false</span><br><span class="line">    - OAUTH_EXTERNAL_PROVIDERS&#x3D;</span><br><span class="line"></span><br><span class="line">    - OAUTH_CAS3_LABEL&#x3D;cas3</span><br><span class="line">    - OAUTH_CAS3_SERVER&#x3D;</span><br><span class="line">    - OAUTH_CAS3_DISABLE_SSL_VERIFICATION&#x3D;false</span><br><span class="line">    - OAUTH_CAS3_LOGIN_URL&#x3D;&#x2F;cas&#x2F;login</span><br><span class="line">    - OAUTH_CAS3_VALIDATE_URL&#x3D;&#x2F;cas&#x2F;p3&#x2F;serviceValidate</span><br><span class="line">    - OAUTH_CAS3_LOGOUT_URL&#x3D;&#x2F;cas&#x2F;logout</span><br><span class="line"></span><br><span class="line">    - OAUTH_GOOGLE_API_KEY&#x3D;</span><br><span class="line">    - OAUTH_GOOGLE_APP_SECRET&#x3D;</span><br><span class="line">    - OAUTH_GOOGLE_RESTRICT_DOMAIN&#x3D;</span><br><span class="line"></span><br><span class="line">    - OAUTH_FACEBOOK_API_KEY&#x3D;</span><br><span class="line">    - OAUTH_FACEBOOK_APP_SECRET&#x3D;</span><br><span class="line"></span><br><span class="line">    - OAUTH_TWITTER_API_KEY&#x3D;</span><br><span class="line">    - OAUTH_TWITTER_APP_SECRET&#x3D;</span><br><span class="line"></span><br><span class="line">    - OAUTH_GITHUB_API_KEY&#x3D;</span><br><span class="line">    - OAUTH_GITHUB_APP_SECRET&#x3D;</span><br><span class="line">    - OAUTH_GITHUB_URL&#x3D;</span><br><span class="line">    - OAUTH_GITHUB_VERIFY_SSL&#x3D;</span><br><span class="line"></span><br><span class="line">    - OAUTH_GITLAB_API_KEY&#x3D;</span><br><span class="line">    - OAUTH_GITLAB_APP_SECRET&#x3D;</span><br><span class="line"></span><br><span class="line">    - OAUTH_BITBUCKET_API_KEY&#x3D;</span><br><span class="line">    - OAUTH_BITBUCKET_APP_SECRET&#x3D;</span><br><span class="line"></span><br><span class="line">    - OAUTH_SAML_ASSERTION_CONSUMER_SERVICE_URL&#x3D;</span><br><span class="line">    - OAUTH_SAML_IDP_CERT_FINGERPRINT&#x3D;</span><br><span class="line">    - OAUTH_SAML_IDP_SSO_TARGET_URL&#x3D;</span><br><span class="line">    - OAUTH_SAML_ISSUER&#x3D;</span><br><span class="line">    - OAUTH_SAML_LABEL&#x3D;&quot;Our SAML Provider&quot;</span><br><span class="line">    - OAUTH_SAML_NAME_IDENTIFIER_FORMAT&#x3D;urn:oasis:names:tc:SAML:2.0:nameid-format:transient</span><br><span class="line">    - OAUTH_SAML_GROUPS_ATTRIBUTE&#x3D;</span><br><span class="line">    - OAUTH_SAML_EXTERNAL_GROUPS&#x3D;</span><br><span class="line">    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_EMAIL&#x3D;</span><br><span class="line">    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_NAME&#x3D;</span><br><span class="line">    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_FIRST_NAME&#x3D;</span><br><span class="line">    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_LAST_NAME&#x3D;</span><br><span class="line"></span><br><span class="line">    - OAUTH_CROWD_SERVER_URL&#x3D;</span><br><span class="line">    - OAUTH_CROWD_APP_NAME&#x3D;</span><br><span class="line">    - OAUTH_CROWD_APP_PASSWORD&#x3D;</span><br><span class="line"></span><br><span class="line">    - OAUTH_AUTH0_CLIENT_ID&#x3D;</span><br><span class="line">    - OAUTH_AUTH0_CLIENT_SECRET&#x3D;</span><br><span class="line">    - OAUTH_AUTH0_DOMAIN&#x3D;</span><br><span class="line"></span><br><span class="line">    - OAUTH_AZURE_API_KEY&#x3D;</span><br><span class="line">    - OAUTH_AZURE_API_SECRET&#x3D;</span><br><span class="line">    - OAUTH_AZURE_TENANT_ID&#x3D;</span><br></pre></td></tr></table></figure>
<p>gitlab的docker-compose配置文件其实直接从官方拿过来用的。虽然没什么太大参考价值。不过这里用到了常用的选项，比如restart,image,command,volumes,environment,depends_on。</p>
<p>各个配置项的作用:</p>
<ul>
<li>restart 当容器意外退出后是否自动再次重新启动</li>
<li>image 容器镜像</li>
<li>command 容器启动后执行的命令</li>
<li>volumes 挂载卷，将本地的磁盘目录挂在到容器内 主要做数据备份用</li>
<li>environment 环境变量配置</li>
<li>depends_on 依赖项，这个配置可以确保依赖服务被配置，但是并不能保证启动顺序</li>
</ul>
<h2 id="Rap"><a href="#Rap" class="headerlink" title="Rap"></a>Rap</h2><p>淘宝的rap是个很不错的东西。前后端分离时候最麻烦的东西就是文档&amp;&amp;文档维护。加上rap本身的数据mock功能，这是一个杀手锏。<br>rap的docker-compose配置在github上找到一个不错的。<a href="https://github.com/srzyhead/rap">srzyhead/rap</a>,不过mysql的配置有点问题导致数据统计没法用，跑过去提了一下pull request。现在没啥问题了，直接git clone回来，按照readme操作即可。</p>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>这个没用到docker-compose，简单的运行了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir data</span><br><span class="line">docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_USER=lyshow -e MYSQL_PASSWORD=123456 -p 3306:3306 -v $(pwd)/data:/var/lib/mysql -d mysql:5.6 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure>

<h2 id="java项目部署"><a href="#java项目部署" class="headerlink" title="java项目部署"></a>java项目部署</h2><p>主要是两个类型的历史项目，一个基于ant打包的，一个是基于maven打包的项目。</p>
<h3 id="ant项目"><a href="#ant项目" class="headerlink" title="ant项目"></a>ant项目</h3><p>配置目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── server.xml</span><br><span class="line">├── tomcat7</span><br><span class="line">└── wait-for-file.sh</span><br></pre></td></tr></table></figure>
<p>docker-compose.yml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;2&#39;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  ant-test:</span><br><span class="line">    image: frekele&#x2F;ant:1.9.7-jdk7</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;tomcat7&#x2F;:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;:Z</span><br><span class="line">    - ..&#x2F;..&#x2F;hotdoc&#x2F;pc&#x2F;test&#x2F;:&#x2F;data&#x2F;:Z</span><br><span class="line">    entrypoint: |</span><br><span class="line">     bash -c &quot;rm -f &#x2F;data&#x2F;done &amp;&amp; rm -rf &#x2F;data&#x2F;WebRoot&#x2F;WEB-INF&#x2F;classes &amp;&amp; mkdir -p &#x2F;data&#x2F;WebRoot&#x2F;WEB-INF&#x2F;classes &amp;&amp; ant -f &#x2F;data&#x2F;build.xml &amp;&amp; touch &#x2F;data&#x2F;done&quot;</span><br><span class="line"></span><br><span class="line">  tomcat-test:</span><br><span class="line">    image: openweb&#x2F;oracle-tomcat:7-jre7</span><br><span class="line">    command: [&quot;bin&#x2F;catalina.sh&quot;, &quot;run&quot;]</span><br><span class="line">    depends_on:</span><br><span class="line">    - ant-test-test</span><br><span class="line">    entrypoint: &#x2F;tool&#x2F;wait-for-file.sh &#x2F;data&#x2F;done</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;9088:800&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;wait-for-file.sh:&#x2F;tool&#x2F;wait-for-file.sh</span><br><span class="line">    - .&#x2F;server.xml:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;conf&#x2F;server.xml</span><br><span class="line">    - ..&#x2F;..&#x2F;hotdoc&#x2F;pc&#x2F;test&#x2F;:&#x2F;data&#x2F;:Z</span><br></pre></td></tr></table></figure>
<p>主要是用到了两个服务,一个编译服务,一个tomcat。</p>
<p>server.xml和tomcat7就不说了，主要是项目依赖。主要需要注意的是wait-for-file.sh这个,前面已经说到了，depends_on可以配置依赖项，但是并没有办法确保依赖服务器在主服务就绪前就绪,所以就有了wait-for-file.sh这个东西。<br>wait-for-file.sh里面东西很简单:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">waitFile&#x3D;&quot;$1&quot;</span><br><span class="line">shift</span><br><span class="line">cmd&#x3D;&quot;$@&quot;</span><br><span class="line"></span><br><span class="line">until test -e $waitFile</span><br><span class="line">do</span><br><span class="line">  &gt;&amp;2 echo &quot;Waiting for file [$waitFile].&quot;</span><br><span class="line">  sleep 1</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">&gt;&amp;2 echo &quot;Found file [$waitFile].&quot;</span><br><span class="line">exec $cmd</span><br></pre></td></tr></table></figure>
<p>主要逻辑就是利用文件的存在来判断是否执行一个操作。这个东西似乎从stackoverflow找到的，非专业只管用就是了。<br>例子在上面已经有了,entrypoint里面进行wait,然后command里面执行最终要执行的命令。编译服务在启动之前要记住需要删除这个作为flag的done文件。</p>
<h3 id="mvn项目"><a href="#mvn项目" class="headerlink" title="mvn项目"></a>mvn项目</h3><p>mvn的项目和ant的是一个思路，一个编译服务，一个tomcat<br>配置结构:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── server.xml</span><br><span class="line">└── wait-for-file.sh</span><br></pre></td></tr></table></figure>

<p>docker-compose.yml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;2&#39;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  mvn-test-ios:</span><br><span class="line">    image: maven:3.2.3-jdk-7u65</span><br><span class="line">    volumes:</span><br><span class="line">    - ..&#x2F;..&#x2F;..&#x2F;hotdoc&#x2F;mobile&#x2F;test_ios:&#x2F;data&#x2F;:Z</span><br><span class="line">    - ~&#x2F;.m2&#x2F;:&#x2F;root&#x2F;.m2&#x2F;</span><br><span class="line">    entrypoint: |</span><br><span class="line">     bash -c &quot;rm -rf &#x2F;data&#x2F;done &amp;&amp; cd &#x2F;data &amp;&amp; mvn clean install -Dmaven.test.skip&#x3D;true &amp;&amp; echo &#39;############test_ios  mvn clean install is ok  ##############&#39; &amp;&amp; touch &#x2F;data&#x2F;done&quot;</span><br><span class="line"></span><br><span class="line">  tomcat-test-ios:</span><br><span class="line">    image: openweb&#x2F;oracle-tomcat:7-jre7</span><br><span class="line">    command: [&quot;bin&#x2F;catalina.sh&quot;, &quot;run&quot;]</span><br><span class="line">    depends_on:</span><br><span class="line">    - mvn-test-ios</span><br><span class="line">    entrypoint: &#x2F;tool&#x2F;wait-for-file.sh &#x2F;data&#x2F;done</span><br><span class="line">    environment:</span><br><span class="line">    - LANG&#x3D;zh_CN.UTF-8</span><br><span class="line">    - TZ&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;9001:800&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;wait-for-file.sh:&#x2F;tool&#x2F;wait-for-file.sh</span><br><span class="line">    - .&#x2F;server.xml:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;conf&#x2F;server.xml</span><br><span class="line">    - ..&#x2F;..&#x2F;..&#x2F;hotdoc&#x2F;mobile&#x2F;test_ios:&#x2F;data&#x2F;:Z</span><br></pre></td></tr></table></figure>

<p>思路和ant的一模一样,只不过编译服务器换成了mvn的，mvn编译时候需要下载过多的依赖，为了省事省时，做了个磁盘映射: ~/.m2/:/root/.m2/ 这样可以高效利用缓存，重启服务器也不会又要再次下载依赖了。</p>
<h3 id="react的项目"><a href="#react的项目" class="headerlink" title="react的项目"></a>react的项目</h3><p>以上项目是历史项目，不过最近做了一个完全前后端分离的的react为基础的项目。因为用到了react-router,所以需要对nginx做一些配置才能正常运行。后端的代码依然是基于java的,构建工具是maven。</p>
<p>配置结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── nginx.conf</span><br><span class="line">├── server.xml</span><br><span class="line">└── wait-for-file.sh</span><br></pre></td></tr></table></figure>

<p>docker-compose.yml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;2&#39;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  mvn-opeartion:</span><br><span class="line">    image: maven:3.2.3-jdk-7u65</span><br><span class="line">    volumes:</span><br><span class="line">    - ..&#x2F;..&#x2F;hotdoc&#x2F;operation&#x2F;lyshows:&#x2F;data&#x2F;:Z</span><br><span class="line">    - ~&#x2F;.m2&#x2F;:&#x2F;root&#x2F;.m2&#x2F;</span><br><span class="line">    entrypoint: |</span><br><span class="line">     bash -c &quot;rm -rf &#x2F;data&#x2F;done &amp;&amp; cd &#x2F;data &amp;&amp; mvn clean install -Dmaven.test.skip&#x3D;true &amp;&amp; echo &#39;############test_opeartion  mvn clean install is ok  ##############&#39; &amp;&amp; touch &#x2F;data&#x2F;done&quot;</span><br><span class="line"></span><br><span class="line">  tomcat-operation:</span><br><span class="line">    image: openweb&#x2F;oracle-tomcat:7-jre7</span><br><span class="line">    command: [&quot;bin&#x2F;catalina.sh&quot;, &quot;run&quot;]</span><br><span class="line">    entrypoint: &#x2F;tool&#x2F;wait-for-file.sh &#x2F;data&#x2F;done</span><br><span class="line">    environment:</span><br><span class="line">    - LANG&#x3D;zh_CN.UTF-8</span><br><span class="line">    - TZ&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;9003:800&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;wait-for-file.sh:&#x2F;tool&#x2F;wait-for-file.sh</span><br><span class="line">    - .&#x2F;server.xml:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;conf&#x2F;server.xml</span><br><span class="line">    - ..&#x2F;..&#x2F;hotdoc&#x2F;operation&#x2F;lyshows:&#x2F;data&#x2F;:Z</span><br><span class="line"></span><br><span class="line">  nginx:</span><br><span class="line">    image: nginx:stable-alpine</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">    - 7776:8888</span><br><span class="line">    - 443:443</span><br><span class="line">    links:</span><br><span class="line">    - tomcat-operation:backend</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf:ro</span><br><span class="line">    - ..&#x2F;..&#x2F;hotdoc&#x2F;operation&#x2F;frontEnd&#x2F;dist:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;dist</span><br></pre></td></tr></table></figure>

<p>nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes 1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_log   &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;</span><br><span class="line">pid         &#x2F;var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">    default_type application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">    &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main;</span><br><span class="line"></span><br><span class="line">    sendfile on;</span><br><span class="line">    #tcp_nopush on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout 65;</span><br><span class="line"></span><br><span class="line">    # 开启gzip</span><br><span class="line">    gzip on;</span><br><span class="line"></span><br><span class="line">    # 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line">    # gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明</span><br><span class="line">    gzip_comp_level 6;</span><br><span class="line"></span><br><span class="line">    # 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。</span><br><span class="line">    gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png;</span><br><span class="line"></span><br><span class="line">    # 是否在http header中添加Vary: Accept-Encoding，建议开启</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8888;</span><br><span class="line">        server_name &quot;&quot;;</span><br><span class="line">        root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;dist;</span><br><span class="line"></span><br><span class="line">        gzip_static on;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">          try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       location &#x2F;api &#123;</span><br><span class="line">            proxy_set_header  X-Real-IP  $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend:800&#x2F;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>server.xml是tomcat的配置，这里主要依托后端项目,但是这也不是重点，所以也不贴了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>目前docker和docker-compose主要是用在了公司的开发服务上面，3个月来主要是刚开始gitlab宕机了一次，重启之后数据毫无影响，整体体验还是非常不错的。<br>而且依托docker，这一套环境在几天之内就完全搭建起来，而且没有污染宿主机器环境，个人感觉非常不错。</p>
<h1 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h1><p>docker-compose内部容器访问宿主机器端口尚未找到办法。<br>PS: 在此文正式发布之前，已经找到了解决方案:那就是external_links选项;但是external_links存在的问题是两个容器之间必须有共通的网络才行，而默认使用docker启动的docker容器似乎是bridge，所以这里需要设置network选项为bridge才行。<br>当然，说了这么多，如果没有代码其实还是很不好理解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tomcat-operation:</span><br><span class="line">    image: openweb&#x2F;oracle-tomcat:7-jre7</span><br><span class="line">    command: [&quot;bin&#x2F;catalina.sh&quot;, &quot;run&quot;]</span><br><span class="line">    entrypoint: &#x2F;tool&#x2F;wait-for-file.sh &#x2F;data&#x2F;done</span><br><span class="line">    network_mode: &quot;bridge&quot;</span><br><span class="line">    environment:</span><br><span class="line">    - LANG&#x3D;zh_CN.UTF-8</span><br><span class="line">    - TZ&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;9003:800&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;wait-for-file.sh:&#x2F;tool&#x2F;wait-for-file.sh</span><br><span class="line">    - .&#x2F;server.xml:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;conf&#x2F;server.xml</span><br><span class="line">    - ..&#x2F;..&#x2F;hotdoc&#x2F;operation&#x2F;lyshows:&#x2F;data&#x2F;:Z</span><br><span class="line">    external_links:</span><br><span class="line">    - mysql:mysql</span><br><span class="line"></span><br><span class="line">  nginx:</span><br><span class="line">    image: nginx:stable-alpine</span><br><span class="line">    restart: always</span><br><span class="line">    network_mode: &quot;bridge&quot;</span><br><span class="line">    ports:</span><br><span class="line">    - 7776:8888</span><br><span class="line">    - 443:443</span><br><span class="line">    links:</span><br><span class="line">    - tomcat-operation:backend</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf:ro</span><br><span class="line">    - ..&#x2F;..&#x2F;hotdoc&#x2F;operation&#x2F;frontEnd&#x2F;dist:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;dist</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>docker-compse</tag>
      </tags>
  </entry>
  <entry>
    <title>node-buffer笔记</title>
    <url>/2016/11/06/node-buffer/</url>
    <content><![CDATA[<h1 id="Buffer是什么"><a href="#Buffer是什么" class="headerlink" title="Buffer是什么"></a>Buffer是什么</h1><p>Javascript十分善于操作字符串，但是它并不善于操作二进制数据，在Javascript语言中也没有任何二进制相关的数据结构。<br>但是当Javascript扩展到后端领域以后，数据库操作、图像操作、文件上传这类后端很常见的操作，都无法再依赖字符这种类型来进行操作了，所以Node实现了一个叫做Buffer的 <strong>二进制缓冲区</strong>。它的单位是 <strong>字节</strong>，可以 <strong>随机设置和获取缓冲区的数据</strong>。</p>
<h1 id="Buffer怎么用"><a href="#Buffer怎么用" class="headerlink" title="Buffer怎么用"></a>Buffer怎么用</h1><h2 id="创建一个缓冲区"><a href="#创建一个缓冲区" class="headerlink" title="创建一个缓冲区"></a>创建一个缓冲区</h2><h3 id="根据一个字符串创建一个Buffer缓冲区很容易"><a href="#根据一个字符串创建一个Buffer缓冲区很容易" class="headerlink" title="根据一个字符串创建一个Buffer缓冲区很容易"></a>根据一个字符串创建一个Buffer缓冲区很容易</h3><p>  <code style="margin-left: 2em;">语法: new Buffer(string[, encoding]) </code><br>但是node最近也在快速发展中，这个API在v6中遭到了废弃，所以在v6之后的版本中，使用以下语法<br>  <code style="margin-left: 2em;"> Buffer.from(string[, encoding])</code></p>
<p>这里encoding默认值为utf-8，其他的可选值还有asciii、base64等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Buffer.from(&quot;que01.top&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="创建一个指定空间的Buffer"><a href="#创建一个指定空间的Buffer" class="headerlink" title="创建一个指定空间的Buffer"></a>创建一个指定空间的Buffer</h3><p><code style="margin-left: 2em;">语法: new Buffer(size) </code><br>同样的，这个语法在v6之后废弃了，新的API：<br><code style="margin-left: 2em;">语法: Buffer.alloc(size[, fill[, encoding]]) </code></p>
<p>size:关于size的大小有以下规定</p>
<ul>
<li>size必须小于等于buffer.kMaxLength，在32位系统下它为(2^30)-1,64位系统下它为(2^31)-1</li>
<li>当size&lt;=0,将会创建一个size=0的buffer</li>
</ul>
<p>fill:预先填充的值，默认为0<br>encoding:编码</p>
<h2 id="Buffer的其他方法"><a href="#Buffer的其他方法" class="headerlink" title="Buffer的其他方法"></a>Buffer的其他方法</h2><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>我们可以将buffer还原为一个字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var buf &#x3D; Buffer.from(&quot;my webSite:que01.top&quot;)</span><br><span class="line">undefined</span><br><span class="line">&gt; buf.toString()</span><br><span class="line">&#39;my webSite:que01.top&#39;</span><br></pre></td></tr></table></figure>
<h3 id="toJSON"><a href="#toJSON" class="headerlink" title="toJSON"></a>toJSON</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var buf2 &#x3D; Buffer.from([1,2,3,4])</span><br><span class="line">undefined</span><br><span class="line">&gt; buf2.toJSON()</span><br><span class="line">&#123; type: &#39;Buffer&#39;, data: [ 1, 2, 3, 4 ] &#125;</span><br></pre></td></tr></table></figure>
<h3 id="indexOf-amp-amp-lastIndexOf"><a href="#indexOf-amp-amp-lastIndexOf" class="headerlink" title="indexOf &amp;&amp; lastIndexOf"></a>indexOf &amp;&amp; lastIndexOf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var buf &#x3D; Buffer.from(&quot;my webSite:que01.top&quot;)</span><br><span class="line">undefined</span><br><span class="line">&gt; buf.indexOf(&quot;que01&quot;)</span><br><span class="line">11</span><br><span class="line">&gt; var buf2 &#x3D; Buffer.from([1,2,3,4])</span><br><span class="line">undefined</span><br><span class="line">&gt; buf2.indexOf(2)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p><code style="margin-left: 2em;">语法: Buffer.concat(list[, totalLength]) </code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; let a &#x3D;  Buffer.from(&quot;我是：&quot;),</span><br><span class="line">      b &#x3D;  Buffer.from(&quot;张三&quot;);</span><br><span class="line">console.log(Buffer.concat([a,b],a.length+b.length).toSring())</span><br><span class="line">我是：张三    </span><br></pre></td></tr></table></figure>

<h1 id="暂结"><a href="#暂结" class="headerlink" title="暂结"></a>暂结</h1><p>暂时就这样吧。Buffer目前来说因为个人还是偏向Web开发，暂时也没有太多应用。更多的时间有机会我再来补充。</p>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>vim-notebook</title>
    <url>/2016/07/24/vim-notebook/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Vim的使用到如今算是有4年多了。期间断断续续也开始使用sublime，notepad+，atom，vscode等现代编辑器。<br>但是同vim相比，始终少了那种手指在键盘跳舞的感觉。即使很多时候，vim在完成特定任务时候效率有所不如。<br>但是vim完全依托键盘的理念，始终让我迷醉所以不忍心放弃，尤其是当YouCompleteMe和ternJs的出世，让vim在前端编程上渐渐赶上了IDE的功能。<br>然而我也仅仅是知道了很少很少部分的vim使用而已。<br>所以这里打算做记录一下。关于插件，关于配置，关于心得。</p>
<p>我还是执着的认为，各种编辑器层出不穷，但是Vim你完全可以使用一辈子。Geek的感觉，指尖跳舞的感觉，『怀古的情节』,还有专注的力量。</p>
<h1 id="从配置开始说起"><a href="#从配置开始说起" class="headerlink" title="从配置开始说起"></a>从配置开始说起</h1><p>我fork了一份github上star最多的vimrc配置。并做了自己的定义和修改。我尽量保持对原来配置的完整的情况进行定义，这样可以保证那一天我再想去merge大神配置时候不会出现太多的配置冲突。<br>这里是大神的配置<a href="https://github.com/amix/vimrc">amix/vimrc</a>,这里是我的配置<a href="https://github.com/que01/vimrc">que01/vimrc</a>.</p>
<p>虽然大神的配置千锤百炼，但是如果是同为前端的你话，那么还是更加推荐我自己的配置。毕竟作为一名一直紧追前沿的前端从业者,我也许更懂前端开发过程中需要怎样的体验。</p>
<p>个人的vimrc和amix/vimrc的安装还是有区别的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先是官方的安装走一遍</span></span><br><span class="line">git clone https://github.com/que01/vimrc ~/.vim_runtime &amp;&amp; cd ~/.vim_runtime &amp;&amp; sh install_awesome_vimrc.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 个人配置需要的</span></span><br><span class="line">git submodule init &amp;&amp; git submodule update</span><br><span class="line">cd sources_non_forked/YouCompleteMe &amp;&amp; sh install.sh</span><br><span class="line">cd sources_non_forked/vimproc &amp;&amp; make</span><br></pre></td></tr></table></figure>

<p>当然，如果你不想配置的，我自己做了一份docker的镜像，如果想多地共用，可以直接使用docker来替代本地的vim。==&gt; <a href="https://hub.docker.com/r/que01/docker-vim-tiny/">que01/docker-vim-tiny</a></p>
<p>这里列举一下自己新加入的插件:</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="#YoucompleteMe-amp-amp-tern-for-vim">YouCompleteMe</a></td>
<td align="left">vim补全神器top1</td>
</tr>
<tr>
<td align="left"><a href="#YoucompleteMe-amp-amp-tern-for-vim">tern for vim</a></td>
<td align="left">js语气补全引擎</td>
</tr>
<tr>
<td align="left">emmet</td>
<td align="left">emmet前端都知道</td>
</tr>
<tr>
<td align="left">vim-jsx</td>
<td align="left">react的jsx支持</td>
</tr>
<tr>
<td align="left">auto-pairs</td>
<td align="left">括号自动配对</td>
</tr>
<tr>
<td align="left">tabular</td>
<td align="left">对其代码</td>
</tr>
<tr>
<td align="left">vim-es6</td>
<td align="left">es6支持</td>
</tr>
<tr>
<td align="left">vim-markdown(替换了原来的)</td>
<td align="left">markdown支持</td>
</tr>
<tr>
<td align="left"><a href="#vim-youdao-translater">vim-youdao-translater </a></td>
<td align="left">有道翻译,这个还是超级好用!读源代码时候有这个东西如虎添翼</td>
</tr>
<tr>
<td align="left">vimshell</td>
<td align="left">在vim下进行shell操作。虽然没有zsh好用,但是可堪一用的</td>
</tr>
</tbody></table>
<h1 id="vim基础操作"><a href="#vim基础操作" class="headerlink" title="vim基础操作"></a>vim基础操作</h1><h2 id="vim的模式"><a href="#vim的模式" class="headerlink" title="vim的模式"></a>vim的模式</h2><ul>
<li>启动Vim后，vim在 Normal 模式下。</li>
<li>让我们进入 Insert 模式，请按下键 i 。此时vim左下角有一个–insert–字样,此时可以进行输入了</li>
<li>如果你想返回 Normal 模式，请按 ESC 键。</li>
</ul>
<h2 id="vim的移动"><a href="#vim的移动" class="headerlink" title="vim的移动"></a>vim的移动</h2><h3 id="简单的移动"><a href="#简单的移动" class="headerlink" title="简单的移动"></a>简单的移动</h3><pre>
j 向下                              k
k 向上                          h       l
l 向右                              j
h 向左
</pre>

<h3 id="复杂一点的移动"><a href="#复杂一点的移动" class="headerlink" title="复杂一点的移动"></a>复杂一点的移动</h3><table>
<thead>
<tr>
<th align="left">按键</th>
<th align="left">行为</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">数字零，到行头,本配置有修改,到当前行第一个字母</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">到本行行尾</td>
</tr>
<tr>
<td align="left">g_</td>
<td align="left">到本行最后一个不是blank字符的位置。</td>
</tr>
<tr>
<td align="left">/pattern</td>
<td align="left">搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）</td>
</tr>
</tbody></table>
<h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><p>y负责复制&amp;&amp;p负责粘贴</p>
<h2 id="Undo-Redo"><a href="#Undo-Redo" class="headerlink" title="Undo/Redo"></a>Undo/Redo</h2><p>u撤销 &amp; <C-r>重做。C-r是指Control+r</p>
<h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><table>
<thead>
<tr>
<th align="left">按键</th>
<th align="left">行为</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:q!</td>
<td align="left">退出不保存</td>
</tr>
<tr>
<td align="left">:wq</td>
<td align="left">保存并退出</td>
</tr>
<tr>
<td align="left">:qa!</td>
<td align="left">强行退出所有的正在编辑的文件，就算别的文件有更改</td>
</tr>
<tr>
<td align="left">:x</td>
<td align="left">相当于:wq但是仅在需要时候才保存</td>
</tr>
</tbody></table>
<h2 id="基础篇收尾"><a href="#基础篇收尾" class="headerlink" title="基础篇收尾"></a>基础篇收尾</h2><p>这就是基础的东西了，如果觉得不够的话，可以自行爬文<a href="http://coolshell.cn/articles/5426.html">《简明 Vim 练级攻略》</a>.这一小节的内容基本来源这里。<br>之所以不深入，原因在个人，这不是一篇小白文，主要面向用户主要是中级用户。</p>
<h1 id="个人配置快捷键-amp-amp-有用的按键"><a href="#个人配置快捷键-amp-amp-有用的按键" class="headerlink" title="个人配置快捷键&amp;&amp;有用的按键"></a>个人配置快捷键&amp;&amp;有用的按键</h1><p>这里包含两个部分的内容，一个是插件的快捷键绑定，一个比较有用的一些自带的按键,:开头的是命令。这里为了方便打字，按键都不打尖括号了。</p>
<table>
<thead>
<tr>
<th align="left">按键</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">loader+yd</td>
<td align="left">翻译光标所在单词</td>
</tr>
<tr>
<td align="left">ysw(</td>
<td align="left"><a href="#vim-surround">vim-surround</a>系列快捷键</td>
</tr>
<tr>
<td align="left">:Tab /=</td>
<td align="left">对其=号</td>
</tr>
<tr>
<td align="left">:TableFormat</td>
<td align="left">在markdown文档中格式化table</td>
</tr>
<tr>
<td align="left">loader+o</td>
<td align="left">打开buffer列表</td>
</tr>
<tr>
<td align="left">C+f</td>
<td align="left">ctrlP搜索,多次按下可以改变搜索规则</td>
</tr>
<tr>
<td align="left">C+l</td>
<td align="left">jsdoc激活，在js的function上方按下生成注释</td>
</tr>
<tr>
<td align="left">C+J</td>
<td align="left">ultisnips补全需要用到这个</td>
</tr>
<tr>
<td align="left">Tab&amp;S-Tab</td>
<td align="left">superTab的上下切换</td>
</tr>
<tr>
<td align="left">C-d</td>
<td align="left">多光标选中</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">高亮所有光标下单词,n,p上写切换</td>
</tr>
<tr>
<td align="left">gg</td>
<td align="left">跳到文件头部</td>
</tr>
<tr>
<td align="left">GG</td>
<td align="left">调到文件尾部</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">跳到当前行第一个字符</td>
</tr>
<tr>
<td align="left">I</td>
<td align="left">调到当前行首并设为插入状态</td>
</tr>
<tr>
<td align="left">A</td>
<td align="left">调到当前行末尾并设为插入状态</td>
</tr>
<tr>
<td align="left">dd</td>
<td align="left">删除当前行</td>
</tr>
<tr>
<td align="left">gG,g$</td>
<td align="left">删除光标到行末尾</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">删除当前行内容，但是不删除行</td>
</tr>
<tr>
<td align="left">dw</td>
<td align="left">删除一个单词</td>
</tr>
<tr>
<td align="left">yw</td>
<td align="left">复制一个单词</td>
</tr>
<tr>
<td align="left">:split</td>
<td align="left">水平切割窗口</td>
</tr>
<tr>
<td align="left">:vsplit</td>
<td align="left">垂直切割窗口</td>
</tr>
<tr>
<td align="left">:close</td>
<td align="left">关闭窗口</td>
</tr>
<tr>
<td align="left">H</td>
<td align="left">移动到可视区域最上一行</td>
</tr>
<tr>
<td align="left">L</td>
<td align="left">移动到可视区域最下一行</td>
</tr>
<tr>
<td align="left">M</td>
<td align="left">移动到可视区域中间</td>
</tr>
<tr>
<td align="left">:s/aa/bb/g</td>
<td align="left">光标所在行出现的所有包含 aa 的字符串中的 aa 替换为 bb</td>
</tr>
<tr>
<td align="left">:g/^$/d</td>
<td align="left">删除空行</td>
</tr>
<tr>
<td align="left">cib</td>
<td align="left">光标移动到括号按下，清除括号内部并设为插入</td>
</tr>
<tr>
<td align="left">cit</td>
<td align="left">同上 html标签内部</td>
</tr>
<tr>
<td align="left">ci’ &amp; ci”</td>
<td align="left">同上，单双引号</td>
</tr>
</tbody></table>
<h1 id="Vim插件"><a href="#Vim插件" class="headerlink" title="Vim插件"></a>Vim插件</h1><p>vim插件使用基本是本文的重点所在。当基本掌握了Vim之后，各种各样的Vim插件帮你实现各种IDE才可能具有的高级功能。可以大大提高个人效率和编辑体验.<br>本文挑重点写一下个人认为非常有用的插件。这些排名不代表优先级，排位仅仅是随兴所至。</p>
<h2 id="vim-youdao-translater"><a href="#vim-youdao-translater" class="headerlink" title="vim-youdao-translater"></a>vim-youdao-translater</h2><p>中文用户会知道有个东西叫做有道词典，IT程序🐶会知道有种东西叫做vim。当vim遇到有道词典，那确实是一件赏心悦目的事情。<br>空口无凭，上个图让大家看看实在的:<br><img src="/images/youdao.png" alt="youdao"><br>在本配置的中的使用方法：光标移动过去,然后按<code>< loader>yd</code>,如果你不知道什么是loader键，那我不解释了，直接说个人配置的是逗号键:,。<br>如果你不爱用我配置，那么安装好这个插件以后，在配置里加上如下代码即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">noremap &lt;leader&gt;yd :&lt;C-u&gt;Ydc&lt;CR&gt;</span><br></pre></td></tr></table></figure>

<h2 id="YoucompleteMe-amp-amp-tern-for-vim"><a href="#YoucompleteMe-amp-amp-tern-for-vim" class="headerlink" title="YoucompleteMe&amp;&amp;tern_for_vim"></a>YoucompleteMe&amp;&amp;tern_for_vim</h2><p>这两个放在一起写是有原因，因为作为前端，这两个插件是配合在一起才能发挥最大用途的。<br>不过在使用他们之前我们尚需要配置:</p>
<ol>
<li>cd <you project folder> &amp;&amp; touch .tern-project # 到项目文件夹下创建.tern-project</li>
<li>粘贴配置文件到.tern-project #配置可以去ternjs官网看文档</li>
</ol>
<p>个人一般通用的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;libs&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;browser&quot;</span>,</span><br><span class="line">    <span class="string">&quot;jquery&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里让不知道的童鞋看看它们结合的强大:<br><img src="/images/ycmd1.png" alt="ymcd1"><br><img src="/images/ycmd2.png" alt="ycmd2"><br>通过上面的代码可以看到,vim此时已经可以做到一定程度语意补全，即很多ide扯到的智能感知。<br>如果上面那两个图还没能说明什么，那么再看下面这个图，你会明白为什么说它是vim补全的top1:<br><img src="/images/ycmd3.png" alt="ycmd3"><br>就是这样,它不仅进行了补全，还智能识别了每个属性的值的类型。有了这两货，摆脱IDE真的不是什么梦了。</p>
<h2 id="vim-surround"><a href="#vim-surround" class="headerlink" title="vim-surround"></a>vim-surround</h2><p>vim-surround是个超级神器,如果说有些插件是长枪，一扫一大片的话，那么vim-surround可以说是弓箭，专攻一点。</p>
<p>添加括号(html标签中空格请忽视):</p>
<table>
<thead>
<tr>
<th align="left">start</th>
<th align="left">命令</th>
<th align="left">end</th>
</tr>
</thead>
<tbody><tr>
<td align="left">H*ello world</td>
<td align="left">ysw(</td>
<td align="left">H(ello) world</td>
</tr>
<tr>
<td align="left">H*ello world</td>
<td align="left">ysaw(</td>
<td align="left">(Hello) world</td>
</tr>
<tr>
<td align="left">H*ello world</td>
<td align="left">ys$(</td>
<td align="left">H(ello world)</td>
</tr>
<tr>
<td align="left">H*ello world</td>
<td align="left">ys2aw(</td>
<td align="left">(Hello world)</td>
</tr>
<tr>
<td align="left">Hello wo*rld</td>
<td align="left">yss(</td>
<td align="left">(Hello world)</td>
</tr>
<tr>
<td align="left">Hello wo*rld</td>
<td align="left">vlllllS(</td>
<td align="left">Hel(lo wor)ld)</td>
</tr>
<tr>
<td align="left">*Hello world</td>
<td align="left">VS</td>
<td align="left">&lt; p&gt;Hello world&lt; /p&gt;</td>
</tr>
</tbody></table>
<p>修改括号(html标签中空格请忽视):</p>
<table>
<thead>
<tr>
<th align="left">start</th>
<th align="left">命令</th>
<th align="left">end</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[H*ello world]</td>
<td align="left">cs[&lt; p&gt;</td>
<td align="left">&lt; p&gt;Hello world&lt;/ p&gt;</td>
</tr>
<tr>
<td align="left">&lt; p&gt;H*ello world&lt;/ p&gt;</td>
<td align="left">cst&lt; div&gt;</td>
<td align="left">&lt; div&gt;Hello world&lt;/ div&gt;</td>
</tr>
<tr>
<td align="left">&lt; div&gt;H*ello world&lt;/ div&gt;</td>
<td align="left">cst(</td>
<td align="left">(Hello world)</td>
</tr>
</tbody></table>
<p>删除括号:</p>
<table>
<thead>
<tr>
<th align="left">start</th>
<th align="left">命令</th>
<th align="left">end</th>
</tr>
</thead>
<tbody><tr>
<td align="left">(H*ello) world</td>
<td align="left">ds(</td>
<td align="left">Hello world</td>
</tr>
<tr>
<td align="left">&lt; p&gt;Hello world&lt;/ p&gt;</td>
<td align="left">dst</td>
<td align="left">Hello world))</td>
</tr>
</tbody></table>
<h2 id="tabular"><a href="#tabular" class="headerlink" title="tabular"></a>tabular</h2><p>tabular是一个用来对齐文本的插件，功能非常强大，对代码有洁癖和美观要求的人来说是非常实用的。<br>具体的官方文档可以看这里: <a href="http://vimcasts.org/episodes/aligning-text-with-tabular-vim/">官方文档</a></p>
<p>这个使用比较简单，视频里面的都可以用，不过最后的设置个人测试了一下似乎没有效果。</p>
<p>不过这个插件使用还是非常简单的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">one = <span class="number">1</span></span><br><span class="line">two = <span class="number">2</span></span><br><span class="line">three = <span class="number">3</span></span><br><span class="line">four = <span class="number">4</span>  </span><br><span class="line"><span class="comment">// :Tab /=</span></span><br><span class="line">&#123;</span><br><span class="line">        title: <span class="string">&quot;Aligning assignments&quot;</span></span><br><span class="line">        h264Src: <span class="string">&quot;/media/alignment.mov&quot;</span>,</span><br><span class="line">        oggSrc: <span class="string">&quot;/media/alignment.ogv&quot;</span></span><br><span class="line">        posterSrc: <span class="string">&quot;/media/alignment.png&quot;</span></span><br><span class="line">        duration: <span class="number">320</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// :Tab /:</span></span><br></pre></td></tr></table></figure>
<p>简单说就是运行 :Tab /&lt;分隔符号&gt;<br>当然，这么说不是最准确的表达，不过初步使用就这样理解无所谓了。</p>
<h2 id="vim-markdown"><a href="#vim-markdown" class="headerlink" title="vim-markdown"></a>vim-markdown</h2><p>vim-markdown依赖tabular。</p>
<p>下面是一些快捷键。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">]]: go to next header. &lt;Plug&gt;Markdown_MoveToNextHeader</span><br><span class="line"></span><br><span class="line">[[: go to previous header. Contrast with ]c. &lt;Plug&gt;Markdown_MoveToPreviousHeader</span><br><span class="line"></span><br><span class="line">][: go to next sibling header if any. &lt;Plug&gt;Markdown_MoveToNextSiblingHeader</span><br><span class="line"></span><br><span class="line">[]: go to previous sibling header if any. &lt;Plug&gt;Markdown_MoveToPreviousSiblingHeader</span><br><span class="line"></span><br><span class="line">]c: go to Current header. &lt;Plug&gt;Markdown_MoveToCurHeader</span><br><span class="line"></span><br><span class="line">]u: go to parent header (Up). &lt;Plug&gt;Markdown_MoveToParentHeader</span><br></pre></td></tr></table></figure>

<p>然而这个感觉平时不是很用得上，虽然可能上还是很有用的，不过我个人觉得还是表格格式化最有用:<br>使用 :TableFormat 可以将排版稀烂的表格格式化好,这里给个稀烂的例子</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|name|age|</span><br><span class="line">|zhangsan|15|</span><br><span class="line">|lisi|4|</span><br><span class="line">|wangerxiao|18|</span><br></pre></td></tr></table></figure>
<p>光标移动到这个table的区域内，运行上面的命令，即可将table格式化好.</p>
<h2 id="NERD-Tree"><a href="#NERD-Tree" class="headerlink" title="NERD Tree"></a>NERD Tree</h2><p>NERD Tree是最常用的插件了。就个人经验来说，它甚至是最常用的。</p>
<p>盗来的图,哈哈：<br><img src="https://raw.githubusercontent.com/yangyangwithgnu/use_vim_as_ide/master/pics/%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8.gif"></p>
<p>本配置中的开关项目树的方法: &lt; loader&gt; + nn</p>
<p>快捷键：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">o       在已有窗口中打开文件、目录或书签，并跳到该窗口</span><br><span class="line">go      在已有窗口 中打开文件、目录或书签，但不跳到该窗口</span><br><span class="line">t       在新 Tab 中打开选中文件/书签，并跳到新 Tab</span><br><span class="line">T       在新 Tab 中打开选中文件/书签，但不跳到新 Tab</span><br><span class="line">i       split 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gi      split 一个新窗口打开选中文件，但不跳到该窗口</span><br><span class="line">s       vsplit 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gs      vsplit 一个新 窗口打开选中文件，但不跳到该窗口</span><br><span class="line">!       执行当前文件</span><br><span class="line">O       递归打开选中 结点下的所有目录</span><br><span class="line">x       合拢选中结点的父目录</span><br><span class="line">X       递归 合拢选中结点下的所有目录</span><br><span class="line">e       Edit the current dif</span><br><span class="line"></span><br><span class="line">双击    相当于 NERDTree-o</span><br><span class="line">中键    对文件相当于 NERDTree-i，对目录相当于 NERDTree-e</span><br><span class="line"></span><br><span class="line">D       删除当前书签</span><br><span class="line"></span><br><span class="line">P       跳到根结点</span><br><span class="line">p       跳到父结点</span><br><span class="line">K       跳到当前目录下同级的第一个结点</span><br><span class="line">J       跳到当前目录下同级的最后一个结点</span><br><span class="line">k       跳到当前目录下同级的前一个结点</span><br><span class="line">j       跳到当前目录下同级的后一个结点</span><br><span class="line"></span><br><span class="line">C       将选中目录或选中文件的父目录设为根结点</span><br><span class="line">u       将当前根结点的父目录设为根目录，并变成合拢原根结点</span><br><span class="line">U       将当前根结点的父目录设为根目录，但保持展开原根结点</span><br><span class="line">r       递归刷新选中目录</span><br><span class="line">R       递归刷新根结点</span><br><span class="line">m       显示文件系统菜单</span><br><span class="line">cd      将 CWD 设为选中目录</span><br><span class="line"></span><br><span class="line">I       切换是否显示隐藏文件</span><br><span class="line">f       切换是否使用文件过滤器</span><br><span class="line">F       切换是否显示文件</span><br><span class="line">B       切换是否显示书签</span><br><span class="line"></span><br><span class="line">q       关闭 NerdTree 窗口</span><br><span class="line">?       切换是否显示 Quick Help</span><br></pre></td></tr></table></figure>

<h2 id="bufexplorer"><a href="#bufexplorer" class="headerlink" title="bufexplorer"></a>bufexplorer</h2><p>有了bufexplorer就可以浏览和管理buffer了。tab虽然也是vim中一个重要概念，但是个人还是更喜欢直接使用buffer而不用tab。</p>
<p>激活bufexplorer的快捷键是 &lt; loder&gt;+o;<br>激活以后是这样的:<br><img src="/images/buffer.png" alt="buffer"></p>
<p>我们是用jk进行上下移动，按d删除一个buffer，按enter进入光标所在的buffer。当我们编辑多个文件时候就是这样简单.</p>
<h2 id="ctrlp"><a href="#ctrlp" class="headerlink" title="ctrlp"></a>ctrlp</h2><p>用惯了sublime和atom的C-p吧？这个插件就是用来解决这个痛点(如果你没用试过但是有这个编辑器强烈推荐试试，如果没有就智能告诉你，这是一个项目内部模糊检索文件功能)，就算有NERD tree,但是如果你清晰记得文件名中某个单词，之间模糊检索会更快！</p>
<p>虽然C-p是默认的按键绑定，但是这份配置绑定到了C+f.初次使用需要检索全局文件项目很大就会比较慢，但是如果小项目几秒就好了。效果图是这样的:<br><img src="/images/ctrlP.png" alt="ctrlP"></p>
<h2 id="mru-vim"><a href="#mru-vim" class="headerlink" title="mru.vim"></a>mru.vim</h2><p>MRU是啥？Most Recently Used——最近打开最多的。这个插件倍整合到ctrlP了。如果想使用它，那么按下 C-f即可，当你多次按下C-f会在不同检索方式中切换，其中就会有MRU.</p>
<h2 id="vim-fugitive"><a href="#vim-fugitive" class="headerlink" title="vim-fugitive"></a>vim-fugitive</h2><p>好吧，vim绑上了git，这一定是在犯规！vim-fugitive是一个vim中使用git的wrapper——原谅我很不好翻译这个词汇.</p>
<p>基本使用:</p>
<table>
<thead>
<tr>
<th align="left">git</th>
<th align="left">fugitive</th>
<th align="left">action</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:Git checkout %</td>
<td align="left">:Gread</td>
<td align="left">将当前文件反转至上次的checkout状态</td>
</tr>
<tr>
<td align="left">:Git rm %</td>
<td align="left">:Gremove</td>
<td align="left">从Git中删除该文件，并且vim中也删除该文件的buffer</td>
</tr>
<tr>
<td align="left">:Git mv %</td>
<td align="left">:Gmove</td>
<td align="left">重命名当前的文件名以及对应的buffer名</td>
</tr>
<tr>
<td align="left">:Git commit</td>
<td align="left">:Gcommit</td>
<td align="left">提交，可以使用ctrl+n来补全</td>
</tr>
<tr>
<td align="left">:Git blame</td>
<td align="left">:Gblame</td>
<td align="left">查看当前文件每一行的最后一次修改都是谁完成的</td>
</tr>
<tr>
<td align="left">:Git status</td>
<td align="left">:Gstatus</td>
<td align="left">打开一个git status命令的窗口.Ctrl+n和Ctrl+p可以在文件中上下移动</td>
</tr>
</tbody></table>
<h3 id="Gstatus的内部命令"><a href="#Gstatus的内部命令" class="headerlink" title=":Gstatus的内部命令"></a>:Gstatus的内部命令</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">行为</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><Enter></td>
<td align="left">open current file in the window below</td>
</tr>
<tr>
<td align="left">p</td>
<td align="left">run <code>git add –patch</code> for current file</td>
</tr>
<tr>
<td align="left">C</td>
<td align="left">invoke :Gcommit</td>
</tr>
</tbody></table>
<h2 id="vim-jsdoc"><a href="#vim-jsdoc" class="headerlink" title="vim-jsdoc"></a>vim-jsdoc</h2><p>你不一定听过这个插件，但是一定听过sublime的DocBlockr。<br>什么？你没听说过？好吧，看下面的代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [foobar description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>baz [description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>quux [description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;[type]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foobar</span> (<span class="params">baz, quux</span>) </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>vim下没有DockBlockr,但是你猜到了，vim-jsdoc可以做到同样的事情，而且它可以做的更好——依托灵活的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;如果你只需要同DockBlockr一样的行为仅仅需要第一行配置</span><br><span class="line">nmap &lt;silent&gt; &lt;C-l&gt; ?function&lt;cr&gt;:noh&lt;cr&gt;&lt;Plug&gt;(jsdoc)</span><br><span class="line">&quot;加上这两行后会在底部ex命令行逐个提问类型 描述(推荐,好处是不需要自己移动光标去写了,而且更容易写出标准的注释)</span><br><span class="line">let g:jsdoc_allow_input_prompt&#x3D;1</span><br><span class="line">let g:jsdoc_input_description&#x3D;1</span><br></pre></td></tr></table></figure>

<h2 id="vim-easymotion"><a href="#vim-easymotion" class="headerlink" title="vim-easymotion"></a>vim-easymotion</h2><p>过千的star说明一切，这个插件给vim以更灵活的移动方式.定位单词不在需要按好多次jkhl。<br>本来想自己写下的，不过有人比我写的更好更细心，那么，就引用一下：<br><a href="http://www.wklken.me/posts/2015/06/07/vim-plugin-easymotion.html#1-wb">《VIM插件: EASYMOTION[快速跳转]》</a>;</p>
<h2 id="ultisnips"><a href="#ultisnips" class="headerlink" title="ultisnips"></a>ultisnips</h2><p>去除了snipmate，换了ultisnips，比snipmate更好的补全工具。配合vim-snippets以后，可以发挥非常大的作用，常用的代码补全都有了。</p>
<p>在本配置内的使用方式是： 输入短标记以后会出现下拉pop弹框，按tab切换到目标位置，然后按下&lt; c+j&gt;即可,具体如图，这是没有按下c-j。<br><img src="http://7xpovu.com1.z0.glb.cloudshelldn.com/ultisnip.png"><br>按下c-j马上就变成了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="supertab"><a href="#supertab" class="headerlink" title="supertab"></a>supertab</h2><p>这个插件就是用&lt; Tab&gt;来替换&lt; c-n&gt;的,&lt; S+Tab&gt;等同于&lt; s-p&gt;</p>
<h2 id="vim-multiple-cursors"><a href="#vim-multiple-cursors" class="headerlink" title="vim-multiple-cursors"></a>vim-multiple-cursors</h2><p>4k5的star,只能说sulime的&lt; c+d&gt;好用的不行。<br>这里做了一些配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let g:multi_cursor_use_default_mapping&#x3D;0</span><br><span class="line">&quot; Default mapping</span><br><span class="line">let g:multi_cursor_next_key&#x3D;&#39;&lt;C-d&gt;&#39;</span><br><span class="line">let g:multi_cursor_prev_key&#x3D;&#39;&lt;C-p&gt;&#39;</span><br><span class="line">let g:multi_cursor_skip_key&#x3D;&#39;&lt;C-x&gt;&#39;</span><br><span class="line">let g:multi_cursor_quit_key&#x3D;&#39;&lt;Esc&gt;&#39;&quot;</span><br></pre></td></tr></table></figure>
<p>按下&lt; c+d&gt;就可以像sublime里面一样任性的&lt; c+d&gt;了！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.d0u9.xyz/vimcha-jian-jie-shao-fugitive/">《vim插件介绍－Fugitive》</a>;<br><a href="http://www.wklken.me/posts/2015/06/07/vim-plugin-easymotion.html#1-wb">《VIM插件: EASYMOTION[快速跳转]》</a>;<br><a href="http://coolshell.cn/articles/5426.html">《简明 Vim 练级攻略》</a>.<br><a href="http://www.wklken.me/posts/2015/06/07/vim-plugin-multiplecursors.html">《VIM插件: MULTIPLE-CURSORS》</a>;</p>
]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2016/07/24/Promise/</url>
    <content><![CDATA[<h1 id="从-Deferred-说起"><a href="#从-Deferred-说起" class="headerlink" title="从$.Deferred()说起"></a>从$.Deferred()说起</h1><p>最早对Promise的理解是从网上了解到的，是jQuery内部的近似的实现，文章在这里:<a href="http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html">jQuery的deferred对象详解</a>.<br>其实说的就是deferred对象。虽然说平时很少刻意去实现deferred，但是却尝尝在$.ajax后面使用到deferred。虽然详细的可以直接去看上面那篇文章，毕竟写的具体，不过这里还是要简单扯一扯，避免单(yi)调(wang).</p>
<p>现在控制台跑一下看看$.Deferred对象内部方法:</p>
<p><img src="/images/Deferred.png" alt="$.Deferred"></p>
<p>deferred对象的最大优点，就是它把这一套回调函数接口，从ajax操作扩展到了所有操作。</p>
<p>这里copy一下他人的API翻译,和上文的图上方法比还是有缺失,不过暂时不打算补充(一来懒癌发作,二来这些就够将Deferred用起来了,到了不够用完全可以google之):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.Deferred() 生成一个deferred对象</span><br><span class="line">deferred.done() 指定操作成功时的回调函数</span><br><span class="line">deferred.fail() 指定操作失败时的回调函数</span><br><span class="line">deferred.promise() 没有参数时，返回一个新的deferred对象，该对象的运行状态无法被改变；接受参数时，作用为在参数对象上部署deferred接口。</span><br><span class="line">deferred.resolve() 手动改变deferred对象的运行状态为&quot;已完成&quot;，从而立即触发done()方法。</span><br><span class="line">deferred.reject() 这个方法与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为&quot;已失败&quot;，从而立即触发fail()方法。</span><br><span class="line">$.when() 为多个操作指定回调函数</span><br><span class="line">deferred.then(): 把done和fail结合写在一起了，传递两个回调函数即可。</span><br><span class="line">deferred.always(): 这个方法也是用来指定回调函数的，它的作用是，不管调用的是deferred.resolve()还是deferred.reject()，最后总是执行。</span><br></pre></td></tr></table></figure>

<p>用起Deferred实际上掌握上面几个方法就OK了。<br>这里修改一下参考文章的代码来举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span>(<span class="params">dtd</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dtd = $.Deferred(); <span class="comment">//在函数内部，新建一个Deferred对象</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> randomNum = <span class="built_in">Math</span>.random();</span><br><span class="line">      <span class="built_in">console</span>.log(randomNum);</span><br><span class="line">      <span class="keyword">if</span>(randomNum&gt;<span class="number">0.5</span>)&#123;</span><br><span class="line">        dtd.resolve();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dtd.reject();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,<span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">return</span> dtd.promise(); <span class="comment">// 返回promise对象</span></span><br><span class="line">&#125;;</span><br><span class="line">$.when(wait())</span><br><span class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">&quot;哈哈，成功了！&quot;</span>)&#125;)</span><br><span class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">&quot;出错啦！&quot;</span>)&#125;);</span><br></pre></td></tr></table></figure>

<p>就这一段代码就够展示怎么用了。done和fail就是一个钩子函数,关联到状态上，通过resolve和reject改变Deferred对象的状态，一旦状态改变就触发特定状态下的钩子上注册的函数。<br><strong>如果不能理解没关系，复制到控制台，跑两遍就明白怎么回事了。</strong></p>
<p>不过这玩意儿不是很好用，自己封装一下就OK了(就是下面的initDeferred函数)，这样就可以直接传入函数。就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initDeferred</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $.when((<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dtd = $.Deferred();</span><br><span class="line">    callback(dtd);</span><br><span class="line">    <span class="keyword">return</span> dtd.promise();</span><br><span class="line">  &#125;)())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如何使用:</span></span><br><span class="line"><span class="comment">// 1.定义一个函数时，内部使用状态修改</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">dtd</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> randomNum = <span class="built_in">Math</span>.random();</span><br><span class="line">      <span class="built_in">console</span>.log(randomNum);</span><br><span class="line">      <span class="keyword">if</span>(randomNum&gt;<span class="number">0.5</span>)&#123;</span><br><span class="line">        dtd.resolve();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dtd.reject();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 2.调用它</span></span><br><span class="line"><span class="keyword">var</span> d1 = initDeferred(test)</span><br><span class="line">d1.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">&quot;哈哈，成功了！&quot;</span>)&#125;)</span><br><span class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">&quot;出错啦！&quot;</span>)&#125;);</span><br></pre></td></tr></table></figure>
<p>这样就方便很多了，第一个函数设置Deferred别名，然后记住resolve和reject方法即可，非常简单！</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise是JavaScript异步操作解决方案。随着ES6标准的发布，它已经成为一个标准产物。<br>通过Promise，我们可以避免金字塔般的深度回调嵌套。它的工作原理和$.Deferred()其实是很类似的。</p>
<p>这里用Promise实现一下上面$.Deferred的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> randomNum = <span class="built_in">Math</span>.random();</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(randomNum&gt;<span class="number">0.5</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>,randomNum)</span><br><span class="line">      resolve();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;fail&quot;</span>,randomNum)</span><br><span class="line">      reject();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value,error</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;fail&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在$.Deferred对象里面有fail可以捕获错误，而Promise里面使用catch();它的用法和fail几乎一样，所以不再举例。<br>这里展示下Promise的原型：<br><img src="/images/promise.png"><br>除了提到的then和catch，还有个chain，看名称应该是链式操作用的。暂时还没用过。</p>
<p>除了原型上的方法，Promise对象还有自己私有的方法。<br>下面方法描述来自MDN:</p>
<blockquote>
<p><strong>Promise.all(iterable)</strong><br>返回一个promise对象，当iterable参数里所有的promise都被完成后，该promise也会被完成。<br><strong>Promise.race(iterable)</strong><br>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。<br><strong>Promise.reject(reason)</strong><br>调用Promise的rejected句柄，并返回这个Promise对象。<br><strong>Promise.resolve(value)</strong><br>用成功值value完成一个Promise对象。如果该value为可继续的（thenable，即带有then方法），返回的Promise对象会“跟随”这个value，采用这个value的最终状态；否则的话返回值会用这个value满足（fullfil）返回的Promise对象。</p>
</blockquote>
<p>Promise.all:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.all([a1,a2],<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;都执行完毕了&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.race:race和all有些不同,如果说all像是数组的every,那么Promise.race就像是数组的some.恩，这里抄一块代码看看：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `delay`毫秒后执行resolve</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timerPromisefy</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//console.log(delay)</span></span><br><span class="line">            resolve(delay);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任何一个promise变为resolve或reject 的话程序就停止运行</span></span><br><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">    timerPromisefy(<span class="number">1</span>),</span><br><span class="line">    timerPromisefy(<span class="number">32</span>),</span><br><span class="line">    timerPromisefy(<span class="number">64</span>),</span><br><span class="line">    timerPromisefy(<span class="number">128</span>)</span><br><span class="line">]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);    <span class="comment">// =&gt; 1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以把代码贴到浏览器.race仅仅会在第一次resolve之后触发回调。但是需要注意的是timerPromisefy却一共执行了4次，去掉console.log的注释就可以看到了。</p>
<p>API就是这几个，跑顺了几个DEMO之后似乎也没有什么值得说的了。想想还是深入一下尝试自己想办法简单实现这个ES6中Promise。这里仅仅实现resolve和inject好了，当然，为了可以用还有then也需要实现。</p>
<h1 id="暂结"><a href="#暂结" class="headerlink" title="暂结"></a>暂结</h1><p>本来打算谢谢node下的buldbird的，然而发现最终还是没能写下去。看来在node上还是要多练练。本篇就暂时到这里吧。等node实践多一些再回来补充。</p>
<p><span style="text-align:center;">— THE END —</span></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html">《jQuery的deferred对象详解》</a><br><a href="https://leohxj.gitbooks.io/front-end-database/content/jQuery/deferred-object.html">《Deferred对象》</a><br><a href="">《ECMAScript 6 入门》</a><br><a href="http://liubin.org/promises-book">《JavaScript Promise迷你书（中文版》</a></p>
]]></content>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端开发整理</title>
    <url>/2016/07/22/mobile-develop/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>基本概念有几个</p>
<ul>
<li>物理像素(physical pixel)</li>
<li>CSS像素</li>
<li>屏幕密度</li>
<li>设备像素比(device pixel ratio)</li>
</ul>
<h2 id="物理像素"><a href="#物理像素" class="headerlink" title="物理像素"></a>物理像素</h2><p>物理像素应该是到过最多的东西。这归功于厂商宣传的好：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">480P:480*320</span><br><span class="line">720P:1028*720</span><br><span class="line">1080P:1920*1080</span><br><span class="line">2K屏:2560*1440</span><br><span class="line"><span class="comment">#IOS</span></span><br><span class="line">4 4s:960*640</span><br><span class="line">5 5c 5s se:1136*640</span><br><span class="line">6 6s:1334*750</span><br><span class="line">6+ 6s+:1920*1080(1080P)</span><br></pre></td></tr></table></figure>

<h2 id="CSS像素"><a href="#CSS像素" class="headerlink" title="CSS像素"></a>CSS像素</h2><p>CSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。写过CSS的都会知道，这个就是px。</p>
<h2 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h2><p>屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算(PPI)。</p>
<h2 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设备像素比 ＝ 物理像素 &#x2F; 设备独立像素</span><br></pre></td></tr></table></figure>
<p>在javascript中，可以通过 <code>window.devicePixelRatio</code> 获取到当前设备的dpr。</p>
<p>在css中，可以通过<code>-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio</code>进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。</p>
<h1 id="移动设备调试"><a href="#移动设备调试" class="headerlink" title="移动设备调试"></a>移动设备调试</h1><p>移动端设备的调试一直是个比较困扰人的问题。不过好在已经有人对移动端的调试做了总结。具体可以参考这个GithubReop:<a href="https://github.com/jieyou/remote_inspect_web_on_real_device">jieyou/remote_inspect_web_on_real_device</a></p>
<p>文中提到的内容有以下内容(内容来自上诉repo),基本已经涵盖了各种环境下的调试，包括浏览器，微信，webView——可见作者确实非常有经验:</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">关键点</th>
<th align="left">实现难度<em>小</em> 为佳）</th>
<th align="left">调试效果<em>大</em> 为佳）</th>
<th align="left">可用的桌面设备</th>
<th align="left">可用的移动设备及可调试的浏览器</th>
</tr>
</thead>
<tbody><tr>
<td align="left">spy-debugger (简化weinre配置，支持https)</td>
<td align="left">需要桌面设备和移动设备同一网段</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">PC、MAC</td>
<td align="left">全部</td>
</tr>
<tr>
<td align="left">调试Android上的Chrome</td>
<td align="left">需要翻墙</td>
<td align="left">2</td>
<td align="left">4</td>
<td align="left">PC、MAC</td>
<td align="left">Android上的Chrome</td>
</tr>
<tr>
<td align="left">调试Android APP里的webview</td>
<td align="left">需要翻墙</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">PC、MAC</td>
<td align="left">Android APP里的webview</td>
</tr>
<tr>
<td align="left">调试Android上的x5内核（微信等）</td>
<td align="left">安装较为繁琐</td>
<td align="left">3</td>
<td align="left">5</td>
<td align="left">PC、MAC</td>
<td align="left">Android上的应用了x5内核的app，如微信、手Q、QQ浏览器等</td>
</tr>
<tr>
<td align="left">调试Android上的UC</td>
<td align="left">需要桌面设备和移动设备同一网段</td>
<td align="left">1</td>
<td align="left">3</td>
<td align="left">PC、MAC</td>
<td align="left">Android上的UC</td>
</tr>
<tr>
<td align="left">调试iOS上的Safari</td>
<td align="left">需要MAC（甚至可以无需iOS设备）</td>
<td align="left">2</td>
<td align="left">4</td>
<td align="left">MAC</td>
<td align="left">iOS上的Safari</td>
</tr>
</tbody></table>
<h1 id="移动端适配方案"><a href="#移动端适配方案" class="headerlink" title="移动端适配方案"></a>移动端适配方案</h1><p>写之前寻找了下有没有更具体系统的资料，毕竟如果有更系统的资料可以起到很好的借鉴作用。最后发现还是这篇比较系统:<a href="http://html-js.com/article/MobileWeb">MobileWeb</a></p>
<p>综合来说，是这几种可行方案。</p>
<ul>
<li>固定高度，宽度自适应</li>
<li>固定宽度，viewport缩放</li>
<li>rem做宽度，viewport缩放</li>
</ul>
<p>具体的细节这里就不具体写了，可以去爬文查看。这里仅仅对实现的原理进行部分总结。有了这个原理就可以做到心中有谱，知道每种方案是怎么回事。</p>
<h2 id="固定高度，宽度自适应"><a href="#固定高度，宽度自适应" class="headerlink" title="固定高度，宽度自适应"></a>固定高度，宽度自适应</h2><p>固定高度几乎是从PC端转移动端切图时候瞬间就会想到的方案：</p>
<ol>
<li>PC端早有百分比布局的实践</li>
<li>高度可以写死来避免高度不能使用百分比的问题</li>
</ol>
<h2 id="固定宽度，viewport缩放"><a href="#固定宽度，viewport缩放" class="headerlink" title="固定宽度，viewport缩放"></a>固定宽度，viewport缩放</h2><p>固定宽度这个是将viewport的width写死来实现的。设计图、页面宽度、viewport width使用一个宽度，浏览器帮我们完成缩放。单位使用px即可。<br>这个方案的优点嘛，设好了这块以后，可以完全按照PC端切图的经验来，单位完全可以使用px。<br>不过不足之处上，原文可能没有指出:在这种方案下做的页面可以相对省事的适配好各种屏幕，但是除了生硬的缩放外和由此来的模糊外，还有一个缺陷是无法做响应式，因为PC端并不认viewport.</p>
<h2 id="rem做宽度，viewport缩放"><a href="#rem做宽度，viewport缩放" class="headerlink" title="rem做宽度，viewport缩放"></a>rem做宽度，viewport缩放</h2><p>这个方案是个人最看好的方案。或者是因为对rem充满好感的缘故。<br>下面是引用的秒速</p>
<blockquote>
<p>依照某特定宽度设定 rem 值（即 html 的 font-size），页面任何需要弹性适配的元素，尺寸均换算为 rem 进行布局；当页面渲染时，根据页面有效宽度进行计算，调整 rem 的大小，动态缩放以达到适配的效果。利用该方案，还可以根据 devicePixelRatio 设定 initial-scale 来放大 viewport，使页面按照物理像素渲染，提升清晰度。</p>
</blockquote>
<p>个人最喜欢的还是 <strong>rem做宽度，viewport缩放</strong> 。适配这个东西，算是移动端入门第一步，有了理论打基础整个开发才可能达到得心应手的程度。</p>
<h1 id="REM技术实现方案"><a href="#REM技术实现方案" class="headerlink" title="REM技术实现方案"></a>REM技术实现方案</h1><p>目前来说rem方案里面淘宝的<a href="https://github.com/amfe/lib-flexible">amfe/lib-flexible</a>比较出名，而且是实践总结，所以坑相对也会平坦一些。</p>
<p>不过如果不用淘宝的方案，其实自己也可以写js替代它，这是目前个人用过的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> docEl = doc.documentElement</span><br><span class="line">    <span class="keyword">var</span> designWidth = <span class="number">750</span>   <span class="comment">// 设计稿宽度</span></span><br><span class="line">    <span class="keyword">var</span> baseWidth = <span class="number">320</span>     <span class="comment">// 如果 clientWidth 取不到值，给个最小宽度值</span></span><br><span class="line">    <span class="keyword">var</span> baseFontSize = <span class="number">100</span>  <span class="comment">// Rem 计算基础值，我这里给 100</span></span><br><span class="line">    <span class="keyword">var</span> giveBaseWidth = <span class="number">480</span></span><br><span class="line">    <span class="keyword">var</span> giveBaseFontSize = (giveBaseWidth/designWidth)*baseFontSize</span><br><span class="line">    <span class="keyword">var</span> resizeEvt = <span class="string">&#x27;orientationchange&#x27;</span> <span class="keyword">in</span> win ? <span class="string">&#x27;orientationchange&#x27;</span> : <span class="string">&#x27;resize&#x27;</span></span><br><span class="line">    recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> clientWidth = docEl.clientWidth || baseWidth</span><br><span class="line">        <span class="keyword">if</span> (clientWidth &gt; designWidth) clientWidth = designWidth</span><br><span class="line">        <span class="keyword">var</span> fontSize = (baseFontSize*clientWidth/designWidth)</span><br><span class="line">        fontSize = fontSize &gt;= giveBaseFontSize ? giveBaseFontSize : fontSize</span><br><span class="line">        docEl.style.fontSize = fontSize + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    doc.addEventListener</span><br><span class="line">      &amp;&amp;</span><br><span class="line">    (</span><br><span class="line">      win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>),</span><br><span class="line">      doc.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, recalc, <span class="literal">false</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>把它加入到head头部就好。然后编辑器设置base值，将px统一手动转换成rem也好，使用编辑器插件也好，总之转换过来就ok了。<br>不过说实话，每次加这个&amp;&amp;转换也是比较烦的事情，所以如果使用的webpack方案，可以使用 <strong>px2rem-webpack-plugin</strong> 补丁，这个补丁依赖了html-webpack-plugin，所以如果用了它可以不用自己在安装一次了。</p>
<p>这里简单copy一下文档，归结一下使用方法,具体使用姿势：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">var Px2remWebpackPlugin &#x3D; require(&#39;px2rem-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">var webpackConfig &#x3D; &#123;</span><br><span class="line">  entry: &#39;app.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: &#39;dist&#39;,</span><br><span class="line">    filename: &#39;[hash].app.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(),</span><br><span class="line">    new Px2remWebpackPlugin(&#123;originScreenWidth: 750&#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后生成的html里面是类似这样的:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.documentElement.style.fontSize = <span class="number">100</span> * innerWidth / <span class="number">320</span> + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"><span class="javascript">  addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">       <span class="built_in">document</span>.documentElement.style.fontSize = <span class="number">100</span> * innerWidth / <span class="number">320</span> + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"><span class="javascript">       <span class="built_in">window</span>.unit = <span class="number">100</span> * innerWidth / <span class="number">320</span>;</span></span><br><span class="line"><span class="javascript">       <span class="keyword">var</span> e = <span class="built_in">document</span>.createEvent(<span class="string">&#x27;Event&#x27;</span>);</span></span><br><span class="line"><span class="javascript">       e.initEvent(<span class="string">&#x27;adjustReady&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">       <span class="built_in">window</span>.dispatchEvent(e);</span></span><br><span class="line">    &#125;, 480);</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  addEventListener(<span class="string">&#x27;orientationchange&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.documentElement.style.fontSize = <span class="number">100</span> * innerWidth / <span class="number">320</span> + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line">      &#125;, 480)</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;6062412d2f3140cc3dd0.app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>原理和上面差不多,只不过是自动帮你插入代码到了html里面。originScreenWidth: 750这个是设置设计图的宽度。<br>这个插件怎么说呢，初看，单页的话似乎用途也不太大。但是，它最大的用途其实是将css里面的px转换成rem，这样就不需要依赖编辑器的转换了。</p>
<h1 id="关于HOTCSS"><a href="#关于HOTCSS" class="headerlink" title="关于HOTCSS"></a>关于HOTCSS</h1><p>实际上hotcss这小节应该列入rem技术方案那儿的。不过想了想还是把它挪出来单独写了。github地址：<a href="https://github.com/imochen/hotcss">hotcss</a>。</p>
<p>主要优势：</p>
<ul>
<li>保证不同设备下的统一视觉体验。</li>
<li>不需要你再手动设置viewport，根据当前环境计算出最适合的viewport。</li>
<li>支持任意尺寸的设计图，不局限于特定尺寸的设计图。</li>
<li>支持单一项目，多种设计图尺寸，专为解决大型，长周期项目。</li>
<li>提供px2rem转换方法，CSS布局，零成本转换，原始值不丢失。</li>
<li>有效解决移动端真实1像素问题。</li>
</ul>
<p>恩，谈这个之前，还是得感叹一下，前端发展的实在太快了。当我还在使用px2rem很快乐的时候，更先进的东西就不期而至了。<br>hotcss的readme写了以上的优势，但是并没有说，是针对 <strong>谁</strong> 的优势，但是想想，实际上它针对的，就是上面写到的rem方案。hotcss是上面rem方案的加强版，官方说是 <strong>移动端布局终极解决方案</strong>，其实也没什么错，就目前来说，这已经最先进的rem方案。</p>
<p>具体的使用使用方法，由于是国内的开源项目，是中文文档，就不再复制了。</p>
<h1 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h1><p>本来到了上章就讲完了。奈何，前端发展太快，我们又有了新的选择。<br>那就是组件化开发。这个讲起来就相对复杂一些。主要的技术栈是两个:<strong>Vue + webpack + vue-router</strong> &amp;&amp; <strong>React+webpack+react-router</strong>。简单说，是Vue体系和React体系。</p>
<p>Vue体系下我认为最好的组件库是<a href="https://github.com/airyland/vux">Vux</a>,因为它足够全面，基本上能想到的组件，难以实现的组件的，它都做好了。怎么说这个全呢？有一次我做一个类似淘宝的快递进度条这个，去看vux的组件库，它都做好了。我认为它是最强的移动端组件库了。这是<a href="https://vuxjs.gitbooks.io/vux/content/">文档地址</a></p>
<p>React体系下的移动端UI库，国内我认为最好的应该是<a href="https://mobile.ant.design/docs/react/introduce">Antd Mobile</a>了,延续了ant的文档风格，常见的组件基本都有了,不过相比vux,它的组件丰富程度确实只能算是一般。</p>
<p>就Vue体系来讲,使用<a href="https://github.com/vuejs/vue-cli">vue-cli</a>是一个非常棒的选择，如果是React,阿里加的<a href="https://github.com/dvajs/dva-cli">dva-cli</a>认真讲其实非常不错。不过，就我个人看法来说vue-cli就是比较国际范儿，功能全面支持多种手脚架；相对来说dva-cli就要差一些，不过他对React的redux逻辑封装的非常好，最新的版本都可以生成model了。</p>
<p>不过，如果使用vue-cli也好，dva-cli也好，他们本身都是不带router的，所以，你需要自己去集成它。router+webpack，是按需加载的必要项目，如果你用它们做移动端项目，项目稍大一点，这就是必选项。</p>
<div style="text-align:center;">--------------------- THE END ---------------------</div>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://github.com/riskers/blog/issues/18">移动端适配方案(下) </a></p>
]]></content>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>web性能优化</title>
    <url>/2016/07/17/web-performance/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在写这篇文章以前在个人做过的优化基础和认知基础上，查阅了众多文章。毕竟要写个什么就得认真点弄，这些文章在最后将会一一指出出处。性能优化是个很广泛的命题，这点必须承认。</p>
<p>前端作为网站的面子工程建设者，很大程度上承担了性能优化的重担，但是这不是全部，网站的性能优化做好了前端的优化之后，优化方向就慢慢跑到底层去了——比如:<b style="color:red">HTML&amp;JS&amp;CSS&amp;IMG-&gt;HTTP-&gt;TCP-&gt;DNS</b> 这个路径。</p>
<p>写到这个路径这里，我也算是有个写作路径了，就按这个路径来写。</p>
<h1 id="优化纬度"><a href="#优化纬度" class="headerlink" title="优化纬度"></a>优化纬度</h1><h2 id="HTML-amp-JS-amp-CSS-amp-IMG优化"><a href="#HTML-amp-JS-amp-CSS-amp-IMG优化" class="headerlink" title="HTML&amp;JS&amp;CSS&amp;IMG优化"></a>HTML&amp;JS&amp;CSS&amp;IMG优化</h2><p>HTML&amp;JS&amp;CSS&amp;IMG这个层面上东西不少，核心的一条里面就有体积。因为体积决定了速度。不过这些都不算全部，一个个整理一下。<br><b style="color:red"><br>个人以为:HTML&amp;JS&amp;CSS&amp;IMG这个层面上的优化绝对是在考验一个前端基本的修养，这是本职。其他方面的东西，可以算是一个前端的综合面面观吧。<br></b></p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML据说可以优化的地方很多，比如这里的介绍: <a href="http://www.kancloud.cn/kancloud/web_performance_optimization/80992"><strong>飞机</strong></a>,但是就个人做过的优化体验来说HTML上面可以玩的文章不算多。这里按权重到低列举一下:</p>
<ol>
<li><strong>压缩:</strong> 前端优化说穿了就一句:速度。体积是速度的第一道保障。选一个好的压缩工具然后压缩pre之外的一切是不会错的。</li>
<li><strong>CSS置顶和JS置尾:</strong> css置顶可以更快渲染页面，页面不会载入初期出现无样式的难看样子，置尾JS这个一来为了更快渲染DOM防止js载入阻塞了HTML，二来是多数JS代码依赖DOMReady，过早载入js会导致部分js执行报错、失效。</li>
<li><strong>外部js和css:</strong> 这个有利于充分利用缓存，使得js和css不会因为html变化失效重新请求占用带宽和时间。</li>
<li><strong>指定图片大小:</strong> 可以减少页面的重排。</li>
<li><strong>使用相对URL:</strong> 使用相对路径的好处有几个，一个是可以减少路径长度，一个则是对工程化有非常大的便利程度，相对路径有利于自动化工具找到引用的文件。</li>
<li><strong>删除注释:</strong> 这个似乎不用说太多。更少的注释代表更少的带宽和更快的速度，不过大多数时候这个无足重轻，注释在HTML中个人认为占用不会达到1%。不过这实在一个很容易做到的优化措施。</li>
<li><strong>减少HTML标签嵌套深度:</strong> PC端这不是一个问题，但是在移动端这是一个行之有效的优化方案。</li>
</ol>
<h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><p>早期项目不大要求不高时候JS效率差点其实无所谓，因为js根本就没多少行。但是随着越来越多的前端主导团队出现，SPA的盛行，项目js早就开始实现从KB向MB跨越了。还是托了GZIP的福，让那些动不动上MB的JS可以压缩到200K以内，要不然很多很多项目根本过不了上线审核。</p>
<p>言归正传，现在说说JS相关，JS性能优化有很多，但是这里只列举一些比较重要的。依旧按按权重到低列举:</p>
<ol>
<li><strong>压缩:</strong> 至少在网速没有实现质的突破和移动流量变得廉价之前，优化的权重个人认为首推的还是体积。更小体积就是更快的速度，js压缩一遍再上线应当作为必经道路</li>
<li><strong>combo:</strong> 这玩意是说合并。每个请求背后都经历着DNS解析-&gt;TCP三次握手-&gt;HTTP传输的路径，压缩可以显著减少重复和浪费，尤其是一些早期单个页面引入JS数量达到10+的项目。</li>
<li><strong>减少操作DOM:</strong></li>
</ol>
<ul>
<li>缓存已经访问过的元素；</li>
<li>使用 DocumentFragment 暂存 DOM，整理好以后再插入 DOM 树；</li>
<li>操作 className，而不是多次读写 style；</li>
<li>避免使用 JavaScript 修复布局。</li>
</ul>
<ol start="4">
<li><strong>ajax缓存:</strong> Make AJAX cacheable是YSlow一个检测项目。Optimizing AJAX responses is important to improve performance(优化ajax请求对提高性能是重要的)。ajax更多是304协商缓存，但是个人认为已经足够。至于200(from cache)强缓存嘛，如果服务端做好Cache-Control或者Expires配置，那更是极好的。 <strong>使用这个措施，jQuery的ajaxSetup就要打开缓存了。</strong></li>
<li><strong>高效的事件处理:</strong></li>
</ol>
<ul>
<li>减少绑定事件监听的节点，如通过事件委托；</li>
<li>尽早处理事件，在 DOMContentLoaded 即可进行，不用等到 load 以后。</li>
<li>节流函数限制mousemove,scroll等触发频次太高的事件触发次数</li>
</ul>
<ol start="6">
<li><strong>Ajax通过GET发出:</strong> Use GET for AJAX requests同样是是YSlow一个检测项目。</li>
</ol>
<ul>
<li>POST发Ajax请求需要两步：1.发送http头文件 2.发送数据</li>
<li>GET发Ajax仅有一步，但是会带上cookie。YSlow说IE的url长度最大2kb，这时注意不能用GET——不过通过浏览器地址栏输入地址那叫做Ajax吗？这点我有时间测试一下(<b style="color:red">TODO</b>)。</li>
</ul>
<ol start="7">
<li><strong>JS并行加载:</strong> jQuery走过来的人肯定遇到过js顺序换个就报错的事情，这是因为HTML从上到下执行，一个js载入完成之前不会载入它下面的js(下载过程中会阻塞下面的下载和渲染)。如果js过多的话这就会造成过多的时间被白白浪费。但是一定的技术方案是可以同时实现依赖和并行下载的问题的，比如Lab.js。</li>
</ol>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>CSS研究的不深入，下面是自己可以想到的全部了：</p>
<ol>
<li><strong>压缩:</strong> 减少体积</li>
<li><strong>合并:</strong> 减少HTTP</li>
<li><strong>雪碧图:</strong> 减少HTTP</li>
<li><strong>拆分&amp;按需加载:</strong> 尽量减少无用的css</li>
<li><strong>选择器优化:</strong> 研究的不深入就不献丑了，个人认为大头是层级嵌套这类。</li>
</ol>
<h2 id="IMG"><a href="#IMG" class="headerlink" title="IMG"></a>IMG</h2><ol>
<li><strong>不用图片:</strong> 体积的节省不如直接不用，很多简单的图可以用css实现的就别用图片了。另外SVG也可以用来替代图片了。</li>
<li><strong>优化图片格式:</strong> 比如说:webP。这个可以视为压缩的更优方案。更小体积更多细节。</li>
<li><strong>压缩:</strong> 这个不用说吧？</li>
<li><strong>合并</strong> 雪碧图，不要问我雪碧图是啥</li>
<li><strong>合适的尺寸:</strong> 不要用100*100的图缩放成10*10的</li>
<li><strong>多域名:</strong> 浏览器对单个域名下的请求并发数是有限制的(参考TCP下的图表,<a href="/2016/07/17/web-performance/#TCP%E4%BC%98%E5%8C%96"><b style='color:red'>GO</b></a>)，如果是图片量很多的页面，需要考虑使用多域名。这个可以参考百度图片</li>
</ol>
<p>图片优化无关但是和图片有关的：</p>
<ol>
<li>懒加载</li>
<li>Gzip</li>
<li>CDN</li>
<li>缓存</li>
</ol>
<h1 id="HTTP优化"><a href="#HTTP优化" class="headerlink" title="HTTP优化"></a>HTTP优化</h1><p>http优化这块呢，就一个原则吧：<br><b style="color:red">越少越好,越小越好,越快越好</b></p>
<h2 id="越少越好"><a href="#越少越好" class="headerlink" title="越少越好"></a>越少越好</h2><p>这个就是要减少请求数量了。<br>主要是下么几个方面：</p>
<ul>
<li><strong>js&amp;css&amp;img合并:</strong> 这个在上面已经有提到。</li>
<li><strong>做好强缓存方案:</strong> 强缓存(200 from cache)是当代web优化的重中之重吧。为了实现这个目的，一定要配置好响应头的Cache-Control&amp;Expires(可以参考上一篇<a href="/2016/07/15/http-cache/">《错配的nginx——web缓存问题探究》</a>)。如果不写这个到响应头,很多坑比的事情会找上你。</li>
<li><strong>Ajax缓存:</strong> 做好服务端优化这个不少地方也是可以实现强缓存而不需要多次请求的。</li>
<li><strong>正确设置src属性</strong> 空的src属性，会被浏览器指向前页面所在目录。</li>
</ul>
<h2 id="越小越好"><a href="#越小越好" class="headerlink" title="越小越好"></a>越小越好</h2><ul>
<li><strong>js&amp;css&amp;img压缩:</strong> 压缩能减少体积这个地球人都知道。</li>
<li><strong>Gzip</strong> 这个东西嘛,说实话,多数时候比你进行js&amp;css&amp;img压缩更加简单高效。<b style="color:red">Gzip绝对是重量级的东西(200 from cache强缓存也是重量级的东西，他们一个从根源上解决请求，一个解决请求中的传输大小，做好这两个往往比你费尽心思做的其他所有的优化更加管用&amp;省事)</b>。</li>
</ul>
<h2 id="越快越好"><a href="#越快越好" class="headerlink" title="越快越好"></a>越快越好</h2><p>就三个字母:CDN</p>
<h1 id="TCP优化"><a href="#TCP优化" class="headerlink" title="TCP优化"></a>TCP优化</h1><ol>
<li><strong>同一域名下的TCP连接的限制:</strong> CDN和单独的图片空间和避开这个限制提高并行下载速度，但是过多域名会造成DNS解析时间的开销。</li>
<li><strong>一定要减少404:</strong> 上面说了TCP限制的事情，，而404本身就会占用一个TCP链接。这就和有数几条运输公路堵了1条一样，如果404更多的话，那岂不是就三四条路动不动堵车一样。。。</li>
</ol>
<p><strong>补充:</strong> 下面是网上找到的TCP数量资料(<a href="http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">Roundup on Parallel Connections</a>),数据不是很新，但是可以参考一下。</p>
<table>
<thead>
<tr>
<th align="left">Browser</th>
<th align="left">HTTP/1.1</th>
<th align="left">HTTP/1.0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IE 6,7</td>
<td align="left">2</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">IE 8</td>
<td align="left">6</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">Firefox 3</td>
<td align="left">6</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">Safari 3,4</td>
<td align="left">4</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">Chrome 4+</td>
<td align="left">6</td>
<td align="left">?</td>
</tr>
<tr>
<td align="left">iPhone 4</td>
<td align="left">4</td>
<td align="left">?</td>
</tr>
<tr>
<td align="left">Opera 10.51+</td>
<td align="left">8</td>
<td align="left">?</td>
</tr>
</tbody></table>
<h1 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h1><p>DNS优化说实话个人没有做过，不过写到这里还是去了解了一下:<br>一般来说，在前端优化中与 DNS 有关的有两点：一个是减少DNS的请求次数，另一个就是进行DNS预获取。</p>
<h2 id="减少请求数量"><a href="#减少请求数量" class="headerlink" title="减少请求数量"></a>减少请求数量</h2><p>减少请求数量这个东西其实和提升TCP并发是相爱相杀的关系。这表现在:</p>
<ul>
<li>越少的域名代表越少的DNS请求</li>
<li>越多的域名代表着越多的并发</li>
<li>而我们想要的是：更少的DNS请求和更多并发</li>
</ul>
<p>这样就没得整了，大多数方案都是整个平衡，将域名限制在2-4之间。<br>然而淘宝跳出来说：我有钱我任性，我的资产一个域名装不下：<br><img width=200 src="/images/domainNum.png"/><br>好吧，淘宝牺牲了DNS访问请求来保证并发了，好了，你现在知道淘宝为什么要做 <a href="http://www.alidns.com/">阿里DNS</a>了吧？相应的，还有”马化腾DNS”和”李寥宏DNS”，你们现在知道为嘛要有这个吗？</p>
<p>不过除了自建DNS服务器，淘宝还在首页用到了DNS Prefetch，就是下面这货，算是取了个很好的平衡。</p>
<h2 id="预获取"><a href="#预获取" class="headerlink" title="预获取"></a>预获取</h2><p>淘宝网站首页用到了这个DNS优化:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//g.tbcdn.cn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//g.alicdn.com&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//tce.alicdn.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个就是预先获取的实现方式了，具体的可以点参考文章了解更多，或者直接这里：<a href="http://www.itechzero.com/first-of-front-end-series-dns-prefetch-increase-load-speed.html">1-2-3——走你！</a>。</p>
<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p>DNS也是有缓存，它定义了DNS在服务器上的存活时间。<br>当地址栏敲下网址按下Enter，浏览器就开始使用DNS来进行网址解析，这个路径往往是这样的浏览器缓存-&gt;本机缓存-&gt;路由器缓存-&gt;ISP DNS-&gt;根服务器递归搜索。</p>
<p><strong>浏览器DNS缓存的DNS和TTL无关</strong>，这个一般看浏览器厂商的倾向了，Chrome的过期时间是1分钟。<br><strong>本机缓存不会完全等于这个TTL</strong> 它会参考但是不完全等于TTL值。<br><strong>ISP的缓存要看ISP心情和良心</strong>，有些缓存服务器（不多）会忽略网站DNS提供的TTL，自己设置一个较长的TTL。</p>
<p>所以总体来说，较长的TTL有利于提高网页打开速度，这个速度是全局性质的,因为所有的速度都必须加上DNS解析时间，积少成多这个时间就非常可观了。举个例子说你网站就算快成光不要时间传输渲染，但是DNS解析要10秒，照样体验一团糟。</p>
<p>所以说较长的TTL会直接有利于提高网站打开速度，这个速度是基础级别的，你的网络DNS解析时间有多长，这个优化相应的就会多有效。一般的域名TTL从20分钟到数小时都是很常见的。如果你不考虑灾备的话可以将这个TTL设为一天或者一周。但是这也意味一旦你的网站服务器挂了你无法快速恢复，比如被人格式化了硬盘，那么你的服务就必然会中断一天或者一周。</p>
<p>这项优化必须要谨慎再谨慎。毕竟灾难可能随时到来。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里算是词穷了。目前个人理解的优化基本就到此为止了。不过最后还是做个总结吧，优化的主要路径：</p>
<ol>
<li>200(from cache)强缓存、304协商缓存和Gzip，这个一定要做，所谓web优化，我认为5成的比重在这里。</li>
<li>HTML+JS+CSS压缩、按需加载，雪碧图，这个也必须要做，我认为它占到优化比重的3成。</li>
<li>最后2成嘛，多域名，高TCP并发，CDN，自建DNS，服务器集群，这些就要靠钱来砸了。</li>
</ol>
<p>就这样了，如果有错误，欢迎大家指出。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.infoq.com/cn/news/2010/05/baidu-html-optimize">《不应忽视的HTML优化》</a><br><a href="https://csspod.com/frontend-performance-best-practices/#javascript">《前端性能优化最佳实践》</a><br><a href="http://borninsummer.com/2015/01/03/web-performance-in-practice/">《Web前端性能优化实践》</a><br><a href="https://www.zhihu.com/question/21815101">知乎问答</a><br><a href="http://www.itechzero.com/first-of-front-end-series-dns-prefetch-increase-load-speed.html">《前端优化系列之一：DNS预获取 DNS Prefetch 提升页面载入速度》</a><br><a href="http://blog.csdn.net/charleslei/article/details/51083229">《浏览器、操作系统DNS缓存时间》</a></p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>错配的nginx——web缓存问题探究</title>
    <url>/2016/07/15/http-cache/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>随着项目的推进，渐渐的要上https，要从tomcat服务器转换到nginx+tomcat组合的方式了。 nginx有个问题就是缓存太”严重”,我认为这其实是一个大的优化，如果用好了可以对项目体验起到很好的催化，这也是nginx作为服务器的前端的意义所在。 但是往往当开发人员对http理解薄弱的，就会对此很搓火。因为过强的缓存会导致页面滞后，debug时候很多东西无法及时出来，只能动不动强制清缓存，大大破坏了开发体验。</p>
<h1 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h1><p>其实一直一来都在做强缓存。新起的项目都做好了资源的hash。但是如果不是这次错配的nginx导致个人寻根结底找原因，也不会有这篇关于http缓存的文章。 HTTP的文章其实网上已经有很多了。个人完全不认为会比那些无比详细和成系列的雄文对比。仅仅是个人对知识体系的一个总结吧。</p>
<p>言归正传。问题的由来其实是因为nginx的响应头配置有问题，它里面既没有 Cache-Control,也没有Expires。导致很多资源无端200(from cache)而不304，使得资源存在更新不及时的问题.</p>
<p>举个栗子,这是清空缓存后第一次访问资源的http响应头：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Server</span>: Apache-Coyote/1.1</span><br><span class="line"><span class="attribute">Accept-Ranges</span>: bytes</span><br><span class="line"><span class="attribute">ETag</span>: W/&quot;2477-1467900381000&quot;</span><br><span class="line"><span class="attribute">Last-Modified</span>: Thu, 07 Jul 2016 14:06:21 GMT</span><br><span class="line"><span class="attribute">Content-Type</span>: image/png</span><br><span class="line"><span class="attribute">Content-Length</span>: 2477</span><br><span class="line"><span class="attribute">Date</span>: Fri, 15 Jul 2016 14:00:41 GMT</span><br></pre></td></tr></table></figure>

<p>这是对应的请求头:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Accept:image/webp,image/*,*/*;q=0.8</span><br><span class="line">Accept-Encoding:gzip, deflate, sdch</span><br><span class="line">Accept-Language:zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4</span><br><span class="line">Cache-Control:max-age=0</span><br><span class="line"><span class="attribute">Connection:keep-alive</span></span><br><span class="line">Cookie:CNZZDATA1256284005=647609082-1468586434-%7C1468586434</span><br><span class="line"><span class="attribute">Host:www.xxx.com</span></span><br><span class="line"><span class="attribute">Referer:http://www.xxx.com/</span></span><br><span class="line">User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br></pre></td></tr></table></figure>

<p>然后在地址栏敲回车以后以后，返回的200(from cache),而我不是猜想的304 总之一句话就是这个问题的关键在于：响应头里既没有 Cache-Control也没有Expires的时候，是如何在新鲜度检测阶段直接认为新鲜度没有问题的。</p>
<h1 id="问题的抛出"><a href="#问题的抛出" class="headerlink" title="问题的抛出"></a>问题的抛出</h1><p>在搞清整个问题之前我觉得还是要将HTTP缓存机制好好整理处理作为问题解决的前提和疑问抛出的前提。</p>
<p>用最简单的话来说，服务器缓存启用是存在两个判断机制的：</p>
<ol>
<li>新鲜度检测阶段 需要依赖响应头的Cache-Control和Expires，通过才会返回200(from cache)</li>
<li>资源二次校验阶段 校验资源一致性,如果一致返回304,如果不一致返回200,当然，如果没有找到返回404</li>
</ol>
<p>现在的问题就抛出来了，为什么，响应头里面没有Cache-Control和Expires,那么按照上诉的缓存启用机制，返回的状态吗可能是304,可能是200,可能是404或者更多的，但是就是不可能是200(from cache)。但是现实用惨淡的现实告诉我们，结果就是200(from cache)！这是为什么呢？</p>
<h1 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h1><h2 id="用户操作对缓存的影响"><a href="#用户操作对缓存的影响" class="headerlink" title="用户操作对缓存的影响"></a>用户操作对缓存的影响</h2><p>用户不同的操作是对缓存存在固有影响，正常链接点入、新tab打开网址/窗口、F5刷新、前进后退、Ctrl+F5强刷，对缓存都会不同的表现</p>
<table>
<thead>
<tr>
<th align="left">用户操作</th>
<th align="left">Exprires/Cache-Control</th>
<th align="left">Last-Modified/Etag</th>
</tr>
</thead>
<tbody><tr>
<td align="left">地址栏回车</td>
<td align="left">有效</td>
<td align="left">有效</td>
</tr>
<tr>
<td align="left">页面链接转跳</td>
<td align="left">有效</td>
<td align="left">有效</td>
</tr>
<tr>
<td align="left">新开窗口</td>
<td align="left">有效</td>
<td align="left">有效</td>
</tr>
<tr>
<td align="left">前进后退</td>
<td align="left">无效</td>
<td align="left">有效</td>
</tr>
<tr>
<td align="left">Ctrl+F5强刷</td>
<td align="left">无效</td>
<td align="left">无效</td>
</tr>
</tbody></table>
<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p>缓存总体上的流程是这样的(原图来自《http权威指南》,个人有涂鸦)：<br><img src="/images/%E7%BC%93%E5%AD%98.png"></p>
<h3 id="新鲜度检测"><a href="#新鲜度检测" class="headerlink" title="新鲜度检测"></a>新鲜度检测</h3><p><strong>Cache-Control与Expires</strong> 是新鲜度检测的关键:</p>
<p>Cache-Control与Expires的作用一致，都是指明当前资源的有效期。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。<br>详细一点说明的话，Expires是http/1.0定义的资源有效期，它是一个历史遗留产物。它的值是一个绝对值，它显示指定了一个日期作为过期时间。然而经过一段时间实践之后，Bug就出来了：当客户端可服务器时间不一致，那么到底怎么处理呢？</p>
<p>Cache-Control是http/1.1定义的，功能很多，但是核心的我认为还是还是改变了资源有效期的表达方式，我认为最大的意义是Cache-Control是Expires的bugfix产物(作为bugfix优先级当然会更高)。它使用max-age来根据最后时间加上这个max-age动态计算了过期时间，这样就不存在Expires的Bug了。</p>
<p><strong>Cache-Control可选值:</strong>(偷懒摘自《翻译：web制作、开发人员需知的Web缓存知》)</p>
<ul>
<li>**max-age=[秒]**：表示在这个时间范围内缓存是新鲜的无需更新。类似Expires时间，不过这个时间是相对的，而不是绝对的。也就是某次请求成功后多少秒内缓存是新鲜的。</li>
<li>**s-maxage=[秒]**：类似max-age, 除了仅应用于共享缓存（如代理）。</li>
<li><strong>public</strong>：标记认证的响应才能够被缓存。一般而言，需要认证HTTP请求内容会自动私有化（不会被缓存Add）。</li>
<li><strong>private</strong>：允许缓存专门为某一个用户存储响应，比方说在浏览器中；共享缓存一般不会，例如在代理中。</li>
<li><strong>no-cache</strong>：每次在释放缓存副本之前都强制发送请求给源服务器进行验证，这在确保认证有效性上很管用（和public结合使用）或者保证内容必须是即时的，不得无视缓存的所有优点，如国内的微博、twitter等的刷新显示Add。</li>
<li><strong>no-store</strong>：强制缓存在任何情况下都不要保留任何副本。</li>
<li><strong>must-revalidate</strong>：告诉缓存，我给你准备了一些关于新鲜度的信息，在表现的时候要严格遵循之。HTTP允许缓存在某些特定情况下返回过期数据，指定了这个属性，相对于告诉缓存，你丫必须严格遵循我的规则。</li>
<li><strong>proxy-revalidate</strong>：类似must-revalidate，除了只能应用于代理缓存。</li>
</ul>
<p><b style="color:red">个人注:</b>理想的情况下，Cache-Control与Expires可以都标明以达到最优兼容，但是这不是必须都有的，多数可以只有其中一个也不会有什么大问题(如果引起BUG就另说了)，但是——不要两个都没有，不然会引起相对诡异的现象，如果本文的例子。<br><b style="color:red">——但是你硬要这么干，确实可以两个都没有.</b></p>
<h3 id="资源二次校验"><a href="#资源二次校验" class="headerlink" title="资源二次校验"></a>资源二次校验</h3><p><strong>Last-Modified/ETag</strong> 这两个数据用于确定数据是否改变<br>Last-Modified嘛，很好理解，文件最后修改时间。如果这个东西那么好用的话其实Etag不过画蛇添足罢了，但是很可惜的Last-Modified的时间度量单位是秒——这意味着一秒内的修改服务器分辨不出来——股票行情系统和金融系统对此有利益攸关的需求。<br>所以就有了ETag，这个东西就是类似文件hash的东西，在服务器上用于分辨文件是不是同一个。</p>
<p>Last-Modified与ETag是可以一起使用的，<strong>服务器会优先验证ETag</strong>。一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304</p>
<p><b style="color:red">个人注:</b>如果你想用304，Last-Modified和ETag是很重要的属性。如果你还想用304，那么就不要删除它们(删除其中一个会不会有影响个人还未验证)。</p>
<h3 id="新鲜度校验的补充"><a href="#新鲜度校验的补充" class="headerlink" title="新鲜度校验的补充"></a>新鲜度校验的补充</h3><p><strong>试探性过期</strong>(本章摘自HTTP权威指南Page193)<br>如果响应中没有 Cache-Control: max-age 首部,也没有 Expires 首部,缓存可 以 <strong>计算出一个试探性最大使用期</strong>。可以使用任意算法,但如果得到的最大使用期大于24小时,就应该向响应首部添加一个 Heuristic Expiration Warning首部。据我们所知,很少有浏览器会为用户提供这种警告信息。<br>LM-Factor 算法是一种很常用的试探性过期算法,<strong>如果文档中包含了最后修改日期, 就可以使用这种算法</strong>。LM-Factor算法 <strong>将最后修改日期作为依据</strong>,来估计文档有多么易变。算法的逻辑如下所示。<br>• 如果已缓存文档最后一次修改发生在很久以前,它可能会是一份稳定的文档,不太会突然发生变化,因此将其继续保存在缓存中会比较安全。<br>• 如果已缓存文挡最近被修改过,就说明它很可能会频繁地发生变化,因此在与服 务器进行再验证之前,只应该将其缓存很短一段时间。</p>
<p>这段描述已经解决了个人的疑惑了,<strong>简单说算法猜你近期没有改的不会突然改了,反之认为你会突然改</strong>。在《HTTP权威指南》内有简单的公式和图例，有兴趣的可以自行前往翻阅。</p>
<p><b style="color:red">个人注:</b>《HTTP权威指南》有这样一段话：</p>
<blockquote>
<p>HTTP 有一组非常复杂的新鲜度检测规则,缓存产品支持的大量配置选项,以及与 非 HTTP 新鲜度标准进行互通的需要则使问题变得更加严重了。本章其余的大部分 篇幅都用于解释新鲜度的计算问题。</p>
</blockquote>
<p>所以，这个新鲜度校验是非常复杂的，远不是网上大多数文章提到的那么简略，如果以后在新鲜度校验这里出现疑问，不妨翻一翻。</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>问题到这里算是解决了，解决方案很简单，加上了Cache-Control和Expires。但是这次的服务器错配的导致的问题的探索，着实是很大程度上提高了个人对HTTP缓存的理解。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.zhangxinxu.com/wordpress/2013/05/caching-tutorial-for-web-authors-and-webmasters/">《翻译：web制作、开发人员需知的Web缓存知识》</a><br><a href="http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/">【Web缓存机制系列】2 – Web浏览器的缓存机制 </a><br><a href="https://book.douban.com/subject/10746113/">《HTTP权威指南》</a></p>
]]></content>
      <tags>
        <tag>http-cache</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>dockerfile构建前端vim环境</title>
    <url>/2016/07/13/dockerfile/</url>
    <content><![CDATA[<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>开篇呢我想贴下上一篇的发布代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push que01/vim</span><br></pre></td></tr></table></figure>
<p>如果，我是说如果你自己也曾经这样push一个容器过，那么就会知道在国内这环境通过跨洋电缆把这容器传到dockerHub是多么艰辛。</p>
<p>而且一旦使用的baseBox更新了，如果你也打算跟着更新时候，如果使用这种方式会让人彻底崩溃。</p>
<p>所幸，我们有自动构建这个工具。linux的自动构建工具其实有很多，好几年前毕业前个人曾经仰望过，似乎需要进行shell编程，所以望而却步了。不过Docker的dockerfile却如此简单。</p>
<p>本文算是对上一篇进行了自动化构建。</p>
<p>不过考虑到官方的centos(70M+)比ubuntu(120M+)要小一些。所以我干脆换了centos做baseBox。如果有可能再尝试下更小的alpine Linux，这才是真正的小到极致吧。不过本文构建的镜像应当还是有用的。毕竟centos是非常常用的一个发行版。<br>体积这事，这算是用屌丝版mbpr的怨念吧。。。</p>
<p><strong>7.15更新</strong><br>今天用alpine做baseBox完成了同样的工作，体积来说实在是小了太多了。压缩后为64M,一旦解压也只有220M不到。算是小到极致了。<a href="https://hub.docker.com/r/que01/docker-vim-tiny/tags/">que01/docker-vim-tiny</a> 大家可以去看看Dockerfile怎么写的。这里不再赘述。alpine的包管理实在不太熟，错误太多次才搞好。。。</p>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>创建相关的自动化配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch Dockerfile</span><br><span class="line">atom Dockerfile</span><br></pre></td></tr></table></figure>
<p>把下面代码贴进去：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER que01 &lt;que01@foxmail.com&gt;</span><br><span class="line"></span><br><span class="line">RUN yum install -y --nogpgcheck vim git zsh python-devel cmake  &amp;&amp; yum groupinstall --nogpgcheck -y &quot;Development tools&quot; &amp;&amp; \</span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; &amp;&amp; \</span><br><span class="line">echo &quot;export TERM=&#x27;xterm-256color&#x27;&quot; &gt;&gt; ~/.zshrc &amp;&amp; \</span><br><span class="line">git clone https://github.com/que01/vimrc ~/.vim_runtime &amp;&amp; cd ~/.vim_runtime &amp;&amp; \</span><br><span class="line">sh install_awesome_vimrc.sh &amp;&amp; git submodule init &amp;&amp; git submodule update &amp;&amp; \</span><br><span class="line">cd ~/.vim_runtime/sources_non_forked/YouCompleteMe &amp;&amp; git submodule update --init --recursive &amp;&amp; \</span><br><span class="line">curl --silent --location https://rpm.nodesource.com/setup_4.x | bash - &amp;&amp; yum -y --nogpgcheck install nodejs &amp;&amp; \</span><br><span class="line">./install.py --tern-completer &amp;&amp; \</span><br><span class="line">yum remove -y cmake libarchive lzo gcc cpp glibc-devel glibc-headers kernel-headers libgomp libmpc mpfr \</span><br><span class="line">autoconf automake bison byacc cscope ctags diffstat doxygen elfutils flex gcc-c++ gcc-gfortran gettext \</span><br><span class="line">indent intltool libtool make patch patchutils rcs redhat-rpm-config rpm-build rpm-sign subversion swig \</span><br><span class="line">systemtap apr  apr-util avahi-libs  boost-system boost-thread bzip2 dwz dyninst emacs-filesystem file gdb \</span><br><span class="line">gettext-common-devel gettext-devel gettext-libs gnutls kernel-devel libcroco libdwarf libgfortran libmodman \</span><br><span class="line">libproxy libquadmath libunistring m4 mokutil neon nettle pakchois trousers unzip zip libquadmath-devel \</span><br><span class="line">libstdc++-devel perl-Test-Harness perl-Data-Dumper perl-Thread-Queue perl-XML-Parser perl-srpm-macros \</span><br><span class="line">subversion-libs systemd-sysv systemtap-client systemtap-devel systemtap-runtime &amp;&amp; \</span><br><span class="line">yum clean all &amp;&amp; cd ~/.vim_runtime &amp;&amp; find . -name &quot;.git&quot; | xargs rm -Rf</span><br></pre></td></tr></table></figure>

<p>下面简单讲讲为什么要这么写，也不枉当初大学时候那么喜欢linux，装遍各大发行版。。。</p>
<h2 id="Dockerfile相关"><a href="#Dockerfile相关" class="headerlink" title="Dockerfile相关"></a>Dockerfile相关</h2><p>这里个人也是新手，仅仅用了三个相关的命令：</p>
<ul>
<li><strong>FROM</strong>        设置基础的镜像baseBox</li>
<li><strong>MAINTAINER</strong>  设置维护者信息</li>
<li><strong>RUN</strong>         编写要在容器内部运行的脚本。</li>
</ul>
<p>另外说一下要将所有命令用&amp;&amp;写一行的原因：因为之前看过一篇文章，其介绍说每个RUN会创建一层容器导致打包体积变大，所以直接这样写了。</p>
<h2 id="Linux相关的东西"><a href="#Linux相关的东西" class="headerlink" title="Linux相关的东西"></a>Linux相关的东西</h2><p>这里也就讲讲RUN里面的命令。</p>
<p>yum是centos的包管理工具，这个和ubuntu的apt-get是一类的东西。我们在centos里面使用<code>yum install xxx</code>来安装一个包。</p>
<ul>
<li>-y 选项用来静默安装，对各种需要交互的环节帮你自动按y</li>
<li>–nogpgcheck 这个嘛，因为我当时install时候会提示gpg不对，这个用来取消签名或者证书检查</li>
</ul>
<p>相关安装的软件包：</p>
<ul>
<li>vim git zsh 这几个不用提</li>
<li>python-devel cmake “Development tools” 编译YouCompleteMe要用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/que01/vimrc ~/.vim_runtime &amp;&amp; cd ~/.vim_runtime &amp;&amp; \</span><br><span class="line">sh install_awesome_vimrc.sh &amp;&amp; git submodule init &amp;&amp; git submodule update &amp;&amp; \</span><br><span class="line">cd ~/.vim_runtime/sources_non_forked/YouCompleteMe &amp;&amp; git submodule update --init --recursive &amp;&amp; \</span><br></pre></td></tr></table></figure>
<p>这排代码是我个人的vimrc的git repo,里面使用submodule加入了youcompelteMe，相关代码都是获取必要的文件用的。上篇文章介绍过，可以放心用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure>
<p>这行是oh-my-zsh，centos里面自带了curl，那么就不用ubuntu里面那样安装一个了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --silent --location https://rpm.nodesource.com/setup_4.x | bash - &amp;&amp; yum -y --nogpgcheck install nodejs</span><br></pre></td></tr></table></figure>
<p>这行呢，是nodejs官网的，安装node用的，ternJs需要这个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;install.py --tern-completer</span><br></pre></td></tr></table></figure>
<p>这行是编译youcompelteMe用的，官方Readme可查。–tern-completer用来自动安好ternjs，不过需要node支持。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove -y xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure>
<p>这个超级长的一排是安装编译环境yum groupinstall –nogpgcheck -y “Development tools”时候自动安装的依赖啊什么，编译完了就卸载掉。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum clean all &amp;&amp; cd ~/.vim_runtime &amp;&amp; find . -name &quot;.git&quot; | xargs rm -Rf</span><br></pre></td></tr></table></figure>
<p>清除yum包的各种缓存，然后进入vimrc配置文件夹，删除下该文件夹下所有的.git文件夹以求减少体积(YouCompleteMe的git库还是非常大的！)。</p>
<h1 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h1><p>其实这篇就是对上一篇的自动化构建，没有太多值得一提的地方，主要是对yum比较熟悉就行了。<br>另，编译好的镜像已经发布了。大家需要可以使用下面命令pull回来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull que01/vim</span><br></pre></td></tr></table></figure>
<p>下载体积也就138M，不过解压完毕有420M，感觉dockerHub真是黑科技！</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker构建前端开发环境</title>
    <url>/2016/07/08/docker-note/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文写作前面其实个人也尝试用过docker，那时候docker for Mac尚需要virtualBox支持。不过到本文开篇时候，docker的版本已经是 <strong>1.12.0-rc3</strong> ,似乎已经不需要单独的virtualBox了。</p>
<p>之前因为virtualBox依赖所以个人放弃了继续玩下去，一来因为对性能有点洁癖，二来因为vagrant还是能满足需求的同时似乎没比docker在mac上性能差。不过现在看到不需要virtualBox了，所以又开始折腾一下，算玩物丧志吧。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装这事，感觉还是不提了，这个直接上官网链接就好了，这里是 <a href="https://docs.docker.com/engine/installation/#installation">直达飞机</a></p>
<h1 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h1><p>获取镜像使用 <strong>docker pull</strong> 命令即可。<br>如果顾虑dockerHub的网速，可以使用网易的仓库。<a href="https://c.163.com/hub#/m/home/">网易蜂巢</a>.<br>这里安装的是ubuntu：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 网易</span></span><br><span class="line">docker pull hub.c.163.com/public/ubuntu:14.04-common</span><br><span class="line"><span class="meta">#</span><span class="bash"> dockerHub</span></span><br><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>

<p>PS:顺便说一句，直接使用dockerHub现在速度也非常理想，为了更好的兼容性，建议还是dockerHub吧。本文最初使用网易的镜像，但是运行run失败了，始终无法进入tty，数次ctrl-c重新运行也无效。而dockerHub的几乎不到一秒就进入了tty。<br>对比了一下网易和dockerHub的镜像，网易的达到350多M，而dockerHub的只有182M，这应该是Mac新版本的docker导致的。</p>
<h1 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h1><p>运行容器需要运行 <strong>docker run</strong> 命令。run命令参数比较多：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--add-host          -- Add a custom host-to-IP mapping</span><br><span class="line">--attach        -a  -- Attach to STDIN, STDOUT or STDERR</span><br><span class="line">--cap-add           -- Add Linux capabilities</span><br><span class="line">--cap-drop          -- Drop Linux capabilities</span><br><span class="line">--cidfile           -- Write the container ID to the file</span><br><span class="line">--cpu-shares    -c  -- CPU shares (relative weight)</span><br><span class="line">--cpuset-cpus       -- CPUs in which to allow execution (0-3, 0,1)</span><br><span class="line">--detach        -d  -- Run container in the background, print new container id</span><br><span class="line">--device            -- Add a host device to the container</span><br><span class="line">--dns               -- Set custom dns servers</span><br><span class="line">--dns-search        -- Set custom DNS search domains</span><br><span class="line">--entrypoint        -- Overwrite the default entrypoint of the image</span><br><span class="line">--env           -e  -- Set environment variables</span><br><span class="line">--env-file          -- Read in a file of environment variables</span><br><span class="line">--expose            -- Expose a port from the container without publishing it to your host</span><br><span class="line">--hostname      -h  -- Container host name</span><br><span class="line">--interactive   -i  -- Keep STDIN open even if not attached</span><br><span class="line">--ipc               -- IPC namespace to use</span><br><span class="line">--label         -l  -- Set meta data on a container</span><br><span class="line">--link              -- Add link to another container (name:alias)</span><br><span class="line">--log-driver        -- Logging driver for the container</span><br><span class="line">--lxc-conf          -- Add custom LXC options</span><br><span class="line">--mac-address       -- Container MAC address (e.g. 92:d0:c6:0a:29:33)</span><br><span class="line">--memory        -m  -- Memory limit (format: &lt;number&gt;&lt;optional unit&gt;, where unit = b, k, m or g)</span><br><span class="line">--name              -- Assign a name to the container</span><br><span class="line">--net               -- Set the Network mode for the container</span><br><span class="line">--pid               -- PID namespace to use</span><br><span class="line">--privileged        -- Give extended privileges to this container</span><br><span class="line">--publish       -p  -- Publish a containers port to the host (format: ip:hostPort:containerPort/protocol)</span><br><span class="line">--publish-all   -P  -- Publish all exposed ports to the host interfaces</span><br><span class="line">--restart           -- Restart policy to apply when a container exits</span><br><span class="line">--rm                -- Automatically remove the container when it exits (incompatible with -d)</span><br><span class="line">--security-opt      -- Security Options</span><br><span class="line">--sig-proxy         -- Proxify all received signal to the process (even in non-tty mode)</span><br><span class="line">--tty           -t  -- Allocate a pseudo-tty</span><br><span class="line">--ulimit            -- Ulimit options</span><br><span class="line">--user          -u  -- Username or UID</span><br><span class="line">--volume        -v  -- Bind mount a volume (e.g. -v /host:/container or -v /container)</span><br><span class="line">--volumes-from      -- Mount volumes from the specified container(s)</span><br><span class="line">--workdir       -w  -- Working directory inside the container</span><br></pre></td></tr></table></figure>
<p>我们这里运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -t -i ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。这个在上面的选项里面有。</p>
<h1 id="终止-amp-运行容器"><a href="#终止-amp-运行容器" class="headerlink" title="终止&amp;运行容器"></a>终止&amp;运行容器</h1><p>终止和重新运行一个容器都很容易。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ docker ps #获取容器的列表</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">c72f5174d56a        ubuntu              &quot;/bin/bash&quot;         3 minutes ago       Up 3 minutes                            naughty_almeida</span><br><span class="line">➜  ~ docker stop c72f5174d56a # 将id填入即可终止</span><br><span class="line">➜  ~ docker start c72f5174d56a # 将id填入即可运行</span><br></pre></td></tr></table></figure>
<h1 id="exce"><a href="#exce" class="headerlink" title="exce"></a>exce</h1><p>Docker的优势是轻量级，一个高配置服务器可以同时运行超过上百个Container，这就决定了绝大多数的Container都是在后台静默运行的。<br>之前说的终止和运行容器，其实就是说，在后台进行终止和运行。但是容器最终还是需要进行shell交互的。这里就需要用到exce命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it baseBox zsh</span><br></pre></td></tr></table></figure>
<p>这里的-i和-t和run是一样的，baseBox是容器的名称，zsh是要运行的命令。<br>几乎是一秒后，容器就进入了tty交互了。此时我们就可以开始进入自己的镜像定制了。</p>
<h1 id="定制镜像-vim-wrapper"><a href="#定制镜像-vim-wrapper" class="headerlink" title="定制镜像(vim-wrapper)"></a>定制镜像(vim-wrapper)</h1><p>这里就随意记录一下自己的折腾记录。记录是按标题顺序来的。</p>
<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>先安装vim非我所愿。只是ubuntu这个最小的镜像没有vi也没有vim导致我没法换源。。。跨洋的网速大家都知道的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line">vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>然后填入163的源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">163</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>
<p>然后 <code>apt-get update</code>更新之。</p>
<h2 id="oh-my-zsh-amp-amp-git"><a href="#oh-my-zsh-amp-amp-git" class="headerlink" title="oh-my-zsh &amp;&amp; git"></a>oh-my-zsh &amp;&amp; git</h2><p>oh-my-zsh是愉快工作的第一步。感觉这是个没有就没法活的东西。<br>因为安装需要git和zsh和wget依赖，先行安装一下。考虑到git这东西其实是必备的，所以一起弄了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get instal -y git zsh wget</span><br><span class="line">sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure>

<h2 id="vim-plugins-YouCompeleteMe"><a href="#vim-plugins-YouCompeleteMe" class="headerlink" title="vim plugins + YouCompeleteMe"></a>vim plugins + YouCompeleteMe</h2><p>YouCompeleteMe其实也是vim plugins。。。这个大家都知道，不过这东西好用到可以拿出来着重说了。基于语意的补全加上ternJs的加持，很大程度上可以媲美IDE补全了。如果用vim做开发，这个插件是体验的最大保证之一了。个人因为是前端开发，所以这里的配置基本以此为准，只处理js补全。其他语言的可以酌情看github的Readme处理。</p>
<p>ps: <a href="https://github.com/que01/vimrc">https://github.com/que01/vimrc</a> 这个仓库是根据 <a href="https://github.com/amix/vimrc">https://github.com/amix/vimrc</a> 项目而来。6k的star看着比较眼馋。主要补充了YouCompeleteMe和一个巴掌不到的插件补充。可以放心用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/que01/vimrc ~/.vim_runtime</span><br><span class="line">cd ~/.vim_runtime &amp;&amp; git submodule init &amp;&amp; git submodule update</span><br><span class="line">cd ~/.vim_runtime/sources_non_forked/YouCompleteMe &amp;&amp; git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
<p>到这里配置就完事了。不过还需要对YouCompeleteMe单独编译一番。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先处理编译环境</span></span><br><span class="line">apt-get install build-essential cmake &amp;&amp; apt-get install python-dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 会被安装的包，记录一下，等会编译完了删掉，删掉。。。不然这image打包起来也太大了。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> binutils build-essential bzip2 cmake cmake-data cpp cpp-5 dpkg-dev fakeroot g++ g++-5 gcc gcc-5 libalgorithm-diff-perl libalgorithm-diff-xs-perl libalgorithm-merge-perl</span></span><br><span class="line">  libarchive13 libasan2 libatomic1 libcc1-0 libcilkrts5 libcurl3 libdpkg-perl libfakeroot libfile-fcntllock-perl libgcc-5-dev libgomp1 libisl15 libitm1 libjsoncpp1 liblsan0</span><br><span class="line">  liblzo2-2 libmpc3 libmpfr4 libmpx0 libquadmath0 libstdc++-5-dev libtsan0 libubsan0 libxml2 sgml-base xml-core</span><br><span class="line"><span class="meta">#</span><span class="bash"> node安装 ternJS需要</span></span><br><span class="line">apt-get install nodejs curl &amp;&amp; mv /usr/bin/nodejs /usr/bin/node #其他发行版都是node，这里改改不然麻烦</span><br><span class="line"><span class="meta">#</span><span class="bash"> npm安装</span></span><br><span class="line">curl -L https://www.npmjs.com/install.sh | sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译开始</span></span><br><span class="line">cd ~/.vim/bundle/YouCompleteMe &amp;&amp; ./install.py --tern-completer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 完成后删除工具包 wget curl 还有build-essential cmake和相关依赖</span></span><br><span class="line">apt-get remove curl wget binutils build-essential bzip2 cmake cmake-data cpp cpp-5 dpkg-dev fakeroot g++ g++-5 gcc gcc-5 libalgorithm-diff-perl libalgorithm-diff-xs-perl libalgorithm-merge-perl</span><br><span class="line">  libarchive13 libasan2 libatomic1 libcc1-0 libcilkrts5 libcurl3 libdpkg-perl libfakeroot libfile-fcntllock-perl libgcc-5-dev libgomp1 libisl15 libitm1 libjsoncpp1 liblsan0</span><br><span class="line">  liblzo2-2 libmpc3 libmpfr4 libmpx0 libquadmath0 libstdc++-5-dev libtsan0 libubsan0 libxml2 sgml-base xml-core</span><br></pre></td></tr></table></figure>
<p>到这里基本就完事了，不过下一步我们继续来精简体积保证images更小。这里从更多还是YouCompeleteMe下手，毕竟这玩意儿实在太大了。</p>
<p>这里操作依赖zsh，所以务必运行一下zsh进入oh-my-zsh。其实主要就一条：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除版本库</span></span><br><span class="line">cd ~/.vim_runtime</span><br><span class="line">rm -rf */**/.git&lt;TAB&gt; #然后oh-my-zsh会将所有的.git自动补全处理，回车，删除，这些git版本记录是体积大头</span><br><span class="line"><span class="meta">#</span><span class="bash">删除不要的third_party，我们只需要前端补全</span></span><br><span class="line">cd ~/.vim_runtime/sources_non_forked/YouCompleteMe/third_party/ycmd/third_party</span><br><span class="line">rm -rf gocode godef JediHTTP</span><br></pre></td></tr></table></figure>
<p>然后我查看了一下体积：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  third_party du -h --max-depth=1 .</span><br><span class="line">3.5M	./requests</span><br><span class="line">216K	./racerd</span><br><span class="line">11M	./tern_runtime</span><br><span class="line">28M	./OmniSharpServer</span><br><span class="line">4.9M	./python-future</span><br><span class="line">472K	./argparse</span><br><span class="line">668K	./waitress</span><br><span class="line">1.3M	./bottle</span><br><span class="line">48K	./frozendict</span><br><span class="line">49M	.</span><br></pre></td></tr></table></figure>
<p>似乎也没可以放心删了，其他的不知道会不会有依赖。。。不删了。最后看了下体积，整个root目录当前118M，顺手把.vim_runtime下么的doc目录全删了(rm -rf */**/doc<TAB>)，反正我用不上。。。现在116M。。。</p>
<h2 id="打包前的清场"><a href="#打包前的清场" class="headerlink" title="打包前的清场"></a>打包前的清场</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get clean &amp;&amp; apt-get autoremove &amp;&amp; apt-get autoclean &amp;&amp; rm -rf /tmp</span><br></pre></td></tr></table></figure>

<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit -a que01  -m &#x27;vim config &amp; zhs config &amp; git&#x27; baseBox que01/vim</span><br></pre></td></tr></table></figure>
<p>最后查看打包好的镜像，体积：561.6 MB。<br>。。。有些心醉啊。。。。git,oh-my-zsh,vim这3个作为工作基础那真是一个都不能少，不过vim+youcomplete确实占用了太多空间了，youcomplete单独的占用达到105M+，vim+python目测有80到100M，git有60，oh-my-zsh暂用不大大概有7M的样子，加起来大概有270M的样子(加上ubuntu有125，至少也会有将近400了)，加上杂七杂八的依赖，估计也小不下去了。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push que01/vim</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这篇呢，记录了自己打包的基础docker image，总体来讲还是可以用了，不过容器之间的连接还是有些犯晕，有时间我再另行整理记录一下。</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>React全家桶:react-starter-kit之三</title>
    <url>/2016/07/01/react-starter-kit-3/</url>
    <content><![CDATA[<h1 id="之前"><a href="#之前" class="headerlink" title="之前"></a>之前</h1><p>在之前写分页功能时候，曾经添加过一个count的小接口，可以通过GraphQL来查询news的条目数。这里我们就以此来实例说明如何使用GraphQL来做一个接受一个查询。</p>
<p>这个接口具备两种逻辑处理。</p>
<ol>
<li>当没有传递指定标签id时候返回全部条目</li>
<li>指定标签id时候返回指定id的条目数</li>
</ol>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>在进行查询之前我们需要对字段类型进行约束。<br>文件: <code>data/types/NewsCountType.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  GraphQLObjectType <span class="keyword">as</span> ObjectType,</span><br><span class="line">  GraphQLInt <span class="keyword">as</span> IntType,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;graphql&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NewsCountType = <span class="keyword">new</span> ObjectType(&#123;</span><br><span class="line">  name: <span class="string">&#x27;NewsCount&#x27;</span>,</span><br><span class="line">  fields: &#123;</span><br><span class="line">    count:&#123;<span class="attr">type</span>:IntType&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> NewsCountType;</span><br></pre></td></tr></table></figure>

<p>这里使用GraphQLObjectType来定义了返回的是一个对象，GraphQLInt则定义了返回的count属性是一个数字。<br>当然，这里只是非常的简单了使用了一个小案例。这里列举一下更多的类型定义。</p>
<ul>
<li><strong>GraphQLScalarType</strong>:Scalar Types，标量类型。最细粒度的类型<ul>
<li>GraphQLInt:Int</li>
<li>GraphQLFloat:Float</li>
<li>GraphQLString:String</li>
<li>GraphQLBoolean:Boolean</li>
<li>GraphQLID:ID</li>
</ul>
</li>
<li><strong>GraphQLObjectType</strong>:对象</li>
<li><strong>GraphQLInterfaceType</strong>:接口</li>
<li><strong>GraphQLUnionType</strong>:联合</li>
<li><strong>GraphQLEnumType</strong>:枚举</li>
<li><strong>GraphQLInputObjectType</strong>:输入对象</li>
<li><strong>GraphQLList</strong>:列表</li>
<li><strong>GraphQLNonNull</strong>:NonNull</li>
</ul>
<h3 id="GraphQLObjectType"><a href="#GraphQLObjectType" class="headerlink" title="GraphQLObjectType"></a>GraphQLObjectType</h3><p>几乎所有的GraphQL都是Object对象。它具有一个name属性和一个非常重要的fields属性，这里定义了它的数据结构。就像之前，贴出的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> AddressType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">  name: <span class="string">&#x27;Address&#x27;</span>,</span><br><span class="line">  fields: &#123;</span><br><span class="line">    street: &#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">    number: &#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">    formatted: &#123;</span><br><span class="line">      type: GraphQLString,</span><br><span class="line">      <span class="function"><span class="title">resolve</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.number + <span class="string">&#x27; &#x27;</span> + obj.street</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> PersonType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">  name: <span class="string">&#x27;Person&#x27;</span>,</span><br><span class="line">  fields: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    name: &#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">    bestFriend: &#123; <span class="attr">type</span>: PersonType &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="GraphQLInterfaceType"><a href="#GraphQLInterfaceType" class="headerlink" title="GraphQLInterfaceType"></a>GraphQLInterfaceType</h3><p>(这块暂时不是太理解,见谅)<br>When a field can return one of a heterogeneous set of types, a Interface type is used to describe what types are possible, what fields are in common across all types, as well as a function to determine which type is actually used when the field is resolved.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EntityType = <span class="keyword">new</span> GraphQLInterfaceType(&#123;</span><br><span class="line">  name: <span class="string">&#x27;Entity&#x27;</span>,</span><br><span class="line">  fields: &#123;</span><br><span class="line">    name: &#123; <span class="attr">type</span>: GraphQLString &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="GraphQLUnionType"><a href="#GraphQLUnionType" class="headerlink" title="GraphQLUnionType"></a>GraphQLUnionType</h3><p>当一个字段可以返回一个异构集合的类型中的一种，一个Union类型用于描述什么类型是可能的，以及提供一个函数，以确定哪些类型时该字段被解析实际使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> PetType = <span class="keyword">new</span> GraphQLUnionType(&#123;</span><br><span class="line">  name: <span class="string">&#x27;Pet&#x27;</span>,</span><br><span class="line">  types: [ DogType, CatType ],</span><br><span class="line">  <span class="function"><span class="title">resolveType</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">      <span class="keyword">return</span> DogType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">      <span class="keyword">return</span> CatType;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="GraphQLEnumType"><a href="#GraphQLEnumType" class="headerlink" title="GraphQLEnumType"></a>GraphQLEnumType</h3><p>可枚举的数据类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> RGBType = <span class="keyword">new</span> GraphQLEnumType(&#123;</span><br><span class="line">  name: <span class="string">&#x27;RGB&#x27;</span>,</span><br><span class="line">  values: &#123;</span><br><span class="line">    RED: &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    GREEN: &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    BLUE: &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="GraphQLInputObjectType"><a href="#GraphQLInputObjectType" class="headerlink" title="GraphQLInputObjectType"></a>GraphQLInputObjectType</h3><p>为了查询对象定义的数据类型.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> GeoPoint = <span class="keyword">new</span> GraphQLInputObjectType(&#123;</span><br><span class="line">  name: <span class="string">&#x27;GeoPoint&#x27;</span>,</span><br><span class="line">  fields: &#123;</span><br><span class="line">    lat: &#123; <span class="attr">type</span>: <span class="keyword">new</span> GraphQLNonNull(GraphQLFloat) &#125;,</span><br><span class="line">    lon: &#123; <span class="attr">type</span>: <span class="keyword">new</span> GraphQLNonNull(GraphQLFloat) &#125;,</span><br><span class="line">    alt: &#123; <span class="attr">type</span>: GraphQLFloat, <span class="attr">defaultValue</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="GraphQLList"><a href="#GraphQLList" class="headerlink" title="GraphQLList"></a>GraphQLList</h3><p>列表是其他类型的封装，通常用于对象字段的描述。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PersonType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">  name: <span class="string">&#x27;Person&#x27;</span>,</span><br><span class="line">  fields: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    parents: &#123; <span class="attr">type</span>: <span class="keyword">new</span> GraphQLList(Person) &#125;,</span><br><span class="line">    children: &#123; <span class="attr">type</span>: <span class="keyword">new</span> GraphQLList(Person) &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="GraphQLNonNull"><a href="#GraphQLNonNull" class="headerlink" title="GraphQLNonNull"></a>GraphQLNonNull</h3><p>Non-Null 强制类型的值不能为 null.在请求出错时会报错。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>类型系统是GraphQL重要的组成部分之一，它规定了数据的类型。如果数据不符合指定的类型，GraphQL将会自动进行报错。这对调试接口非常重要。同时可以强制接口符合约定，保证代码的健壮性。</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>GraphQL的查询语句相信是GraphQL最吸引人的地方，我个人认为，没有之一。<br>这里简单记录一下自己近段时间做的东西。主要包含前端和后端的实现，没有用到的地方就暂时不记录了。<br>这是获取数据的代码部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resetNewsState:<span class="function"><span class="keyword">function</span> (<span class="params">context,currentPage,pageSize,hotTag</span>) </span>&#123;</span><br><span class="line">	 <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">	 <span class="comment">//获取新的数据</span></span><br><span class="line">	 fetch(<span class="string">&#x27;/graphql&#x27;</span>, &#123;</span><br><span class="line">		 method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">		 headers: &#123;</span><br><span class="line">			 Accept: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">			 <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">		 &#125;,</span><br><span class="line">		 body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">		 query: <span class="string">`&#123;news( currentPage:<span class="subst">$&#123;currentPage||<span class="built_in">this</span>.props.currentPage&#125;</span>, pageSize:<span class="subst">$&#123;pageSize||<span class="built_in">this</span>.props.pageSize&#125;</span>, hotTag:<span class="subst">$&#123;hotTag||<span class="number">9999</span>&#125;</span> )&#123;title,link,contentSnippet&#125;, tags&#123;name,id&#125;, count( hotTag:<span class="subst">$&#123;hotTag||<span class="number">9999</span>&#125;</span> )&#123;count&#125;&#125;`</span></span><br><span class="line">		 &#125;),</span><br><span class="line">		 credentials: <span class="string">&#x27;include&#x27;</span></span><br><span class="line">	 &#125;).then(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line">		 <span class="keyword">let</span> &#123; data &#125; = <span class="keyword">await</span> resp.json();</span><br><span class="line">		 <span class="comment">//设置全局store提供给页码组件</span></span><br><span class="line">		 <span class="comment">//总条目数</span></span><br><span class="line">		 self.props.setRuntime(&#123;</span><br><span class="line">			 name:<span class="string">&quot;newsTotalItem&quot;</span>,</span><br><span class="line">			 value:data.count.count</span><br><span class="line">		 &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		 <span class="comment">//内部状态</span></span><br><span class="line">		 (context||<span class="built_in">this</span>).setState(&#123;</span><br><span class="line">			 news:data.news,</span><br><span class="line">			 tags:data.tags,</span><br><span class="line">			 newsLoading:<span class="literal">false</span></span><br><span class="line">		 &#125;);</span><br><span class="line">	 &#125;);</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
<p>其中 <code>query</code>就是其中关键的查询代码。GraphQL的查询代码个人认为如果做好了配置，那么几乎是所见即所得的。如果这样还不太好理解。那么我就贴一下请求参数的反悔响应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;request</span><br><span class="line">&quot;&#123;</span><br><span class="line">  news(</span><br><span class="line">    currentPage:1,</span><br><span class="line">    pageSize:10,</span><br><span class="line">    hotTag:9999</span><br><span class="line">)&#123;title,link,contentSnippet&#125;,</span><br><span class="line">tags&#123;name,id&#125;,</span><br><span class="line">count(</span><br><span class="line">  hotTag:9999</span><br><span class="line">)&#123;count&#125;&#125;&quot;</span><br><span class="line">&#x2F;&#x2F;response</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;news&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;title&quot;: &quot;测试标题1&quot;,</span><br><span class="line">        &quot;link&quot;: &quot;http:&#x2F;&#x2F;www.baidu.com&quot;,</span><br><span class="line">        &quot;contentSnippet&quot;: &quot;测试摘要测试摘要&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;title&quot;: &quot;测试标题2&quot;,</span><br><span class="line">        &quot;link&quot;: &quot;http:&#x2F;&#x2F;www.baidu.com&quot;,</span><br><span class="line">        &quot;contentSnippet&quot;: &quot;测试摘要测试摘要&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    &quot;tags&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;javascript&quot;,</span><br><span class="line">        &quot;id&quot;: &quot;1&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;css&quot;,</span><br><span class="line">        &quot;id&quot;: &quot;2&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;count&quot;: &#123;</span><br><span class="line">      &quot;count&quot;: 17</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很容易理解呢？通过编写查询语句，几乎就可以前端自己设计好需要的需要的json数据，从而优化请求。当然，这紧紧是前端部分。当我们使用以下代码查询条目数的时候，指定了hotTag的id为9999(这里是一个特殊标志符，代表查询全部hotTag)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">count(</span><br><span class="line">  hotTag:<span class="number">9999</span></span><br><span class="line">)&#123;count&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>其中， <code>count:&#123;type:IntType&#125;</code>规定了hotTag参数必须为数字。这个在第一个代码片段有写。但是这紧紧是前端的查询，为了获取到想要的数据，我们还需要后端也做好相应的查询操作。</p>
<p>以下贴出查询的完整查询代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//=============================</span></span><br><span class="line"><span class="comment">//src/data/queries/newsCount.js</span></span><br><span class="line"><span class="comment">//=============================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; GraphQLInt &#125; <span class="keyword">from</span> <span class="string">&#x27;graphql&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fetch <span class="keyword">from</span> <span class="string">&#x27;../../core/fetch&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> NewsCountType <span class="keyword">from</span> <span class="string">&#x27;../types/NewsCountType&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React.js News Feed (RSS)</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;/api/news&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> lastFetchTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newsCount = &#123;</span><br><span class="line">  type: NewsCountType,</span><br><span class="line">  args: &#123;</span><br><span class="line">    hotTag:&#123; <span class="attr">type</span>: GraphQLInt&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">resolve</span>(<span class="params">reqObj,&#123;hotTag&#125;</span>)</span> &#123;</span><br><span class="line">      lastFetchTask = <span class="keyword">await</span> fetch(url,&#123;</span><br><span class="line">          method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">          headers: &#123;</span><br><span class="line">            Accept: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          body: <span class="built_in">JSON</span>.stringify(&#123;hotTag&#125;),</span><br><span class="line">          credentials: <span class="string">&#x27;include&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">        .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (data.code === <span class="number">200</span>) &#123;</span><br><span class="line">            count = data.count;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> &#123;count&#125;;</span><br><span class="line">        &#125;)</span><br><span class="line">        .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          lastFetchTask = <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (count.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;count&#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> lastFetchTask;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> newsCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===================</span></span><br><span class="line"><span class="comment">//src/data/schema.js</span></span><br><span class="line"><span class="comment">//===================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  GraphQLSchema <span class="keyword">as</span> Schema,</span><br><span class="line">  GraphQLObjectType <span class="keyword">as</span> ObjectType,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;graphql&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tags <span class="keyword">from</span> <span class="string">&#x27;./queries/tags&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> content <span class="keyword">from</span> <span class="string">&#x27;./queries/content&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> news <span class="keyword">from</span> <span class="string">&#x27;./queries/news&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> count <span class="keyword">from</span> <span class="string">&#x27;./queries/newsCount&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  query: <span class="keyword">new</span> ObjectType(&#123;</span><br><span class="line">    name: <span class="string">&#x27;Query&#x27;</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">      tags,</span><br><span class="line">      content,</span><br><span class="line">      news,</span><br><span class="line">      count</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> schema;</span><br></pre></td></tr></table></figure>
<p>src/data/queries/newsCount.js文件是对数据进行具体查询和定义参数的文件，而src/data/schema.js则导出了一个Schema。</p>
<p>在这里我们可以发散一下，当我们要使用和定义后端的GraphQL相关，那么该怎么做呢：<br>我们需要一个GraphGL的Schema。它有以下结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  query: <span class="keyword">new</span> ObjectType(&#123;</span><br><span class="line">    name: <span class="string">&#x27;Query&#x27;</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">	count:&#123;</span><br><span class="line">		type: NewsCountType,</span><br><span class="line">		args: &#123;</span><br><span class="line">			hotTag:&#123; <span class="attr">type</span>: GraphQLInt&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		resolve:<span class="function"><span class="keyword">function</span>(<span class="params">reqObj,paramObj</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结合我们的类型系统，是不是很有感觉了呢？是的，当我们反复循环嵌套相关的数据类型，然后使用Schema返回。那么就可以配合前两篇文章写到的。从前端后端两个方面来实现GraphQL的对接。</p>
<h1 id="收个尾"><a href="#收个尾" class="headerlink" title="收个尾"></a>收个尾</h1><p>写到这里心里其实有些索然。因为感觉没有说到很深入的境地。但是怎么说呢，通过这篇文章好好体会一下，应该也可以在react-starter-kit里面使用GraphQL了，毕竟正常使用应该也用不到太过复杂的功能。</p>
<p>然而毕竟事情未能尽善，从第一篇到这一篇，期间磨磨蹭蹭一个月也过去了，新东西太多太快但是时间精力有限。限于个人水平文章也无法写的很通俗，但是确实是用心去做了。</p>
<p>有时间把源代码整理完毕一起放出来供参考。</p>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>express</tag>
        <tag>react同构应用</tag>
      </tags>
  </entry>
  <entry>
    <title>React全家桶:react-starter-kit之二</title>
    <url>/2016/06/16/react-starter-kit-2/</url>
    <content><![CDATA[<h1 id="之前"><a href="#之前" class="headerlink" title="之前"></a>之前</h1><p>好像也没有太多值得一提的地方，但是react-starter-kit这个当前相当先进(激进)同构技术栈各个难题的克服，还是给了我很大的满足的感。在这个过程中，不仅仅是mongodb、mongoose、express、react和redux的单个技术点，同时也是各个技术点的交叉和融合。特别是GraphQL，实在是给我留下了极其深刻的映像和震撼。</p>
<h1 id="Antd"><a href="#Antd" class="headerlink" title="Antd"></a>Antd</h1><p>Antd可以说是难得的国产精品。<br>说起国产的技术产品，怎么说呢，在早些时候requireJS比较火的时候，阿里出过SeaJS，但是坑很多，如果使用SeaJS，现有的各种模块面临极其繁琐的重新封装。<br>阿里的Alice当初也尝试过，但是也没有用起来。<br>百度的开源的产品让人最深刻的Echarts和Ueditor，但是除了这两个，其他的出的开源产品基本都是处于无维护和没人用的状况。<br>腾讯没啥重量级开源产品，但是其团队成员做的ArtTemplate,artDialog等,其实体验还真的不错。<br>…<br>Antd算是阿里推出的一项重量级开源产品。</p>
<p>好了，不扯太多。我们先在项目内部集成antd。</p>
<p>首先是安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install antd --save-dev</span><br></pre></td></tr></table></figure>
<p>如何使用这里就不说了，这是API的活儿了。<br>不过当你弄完以后，打开使用了antd的页面，你会在控制台看到一下提示：</p>
<p><img src="/images/antd-plugins-error.png" alt="antd-plugins-error"></p>
<p>提示是说用的未编译版本，请使用指定插件来限制打包体积。好吧，然后打开network选项卡看看到底大了多少。。。<br>结果是main.js达到坑爹的8.9M，使用前则是5M左右。考虑到react-starter-kit是各种框架集成，antd一个人用这么多体积确实是太大了。所以老实把插件安装起来好了。</p>
<p>安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-antd --save-dev</span><br></pre></td></tr></table></figure>
<p>安装完毕之后要进行一些配置。打开<code>tool/webpack.config.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: &#x2F;\.jsx?$&#x2F;,</span><br><span class="line">        loader: &#39;babel-loader&#39;,</span><br><span class="line">        include: [</span><br><span class="line">          path.resolve(__dirname, &#39;..&#x2F;node_modules&#x2F;react-routing&#x2F;src&#39;),</span><br><span class="line">          path.resolve(__dirname, &#39;..&#x2F;src&#39;),</span><br><span class="line">        ],</span><br><span class="line">        query: &#123;</span><br><span class="line">          &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;babel&#x2F;babel-loader#options</span><br><span class="line">          cacheDirectory: DEBUG,</span><br><span class="line">          &#x2F;&#x2F; https:&#x2F;&#x2F;babeljs.io&#x2F;docs&#x2F;usage&#x2F;options&#x2F;</span><br><span class="line">          babelrc: false,</span><br><span class="line">          presets: [</span><br><span class="line">            &#39;react&#39;,</span><br><span class="line">            &#39;es2015&#39;,</span><br><span class="line">            &#39;stage-0&#39;,</span><br><span class="line">          ],</span><br><span class="line">          plugins: [</span><br><span class="line">            [&quot;antd&quot;],</span><br><span class="line">            &#39;transform-runtime&#39;,</span><br><span class="line">            ...DEBUG ? [] : [</span><br><span class="line">              &#39;transform-react-remove-prop-types&#39;,</span><br><span class="line">              &#39;transform-react-constant-elements&#39;,</span><br><span class="line">              &#39;transform-react-inline-elements&#39;,</span><br><span class="line">            ],</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>代码挺长，但是其实无非是plugins数组里面加一个<code>["antd"],</code>。<br>到这里babel-plugin-antd基本就能用了，github上面的文档说css也可以实现模块化，但是按文档操作会导致编译报错，这里就先不折腾了。直接将css文件复制到publice目录，然后在view/index.html里面引入。</p>
<h1 id="Redux-amp-react-redux"><a href="#Redux-amp-react-redux" class="headerlink" title="Redux &amp; react-redux"></a>Redux &amp; react-redux</h1><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。通过它可以有条不紊的维护当前越来越复杂的应用状态。Redux虽然不像GraphQL那样可以让人眼前一亮，但是对深谙开发流程但是对状态维护苦恼的开发者来说它是救市良药。具体的大家可以去看看 <a href="http://cn.redux.js.org/">《Redux中文文档》</a>。</p>
<p>react-redux是一个将redux和react整合起来的package，它是胶水。但是需要说明的是:redux专注于状态维护，和React本质上是没有任何关系的。</p>
<p>当写到这里时候，我将默认读者已经阅读过中文文档，对Redux用途和redux三大基础概念:action,reducer和store有了基础认识。</p>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>react-redux提供两个关键模块：Provider和connect。</p>
<h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>Provider这个模块是作为整个App的容器，在你原有的App Container的基础上再包上一层，它的工作很简单，就是接受Redux的store作为props，并将其声明为context的属性之一。</p>
<p>这里就列举一下react-starter-kit里面Provider的设置，打开 <code>src/components/App/App.js</code>,可以很清楚的看到render函数的内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  if (this.props.error) &#123;</span><br><span class="line">    return this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const store &#x3D; this.props.context.store;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Header &#x2F;&gt;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">        &lt;Feedback &#x2F;&gt;</span><br><span class="line">        &lt;Footer &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Redux的store作为props，并将其声明为context的属性之一，子组件可以在声明了contextTypes之后可以方便的通过this.context.store访问到store——但是这里store本质上给connect用的。</p>
<p>Provider本质上为为子组件提供整体的舞台。</p>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>conect正如其名，连接了react和redux。</p>
<p>这里回首一下redux的流程:store保存整体状态，通过调用store.dispatch一个action，来调用对应action的reducer，最终redux会根据action来更新state(应用的状态，而非react组件的state)。</p>
<p>通过connect,React-redux应用中，store中维护的state就是我们的应用state，一个React组件作为View层，做两件事：render和响应用户操作。于是connect就是将store中的必要数据作为props传递给React组件来render，并包装action creator用于在响应用户操作时dispatch一个action。</p>
<p>如果这样说还是不太能理解，那么那就直白一些，redux的store可以视为一个可以保存状态的内存盘，而connect则赋予react组件随处修改store的能力。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>如果这样还是没有明白，我们来实际做个小功能，一个基于antd页码组件的翻页小模块。大致效果如图:<br><img src="/images/pages.png" alt="preview"></p>
<p>这里用到的antd里面的tabs组件和Pagination组件还有Spin组件(显示加载中)。</p>
<p>这是一个比较常见的功能，这里简单说一下功能点:</p>
<ol>
<li>tabs切换选项卡显示</li>
<li>最新选项卡显示一个标签云+分页展示模块。</li>
<li>点击页码时候进行内容切换</li>
<li>切换每页条数时候更新数量</li>
<li>内容和页码组件的其他融合</li>
</ol>
<p>为了简单，这些就都放在home路由的组件里面了。<br>不过开始说redux之前，我们先把路铺好。这里需要提前准备的有：</p>
<ol>
<li>api接口</li>
<li>相对tabs组件和Spin组件</li>
</ol>
<h4 id="api"><a href="#api" class="headerlink" title="api"></a>api</h4><p>首先说说api，分页功能需要整理总条目数。我们调整了news的api数据源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.all(&#39;&#x2F;news&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  const pageSize &#x3D; req.body.pageSize||req.query.pageSize||10;</span><br><span class="line">  const currentPage &#x3D; req.body.currentPage||req.query.currentPage||1;</span><br><span class="line">  const index &#x3D; (currentPage-1)*pageSize;</span><br><span class="line"></span><br><span class="line">  News.count(&#123;&#125;, function(err, count) &#123;</span><br><span class="line">    News</span><br><span class="line">      .find()</span><br><span class="line">      .skip(index)</span><br><span class="line">      .limit(pageSize)</span><br><span class="line">      .exec(function(err,news)&#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">          code:200,</span><br><span class="line">          news:news,</span><br><span class="line">          count:count</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>不算复杂，仅仅是添加了一个count字段，然后一个skip来和limit来实现获取指定分页数据。我们这里使用GraphQL来做数据接口。实际实现就不具体提及。因为这里主要是讲react-redux。<br>最终我们发送这样一个片段:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;</span><br><span class="line">&#123;</span><br><span class="line">    news(currentPage: $ &#123;</span><br><span class="line">        currentPage || this.props.currentPage</span><br><span class="line">    &#125;, pageSize: $ &#123;</span><br><span class="line">        pageSize || this.props.pageSize</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        title, link, contentSnippet</span><br><span class="line">    &#125;, tags &#123;</span><br><span class="line">        name</span><br><span class="line">    &#125;, count &#123;</span><br><span class="line">        count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>
<p>返回这样一个结构的结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;news&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;title&quot;: &quot;测试标题1&quot;,</span><br><span class="line">        &quot;link&quot;: &quot;http:&#x2F;&#x2F;www.baidu.com&quot;,</span><br><span class="line">        &quot;contentSnippet&quot;: &quot;测试摘要测试摘要&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;title&quot;: &quot;测试标题2&quot;,</span><br><span class="line">        &quot;link&quot;: &quot;http:&#x2F;&#x2F;www.baidu.com&quot;,</span><br><span class="line">        &quot;contentSnippet&quot;: &quot;测试摘要测试摘要&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;tags&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;javascript&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;css&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;count&quot;: &#123;</span><br><span class="line">      &quot;count&quot;: 17</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="相对tabs组件和Spin组件"><a href="#相对tabs组件和Spin组件" class="headerlink" title="相对tabs组件和Spin组件"></a>相对tabs组件和Spin组件</h4><p>接下来整理其他相对独立不需要进行状态交互的模块.下面是Home组件的render方法的关键代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Home &#x3D; React.createClass(&#123;</span><br><span class="line">  ...</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    let content;</span><br><span class="line">    if(this.state.newsLoading)&#123;</span><br><span class="line">      content &#x3D; &lt;Spin &#x2F;&gt;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      content &#x3D; (</span><br><span class="line">		&lt;!-- 这里是列表组件 --&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div className&#x3D;&#123;s.root&#125;&gt;</span><br><span class="line">          &lt;div className&#x3D;&#123;s.container&#125;&gt;</span><br><span class="line">            &lt;Tabs type&#x3D;&quot;card&quot;&gt;</span><br><span class="line">              &lt;TabPane tab&#x3D;&quot;最新&quot; key&#x3D;&quot;1&quot;&gt;</span><br><span class="line">                &lt;CloudTags tags&#x3D;&#123;this.state.tags||[]&#125; &#x2F;&gt;</span><br><span class="line">                &#123;content&#125;</span><br><span class="line">                &lt;PaginationContainer &#x2F;&gt;</span><br><span class="line">              &lt;&#x2F;TabPane&gt;</span><br><span class="line">              &lt;TabPane tab&#x3D;&quot;热门&quot; key&#x3D;&quot;2&quot;&gt;选项卡二内容&lt;&#x2F;TabPane&gt;</span><br><span class="line">              &lt;TabPane tab&#x3D;&quot;更新&quot; key&#x3D;&quot;3&quot;&gt;选项卡三内容&lt;&#x2F;TabPane&gt;</span><br><span class="line">            &lt;&#x2F;Tabs&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当 <code>this.state.newsLoading===true</code>时候显示Spin组件,否则显示列表。至于Tabs组件这个，貌似标签结构已经足够清晰，就不说了。<br>需要说明的是，为了尽量减少请求，标签云的数据也一起请求过来了，这也是GraphQL的一个优势展现。</p>
<p>这两步走完，可以提起react-redux正文了。</p>
<h4 id="react-redux-1"><a href="#react-redux-1" class="headerlink" title="react-redux"></a>react-redux</h4><p>开始之前，还是希望大家可以去看看这篇文章: <a href="https://leozdgao.me/reacthe-reduxde-qiao-jie-react-redux/">React和Redux的连接react-redux</a>,对react-redux有相对基础认识</p>
<h5 id="react-starter-kit的Redux处理"><a href="#react-starter-kit的Redux处理" class="headerlink" title="react-starter-kit的Redux处理"></a>react-starter-kit的Redux处理</h5><p>首先，我们需要一个Provider(如果你不知道这是啥，还是先去看看刚才提到的文章)。这个模块是作为整个App的容器。</p>
<p>我们看看react-starter-kit是怎么规划这个模块的：<br>首先是 <code>routes/index.js</code> ，这个文件里面是整个应用的路由规则规划。我们看关键代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  path: &#39;&#x2F;&#39;,</span><br><span class="line">  children: [</span><br><span class="line">    home,</span><br><span class="line">	&lt;!-- ...略 --&gt;</span><br><span class="line">    error,</span><br><span class="line">  ],</span><br><span class="line">  async action(&#123; next, render, context &#125;) &#123;</span><br><span class="line">    const component &#x3D; await next();</span><br><span class="line">    if (component &#x3D;&#x3D;&#x3D; undefined) return component;</span><br><span class="line">    return render(</span><br><span class="line">      &lt;App context&#x3D;&#123;context&#125;&gt;&#123;component&#125;&lt;&#x2F;App&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码的意思是，所有的component，最后输出的时候，都必须放到line12中这个APP容器中去。<br>这个APP容器的关键代码是这样的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  if (this.props.error) &#123;</span><br><span class="line">    return this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">  const store &#x3D; this.props.context.store;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Header &#x2F;&gt;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">        &lt;Feedback &#x2F;&gt;</span><br><span class="line">        &lt;Footer &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体来说，就是通过这种方式把Provider全局使用起来了，所有的路由，都会被APP这个容器包裹起来，方便后面是用connect来链接react和redux。</p>
<h5 id="connect-1"><a href="#connect-1" class="headerlink" title="connect"></a>connect</h5><p>接下来我们来处理状态相关的东西。<br>当前的应用状态是这样的：<br><img src="/images/redux.png" alt="redux state"></p>
<p>在开始之前还是说一下各个组件之间的数据交互。</p>
<ol>
<li>列表数据从来自一个API，里面包含news的列表，同时也包含了条目总数。</li>
<li>条目总数会传到页码组件，同时，页码组件会绑定当前页，页码和条目总数。当组件改变当前页和pageSize会触发news更新</li>
<li>news更新如果总数添加了，又会将总数更新一次传到页码组件里面更新页码。</li>
</ol>
<p>很显然，如果各个组件之间太独立，那么手工传值就会非常让心心烦，也不方便维护，但是如果放到全局的store内部，自动传入到各个组件，那么就变得非常还用且容易维护了。</p>
<p>先来处理一下页码组件,这是在Home文件夹下单独建立的文件PaginationContainer.js：</p>
<script src="https://gist.github.com/que01/2048b15527b02b10efb5fa316f2d3764.js"></script>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">  currentPage: state.runtime.currentPage,</span><br><span class="line">  newsTotalItem:state.runtime.newsTotalItem,</span><br><span class="line">&#125;), &#123;<span class="attr">setRuntime</span>:setRuntimeVariable&#125;)(PaginationContainer);</span><br></pre></td></tr></table></figure>
<p>这个算是将react和redux连接的关键代码，意思是将store上两个属性，映射到currentPage和newTotalItem两个props上，然后react里面就可以直接使用this.props.currentPage,和this.props.newsTotalItem了。setRuntime则是将一个方法也放到对应props上，这样可以使用这个方法来更新store。后面可以看到，我们之后更新store里面的数据都是使用的这个方法。例如onChange和onShowSizeChange都是这样。</p>
<p>当点击不同页码，会触发onChange,而更改每页数量，会触发onShowChage。当这些钩子被触发之后，会更新store内部数据，最后反应到Home组件，被News对应的列表接受到，最终更新页面.</p>
<p>然后是对应的Home.js;</p>
<script src="https://gist.github.com/que01/217f36f2ffe552cf8b4603c51a87c7b3.js"></script>

<p>所有的逻辑都在这里面了。这里来详细说一说。<br>Home这个文件应该从生命周期讲起。</p>
<p>在这些周期里面最先执行的是getInitialState,它返回了react的初始state，这里就是放了一个tags和news的数组，用来存放需要遍历的内容，而newsLoading这个状态主要是在news载入前产生loading的效果，这个很常见了。</p>
<p>接下来是componentDidMount，当react组件载入完毕后执行它，它会运行restNewsState函数,其实就是从api里面获取tags，news和count这三个关键数据。<br>我们来看看这个函数成功后的回调里面的关键代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//总条目数</span></span><br><span class="line">self.props.setRuntime(&#123;</span><br><span class="line">  name:<span class="string">&quot;newsTotalItem&quot;</span>,</span><br><span class="line">  value:data.count.count</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//内部状态</span></span><br><span class="line">(context||<span class="built_in">this</span>).setState(&#123;</span><br><span class="line">  news:data.news,</span><br><span class="line">  tags:data.tags,</span><br><span class="line">  newsLoading:<span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>首先是将count的数量放到store的runtime对象的newsTotalItem上。因为这个数据会共享到页码组件。然后是更新内部的news，tags，newLoading，因为这几个数据是不需要共享的，所以直接放到react内部的state上去。</p>
<p>但是当我们更新内部的state时候会产生一个副作用，那就是会触发componentWillReceiveProps,但是我们也不能不管，因为不用这个钩子，那么会导致PageSize改变，currentPage改变之后我们的news List不会被更新。<br>所以这个时候需要用到shouldComponentUpdate，这个钩子在componentWillReceiveProps之前运行，它返回true，那么才会进行更新，也就是运行componentWillReceiveProps，所以我们在这里对状态进行对比即可，如果没有变更，那么我们返回false即可，这里的对比使用了lodash的isEqual,lodash确实很好用.</p>
<p>最后使用connect将Home包裹起来返回export之即可。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章其实是长话短说，很多细节都略过了，比如tags其实也应该是react-redux中的一环，比如count的GraphQL查询该怎样写。甚至，react和redux的连接，我也没有写出理论来，只是引用了一篇文章来偷偷懒。<br>但是个人还是觉得够了react和redux的连接，需要对redux有了解，需要对react-redux有了解，我认为我做的只是最后一环，如何在react-starter-kit里面给他来一个最后的实践。<br>难者不会，会着不难，这是一个通行万道的钥匙。有了第一次的成功，其实一切无非水到渠成。这也是本文的目的。</p>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>express</tag>
        <tag>react同构应用</tag>
      </tags>
  </entry>
  <entry>
    <title>React全家桶:react-starter-kit之一</title>
    <url>/2016/06/08/react-starter-kit-1/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>一直想做个项目，以react为前端，node做后端，实现前后端都可以使用javascript开发。所以在github上找手脚架时候，找到了react-starter-kit，8k多的star，于是就拍板使用它了。这就是这系列笔记的来源之所以。</p>
<p>然而最终发现，react-starter-kit实在不是一个平易近人的项目，匮乏的文档，匮乏的demo，匮乏的说明，尤其是，匮乏的starter-guide，实在有些匹配不上react-starter-kit这个名字。</p>
<p>——然而已经入坑了，那就只好慢慢填坑爬出来——一把辛酸泪。。。</p>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>在展开所有内容之前，还是有必要讲讲React Starter Kit涵盖了哪些。以下是github项目上介绍：</p>
<blockquote>
<p>React Starter Kit — isomorphic web app boilerplate (Node.js, Express, GraphQL, React.js, Babel 6, PostCSS, Webpack, Browsersync)</p>
</blockquote>
<p>这是React Starter Kit项目的介绍。</p>
<p>总体上呢，我认为可以分为两个部分：</p>
<ol>
<li>工具部分：webpack，babel，browserSync等</li>
<li>框架部分：Express，GraphQL，redux，React等</li>
</ol>
<p>除此以外是个人规划部分：</p>
<ol>
<li>数据库:Mongodb，使用mongoose做连接池</li>
<li>模板引擎:干掉Jade，使用artTemplate(不要问我为嘛用这个，只因为习惯了，另外憎恨Jade语法)</li>
</ol>
<p>加起来，react-starter-kit大概涉及到了：webpack，babel，browserSync，Express，GraphQL，redux，React，mongoose，artTemplate，名副其实的全家桶，需要的储备知识着实不少。</p>
<h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>第一步是src/views目录下的两个jade模板。这是首页和报错页面的基础模板。其中首页模板会在各个页面被重用。</p>
<p>下面是关键上下文代码之一</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file:src/server.js</span></span><br><span class="line">app.get(<span class="string">&#x27;*&#x27;</span>, <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> css = [];</span><br><span class="line">    <span class="keyword">let</span> statusCode = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">const</span> template = <span class="built_in">require</span>(<span class="string">&#x27;./views/index.jade&#x27;</span>); <span class="comment">// eslint-disable-line global-require</span></span><br><span class="line">	...</span><br><span class="line">    res.status(statusCode);</span><br><span class="line">    res.send(template(data));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    next(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123; <span class="comment">// eslint-disable-line no-unused-vars</span></span><br><span class="line">  <span class="built_in">console</span>.log(pe.render(err)); <span class="comment">// eslint-disable-line no-console</span></span><br><span class="line">  <span class="keyword">const</span> template = <span class="built_in">require</span>(<span class="string">&#x27;./views/error.jade&#x27;</span>); <span class="comment">// eslint-disable-line global-require</span></span><br><span class="line">  <span class="keyword">const</span> statusCode = err.status || <span class="number">500</span>;</span><br><span class="line">  res.status(statusCode);</span><br><span class="line">  res.send(template(&#123;</span><br><span class="line">    message: err.message,</span><br><span class="line">    stack: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : err.stack,</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，可以看到两个地方引用(require)了jade模板，并且代码最终会被webpack打包，所以这里webapck使用了jade-loader，为了可以将index.jade改成index.html,我们需要安装 <code>tmodjs-loader</code>，确保html后缀的artTemplate模板可以被正确识别和编译。<br>下面是操作步骤</p>
<ol>
<li>安装tmodjs-loader: <code>npm i tmodjs-loader --save-dev</code></li>
<li>转换jade2html: <a href="http://html2jade.org/">html2jade</a>,将jade贴到右边左边会有编译的HTML，补充好变量位置即可。</li>
<li>设置webpack的loader<br>在 <code>tools/webpack.config.js</code> line127左右的位置插入以下代码，为模板设置正确的loader<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: &#x2F;\.html$&#x2F;,</span><br><span class="line">  loader: &quot;tmodjs&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>关键上下文代码之一：<br>除此以外，在src/content目录下有若干的jade文件，这个是Content Component的jade文件，为了去除jade，我们将它转换为markdown文件即可。Content Component逻辑中已经配置好markdown文章的逻辑。不需要操作更多。</p>
<p>至此，jade模板更换artTemplate工序完成。</p>
<h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h2><p>为了链接mongodb，这里使用了mongoose来连接和操作。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装很容易，在终端下运行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i mongoose --save</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>安装完成之后我们呢需要配置一下才能够使用，在src下新建mongoose目录，用来存放Schema等相关的东西。结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongoose</span><br><span class="line">├── Schema</span><br><span class="line">│   ├── News.js</span><br><span class="line">│   ├── Tags.js</span><br><span class="line">│   └── User.js</span><br><span class="line">└── index.js</span><br></pre></td></tr></table></figure>

<p>这里仅仅展示一下News.js和index.js,已经足够展示整体结构了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file:News.js</span></span><br><span class="line"><span class="keyword">import</span> mongoose <span class="keyword">from</span> <span class="string">&#x27;mongoose&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;mongoDbUrl&#125; <span class="keyword">from</span> <span class="string">&#x27;../../config&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> conn = mongoose.connect(mongoDbUrl);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  title: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">  link: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">  author:<span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">  publishedDate: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">  contentSnippet:<span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> News = mongoose.model(<span class="string">&#x27;news&#x27;</span>, schema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  News;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file:index.js</span></span><br><span class="line"><span class="keyword">import</span> News <span class="keyword">from</span> <span class="string">&#x27;./Schema/News&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Tags <span class="keyword">from</span> <span class="string">&#x27;./Schema/Tags&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&#x27;./Schema/User&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;News,Tags,User&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，虽然目录名字虽然叫做Schema，但是导出的是model，这是为了方便进行数据操作。至于index.js，只是为了方便导入各个Model而做的归集。</p>
<p>另外，这里有个变量mongoDbUrl，从外部引入了，这里也贴一下相关的配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mongodbInfo = &#123;</span><br><span class="line">  url:<span class="string">&quot;xxx.mlab.com&quot;</span>,</span><br><span class="line">  port:<span class="number">19839</span>,</span><br><span class="line">  user:<span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  password:<span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  dbName:<span class="string">&#x27;learn&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fromat:&#x27;mongodb://username:password@ds019839.mlab.com:19839/learn&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mongoDbUrl = <span class="string">&#x27;mongodb://&#x27;</span>+mongodbInfo.user+<span class="string">&#x27;:&#x27;</span>+mongodbInfo.password+<span class="string">&#x27;@&#x27;</span>+mongodbInfo.url+<span class="string">&#x27;:&#x27;</span>+mongodbInfo.port+<span class="string">&#x27;/&#x27;</span>+mongodbInfo.dbName</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实际上就是一个带了认证信息的mongodb链接。<br>这部分内容只是很简单的讲解了如何进行安装，配置，使用上还是需要对mongoose有基础的认识，需要一些知识储备。之前写过的<a href="http://www.que01.top/2016/03/20/mongodb2/">mongoDB笔记(二)</a>可以做一些浅显的参考，更具体的概念性东西，大概需要读者另外爬文了。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>有了数据库连接池，那么现在往下走，基于monogoose来做一些API。API主要考虑到两个方面，一个数据读写，一个是路由设置。</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>我们先从路由开始开工。<br>在src下新建api文件夹，建立api/index.js文件。<br>下面弄个简单的index.js例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;News,User,Tags&#125; <span class="keyword">from</span> <span class="string">&#x27;../mongoose&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取新闻数据</span></span><br><span class="line">router.all(<span class="string">&#x27;/news&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  News.find().exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,news</span>)</span>&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      code:<span class="number">200</span>,</span><br><span class="line">      news:news</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>
<p>完毕之后在src/server.js中添加路由相应的路由代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">&#x27;./api&#x27;</span>;</span><br><span class="line">...</span><br><span class="line">app.use(<span class="string">&#x27;/api&#x27;</span>, api);</span><br></pre></td></tr></table></figure>

<h3 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h3><p>数据读写的代码其实在上面已经贴出来了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">News.find().exec(function()&#123;</span><br><span class="line">	&#x2F;&#x2F;读取完毕之后的回调</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>不过这里仅仅是非常简单的全部查询，并没有限制性的条件，这在大多数时候是不存在的，不过这里还算合用(马上讲到GraphQL)。如果需要了解更多的相关mongoose的查询语句，可以参考我之前写的笔记<a href="http://www.que01.top/2016/03/24/mongodb3/">mongoDB笔记(三)</a>,这篇笔记对响应的查询都有比较详细的记录。</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>到这里，就可以使用浏览器访问 <code>/api/news</code> 来获取json数据了。</p>
<h2 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h2><p>GraphQL是个很赞的东西。怎么形容它呢？当前前端有个词，叫做响应式，页面会根据屏幕宽度来展现不同的外观。而GraphQL的最大优势和这个词汇有点像。它可以从前端接受查询语句，然后按照要求返回指定的字段。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>也许指定的字段这个不太能突出GraphQL的优势，这里举些例子吧。</p>
<p>例一：<br>当前如果有个接口 <code>/api/list</code>，返回的数据结构是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	code:200,</span><br><span class="line">	message:&quot;success&quot;,</span><br><span class="line">	data:[</span><br><span class="line">		&#123;</span><br><span class="line">			name:&quot;&quot;,</span><br><span class="line">			title:&quot;&quot;,</span><br><span class="line">			sum:&quot;&quot;,</span><br><span class="line">			color:&quot;&quot;,</span><br><span class="line">			height:&quot;&quot;,</span><br><span class="line">			width:&quot;&quot;,</span><br><span class="line">			logo:&quot;&quot;,</span><br><span class="line">			brand:&quot;&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而实际上，页面逻辑需要这样的就够了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	code:200,</span><br><span class="line">	message:&quot;success&quot;,</span><br><span class="line">	data:[</span><br><span class="line">		&#123;</span><br><span class="line">			name:&quot;&quot;,</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果前端队这个接口高度复用，不同页面只是过去了name,title,brand等数据进行了单独的调用，可以复用的时候实现最优json结构保持简洁和节省流量带宽吗？</p>
<p>例二：<br>数据结构和例一相同，但是当初接口设计时候只需要做查询就够了，又或者设计时候只接受name进行过滤，到那时现在我们需要队brand进行过滤，此时应该怎么办？</p>
<p>例三：<br>有两个接口 <code>/api/list1</code>和<code>/api/list2</code>，结构和例一一致，但是两种不同品类商品<br>假如我们有这样一个需求：</p>
<ol>
<li>从list1中过滤出brand==”que01”</li>
<li>从list2中过滤出color== “yellow”</li>
<li>将结果分别赋值给{data1:[],data2:[])</li>
</ol>
<p>此时常规的办法的是怎样的？先请求一次list1,过滤，然后请求list2，过滤。拼接。两次请求，3次数据处理，如果服务端承担了这个过滤，也必须请求两次，然后进行合并操作。我们可以更简单一些嘛？</p>
<p><b>是的。在GraphQL中，这些可以毫不费力的实现。</b>这实在是一个超级令人激动的东西。<br>React-starter-kit本身已经集成了GraphQL。但是要使用起来，还是有一些注意事项。不过本文主要立足于怎么将GraphQL在react-starter-kit中用来了，所以就不做太多的理论说明了，有时间单独总结一下它的使用，上面的例子，只是为了让大家明白他的优势。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在react-starter-kit中使用GraphQL不是一件太困难的事情。</p>
<p>在server.js中有以下代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/graphql&#x27;</span>, expressGraphQL(<span class="function"><span class="params">req</span> =&gt;</span> (&#123;</span><br><span class="line">  schema,</span><br><span class="line">  graphiql: <span class="literal">true</span>,</span><br><span class="line">  rootValue: &#123; <span class="attr">request</span>: req &#125;,</span><br><span class="line">  pretty: process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">&#125;)));</span><br></pre></td></tr></table></figure>
<p>GraphQL已经作为中间件载入了。这里仅对初步使用作出讲解。下面是src/data目录的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── models</span><br><span class="line">├── queries</span><br><span class="line">│   ├── content.js</span><br><span class="line">│   ├── news.js</span><br><span class="line">│   └── tags.js</span><br><span class="line">├── schema.js</span><br><span class="line">├── sequelize.js</span><br><span class="line">└── types</span><br><span class="line">    ├── ContentType.js</span><br><span class="line">    ├── NewsItemType.js</span><br><span class="line">    └── TagsType.js</span><br></pre></td></tr></table></figure>
<p>下面是我个人初步的schema.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  GraphQLSchema <span class="keyword">as</span> Schema,</span><br><span class="line">  GraphQLObjectType <span class="keyword">as</span> ObjectType,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;graphql&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tags <span class="keyword">from</span> <span class="string">&#x27;./queries/tags&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> content <span class="keyword">from</span> <span class="string">&#x27;./queries/content&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> news <span class="keyword">from</span> <span class="string">&#x27;./queries/news&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  query: <span class="keyword">new</span> ObjectType(&#123;</span><br><span class="line">    name: <span class="string">&#x27;Query&#x27;</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">      tags,</span><br><span class="line">      content,</span><br><span class="line">      news,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> schema;</span><br></pre></td></tr></table></figure>
<p>这里是最外层的接口了。其中tags，news，content都是最外层的api，也是我们需要自行定制的地方。<br>做好这些以后我们查询时候发送请求到<code>/graphql</code>接口。<br>下面这是发送过去的类似json的<b>字符串</b>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  news &#123;</span><br><span class="line">    title</span><br><span class="line">    link</span><br><span class="line">    author</span><br><span class="line">    publishedDate</span><br><span class="line">    contentSnippet</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后返回的数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;news&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: <span class="string">&quot;测试标题1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;link&quot;</span>: <span class="string">&quot;http://www.baidu.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;author&quot;</span>: <span class="string">&quot;que01&quot;</span>,</span><br><span class="line">        <span class="string">&quot;publishedDate&quot;</span>: <span class="string">&quot;2014-11-11&quot;</span>,</span><br><span class="line">        <span class="string">&quot;contentSnippet&quot;</span>: <span class="string">&quot;测试摘要测试摘要&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: <span class="string">&quot;测试标题2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;link&quot;</span>: <span class="string">&quot;http://www.baidu.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;author&quot;</span>: <span class="string">&quot;que01&quot;</span>,</span><br><span class="line">        <span class="string">&quot;publishedDate&quot;</span>: <span class="string">&quot;2014-11-11&quot;</span>,</span><br><span class="line">        <span class="string">&quot;contentSnippet&quot;</span>: <span class="string">&quot;测试摘要测试摘要&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里值得一提的是,title,link,author,publishedDate,contentSnippet这些字段可以任意顺序组合,删减。</p>
<p>简单的用法的我们暂时就这样简单的一笔跳过，详细的如果有时间另外写一篇讲解这个。我们现在来看看如何处理数据源。我们配合之前做好的api作为数据源来支挽GraphQL。</p>
<p>为了方便，这里使用tags来讲解。下面是tags.js的详细代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; GraphQLList <span class="keyword">as</span> List,GraphQLString &#125; <span class="keyword">from</span> <span class="string">&#x27;graphql&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fetch <span class="keyword">from</span> <span class="string">&#x27;../../core/fetch&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> TagsType <span class="keyword">from</span> <span class="string">&#x27;../types/TagsType&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;/api/tags&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> items = [];</span><br><span class="line"><span class="keyword">let</span> lastFetchTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tags = &#123;</span><br><span class="line">  type: <span class="keyword">new</span> List(TagsType),</span><br><span class="line">  args: &#123;</span><br><span class="line">    id: &#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">    name: &#123; <span class="attr">type</span>: GraphQLString &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">resolve</span>(<span class="params">reqObj,&#123;id,name&#125;</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    lastFetchTask = <span class="keyword">await</span> fetch(url)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">      .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.code === <span class="number">200</span>) &#123;</span><br><span class="line">          items = data.tags;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!!id)&#123;</span><br><span class="line">          items = _.filter(items,&#123;<span class="attr">id</span>:+id&#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!!name)&#123;</span><br><span class="line">          items = _.filter(items,&#123;<span class="attr">name</span>:name&#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">      &#125;)</span><br><span class="line">      .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        lastFetchTask = <span class="literal">null</span>;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (items.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lastFetchTask;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> tags;</span><br></pre></td></tr></table></figure>

<p>这里args里面定义了接口接受的参数，resolve则定义了处理数据的方式并返回数据(第二个参数是传递的请求参数组成的数组)，type则定义了数据类型。做好相应的逻辑配置之后，我们不仅可以想news那样直接返回所有数据，还可以传递参数id和name之一过去过滤数据.like this:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//request：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">tags</span>(<span class="params">name:<span class="string">&quot;css&quot;</span></span>)</span> &#123;</span><br><span class="line">    id,</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//response:</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;tags&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;css&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，最简单的使用就可以跑起来了。这已经可以满足最基础的场景应用。这部分我们到此为止。下一步我们讲讲自定义组件和页面。</p>
<h2 id="自定义组件和页面"><a href="#自定义组件和页面" class="headerlink" title="自定义组件和页面"></a>自定义组件和页面</h2><p>react-starter-kit定义了一些页面，但是很显然，我们不能满足修改已有进行改造使用，更多时候我们需要更多的页面…以及…更多的组件构成的页面…</p>
<p>这里仍旧以<code>/tags</code>页面为说明，这是一个新建的页面，使用了自定义的组件和数据源来构建的新的页面。<br>我们第一步要做的是在<code>/src/routes</code>下新建一个页面，然后在内部建立 <code>Tags.css、Tags.js、index.js</code>三个文件，保持同其他route组件的一致性。</p>
<p>下面是具体code：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;file:Tags.js</span><br><span class="line">import React, &#123; PropTypes &#125; from &#39;react&#39;;</span><br><span class="line">import withStyles from &#39;isomorphic-style-loader&#x2F;lib&#x2F;withStyles&#39;;</span><br><span class="line">import s from &#39;.&#x2F;Tags.css&#39;;</span><br><span class="line"></span><br><span class="line">const title &#x3D; &#39;热门标签&#39;;</span><br><span class="line"></span><br><span class="line">function Tags(props, context) &#123;</span><br><span class="line">  context.setTitle(title);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&#123;s.root&#125;&gt;</span><br><span class="line">      &lt;div className&#x3D;&#123;s.container&#125;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;props.tags.map((item, index) &#x3D;&gt; (</span><br><span class="line">            &lt;span className&#x3D;&#123;s.tags&#125; key&#x3D;&#123;index&#125;&gt;&#123;item.name&#125;&lt;&#x2F;span&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tags.contextTypes &#x3D; &#123; setTitle: PropTypes.func.isRequired &#125;;</span><br><span class="line"></span><br><span class="line">export default withStyles(s)(Tags);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;file:index.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import Tags from &#39;.&#x2F;Tags&#39;;</span><br><span class="line">import fetch from &#39;..&#x2F;..&#x2F;core&#x2F;fetch&#39;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">  path: &#39;&#x2F;tags&#39;,</span><br><span class="line"></span><br><span class="line">  async action() &#123;</span><br><span class="line">    const resp &#x3D; await fetch(&#39;&#x2F;graphql&#39;, &#123;</span><br><span class="line">      method: &#39;post&#39;,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        Accept: &#39;application&#x2F;json&#39;,</span><br><span class="line">        &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,</span><br><span class="line">      &#125;,</span><br><span class="line">      body: JSON.stringify(&#123;</span><br><span class="line">        query: &#39;&#123;tags&#123;name&#125;&#125;&#39;,</span><br><span class="line">      &#125;),</span><br><span class="line">      credentials: &#39;include&#39;,</span><br><span class="line">    &#125;);</span><br><span class="line">    const &#123; data &#125; &#x3D; await resp.json();</span><br><span class="line"></span><br><span class="line">    return &lt;Tags tags&#x3D;&#123;data.tags&#125; &#x2F;&gt;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>css代码就不贴了，虽然它是组件的重要组成部分，但是就逻辑来说，它无关紧要，不是吗？这里简单说下这两个文件，如果说Tags.js是组件的结构逻辑，那么index.js就是数据获取并渲染Tags.js组件的文件。</p>
<p>做好以上步骤以后，我们需要做最后一步，将其添加到路由内部，是我们访问 <code>/tags</code>时候可以访问到。<br>一下是关键代码，文件位置是 <code>/src/routes/index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tags <span class="keyword">from</span> <span class="string">&#x27;./tags&#x27;</span>;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  children: [</span><br><span class="line">    home,</span><br><span class="line">    contact,</span><br><span class="line">    login,</span><br><span class="line">    registerSuccess,</span><br><span class="line">    tags,</span><br><span class="line">    register,</span><br><span class="line">    content,</span><br><span class="line">    error,</span><br><span class="line">  ],</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">action</span>(<span class="params">&#123; next, render, context &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> component = <span class="keyword">await</span> next();</span><br><span class="line">    <span class="keyword">if</span> (component === <span class="literal">undefined</span>) <span class="keyword">return</span> component;</span><br><span class="line">    <span class="keyword">return</span> render(</span><br><span class="line">      &lt;App context=&#123;context&#125;&gt;&#123;component&#125;&lt;/App&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关键点在于import和children中的tags。这里有个非常重要的事情是，自定义组件，请放在content上面(<b>重要的事情说三遍:</b>请放在content上面!请放在content上面!请放在content上面!),如果你不这样做，就无法保证自己路由优先基本，实质上代码逻辑中，经个人调试，会有一个『*』的路由，如果你不放到上面，它就被『*』匹配了,这样就没你的页面什么事情了，因为根本不会往下走了！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文虽然不是深度性的文章，但是确实是一个大纲性质和入门的文章。不管是mongoose、API、GraphQL还是React，他们几乎每个都能写本书。<br>所以说，文章虽然浅显，但是真想用好react-starter-kit，还是需要相对巨量的知识储备。</p>
<p>react-starter-kit，个人认为，虽然是for starter，但是是相对于react-starter-kit的受众starter来说，它实在不是相对于前端初学者。</p>
<p>虽然是个starter-kit，但是：</p>
<pre><code>—— 如果你没有学过express，请不必细看下去；
—— 如果你没有学过mongoose，请不必细看下去；
—— 如果你没有学过React，请不必细看下去；
—— 如果你没有打算学GraphQL，请不必细看下去；</code></pre>
<p>就这样吧，感叹下，前端实在太快，如果没有足够的知识储备，真的无法走在前沿。<br>——向小伙伴们祝好！</p>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>express</tag>
        <tag>react同构应用</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM的简单实现-脏检测</title>
    <url>/2016/05/07/a-simple-mvvm-framwork-1/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>敲下这几个时候心里其实有些犹豫。但是很多事有了开始就行了。遇到的困难主要是第一步难，走过去了就会很平坦。</p>
<p>决定研究一下MVVM，前一篇文章主要讲了MVVM数据绑定的两种实现方式：观察者模式和脏检查模式。最后决定用脏检查来试试。原因上有若干:</p>
<ol>
<li>观察者模式这个在触发上可以理解而且比较直观，但是脏检查模式还是对触发机制有些模糊不清</li>
<li>脏检测据说实现起来相对容易</li>
<li>脏检测这个过程里面的细节个人非常感兴趣</li>
<li>Angular资料比较多 书籍也很多可以参考供参考，mvvm框架这种复杂东西并不适合闭门造车了</li>
</ol>
<blockquote class="blockquote-center"><p>良好的开端，成功的一半。——贺瑞斯 《书简集》</p>
</blockquote>

<h1 id="写在前面-1"><a href="#写在前面-1" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将基于《Build You Own AngularJS》展开。这里自己试试按照《Build You Own AngularJS》步骤来构建。</p>
<h2 id="从Scope开始"><a href="#从Scope开始" class="headerlink" title="从Scope开始"></a>从Scope开始</h2><p>书中的原话是：<br>Scopes are used for many different purposes:</p>
<ul>
<li>Sharing data between controllers and views</li>
<li>Sharing data between different parts of the application </li>
<li>Broadcasting and listening for events</li>
<li>Watching for changes in data</li>
</ul>
<p>这里就不翻译了，都是常见的单词。</p>
<p>当然，虽然这样，但是我认为Scope作为数据双向绑定，才是最大的兴趣点。</p>
<p>我们遵循宏观再微观的顺序，先整整这部分覆盖的内容点。</p>
<ol>
<li>digest cycle和脏检测本身, 包括:$watch,$digest,$apply.</li>
<li>Scope继承 – 这个机制使得不同等级Scope之间的数据和事件继承成为可能.</li>
<li>高效率的面向集合数据的脏检测</li>
<li>事件体系：$on, $emit, and $broadcast.</li>
</ol>
<h2 id="环境设定篇"><a href="#环境设定篇" class="headerlink" title="环境设定篇"></a>环境设定篇</h2><p>开始之前先扯一扯环境安装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建目录并npm init,一路回车</span></span><br><span class="line">mkdir youownangularjs &amp;&amp; cd youownangularjs &amp;&amp; npm init </span><br><span class="line"><span class="comment">//安装grunt插件</span></span><br><span class="line">npm i -g grunt-cli <span class="comment">//如果有跳过</span></span><br><span class="line">npm i grunt grunt-contrib-jshit grunt-contrib-testem sinon --save-dev</span><br><span class="line">npm install -g phantomjs</span><br><span class="line"><span class="comment">//测试需要用到的库 lodash和jquery</span></span><br><span class="line">npm i jquery lodash --save</span><br></pre></td></tr></table></figure>

<p>然后是Gruntfile.js，这个是grunt任务的配置文件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        jshint: &#123;</span><br><span class="line">             all: [<span class="string">&#x27;src/**/*.js&#x27;</span>, <span class="string">&#x27;test/**/*.js&#x27;</span>],</span><br><span class="line">             options: &#123;</span><br><span class="line">             globals: &#123;</span><br><span class="line">                 _: <span class="literal">false</span>,</span><br><span class="line">                 $: <span class="literal">false</span>, </span><br><span class="line">                 jasmine: <span class="literal">false</span>,</span><br><span class="line">                 describe: <span class="literal">false</span>, </span><br><span class="line">                 it: <span class="literal">false</span>,</span><br><span class="line">                 expect: <span class="literal">false</span>, </span><br><span class="line">                 beforeEach: <span class="literal">false</span>, </span><br><span class="line">                 afterEach: <span class="literal">false</span>, </span><br><span class="line">                 sinon: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">             &#125;,</span><br><span class="line">             browser: <span class="literal">true</span>, <span class="attr">devel</span>: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">             &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        testem: &#123;</span><br><span class="line">            unit: &#123;</span><br><span class="line">                options: &#123;</span><br><span class="line">                  framework: <span class="string">&#x27;jasmine2&#x27;</span>,</span><br><span class="line">                  launch_in_dev: [<span class="string">&#x27;PhantomJS&#x27;</span>],</span><br><span class="line">                  before_tests: <span class="string">&#x27;grunt jshint&#x27;</span>,</span><br><span class="line">                  serve_files: [</span><br><span class="line">                              <span class="string">&#x27;node_modules/lodash/lodash.js&#x27;</span>,<span class="comment">//原书是index.js貌似版本更新后变化了</span></span><br><span class="line">                              <span class="string">&#x27;node_modules/jquery/dist/jquery.js&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;node_modules/sinon/pkg/sinon.js&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;src/**/*.js&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;test/**/*.js&#x27;</span></span><br><span class="line">                  ],</span><br><span class="line">                  watch_files: [</span><br><span class="line">                              <span class="string">&#x27;src/**/*.js&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;test/**/*.js&#x27;</span></span><br><span class="line">                  ] </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;);</span><br><span class="line">    grunt.loadNpmTasks(<span class="string">&#x27;grunt-contrib-jshint&#x27;</span>);</span><br><span class="line">    grunt.loadNpmTasks(<span class="string">&#x27;grunt-contrib-testem&#x27;</span>);</span><br><span class="line">    grunt.registerTask(<span class="string">&#x27;default&#x27;</span>, [<span class="string">&#x27;testem:run:unit&#x27;</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>项目结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">├── Gruntfile.js</span><br><span class="line">├── index.js</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   ├── hello.js</span><br><span class="line">│   └── scope.js</span><br><span class="line">└── test</span><br><span class="line">    ├── hello_spec.js</span><br><span class="line">    └── scope.spec.js</span><br></pre></td></tr></table></figure>

<h2 id="watch-amp-digest"><a href="#watch-amp-digest" class="headerlink" title="$watch&amp;$digest"></a>$watch&amp;$digest</h2><p>想了一下，如果按部就班顺书而就，那么这篇文章也就成为了一个翻译，而且顺着别人思路来也得不到什么相对深层次的思考，所以这里反其道而来，分析测试，来踹度作者思路，还是走了捷径，但是相比顺思路来还是有其思考过程。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line">describe(<span class="string">&quot;Scope&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">&quot;可以用来做构造器,也可以作为一个对象使用|can be constructed and used as an object&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">var</span> scope = <span class="keyword">new</span> Scope();</span><br><span class="line">        scope.aProperty = <span class="number">1</span>;</span><br><span class="line">        expect(scope.aProperty).toBe(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    describe(<span class="string">&quot;digest&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> scope;</span><br><span class="line">        beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; scope = <span class="keyword">new</span> Scope();</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&#x27;第一次$digest时候调用监视器的监听函数|calls the listener function of a watch on first $digest&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> watchFn    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;wat&#x27;</span>; &#125;;</span><br><span class="line">            <span class="keyword">var</span> listenerFn = jasmine.createSpy();</span><br><span class="line">            scope.$watch(watchFn, listenerFn);</span><br><span class="line"></span><br><span class="line">            scope.$digest();</span><br><span class="line"></span><br><span class="line">            expect(listenerFn).toHaveBeenCalled();</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&quot;调用监视器的监听函数时候将scope作为参数传入|calls the watch function with the scope as the argument&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> watchFn = jasmine.createSpy();</span><br><span class="line">            <span class="keyword">var</span> listenerFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">            scope.$watch(watchFn, listenerFn);</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(watchFn).toHaveBeenCalledWith(scope);</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&quot;当监听的值改变时候调用监视器的监听函数|calls the listener function when the watched value changes&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; scope.someValue = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            scope.counter = <span class="number">0</span>;</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.someValue; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123; scope.counter++; &#125;</span><br><span class="line">            );</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">0</span>);</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">            scope.someValue = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        it(<span class="string">&quot;当监视值开始是undefined时候调用监视函数|calls listener when watch value is first undefined&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            scope.counter = <span class="number">0</span>;</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.someValue; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123; scope.counter++; &#125;</span><br><span class="line">            );</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        it(<span class="string">&quot;may have watchers that omit the listener function&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> watchFn = jasmine.createSpy().and.returnValue(<span class="string">&#x27;something&#x27;</span>);</span><br><span class="line">            scope.$watch(watchFn);</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(watchFn).toHaveBeenCalled();</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&quot;相同digest里面监视器循环调用|triggers chained watchers in the same digest&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//先监视nameUpper，然后再监视name(监听函数里面修改nameUpper)，最后改变name以期循环调用</span></span><br><span class="line">            scope.name = <span class="string">&#x27;Jane&#x27;</span>;</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.nameUpper; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (newValue) &#123;</span><br><span class="line">                        scope.initial = newValue.substring(<span class="number">0</span>, <span class="number">1</span>) + <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125; &#125;</span><br><span class="line">            );</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.name; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (newValue) &#123;</span><br><span class="line">                        scope.nameUpper = newValue.toUpperCase();</span><br><span class="line">                    &#125; &#125;</span><br><span class="line">            );</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.initial).toBe(<span class="string">&#x27;J.&#x27;</span>);</span><br><span class="line">            scope.name = <span class="string">&#x27;vob&#x27;</span>;</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.initial).toBe(<span class="string">&#x27;V.&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&quot;终止一个迭代10次的监视器|gives up on the watches after 10 iterations&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            scope.counterA = <span class="number">0</span>;</span><br><span class="line">            scope.counterB = <span class="number">0</span>;</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.counterA; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                    scope.counterB++;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.counterB; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                    scope.counterA++;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">            expect((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; scope.$digest(); &#125;)).toThrow();</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&quot;结束digest，当最后的监视器是干净的|ends the digest when the last watch is clean&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            scope.array = _.range(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">var</span> watchExecutions = <span class="number">0</span>;</span><br><span class="line">            _.times(<span class="number">100</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123; scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123;</span><br><span class="line">                    watchExecutions++;</span><br><span class="line">                    <span class="keyword">return</span> scope.array[i];</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123; &#125;</span><br><span class="line">            ); &#125;);</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(watchExecutions).toBe(<span class="number">200</span>);</span><br><span class="line">            scope.array[<span class="number">0</span>] = <span class="number">420</span>;</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(watchExecutions).toBe(<span class="number">301</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        it(<span class="string">&quot;does not end digest so that new watches are not run&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            scope.aValue = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">            scope.counter = <span class="number">0</span>;</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.aValue; &#125;,</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                    scope.$watch(</span><br><span class="line">                        <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.aValue; &#125;,</span><br><span class="line">                        <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                            scope.counter++;</span><br><span class="line">                        &#125; </span><br><span class="line">                    );</span><br><span class="line">                &#125; );</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&quot;基于值的对比，如果可以的话|compares based on value if enabled&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            scope.aValue = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">            scope.counter = <span class="number">0</span>;</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.aValue; &#125;,</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                    scope.counter++;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="literal">true</span></span><br><span class="line">            );</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">            scope.aValue.push(<span class="number">4</span>);</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&#x27;正确的处理NaN|correctly handles NaNs&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            scope.number = <span class="number">0</span>/<span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line">            scope.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.number; &#125;,</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                    scope.counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>列下主要的标题:</p>
<ol>
<li>Scope 对象</li>
<li>监视对象属性：$watch和$digest</li>
<li>检查Dirty值</li>
<li>初始化监视值</li>
<li>获得Digest的通知</li>
<li>在dirty的时候保持digesting</li>
<li>终止不稳定的Digest</li>
<li>短路digest进程，如果最后一个污点被清除</li>
<li>基于值的脏检测</li>
</ol>
<p>主要的逻辑如下图：</p>
<iframe id="embed_dom" name="embed_dom" frameborder="0" style="border:1px solid #000;display:block;width:100%; height:500px;" src="https://www.processon.com/embed/573339a7e4b0c102ad1e17b5"></iframe>

<p>这是Scope部分主要包含watch和digest的代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* jshint globalstrict: true */</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$$watchers = [];</span><br><span class="line">    <span class="built_in">this</span>.$$lastDirtyWatch = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatchVal</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Scope.prototype.$watch = <span class="function"><span class="keyword">function</span>(<span class="params">watchFn, listenerFn, valueEq</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> watcher = &#123;</span><br><span class="line">	        watchFn: watchFn,</span><br><span class="line">	        listenerFn: listenerFn || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">	        valueEq: !!valueEq,</span><br><span class="line">	        last: initWatchVal</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.$$watchers.push(watcher);</span><br><span class="line">    <span class="built_in">this</span>.$$lastDirtyWatch = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scope.prototype.$$digestOnce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> newValue, oldValue, dirty; </span><br><span class="line">    _.forEach(<span class="built_in">this</span>.$$watchers, <span class="function"><span class="keyword">function</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">        newValue = watcher.watchFn(self);</span><br><span class="line">        oldValue = watcher.last;</span><br><span class="line">        <span class="keyword">if</span> (!self.$$areEqual(newValue, oldValue, watcher.valueEq)) &#123;</span><br><span class="line">            self.$$lastDirtyWatch = watcher;</span><br><span class="line">            watcher.last = (watcher.valueEq ? _.cloneDeep(newValue) : newValue);</span><br><span class="line">            watcher.listenerFn(newValue,(oldValue === initWatchVal ? newValue : oldValue), self);</span><br><span class="line">            dirty = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.$$lastDirtyWatch === watcher) &#123; </span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; &#125;);</span><br><span class="line">    <span class="keyword">return</span> dirty;</span><br><span class="line">&#125;;</span><br><span class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ttl = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> dirty;</span><br><span class="line">    <span class="built_in">this</span>.$$lastDirtyWatch = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        dirty = <span class="built_in">this</span>.$$digestOnce();</span><br><span class="line">        <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;10 digest iterations reached&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (dirty);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Scope.prototype.$$areEqual = <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, valueEq</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (valueEq) &#123;</span><br><span class="line">        <span class="keyword">return</span> _.isEqual(newValue, oldValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newValue === oldValue ||</span><br><span class="line">            (<span class="keyword">typeof</span> newValue === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> oldValue === <span class="string">&#x27;number&#x27;</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">isNaN</span>(newValue) &amp;&amp; <span class="built_in">isNaN</span>(oldValue));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码不多，但是可以通过上面的测试用例。</p>
<p>这里我们来根据测试和标题整理相关知识点——不得不说，这些都是基础的东西，但是组合在一起就变得很考验开发者的功底。废话不说，开始干活。</p>
<h3 id="step1-watchFn传参"><a href="#step1-watchFn传参" class="headerlink" title="step1-watchFn传参"></a>step1-watchFn传参</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&#x27;第一次$digest时候调用监视器的监听函数|calls the listener function of a watch on first $digest&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> watchFn    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;wat&#x27;</span>; &#125;;</span><br><span class="line">    <span class="keyword">var</span> listenerFn = jasmine.createSpy();</span><br><span class="line">    scope.$watch(watchFn, listenerFn);</span><br><span class="line"></span><br><span class="line">    scope.$digest();</span><br><span class="line"></span><br><span class="line">    expect(listenerFn).toHaveBeenCalled();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>先看这个测试,这个测试意图是，当scope.$watch(watchFn, listenerFn);开始监控变化后，一旦运行了$digest，就会触发listenerFn这个回调。<br>这个测试是基于怎样的目的呢？这是确保$digest的功能设置初衷:确保遍历watchers数组，然后遍历它执行里面的监视函数。</p>
<h3 id="step2-digest初次运行"><a href="#step2-digest初次运行" class="headerlink" title="step2-$digest初次运行"></a>step2-$digest初次运行</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&quot;调用监视器的监听函数时候将scope作为参数传入|calls the watch function with the scope as the argument&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> watchFn = jasmine.createSpy();</span><br><span class="line">    <span class="keyword">var</span> listenerFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    scope.$watch(watchFn, listenerFn);</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(watchFn).toHaveBeenCalledWith(scope);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个测试其实两个测试了。<code>expect(watchFn).toHaveBeenCalledWith(scope);</code>，一个是显式的，scope被作为参数传入watchFn，二是隐式的，watchFn被<code>scope.$digest()</code>触发了。这里，在代码中的 <code>newValue = watcher.watchFn(self);</code>使得代码得以通过。</p>
<h3 id="step3-检查Dirty值"><a href="#step3-检查Dirty值" class="headerlink" title="step3-检查Dirty值"></a>step3-检查Dirty值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  it(<span class="string">&quot;当监听的值改变时候调用监视器的监听函数|calls the listener function when the watched value changes&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"></span><br><span class="line">scope.someValue = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      scope.counter = <span class="number">0</span>;</span><br><span class="line">      scope.$watch(</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; </span><br><span class="line">          	<span class="keyword">return</span> scope.someValue; </span><br><span class="line">          &#125;, </span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123; </span><br><span class="line">          	scope.counter++; </span><br><span class="line">          &#125;</span><br><span class="line">      );</span><br><span class="line">      expect(scope.counter).toBe(<span class="number">0</span>);</span><br><span class="line">      scope.$digest();</span><br><span class="line">      expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">      scope.$digest();</span><br><span class="line">      expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">      scope.someValue = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">      expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">      scope.$digest();</span><br><span class="line">      expect(scope.counter).toBe(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>监听值改变以后进行触发。这是脏检测的一个测试，如果被监视的值改变了，那么进行检测，然后调用对应的监听函数。<br>这里测试意图中有几点需要注意一下：</p>
<ol>
<li>第一次$digest时候没有改变值就触发了监听函数</li>
<li>第二次再次直接$digest没有触发</li>
<li>第三次改变scope.someValue没有执行$digest没有触发监听函数</li>
<li>第四次在someValue改变前提下执行$digest，监听函数执行了</li>
</ol>
<p>这里新旧值进行脏检测主要是通过这块代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newValue, oldValue; _.forEach(<span class="built_in">this</span>.$$watchers, <span class="function"><span class="keyword">function</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">newValue = watcher.watchFn(self); oldValue = watcher.last;</span><br><span class="line"><span class="keyword">if</span> (newValue !== oldValue) &#123;</span><br><span class="line">      watcher.last = newValue;</span><br><span class="line">      watcher.listenerFn(newValue, oldValue, self);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="step4-初始化监视值"><a href="#step4-初始化监视值" class="headerlink" title="step4-初始化监视值"></a>step4-初始化监视值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&quot;当监视值开始是undefined时候调用监视函数|calls listener when watch value is first undefined&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    scope.counter = <span class="number">0</span>;</span><br><span class="line">    scope.$watch(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.someValue; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123; scope.counter++; &#125;</span><br><span class="line">    );</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当执行$watch时候scope.someValue是undefined，也就是说，这段测试代码期待即使要监视的属性是undefined也要可以顺利通过。这是一个fixbug性质的测试。<br>目标是为了测试初始化监视值。<br>这里有一些地方值得关注:</p>
<ol>
<li>last即使使得undefined合法也无法使得程序正常运行(undefined===undefined = true,当已有这个监视器会重复)</li>
<li>而我们需要一个不会重复的值.javascript中函数是引用值，除了自身不会和谁相等。可以利用到这里。此时它同监视器函数可能返回的任何值都不会相同。</li>
</ol>
<h3 id="step5-获得Digest的通知"><a href="#step5-获得Digest的通知" class="headerlink" title="step5-获得Digest的通知"></a>step5-获得Digest的通知</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&quot;may have watchers that omit the listener function&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> watchFn = jasmine.createSpy().and.returnValue(<span class="string">&#x27;something&#x27;</span>);</span><br><span class="line">       scope.$watch(watchFn);</span><br><span class="line">       scope.$digest();</span><br><span class="line">       expect(watchFn).toHaveBeenCalled();</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>这里焦点是：</p>
<ol>
<li>这里的$watch仅仅传了一个参数，监听函数listenerFn是空的，这样当遍历过程中执行对应的监听函数必然报错，因为这个listenerFn不存在。所以代码里面有一句 <code>listenerFn: listenerFn || function() &#123; &#125;</code>，这是容错处理。</li>
<li>toHaveBeenCalled是确认是否调用，这里测试用来确保digest时候获取通知。</li>
</ol>
<h3 id="step6-在dirty的时候保持digesting"><a href="#step6-在dirty的时候保持digesting" class="headerlink" title="step6-在dirty的时候保持digesting"></a>step6-在dirty的时候保持digesting</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&quot;相同digest里面监视器链式调用|triggers chained watchers in the same digest&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//先监视nameUpper，然后再监视name(监听函数里面修改nameUpper)，最后改变name以期循环调用</span></span><br><span class="line">    scope.name = <span class="string">&#x27;Jane&#x27;</span>;</span><br><span class="line">    scope.$watch(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.nameUpper; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue) &#123;</span><br><span class="line">                scope.initial = newValue.substring(<span class="number">0</span>, <span class="number">1</span>) + <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125; &#125;</span><br><span class="line">    );</span><br><span class="line">    scope.$watch(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.name; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue) &#123;</span><br><span class="line">                scope.nameUpper = newValue.toUpperCase();</span><br><span class="line">            &#125; &#125;</span><br><span class="line">    );</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.initial).toBe(<span class="string">&#x27;J.&#x27;</span>);</span><br><span class="line">    scope.name = <span class="string">&#x27;vob&#x27;</span>;</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.initial).toBe(<span class="string">&#x27;V.&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里测试主要逻辑是先监视nameUpper，再监视name,name的监听函数里面修改nameUpper以便改了name之后能把变化蔓延到nameUpper，这样可以测试是否可以做到链式调用。</p>
<h3 id="step7-终止不稳定的Digest"><a href="#step7-终止不稳定的Digest" class="headerlink" title="step7-终止不稳定的Digest"></a>step7-终止不稳定的Digest</h3><p>链式调用存在一个问题是两个监视器对应的监听函数里面互相修改彼此的值，这样会无限循环处理脏数据，造成死循环，所以要防止这种情况,对应的代码是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ttl = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> dirty;</span><br><span class="line">    <span class="built_in">this</span>.$$lastDirtyWatch = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        dirty = <span class="built_in">this</span>.$$digestOnce();</span><br><span class="line">        <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;10 digest iterations reached&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (dirty);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里设置了ttl值，值为10。当ttl==10，此时会抛出错误。这样当脏检测机制遇到数据全部干净或者10次迭代循环后会结束digest过程。</p>
<h3 id="step8-短路digest进程"><a href="#step8-短路digest进程" class="headerlink" title="step8-短路digest进程"></a>step8-短路digest进程</h3><p>脏检测最大的问题是优化问题。按照原理来说，脏检测每次执行检测都需要遍历所有的监视属性，那么随着监视属性的数量不断增多，那么会导致脏检测过程变慢这个缺陷无限放大，如果达到一个理论的量，那么会存在内存溢出和应用卡顿到没法用的问题和风险，所以这里有必要进行下一步的优化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&quot;结束digest，当最后的监视器是干净的|ends the digest when the last watch is clean&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    scope.array = _.range(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">var</span> watchExecutions = <span class="number">0</span>;</span><br><span class="line">    _.times(<span class="number">100</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123; </span><br><span class="line">     scope.$watch(</span><br><span class="line">         <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123;</span><br><span class="line">             watchExecutions++;</span><br><span class="line">             <span class="keyword">return</span> scope.array[i];</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123; &#125;</span><br><span class="line">     ); </span><br><span class="line">    &#125;);</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(watchExecutions).toBe(<span class="number">200</span>);</span><br><span class="line">    scope.array[<span class="number">0</span>] = <span class="number">420</span>;</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(watchExecutions).toBe(<span class="number">301</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段测试的意图应该比较明显，_.range(100)创建一个包含100个从0递增到99的数字的数组，_.times则相当于Array的each方法，迭代器里面传入了index索引。<br>这个测试里面监视了从0到99。预期第一次执行$digest(),watchExecutions会等于200，也就是说watchFn被执行了200次。第二次在修改了其中一个值以后，再运行$digest()，会多运行101次watchFn。</p>
<p>这里有些地方需要关注，那就是200和101这两个数。<br>我们这里来算算这个数：</p>
<ol>
<li>首先$.watch操作将数据压入到watcher数组，完毕之后数组里面有100个元素</li>
<li>$digest运行时候会进行脏检测获取newValue，这里会调用1次watchFn，加起来有100次</li>
<li>do…while这断，因为原来没有数据，此时数据是脏的，导致运行了2次$$digestOnce，这样200就得到了</li>
<li>改变值以后再次执行$digest()，仍然会如同上一次，先do一次，然后判断是否脏数据，然后再运行一次do逻辑。</li>
</ol>
<p>优化的主要是第4步，这里整理了一下watch和digest逻辑。首先，digest是基于do…while执行，也就是说当dirty==true时候这个digest不会停止。默认想法下，这个digest是一轮一轮的来对脏数据进行处理，但是经过优化之后，可以跳过一些环节，因为脏数据在数组顶部一些位置，这样处理完了可以直接跳过后面的。</p>
<p>主要的标记在这里:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.$$lastDirtyWatch = watcher;</span><br><span class="line">watcher.last = (watcher.valueEq ? _.cloneDeep(newValue) : newValue);</span><br><span class="line">watcher.listenerFn(newValue,</span><br><span class="line">    (oldValue === initWatchVal ? newValue : oldValue),</span><br><span class="line">    self);</span><br><span class="line">dirty = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>具体来说，这个流程是这样的 ，当第一次进行watch时候，值不存在，所以digest过程do一次之后，触发dirty==true，又跑了一次do逻辑——跑了一次全部，因为$$lastDirtyWatch指向最后一个，当再次改变一个值以后，跑一次do逻辑，将$$lastDirtyWatch作为游标指向最后一个污点属性(此时$$lastDirtyWatch指向第一个)，然后进入触发dirty==true环节，此时因为$$lastDirtyWatch==watcher(第一个监视属性)为真，所以短路跳出了。这样就不需要再跑一次全部。</p>
<h3 id="step9-基于值的脏检测-gt-比较全部基于值"><a href="#step9-基于值的脏检测-gt-比较全部基于值" class="headerlink" title="step9-基于值的脏检测-&gt;比较全部基于值"></a>step9-基于值的脏检测-&gt;比较全部基于值</h3><p>脏检测对比过程中需要确定值类型，当对比的值是一个引用类型的话，即使改变了值，但是由于是一个引用，那么最终还是会相等，因为指向没有任何改变。所以在脏检测过程中需要对引用类型进行一次深拷贝再比较，也就是说，即使是引用值，也必须转换为基于值的比较。</p>
<p>测试用例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&quot;基于值的对比，如果可以的话|compares based on value if enabled&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    scope.aValue = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    scope.counter = <span class="number">0</span>;</span><br><span class="line">    scope.$watch(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.aValue; &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">            scope.counter++;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">    scope.aValue.push(<span class="number">4</span>);</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.counter).toBe(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里scope.counter==1而不是等于2，是由于$$lastDirtyWatch指向了第一个。其他地方没有什么值得注意的地方。</p>
<h3 id="step10-NaNs兼容"><a href="#step10-NaNs兼容" class="headerlink" title="step10-NaNs兼容"></a>step10-NaNs兼容</h3><p>为什么要有这个检测呢？一句代码的事情: <code>(NaN===NaN) === false</code><br>虽然奇怪但是确实如此，如果不对此做特殊处理，那么NaN在脏检测函数中将始终是脏数据。不过，lodash的isEqual方法已经对此做了兼容。所以我们不需要改什么代码了。<br>这里是测试:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&#x27;正确的处理NaN|correctly handles NaNs&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    scope.number = <span class="number">0</span>/<span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line">    scope.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    scope.$watch(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; </span><br><span class="line">        	<span class="keyword">return</span> scope.number; </span><br><span class="line">    	&#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">            scope.counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这没什么奇怪的，但是如果没有isEqual大法加持，正常情况下$digest每执行一次，都会执行一次linstenFn的。。。也就是说scope.counter会被+1.</p>
<h2 id="eval、-apply和-evalAsync"><a href="#eval、-apply和-evalAsync" class="headerlink" title="$eval、$apply和$evalAsync"></a>$eval、$apply和$evalAsync</h2><h3 id="eval"><a href="#eval" class="headerlink" title="$eval"></a>$eval</h3><p>$eval的作用是在scope中执行给出的表达式。<br>$eval很容易实现，代码主要是这样，测试代码就不管了,因为简单的实在不想贴测试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope.prototype.$eval = <span class="function"><span class="keyword">function</span>(<span class="params">expr, locals</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">return</span> expr(<span class="built_in">this</span>, locals);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="apply"><a href="#apply" class="headerlink" title="$apply"></a>$apply</h3><p>$apply作用是将外部js代码引入到scope的digest环节来。这个方法可能是非常非常广为人知的一个方法。尤其是用jquery处理数据更新数据，ajax获取数据更新view什么的。<br>但是$.apply真的没有比$.eval复杂到哪儿去。他实际上调用了$.eval，然后手动触发了digest,代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope.prototype.$apply = <span class="function"><span class="keyword">function</span>(<span class="params">expr</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.$eval(expr); </span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.$digest(); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>try/catch用的比较多，但是try/finally估计很少见了.finally在try和catch代码执行完毕后执行，不管这两个环节结果如何。</p>
<h3 id="evalAsync"><a href="#evalAsync" class="headerlink" title="$evalAsync"></a>$evalAsync</h3><p>$evalAsync作用是代码延迟执行。setTimeout(function(){},0)是代码延迟执行其中一个办法。但是setTimeout的问题是一旦你使用了它，那么就等于完全放弃了对代码执行时机的控制——浏览器可能去渲染UI，可能去响应事件，直到很久以后才会执行指定的代码片段。$evalAsync更优于setTimeout，就是因为它在这个时机上控制得更好。</p>
<p>这里看测试代码，可以更加清晰了解设计意图：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&quot;executes $evalAsync&#x27;ed function later in the same cycle&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; scope.aValue = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">		scope.asyncEvaluated = <span class="literal">false</span>;</span><br><span class="line">		scope.asyncEvaluatedImmediately = <span class="literal">false</span>;</span><br><span class="line">		scope.$watch(</span><br><span class="line">			<span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.aValue; &#125;, </span><br><span class="line">			<span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">				scope.$evalAsync(<span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; </span><br><span class="line">				scope.asyncEvaluated = <span class="literal">true</span>;</span><br><span class="line">			&#125;);</span><br><span class="line">	        scope.asyncEvaluatedImmediately = scope.asyncEvaluated;</span><br><span class="line">	    &#125;);</span><br><span class="line">		scope.$digest(); </span><br><span class="line">		expect(scope.asyncEvaluated).toBe(<span class="literal">true</span>); </span><br><span class="line">		expect(scope.asyncEvaluatedImmediately).toBe(<span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>很显然，这里$evalAsync内部的函数在 <code>scope.asyncEvaluatedImmediately = scope.asyncEvaluated;</code>之前完成了。<br>实现这点不算难，找个地方保存这个函数，然后在digest过程中的do里面先执行一次就可以了。<br>修改后代码这样:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$$watchers = [];</span><br><span class="line">    <span class="built_in">this</span>.$$lastDirtyWatch = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.$$asyncQueue = [];<span class="comment">//add</span></span><br><span class="line">&#125;</span><br><span class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ttl = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> dirty;</span><br><span class="line">    <span class="built_in">this</span>.$$lastDirtyWatch = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">		&lt;!-- 添加start --&gt;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.$$asyncQueue.length) &#123;</span><br><span class="line">            <span class="keyword">var</span> asyncTask = <span class="built_in">this</span>.$$asyncQueue.shift();</span><br><span class="line">            asyncTask.scope.$eval(asyncTask.expression);</span><br><span class="line">        &#125;</span><br><span class="line">		&lt;!-- 添加end --&gt;</span><br><span class="line">        dirty = <span class="built_in">this</span>.$$digestOnce();</span><br><span class="line">        <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;10 digest iterations reached&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (dirty);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>继续看下一个测试:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&quot;executes $evalAsync&#x27;ed functions even when not dirty&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    scope.aValue = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    scope.asyncEvaluatedTimes = <span class="number">0</span>;</span><br><span class="line">    scope.$watch(<span class="function"><span class="keyword">function</span> (<span class="params">scope</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (scope.asyncEvaluatedTimes &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                scope.$evalAsync(<span class="function"><span class="keyword">function</span> (<span class="params">scope</span>) </span>&#123;</span><br><span class="line">                    scope.asyncEvaluatedTimes++;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> scope.aValue;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.asyncEvaluatedTimes).toBe(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>报错了。。。因为第二次运行时候数据不是脏的，因此没有进入do逻辑。。。改改:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Scope.prototype.$digest &#x3D; function() &#123; </span><br><span class="line">	...</span><br><span class="line">do &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; while (dirty || this.$$asyncQueue.length); &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样一来测试是通过了，但是问题是如果如果watcher里面一直$evalAsync导致不停执行do逻辑造成死循环怎么办？所以继续改，先上测试用例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&quot;eventually halts $evalAsyncs added by watches&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    scope.aValue = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    scope.$watch(<span class="function"><span class="keyword">function</span> (<span class="params">scope</span>) </span>&#123;</span><br><span class="line">            scope.$evalAsync(<span class="function"><span class="keyword">function</span> (<span class="params">scope</span>) </span>&#123;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> scope.aValue;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    expect(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        scope.$digest();</span><br><span class="line">    &#125;).toThrow();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>代码改造:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Scope.prototype.$digest &#x3D; function () &#123;</span><br><span class="line">    var ttl &#x3D; 10;</span><br><span class="line">    var dirty;</span><br><span class="line">    this.$$lastDirtyWatch &#x3D; null;</span><br><span class="line">    do &#123;</span><br><span class="line"></span><br><span class="line">        while (this.$$asyncQueue.length) &#123;</span><br><span class="line">            var asyncTask &#x3D; this.$$asyncQueue.shift();</span><br><span class="line">            asyncTask.scope.$eval(asyncTask.expression);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dirty &#x3D; this.$$digestOnce();</span><br><span class="line">        if ((dirty || this.$$asyncQueue.length) &amp;&amp; !(ttl--)) &#123; &#x2F;&#x2F;修改的代码</span><br><span class="line">            throw &quot;10 digest iterations reached&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (dirty || this.$$asyncQueue.length);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样，当 <code>(dirty || this.$$asyncQueue.length)</code>反复为true时候，就会tll累减，最后抛出错误终止。</p>
<h2 id="收个尾"><a href="#收个尾" class="headerlink" title="收个尾"></a>收个尾</h2><p>实际上写完$eval、$apply和$evalAsync这块时候突然发觉有些跑题了。文章初衷还是学习一下脏检测是如何运行的。所以就暂且打住了。不过考虑到往后还会继续深入下去，暂时就不做删除了。</p>
<p>这里再次回顾整理一下脏检测：<br>回顾一下文章标题，总结下脏检测实现思路。</p>
<ol>
<li>Scope 对象</li>
<li>监视对象属性：$watch和$digest</li>
<li>检查Dirty值</li>
<li>初始化监视值</li>
<li>获得Digest的通知</li>
<li>在dirty的时候保持digesting</li>
<li>终止不稳定的Digest</li>
<li>短路digest进程，如果最后一个污点被清除</li>
<li>基于值的脏检测</li>
</ol>
<p>个人总结：<br>基本上脏检测呢，说得有些术语化，其实整个过程真的和高深扯不上太多关系。主要的思路是这样的：</p>
<ol>
<li>实现Scope函数，在原型上挂载$watch和$digest和方法</li>
<li>digest过程返回Dirty值用来判断是否继续执行digest过程</li>
<li>$watch负责添加要监视的属性，而digest负责消灭污点</li>
<li>至于更多的初始值啊，基于值的比较啊，NaN啊，死循环啊，digest优化之类，都不过是细节补充</li>
<li>$apply实现真的说明了很多</li>
</ol>
<p>最后一句话总结就是digest是手动触发——真的没有太多深奥的东西。<br>当然，这里手动触发有不少值得注意的场景：</p>
<ol>
<li>Scope内部数组的splice，slice，push，pop等堆栈操作</li>
<li>View2Data环节过程中各种事件触发</li>
<li>$apply等等</li>
</ol>
<p>到这里这一篇就此暂结，本文主要整理了脏检测过程中细节的实现和测试。最后发现除了深入了实现机制，确实也没有什么特别耀眼的东西。但是整个过程，还是深入了解了脏检测实现过程中需要考虑的细节，收获还是不少。</p>
<p>Thanks For 《Build You Own AngularJS》</p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>双向绑定原理</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM基础之双向绑定原理</title>
    <url>/2016/05/03/two-way-bind/</url>
    <content><![CDATA[<h1 id="双向绑定的实现原理"><a href="#双向绑定的实现原理" class="headerlink" title="双向绑定的实现原理"></a>双向绑定的实现原理</h1><p>到处找了下数据双向绑定的资料。这里跑回来总结一下双向绑定实现的方式:</p>
<ol>
<li>依赖ES5的Object.defineProperty方法构成的观察者模式(订阅发布模式|Pub/Sub)</li>
<li>类似AngularJS的脏值检查模式</li>
</ol>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote>
<p>有关观察者模式这里基本引用来自<a href="http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html">汤姆大叔的博客</a>,需要了解更多可以前往观摩</p>
</blockquote>
<p>观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</p>
<p>观察者模式的优点(更多详情可以看:</p>
<ul>
<li>支持简单的广播通信，自动通知所有已经订阅过的对象。</li>
<li>页面载入后目标对象很容易与观察者存在一种动态关联，增加了灵活性。</li>
<li>目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用。</li>
</ul>
<p>在javascript开发过程中，因为javascript的特殊性，在JavaScript开发中,我们一般用事件模型来替代传统的发布—订阅模式。</p>
<p>在MVVM这里，这个订阅发布路径基本是这样的：</p>
<ol>
<li><p>Data to View(UpdateView订阅了Model的change事件)<br> a. 首先设置一个UpdateView函数，传入Data就更新View<br> b. Object.defineProperty拦截对象的get和set参数，当发生属性变化时候额外触发UpdateView更新View</p>
</li>
<li><p>View to Data(UpdateModel订阅了元素的press、change之类事件)<br> a. 绑定事件 触发时候修改Model,设这个动作叫做UpdateModel<br> b. 触发后进行数据更改</p>
</li>
</ol>
<p>换个通俗的说法就是：Data在改变触发回调时候更新View，而View改动后触发回调更新Data。这里使用观察者模式有两个目的:</p>
<ol>
<li>解耦:目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用</li>
<li>1对多:一个数据可能在一个View里面多处使用。</li>
</ol>
<p>观察者模式其实就这么点了。View2Data随便干过点js开发的人都会理解这个事件触发机制。整个MVVM双向绑定思路里面相对麻烦的其实是Data2View。</p>
<p>当Dom修改时候会有click，change，pressdown等事件可以响应、捕捉。</p>
<p>但是Data数据修改时候却没有什么时机可以用来捕捉以触发一个回调。</p>
<p>这个时候Object.defineProperty就成了唯一的救命稻草——我们在通过这个方法劫持get和set，对它进行了『覆写』，并在这些个覆写的函数里面手动调用相应的回调——事实上它的机制就是那么笨拙，只是把它写到set、get里面自动调用不需要你手动调用了而已，并且模拟了一个change事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拦截 object 的 prop 属性的 get 和 set 方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(object, prop, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getValue(object, prop);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> oldValue = <span class="built_in">this</span>.getValue(object, prop);</span><br><span class="line">        <span class="keyword">if</span> (newValue !== oldValue) &#123;</span><br><span class="line">            <span class="built_in">this</span>.setValue(object, newValue, prop);</span><br><span class="line">            <span class="comment">// 触发变化回调</span></span><br><span class="line">            <span class="built_in">this</span>.triggerChange(prop, newValue, oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="脏值检查模式"><a href="#脏值检查模式" class="headerlink" title="脏值检查模式"></a>脏值检查模式</h2><blockquote>
<p>脏检查即一种不关心你如何以及何时改变的数据，只关心在特定的检查阶段数据是否改变的数据监听技术。</p>
</blockquote>
<p>首先说下脏检查模式和观察者模式最大的区别:<br>就像之前已经说过了，如果不使用Object.defineProperty那么就无法在值发生改变时候触发动作。观察者模式使用Object.defineProperty对get和set进行了覆写，但是脏检查模式没有这样做。这意味它的操作不是被动调用，而是“主动”进入。</p>
<p>这个被动与主动，就是观察者模式，和脏检查模式最根源的区别。</p>
<p>脏检查如何进行观察对象的对比和更新，这是一个处理细节，在原理阶段可以不深究。</p>
<p>更加关心的是，这个主动进入，是遵循怎样的方式。这里细节相对多，以angularJS为例：</p>
<ol>
<li>DOM事件，譬如用户输入文本，点击按钮等。(ng-click)</li>
<li>XHR响应事件 ($http)</li>
<li>浏览器Location变更事件 ($location)</li>
<li>Timer事件($timeout, $interval)</li>
<li>执行$digest()或$apply()</li>
</ol>
<p>这里有写地方需要重点突出:</p>
<ol>
<li>脏检测不是心跳检测。它不会轮询检查数据</li>
<li>数据变化时候默认不会有回调被调用——如果你用过$apply()就知道。它是基于上诉时机触发的。</li>
<li>数据数组的splice等操作会触发Data2View，这是因为数组的方法被重写了。这点同之前一样。</li>
</ol>
<p>当然，脏检测同观察者模式相比也是有优点的:</p>
<blockquote>
<p>1.脏检查完全不关心你改变数据的方式，而常规的set, get的方式则会强加许多限制<br>2.脏检查可以实现批处理完数据之后，再去统一更新view.<br>3.脏检查其实比 GET/SET 更容易实现。脏检查是个单向的检查流程(请不要和双向绑定发生混淆)，可以实现_任意复杂度的表达式支持。而get/set的方式则需要处理复杂依赖链，基本上表达式支持都是阉割的(使用时就像踩雷).<br>——摘自<a href="https://regularjs.github.io/guide/zh/advanced/dirty.html">&lt;&lt;脏检查: 数据绑定的秘密&gt;&gt;</a></p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>暂时收尾一下，MVVM必然是个大话题，但是这里首先主要总结原理，指明下一步研究方向。到此数据绑定的原理基本梳理了一遍。此文暂且收结。</p>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a href="http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html">深入理解JavaScript系列（32）：设计模式之观察者模式</a><br><a href="https://segmentfault.com/a/1190000004847657">利用 JavaScript 数据绑定实现一个简单的 MVVM 库</a><br><a href="https://regularjs.github.io/guide/zh/advanced/dirty.html">脏检查: 数据绑定的秘密</a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>双向绑定原理</tag>
      </tags>
  </entry>
  <entry>
    <title>template 模板技术</title>
    <url>/2016/04/30/template/</url>
    <content><![CDATA[<h1 id="文首的话"><a href="#文首的话" class="headerlink" title="文首的话"></a>文首的话</h1><p>这篇文章总结和自己尝试实现一下模板。然后总结下业界当前各种先进的模板技术。<br>算是一种锻炼吧，写了那么多业务，也用那么多轮子。自己来造轮子看看。</p>
<h1 id="字符串模板的分析"><a href="#字符串模板的分析" class="headerlink" title="字符串模板的分析"></a>字符串模板的分析</h1><p>模板也有很多种，但是这里仅仅分析和实现基于字符串的模板。为了方便，这里就基于artTemplate的语法来分析模板应该具备怎样的功能。</p>
<ol>
<li>字符串中变量解析</li>
<li>条件表达式</li>
<li>遍历输出</li>
</ol>
<h2 id="字符串中变量解析"><a href="#字符串中变量解析" class="headerlink" title="字符串中变量解析"></a>字符串中变量解析</h2><p>先来弄第一个最简单功能，变量替换:<br>目标是实现下面代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">	name:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">	age:<span class="string">&quot;19&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> tplString = <span class="string">&quot;&#123;&#123;name&#125;&#125;今年&#123;&#123;age&#125;&#125;岁&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> string = tpl(tplString,data);</span><br><span class="line"><span class="built_in">console</span>.log(string);</span><br><span class="line"><span class="comment">//张三今年19岁</span></span><br></pre></td></tr></table></figure>
<p>下面是个人实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function tpl(str,data)&#123;</span><br><span class="line">  &#x2F;&#x2F;定义抽出变量正则</span><br><span class="line">  var valReg &#x3D; &#x2F;[\&#123;]&#123;2&#125;\s*\w+\s*[\&#125;]&#123;2&#125;&#x2F;g;</span><br><span class="line">  &#x2F;&#x2F;获取字符串数组</span><br><span class="line">  var strArr &#x3D; str.match(valReg); </span><br><span class="line">  &#x2F;&#x2F;获取变量数组</span><br><span class="line">  var valArr &#x3D; strArr.join(&quot;-&quot;).replace(&#x2F;[\&#123;]&#123;2&#125;\s*&#x2F;g,&quot;&quot;).replace(&#x2F;\s*[\&#125;]&#123;2&#125;&#x2F;g,&quot;&quot;).split(&quot;-&quot;);</span><br><span class="line">  </span><br><span class="line">  for(var i&#x3D;0,len&#x3D;strArr.length;i&lt;len;i++)&#123;</span><br><span class="line">    str&#x3D;str.replace(strArr[i],data[valArr[i]]);</span><br><span class="line">  &#125;</span><br><span class="line">  return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个函数很简单，只是简单的使用replace对变量进行了简单的替换。匹配和替换过程中对花括号之间的变量进行了去空格处理。<br>这个函数还比较粗糙，比如，它仅仅可以处理第一层的数据，假如使用zhangsan.name就会失败。这里先放放。我们继续看条件表达式的处理。</p>
<h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><p>效果大概是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="keyword">if</span> admin&#125;&#125;</span><br><span class="line">    &lt;p&gt;admin&lt;/p&gt;</span><br><span class="line">&#123;&#123;<span class="keyword">else</span> <span class="keyword">if</span> code &gt; <span class="number">0</span>&#125;&#125;</span><br><span class="line">    &lt;p&gt;master&lt;/p&gt;</span><br><span class="line">&#123;&#123;<span class="keyword">else</span>&#125;&#125;</span><br><span class="line">    &lt;p&gt;error!&lt;/p&gt;</span><br><span class="line">&#123;&#123;/<span class="keyword">if</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>发现这个做起来挺麻烦的。主要要点：</p>
<ol>
<li>抽出多行模板文本</li>
<li>模板文本转换成函数</li>
<li>函数求值</li>
</ol>
<h3 id="抽出多行表达式"><a href="#抽出多行表达式" class="headerlink" title="抽出多行表达式"></a>抽出多行表达式</h3><p>首先要抽出从if开始到else到/if之间的文本。暂时写个可以用的正则匹配一下，不太严格：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var blockIfReg &#x3D; &#x2F;[\&#123;]&#123;2&#125;\s*if[\s\S]*[\&#123;]&#123;2&#125;\s*\&#x2F;if[\&#125;]&#123;2&#125;&#x2F;mg;</span><br><span class="line">&#x2F;&#x2F;匹配出来的文本是这样的：</span><br><span class="line">&#x2F;&#x2F;[&quot;&#123;&#123;if admin&gt;0&#125;&#125;\n    &lt;p&gt;admin&lt;&#x2F;p&gt;\n    &#123;&#123;else if code &gt; 0&#125;&#125;\n    &lt;p&gt;master&lt;&#x2F;p&gt;\n    &#123;&#123;else&#125;&#125;\n    &lt;p&gt;error!&lt;&#x2F;p&gt;\n    &#123;&#123;&#x2F;if&#125;&#125;&quot;]</span><br></pre></td></tr></table></figure>
<p>其中↵代表的是换行符号。现在问题是如何优雅的把这个字符串转换为表达式了。。。</p>
<p>先来把这个替换gt什么的符号还原一下,使用replace做这个替换:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mapObj = &#123;</span><br><span class="line">    <span class="string">&quot;&amp;gt;&quot;</span>:<span class="string">&quot;&gt;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&amp;lt;&quot;</span>:<span class="string">&quot;&lt;&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">   <span class="keyword">var</span> matchStringArr = s.match(blockIfReg)||[];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> a <span class="keyword">in</span> mapObj)&#123;</span><br><span class="line">       matchStringArr = matchStringArr.map(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> v.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(a,<span class="string">&#x27;gm&#x27;</span>),mapObj[a]);</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中s是匹配的字符串数组,重点是replace里面的new RegExp(a,’gm’),这里使用了正则，需要替换所有的——顺便发现”字符串中变量解析”时候没有发现这个。回头补下bug。</p>
<p>继续写个正则抽一抽，主要目的是把逻辑字符串抽出来：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTML：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;tpl&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;if admin&gt;0&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123;else if code &lt; 0&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>master<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123;else&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>error!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123;/if&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">JS：</span><br><span class="line">var s = document.getElementById(&quot;tpl&quot;);</span><br><span class="line">console.log(s.split(/[\&#123;]&#123;2&#125;\s*|\s*[\&#125;]&#123;2&#125;/gm));</span><br><span class="line">[&quot;&quot;, &quot;if admin&gt;0&quot;, &quot;↵admin↵↵&quot;, &quot;else if code &gt; 0&quot;, &quot;↵master↵↵&quot;, &quot;else&quot;, &quot;↵error!↵↵&quot;, &quot;/if&quot;, &quot;&quot;]</span><br></pre></td></tr></table></figure>
<p>这里干完以后发现有Bug:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;tpl&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;if admin&gt;0&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123;else if code &lt; 0&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>master<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123;else&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>error!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123;/if&#125;&#125;</span><br><span class="line"></span><br><span class="line">    &#123;&#123;if aaa&gt;0&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123;else if bbbb &lt; 0&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>master<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123;else&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>error!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123;/if&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时有两个if结构了，但是<code>/[&#123;]&#123;2&#125;\s*if[\s\S]*[&#123;]&#123;2&#125;\s*/if[&#125;]&#123;2&#125;/mg</code>匹配成了一个，加个?干掉贪婪匹配：<code>/[&#123;]&#123;2&#125;\s*if[\s\S]*?[&#123;]&#123;2&#125;\s*/if[&#125;]&#123;2&#125;/mg</code> 现在可以了。可以获取匹配到两个包含字符串组成的数组.</p>
<p>下面继续干活：目标是将字符串转换为函数</p>
<p>先将字符串切一切：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//matchStringArr是上面说的两个包含字符串组成的数组</span></span><br><span class="line">matchStringArr=matchStringArr.map(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;<span class="keyword">return</span> v.split(<span class="regexp">/[\&#123;]&#123;2&#125;\s*|\s*[\&#125;]&#123;2&#125;/gm</span>)&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(matchStringArr);</span><br></pre></td></tr></table></figure>
<p>结果如图:<br><img src="/images/2016-05-01_1.png?imageView/2/w/300/h/400/q/100" alt="1"></p>
<p>继续往下处理一下，将其转换成可以用的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">matchStringArr&#x3D;matchStringArr.map(function(v)&#123;</span><br><span class="line">    return transform(v);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function transform(v)&#123;</span><br><span class="line">    var targetString &#x3D; &quot;&quot;;</span><br><span class="line">    v.forEach(function(val,i)&#123;</span><br><span class="line">        if(val&#x3D;&#x3D;&quot;&quot;)&#123;</span><br><span class="line">        &#125;else if(&#x2F;^if&#x2F;.test(val))&#123;</span><br><span class="line">            targetString+&#x3D;&quot;if(&quot;+ val.split(&quot; &quot;)[1]+&quot;)&#123;&quot;+v[i+1]+&quot;&#125;&quot;;</span><br><span class="line">        &#125;else if(val.indexOf(&quot;else if&quot;)&gt;-1)&#123;</span><br><span class="line">            targetString+&#x3D;&quot;else if(&quot;+val.replace(&quot;else if&quot;,&quot;&quot;)+&quot;)&#123;&quot;+v[i+1]+&quot;&#125;&quot;</span><br><span class="line">        &#125;else if(val.indexOf(&quot;else&quot;) &gt; -1)&#123;</span><br><span class="line">            targetString+&#x3D;&quot;else&#123;&quot;+v[i+1]+&quot;&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return targetString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>console.log之：<br><img src="/images/2016-05-01_2.png" alt="2"></p>
<p>到这里基本就差不多了。当然，现在这个函数就算执行了也没卵用，不过先不管，先将其弄成函数再说。究竟。。。有问题会报错的，到时候解决。<br>这里可以使用eval和Function-&gt;eval不建议使用，使用Function好了。</p>
<h3 id="字符串转换函数"><a href="#字符串转换函数" class="headerlink" title="字符串转换函数"></a>字符串转换函数</h3><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p>Function方式构建函数平时几乎没有机会做。不过这里来尝试一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先来个简单的字符串传参</span></span><br><span class="line"><span class="keyword">var</span> sayAge = <span class="built_in">Function</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;return a+&#x27;的年龄是&#x27;+b&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sayAge(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;15&quot;</span>))</span><br><span class="line"><span class="comment">//张三的年龄是15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传入对象看看</span></span><br><span class="line"><span class="keyword">var</span> sayAge = <span class="built_in">Function</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;return a[&#x27;name&#x27;]+&#x27;的年龄是&#x27;+a[&#x27;age&#x27;]&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sayAge(&#123;<span class="attr">name</span>:<span class="string">&quot;李四&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;18&quot;</span>&#125;));</span><br><span class="line"><span class="comment">//李四的年龄是18</span></span><br></pre></td></tr></table></figure>
<p>这样没啥问题了。完善下上面的东西。</p>
<p>整理下之前弄出来的函数字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(admin&gt;<span class="number">0</span>)&#123;</span><br><span class="line">	&lt;p&gt;admin&lt;/p&gt;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(code &lt; <span class="number">0</span>)&#123;</span><br><span class="line">	&lt;p&gt;master&lt;/p&gt; </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	&lt;p&gt;error!&lt;/p&gt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个条件表达式,若干逻辑中取一个返回,先修一修让它可以正常工作<br>然后使用Function构建一个函数试试，这里要测试一下使用Function构建一下改造过的函数是否可以运行<br>这里是代码运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*处理好的字符串</span></span><br><span class="line"><span class="comment">if(admin&gt;0)&#123;</span></span><br><span class="line"><span class="comment">	return &#x27;&lt;p&gt;admin&lt;/p&gt;&#x27;;</span></span><br><span class="line"><span class="comment">&#125;else if(code &lt; 0)&#123;</span></span><br><span class="line"><span class="comment">	return &#x27;&lt;p&gt;master&lt;/p&gt;&#x27;; </span></span><br><span class="line"><span class="comment">&#125;else&#123;</span></span><br><span class="line"><span class="comment">	return &#x27;&lt;p&gt;error!&lt;/p&gt;&#x27;;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="comment">//字符串先并为一行</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;if(admin&gt;0)&#123;return &#x27;&lt;p&gt;admin&lt;/p&gt;&#x27;&#125;else if(code &lt; 0)&#123;return &#x27;&lt;p&gt;master&lt;/p&gt;&#x27;&#125;else&#123;return &#x27;&lt;p&gt;error!&lt;/p&gt;&#x27;&#125;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> testFun = <span class="built_in">Function</span>(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;code&quot;</span>,str);</span><br><span class="line"><span class="built_in">console</span>.log(testFun(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(testFun(-<span class="number">1</span>,-<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/images/2016-05-01_3.png" alt="3"></p>
<p>运行效果良好</p>
<h4 id="完善transform"><a href="#完善transform" class="headerlink" title="完善transform"></a>完善transform</h4><p>这里为了上面代码正常工作改良一下原来的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transform</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> targetString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    v.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val,i</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val==<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="regexp">/^if/</span>.test(val))&#123;</span><br><span class="line">            targetString+=<span class="string">&quot;if(&quot;</span>+ val.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>]+<span class="string">&quot;)&#123;return &#x27;&quot;</span>+v[i+<span class="number">1</span>].replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">&quot;&quot;</span>)+<span class="string">&quot;&#x27;&#125;&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val.indexOf(<span class="string">&quot;else if&quot;</span>)&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">            targetString+=<span class="string">&quot;else if(&quot;</span>+val.replace(<span class="string">&quot;else if&quot;</span>,<span class="string">&quot;&quot;</span>)+<span class="string">&quot;)&#123;return &#x27;&quot;</span>+v[i+<span class="number">1</span>].replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">&quot;&quot;</span>)+<span class="string">&quot;&#x27;&#125;&quot;</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val.indexOf(<span class="string">&quot;else&quot;</span>) &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">            targetString+=<span class="string">&quot;else&#123;return &#x27;&quot;</span>+v[i+<span class="number">1</span>].replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">&quot;&quot;</span>)+<span class="string">&quot;&#x27;&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> targetString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里添加了return，同时把无用的换空格干掉了,同时\s顺便把\n也换掉了。这样，上面的函数就可以很好的运行了。</p>
<h4 id="Function内部变量处理"><a href="#Function内部变量处理" class="headerlink" title="Function内部变量处理"></a>Function内部变量处理</h4><p>到这里逻辑基本算是好了，现在面临的问题是，如何直接传入对象，让函数里面的表达式可以获取到而不需要加this[“admin”]什么。个人的想法是将该变量放到Function构造出的函数的上一层即可。</p>
<p>测试代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> a <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">this</span>[a] = obj[a];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getString:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;if(admin&gt;0)&#123;return &#x27;&lt;p&gt;admin&lt;/p&gt;&#x27;&#125;else if(code &lt; 0)&#123;return &#x27;&lt;p&gt;master&lt;/p&gt;&#x27;&#125;else&#123;return &#x27;&lt;p&gt;error!&lt;/p&gt;&#x27;&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> insertFn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;&#x27;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> insertFn.apply(<span class="built_in">this</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a class="jsbin-embed" href="http://jsbin.com/seyuyu/embed?js,console">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.12"></script></p>
<p>还算成功，可以顺便把之前无法读zhangsan.name这种问题统统解决掉。</p>
<p>包装修缮一下门面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;if(admin&gt;0)&#123;return &#x27;&lt;p&gt;admin&lt;/p&gt;&#x27;&#125;else if(code &lt; 0)&#123;return &#x27;&lt;p&gt;master&lt;/p&gt;&#x27;&#125;else&#123;return &#x27;&lt;p&gt;error!&lt;/p&gt;&#x27;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTplChunk</span>(<span class="params">obj,fnString</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">tmp</span>(<span class="params">obj,fnString</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> a <span class="keyword">in</span> obj)&#123;</span><br><span class="line">      <span class="built_in">this</span>[a] = obj[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      getString:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> insertFn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;&#x27;</span>,fnString);</span><br><span class="line">        <span class="keyword">return</span> insertFn.apply(<span class="built_in">this</span>,<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> target = tmp(obj,fnString).getString();</span><br><span class="line">  tmp=<span class="literal">null</span>;	<span class="comment">//销毁闭包</span></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  admin:<span class="number">1</span>,</span><br><span class="line">  code:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getTplChunk(obj,str));</span><br></pre></td></tr></table></figure>
<p>demo:<br><a class="jsbin-embed" href="http://jsbin.com/hicivuq/embed?js,console">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.12"></script></p>
<p>至此上面两个要点就OK了。</p>
<h4 id="话外之With"><a href="#话外之With" class="headerlink" title="话外之With"></a>话外之With</h4><p>这里使用了闭包和作用域链来实现了代码不加前缀实现变量暴露。除此以外，一个看似更可能更好的实现这个功能的，是with语句。with可以创建一个作用域，在作用域内，在引用特定对象属性时候可以不使用前缀。这是几乎更加契合场景的实现。<br>但是《JavaScript:The Good Parts》作者已经说过”with Statement considered Harmful”，并且ES5的use strict已经禁用了它。那么就放弃使用它吧。反正。。。使用作用域链，我也把它实现了。。。</p>
<h2 id="变量解析和表达式整理"><a href="#变量解析和表达式整理" class="headerlink" title="变量解析和表达式整理"></a>变量解析和表达式整理</h2><p>至此前两个逻辑已经OK，但是两个逻辑之间有些碎片化。我们整理一下代码思路进行重构:</p>
<ol>
<li>模板函数接受元素id和数据进行内部操作</li>
<li>内部操作环节对模板字符串进行分解<ul>
<li>变量</li>
<li>表达式</li>
<li>遍历</li>
</ul>
</li>
<li>依次调用不同方法进行替换并返回最终字符串</li>
</ol>
<p>目前只整理了字符串和表达式的处理方式，下面是，整理好的代码，直接放到jsbin了，贴到博文太长不方便看。<br><a class="jsbin-embed" href="http://jsbin.com/botage/embed?html,js,console">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.12"></script></p>
<p>这里需要说的是，逻辑先处理了表达式再处理了字符串，主要是考虑到这个会通字符串匹配冲突。同时之前发现的若干很明显的bug都修好了。</p>
<h2 id="遍历表达式"><a href="#遍历表达式" class="headerlink" title="遍历表达式"></a>遍历表达式</h2><p>遍历表达式的模板语法是这样的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;each list as value index&#125;&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123;index&#125;&#125; - &#123;&#123;value.user&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">&#123;&#123;&#x2F;each&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>首先，要把它抽取出来，这里使用正则抽取它。<code>/[&#123;]&#123;2&#125;each\s.*[&#125;]&#123;2&#125;[\s\S]*[&#123;]&#123;2&#125;/each[&#125;]&#123;2&#125;/gm</code>,找个了HTML页面测试通过。</p>
<p>接下来要把他换算成表达式。like this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var target &#x3D; &quot;&quot;</span><br><span class="line">list.forEach(function(value,index)&#123;</span><br><span class="line">	target +&#x3D; &#39;&lt;li&gt;&#123;&#123;index&#125;&#125; - &#123;&#123;value.user&#125;&#125;&lt;&#x2F;li&gt;&#39;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>直接改造下transform函数好了，给它加个type参数分类处理。<br>然后获取下列关注点的变量字符串<br><img src="/images/20160502.png" alt="4"></p>
<p>正则提取: <code>/[&#123;]&#123;2&#125;each\s+(\w+)\s+as\s+(\w+)\s+(\w+)*[&#125;]&#123;2&#125;([\s\S]*)[&#123;]&#123;2&#125;/each[&#125;]&#123;2&#125;/gm</code></p>
<p>改造的transform分支2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;else if(type&#x3D;&#x3D;&#x3D;2)&#123;</span><br><span class="line">    var reg &#x3D; &#x2F;[\&#123;]&#123;2&#125;each\s+(\w+)\s+as\s+(\w+)\s+(\w+)*[\&#125;]&#123;2&#125;([\s\S]*)[\&#123;]&#123;2&#125;\&#x2F;each[\&#125;]&#123;2&#125;&#x2F;gm;</span><br><span class="line">    v &#x3D; reg.exec(v);</span><br><span class="line">    targetString &#x3D; &#39;var a &#x3D;&quot;&quot;;&#39;+v[1]+&#39;.forEach(function(&#39;+v[2]+&#39;,&#39;+v[3]+&#39;)&#123;&#39;</span><br><span class="line">                   +  &#39;a +&#x3D; &quot;&lt;li&gt;&#123;&#123;index&#125;&#125; - &#123;&#123;value.user&#125;&#125;&lt;&#x2F;li&gt;&quot;&#39;</span><br><span class="line">                   +&#39;&#125;);return a;&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在问题是li里面的变量不解析，那么我们复用一下字符串解析函数好了，之前保留了data参数可以传参进去。<br>现在是这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;else if(type&#x3D;&#x3D;&#x3D;2)&#123;</span><br><span class="line">    var reg &#x3D; &#x2F;[\&#123;]&#123;2&#125;each\s+(\w+)\s+as\s+(\w+)\s+(\w+)*[\&#125;]&#123;2&#125;([\s\S]*)[\&#123;]&#123;2&#125;\&#x2F;each[\&#125;]&#123;2&#125;&#x2F;gm;</span><br><span class="line">    v &#x3D; reg.exec(v);</span><br><span class="line">    targetString &#x3D;</span><br><span class="line"></span><br><span class="line">    targetString +&#x3D; &#39;var a &#x3D;&quot;&quot;;&#39;+v[1]+&#39;.forEach(function(&#39;+v[2]+&#39;,&#39;+v[3]+&#39;)&#123;&#39;</span><br><span class="line">                   +  &#39;a +&#x3D; &#39;+&#39;fn1(&quot;&#39;+v[4].replace(&#x2F;\s&#x2F;g,&quot;&quot;)+&#39;&quot;,&#39;+v[2]+&#39;)&#39;</span><br><span class="line">                   +&#39;&#125;);return a;&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时问题是fn1获取不到，改下getTplChunk:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getTplChunk(obj,fnString)&#123;</span><br><span class="line">    function tmp(obj,fnString)&#123;</span><br><span class="line">        var isFunction &#x3D; (Object.prototype.toString.call(fnString)&#x3D;&#x3D;&#x3D;&quot;[object Function]&quot;);</span><br><span class="line">        for(var a in obj)&#123;</span><br><span class="line">            this[a] &#x3D; obj[a];</span><br><span class="line">        &#125;;</span><br><span class="line">        this[&quot;fn1&quot;]&#x3D;fn1;</span><br><span class="line">        return &#123;</span><br><span class="line">            getString:function()&#123;</span><br><span class="line">                var insertFn &#x3D; isFunction?fnString:(new Function(&#39;&#39;,fnString));</span><br><span class="line">                return insertFn.apply(this,null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    var target &#x3D; tmp(obj,fnString).getString();</span><br><span class="line">    tmp&#x3D;null;	&#x2F;&#x2F;销毁闭包</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将this[“fn1”]=fn1;假如到作用域上边去;<br>此时console出来的值:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;li&gt;undefined-&#123;&#123;value.user&#125;&#125;&lt;&#x2F;li&gt;&lt;li&gt;undefined-&#123;&#123;value.user&#125;&#125;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>
<p>存在两个问题:</p>
<ol>
<li>index索引不在作用域链上</li>
<li>加了点号的变量无法解析&amp;value.user的方式和上文的不太一样。</li>
</ol>
<p>第2点如此处理:</p>
<ul>
<li>改下正则匹配: <code>var valReg = /[&#123;]&#123;2&#125;\s*\w+[.\w+]*\s*[&#125;]&#123;2&#125;/g;</code>这样可以获取花括号里面的东西。</li>
<li>使用正则干掉前面的前缀引用，这样可以复用之前的逻辑。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">targetString += <span class="string">&#x27;var a =&quot;&quot;;&#x27;</span>+v[<span class="number">1</span>]+<span class="string">&#x27;.forEach(function(&#x27;</span>+v[<span class="number">2</span>]+<span class="string">&#x27;,&#x27;</span>+v[<span class="number">3</span>]+<span class="string">&#x27;)&#123;&#x27;</span></span><br><span class="line">               +  <span class="string">&#x27;a += &#x27;</span>+<span class="string">&#x27;fn1(&quot;&#x27;</span>+v[<span class="number">4</span>].replace(<span class="regexp">/\s/g</span>,<span class="string">&quot;&quot;</span>).replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(v[<span class="number">2</span>]+<span class="string">&#x27;.&#x27;</span>,<span class="string">&quot;gm&quot;</span>),<span class="string">&quot;&quot;</span>)+<span class="string">&#x27;&quot;,&#x27;</span>+v[<span class="number">2</span>]+<span class="string">&#x27;)&#x27;</span></span><br><span class="line">               +<span class="string">&#x27;&#125;);return a;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>第1点参照第2点加变量的方式，可以同样处理，由于index是动态的，那么就要动态传参到fn1了。不过fn1本身会接受一个data，我们加到里面去就ok了。但是在这里上下文不是很好理清，同时，一个变量最终解析时候到底是变量，还是字符串，必须要小心处理。</p>
<p>现在是处理后的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(type===<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="regexp">/[\&#123;]&#123;2&#125;each\s+(\w+)\s+as\s+(\w+)\s+(\w+)*[\&#125;]&#123;2&#125;([\s\S]*)[\&#123;]&#123;2&#125;\/each[\&#125;]&#123;2&#125;/gm</span>;</span><br><span class="line">    v = reg.exec(v);</span><br><span class="line"></span><br><span class="line">    targetString += <span class="string">&#x27;var a =&quot;&quot;;&#x27;</span>+v[<span class="number">1</span>]+<span class="string">&#x27;.forEach(function(&#x27;</span>+v[<span class="number">2</span>]+<span class="string">&#x27;,&#x27;</span>+v[<span class="number">3</span>]+<span class="string">&#x27;)&#123;&#x27;</span></span><br><span class="line">                   +  <span class="string">&#x27;a += &#x27;</span>+<span class="string">&#x27;fn1(&quot;&#x27;</span>+v[<span class="number">4</span>].replace(<span class="regexp">/\s/g</span>,<span class="string">&quot;&quot;</span>).replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(v[<span class="number">2</span>]+<span class="string">&#x27;.&#x27;</span>,<span class="string">&quot;gm&quot;</span>),<span class="string">&quot;&quot;</span>)+<span class="string">&#x27;&quot;,addAttr(&#x27;</span>+ v[<span class="number">2</span>] +<span class="string">&#x27;,&#123;&quot;&#x27;</span>+v[<span class="number">3</span>]+<span class="string">&#x27;&quot;:&#x27;</span>+v[<span class="number">3</span>]+<span class="string">&#x27;&#125;))&#x27;</span></span><br><span class="line">                   +<span class="string">&#x27;&#125;);return a;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——我加了一个addAttr函数到getTplChunk了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAttr</span>(<span class="params">target,obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> a <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        target[a] = obj[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此模板的工作初步完工了，考虑到字符串渲染如果排在each渲染之前，那么会导致它破坏了each里面字符串，因此我们把fn3放在最前面工作。我们来个Demo渲染包含三种表达式的模板看看。</p>
<p><a class="jsbin-embed" href="http://jsbin.com/nojotex/embed?html,js,output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.12"></script></p>
<p>至此，模板就算编写完毕了。现在它还存在一个比较明显的bug：</p>
<ul>
<li>if-else之间不能存在变量</li>
</ul>
<p>有空的话我在补起来,主要是正则需要完善。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里就实现了不太完善的类似artTemplate的模板——全程没有看过artTemplate源码哦。<br>这里说下自己对基于字符串模板的体会：</p>
<ol>
<li>简单:删掉注释和空行不压缩101行,随便两个花括号放一行就能到100行了,最核心的是三个replace就OK了。</li>
<li>复杂：<ul>
<li>当逻辑从字符串抽出时候需要依赖大量相对复杂的正则</li>
<li>with存在性能低下和被ES5严格模式废弃问题，需要使用其他方式规避</li>
<li>使用相对偏门的Function构造函数(不是eval)和构造函数的上下文，以及如何进行变量传递等</li>
</ul>
</li>
</ol>
<h1 id="其他模板技术-amp-amp-碎碎念"><a href="#其他模板技术-amp-amp-碎碎念" class="headerlink" title="其他模板技术&amp;&amp;碎碎念"></a>其他模板技术&amp;&amp;碎碎念</h1><p>本来想写一写其他模板技术的观望的，发现一篇资料，大家可以前往观望。<br>文首有一句话是:</p>
<blockquote>
<p>此文的写作耗时很长，称之为雄文不为过，小心慢用</p>
</blockquote>
<p>个人深以为然。说是雄文确实不为过。</p>
<p>前端组件之争，好像有些陷入模板之争。</p>
<p>最早的时候，Backbone让我们从满是jQuery选择器的沼泽里面拖出来。<br>然后是AngularJS，双向绑定让我们知道了原来操作DOM可以不用去手工获取和修改节点。<br>然后是React，组件化的特性，让我们知道了，应用可以像积木一样拼起来，有时候HTML都可以不用写了。</p>
<p>MVC，M和C是如此稳定没有见到玩出太多花样，而面向用户的V层发展到越来越深。</p>
<p>innerHTML如此流行，我以为这是IE干过最积极的事情。Backbone这类MVC框架依赖模板来将数据转换为HTML字符串，然后使用innerHTML来数据插入。innerHTML是如此快速，以至于大面积的DOM操作几乎没有别的选择；但是它又是如此慢，大面积的模板渲染里面即使只进行最小粒度的更新，它也会全部更新一次，顺便——撸掉你绑定的事件。</p>
<p>AngularJS如果视为模板，有些不合适，因为它做了模板以外的事情(事实上，我一直认为，只有基于字符串的模板，才能算是纯正的模板)。但是它确实是如此好用——如果你精熟而非遇到问题束手无策的普通用户的话。<br>AngularJS在双向绑定方案上使用了脏检测方案，每个双向绑定的元素会存在一个watcher，当触发检测时候会一个个进行对比，然后进行View或者Model的更新。显然，这种方式让优雅和性能洁癖的工程师会有看法。</p>
<p>至于React，我个人认为它最大的贡献除了是小粒度的innerHTML，还有组件化开发方式。——webComponent，感觉入前端以来，从未有一个概念如此让人心往神驰。</p>
<p>好了，不碎嘴了。大家看文章去:</p>
<p>点此前往: <a href="http://www.html-js.com/article/Regularjs-Chinese-guidelines-for-a-comprehensive-summary-of-the-front-template-technology">一个对前端模板技术的全面总结</a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>template</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp相关汇总</title>
    <url>/2016/04/28/gulp/</url>
    <content><![CDATA[<h1 id="Gulp简介"><a href="#Gulp简介" class="headerlink" title="Gulp简介"></a>Gulp简介</h1><p>Gulp是构建在nodejs上的前端构建工具。就构建这个功能来说，Gulp其实几乎什么也做不了,但是依托它庞大的生态，配合各种各样的插件，gulp在前端构建方面几乎无所不能。<br>这里简单列举一下gulp可以做到的事情：</p>
<ol>
<li>css方面<ul>
<li>css多个合并</li>
<li>css压缩</li>
<li>css 自动处理厂商私有前缀</li>
<li>预编译css语言:sass,scss,less编译</li>
</ul>
</li>
<li>JS方面<ul>
<li>js合并</li>
<li>js压缩</li>
</ul>
</li>
<li>HTML<ul>
<li>压缩</li>
<li>插入特定代码片段，比如公有header和footer</li>
</ul>
</li>
<li>模块化<ul>
<li>基于webpack、jspm、browerify的gulp插件实现</li>
</ul>
</li>
<li>强缓存<ul>
<li>当应用上线需要给资源加上版本号防止缓存更新不及时</li>
</ul>
</li>
</ol>
<p>当然，这些并不是Gulp可以做到的全部。但是确实是最常见的部分。依托Gulp的watch方法，我们可以实时监控文件改动进行任务处理+实时刷新。这有效提高了前端开发的效率。</p>
<h1 id="Gulp的安装"><a href="#Gulp的安装" class="headerlink" title="Gulp的安装"></a>Gulp的安装</h1><p>gulp安装需要依赖nodejs，这里不解释如何安装nodejs了。<br>需要说明的是，npm3对早期的npm2依赖无限嵌套这种行为做了平坦化处理，这样有效提高了依赖不会无限深，也有效提高了安装依赖的速度，建议安装之。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm -v <span class="comment">//查看版本号,如果已经大于3.X.X就跳过吧</span></span><br><span class="line">npm i -g npm</span><br></pre></td></tr></table></figure>
<p>下面安装gulp</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i -g gulp</span><br></pre></td></tr></table></figure>
<p>一切就这样简单.</p>
<h1 id="Gulp的接口"><a href="#Gulp的接口" class="headerlink" title="Gulp的接口"></a>Gulp的接口</h1><p>Gulp的接口不多，因为因为其流的思想，用不上太多。<br>Gulp构建过程，可以分为3步：入口指定-&gt;文件留处理-&gt;目标位置指定。<br>具体来说Gulp大致有4个API：</p>
<ul>
<li>gulp.task()</li>
<li>gulp.src()</li>
<li>gulp.dest()</li>
<li>gulp.watch()</li>
</ul>
<h2 id="Gulp-src-globs-options"><a href="#Gulp-src-globs-options" class="headerlink" title="Gulp.src(globs[, options])"></a>Gulp.src(globs[, options])</h2><p>gulp.src是一切任务起点，用来指定入口文件，也就是要用来处理的目标文件</p>
<h3 id="globs-字符串或者数组"><a href="#globs-字符串或者数组" class="headerlink" title="globs 字符串或者数组"></a>globs 字符串或者数组</h3><p>常见的globs用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单一文件</span></span><br><span class="line">gulp.src(<span class="string">&#x27;src/a.scss&#x27;</span>)</span><br><span class="line"><span class="comment">// 多个scss文件</span></span><br><span class="line">gulp.src(<span class="string">&#x27;src/*.scss&#x27;</span>)</span><br><span class="line"><span class="comment">// 目录下所有scss(包括递归子文件夹)</span></span><br><span class="line">gulp.src(<span class="string">&#x27;src/**/*.scss&#x27;</span>)</span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line">gulp.src([</span><br><span class="line">    <span class="string">&#x27;src/a.js&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;src/b.js&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;!src/c.js&#x27;</span>,<span class="comment">//排除c.js</span></span><br><span class="line">    <span class="string">&#x27;src/d.js&#x27;</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<h3 id="option"><a href="#option" class="headerlink" title="option"></a>option</h3><p>option暂时略过,貌似从来没有用过,就不介绍了</p>
<h2 id="gulp-dest-path-options"><a href="#gulp-dest-path-options" class="headerlink" title="gulp.dest(path[, options])"></a>gulp.dest(path[, options])</h2><p>gulp.dist是一切任务的终点，指定处理好的文件存放到哪儿去。</p>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>path可以是静态的字符串，也可以是一个返回一个字符串的函数。</p>
<h3 id="option-1"><a href="#option-1" class="headerlink" title="option"></a>option</h3><p>option是一个对象。这个选项也没用到过，但是有可能用到，先列出来。</p>
<ul>
<li>options.cwd(默认：process.cwd()) 当输出路径为相对路径的时候才有效</li>
<li>options.mode(默认：0777) 新建目录的权限</li>
</ul>
<h2 id="gulp-task-name-deps-fn"><a href="#gulp-task-name-deps-fn" class="headerlink" title="gulp.task(name[, deps, fn])"></a>gulp.task(name[, deps, fn])</h2><p>gulp.task是用来定义任务的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">&#x27;sass&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">&#x27;src/scss/master.scss&#x27;</span>)</span><br><span class="line">        .pipe(sass())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;dist/css&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(<span class="string">&#x27;styles&#x27;</span>,[<span class="string">&#x27;sass&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    gulp.src(<span class="string">&#x27;./dist/css/public.css&#x27;</span>) </span><br><span class="line">        .pipe(minify()) </span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;dist/css&#x27;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第一个任务中没有依赖，直接function里面定义了任务行为，而第二个任务里面依赖了sass，只有sass执行完毕以后才会执行styles任务。</p>
<h2 id="gulp-watch-glob-opts-tasks"><a href="#gulp-watch-glob-opts-tasks" class="headerlink" title="gulp.watch(glob [, opts], tasks)"></a>gulp.watch(glob [, opts], tasks)</h2><p>gulp.watch是个用的相对较少，但是为了开发体验绝不可以或缺的方法。它提供了文件的动态监控。<br>需要掌握的不多，直接上个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.watch(<span class="string">&#x27;js/**/*.js&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;File &#x27;</span> + event.path + <span class="string">&#x27; was &#x27;</span> + event.type + <span class="string">&#x27;, running tasks...&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里只是把event进行了监视。实际上使用过程更多是队event.type状态进行对比，为true执行对应的任务。它可能的值是added, changed, deleted，一般情况我们判断是否为changed即可。</p>
<h1 id="Gulp常用插件"><a href="#Gulp常用插件" class="headerlink" title="Gulp常用插件"></a>Gulp常用插件</h1><p>Gulp倾向一个平台，在这个平台上有各种各样的组件可以选用，以达成任务构建目标。因此，常用的gulp插件的介绍还是必不可少的。</p>
<ol>
<li>css处理:<ul>
<li>自动添加css前缀（gulp-autoprefixer）</li>
<li>压缩css（gulp-minify-css）</li>
<li>sass编译(gulp-sass)</li>
</ul>
</li>
<li>js处理<ul>
<li>合并js文件（gulp-concat）</li>
<li>生成js的map文件(gulp-sourcemaps)</li>
<li>压缩js代码（gulp-uglify）</li>
</ul>
</li>
<li>图片处理<ul>
<li>压缩图片（gulp-imagemin）</li>
</ul>
</li>
<li>其他<ul>
<li>服务和自动刷新(browser-sync)</li>
<li>删除文件和目录(del)</li>
</ul>
</li>
</ol>
<h2 id="css任务"><a href="#css任务" class="headerlink" title="css任务"></a>css任务</h2><p>包括简单的编译,压缩，加私有前缀</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>),</span><br><span class="line">    sass = <span class="built_in">require</span>(<span class="string">&#x27;gulp-ruby-sass&#x27;</span>),</span><br><span class="line">    autoprefixer = <span class="built_in">require</span>(<span class="string">&#x27;gulp-autoprefixer&#x27;</span>),</span><br><span class="line">    minifycss = <span class="built_in">require</span>(<span class="string">&#x27;gulp-minify-css&#x27;</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">&#x27;styles&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;src/styles/main.scss&#x27;</span>)</span><br><span class="line">    .pipe(sass(&#123; <span class="attr">style</span>: <span class="string">&#x27;expanded&#x27;</span> &#125;))</span><br><span class="line">    .pipe(autoprefixer(<span class="string">&#x27;last 2 version&#x27;</span>, <span class="string">&#x27;safari 5&#x27;</span>, <span class="string">&#x27;ie 8&#x27;</span>, <span class="string">&#x27;ie 9&#x27;</span>, <span class="string">&#x27;opera 12.1&#x27;</span>, <span class="string">&#x27;ios 6&#x27;</span>, <span class="string">&#x27;android 4&#x27;</span>))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist/assets/css&#x27;</span>))</span><br><span class="line">    .pipe(minifycss())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist/assets/css&#x27;</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="js任务"><a href="#js任务" class="headerlink" title="js任务"></a>js任务</h2><p>包括简单的语法检查，合并，压缩</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>),</span><br><span class="line">    jshint = <span class="built_in">require</span>(<span class="string">&#x27;gulp-jshint&#x27;</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>),</span><br><span class="line">    concat = <span class="built_in">require</span>(<span class="string">&#x27;gulp-concat&#x27;</span>);</span><br><span class="line">gulp.task(<span class="string">&#x27;scripts&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;src/scripts/**/*.js&#x27;</span>)</span><br><span class="line">    .pipe(jshint(<span class="string">&#x27;.jshintrc&#x27;</span>))</span><br><span class="line">    .pipe(jshint.reporter(<span class="string">&#x27;default&#x27;</span>))</span><br><span class="line">    .pipe(concat(<span class="string">&#x27;main.js&#x27;</span>))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist/assets/js&#x27;</span>))</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist/assets/js&#x27;</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>),</span><br><span class="line">    imagemin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-imagemin&#x27;</span>);</span><br><span class="line">gulp.task(<span class="string">&#x27;images&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;src/images/**/*&#x27;</span>)</span><br><span class="line">    .pipe(imagemin(&#123; <span class="attr">optimizationLevel</span>: <span class="number">3</span>, <span class="attr">progressive</span>: <span class="literal">true</span>, <span class="attr">interlaced</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist/assets/img&#x27;</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="监视任务"><a href="#监视任务" class="headerlink" title="监视任务"></a>监视任务</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">&#x27;watch&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  gulp.watch(<span class="string">&#x27;src/styles/**/*.scss&#x27;</span>, [<span class="string">&#x27;styles&#x27;</span>]);</span><br><span class="line">  gulp.watch(<span class="string">&#x27;src/scripts/**/*.js&#x27;</span>, [<span class="string">&#x27;scripts&#x27;</span>]);</span><br><span class="line">  gulp.watch(<span class="string">&#x27;src/images/**/*&#x27;</span>, [<span class="string">&#x27;images&#x27;</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里介绍到这样差不多可以了。</p>
<h1 id="Gulp工作流实战。"><a href="#Gulp工作流实战。" class="headerlink" title="Gulp工作流实战。"></a>Gulp工作流实战。</h1><p>在之前讲SystemJS时候，说到过整体的工作流。这里说一下自己如何处理这一块的东西。<br>但是在此之前先把之前的设计说明copy一下:</p>
<h2 id="文件目录基础设计"><a href="#文件目录基础设计" class="headerlink" title="文件目录基础设计"></a>文件目录基础设计</h2><p>这里简单说下文件目录基础设计：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── asset</span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── fonts</span><br><span class="line">│   ├── images</span><br><span class="line">│   └── js</span><br><span class="line">├── config.js</span><br><span class="line">├── html</span><br><span class="line">│   ├── dist</span><br><span class="line">│   │   └── login</span><br><span class="line">│   │       ├── login.html</span><br><span class="line">│   │       ├── logout.html</span><br><span class="line">│   │       └── resetPwd.html</span><br><span class="line">│   └── src</span><br><span class="line">│       └── login</span><br><span class="line">│           ├── login.html</span><br><span class="line">│           ├── logout.html</span><br><span class="line">│           └── resetPwd.html</span><br><span class="line">└── modules</span><br><span class="line">    ├── business</span><br><span class="line">    │   └── login</span><br><span class="line">    │       ├── login.js</span><br><span class="line">    │       ├── logout.js</span><br><span class="line">    │       └── resetPwd.js</span><br><span class="line">    ├── github</span><br><span class="line">    ├── npm</span><br><span class="line">    └── privateregistr</span><br></pre></td></tr></table></figure>
<p>根据约定重于配置原则，这里说下设计和约定：</p>
<ol>
<li>开发阶段使用html下src目录放置html文件，modules下business放置业务js和css代码，privateregistr这个随意命名的，用来放置公用模块，使用submodule维护。</li>
<li>发布阶段使用gulp对business下js和css进行打包，统一发布到asset/js和asset/css</li>
<li>每个html/dist下的文件夹为一个大栏目，里面每个html对应一个业务页面，每个页面的js名称结构要同modules/business下结构对应，举例来说：<ul>
<li>html/dist/login/login.html这个文件的对应的js是modules/business/login/login.js</li>
<li>每个页面只接受一个js作为业务入口，意思是如果上文login.js分解为step1.js&amp;step2.js&amp;step3.js是可以的，但是最终将只引入login.js一个，其他将require方式引用进去，不提供单独的script标签给它们。</li>
</ul>
</li>
<li>modules文件夹是jspm packages folder，里面的github和npm分别是github和npm下载的包，privateregistr则是使用jspm-git构建的私有包目标源。config.js是system.js的配置文件。</li>
</ol>
<h2 id="任务流程"><a href="#任务流程" class="headerlink" title="任务流程"></a>任务流程</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;gulp-load-plugins&#x27;</span>)();</span><br><span class="line"><span class="keyword">var</span> filewalker = <span class="built_in">require</span>(<span class="string">&#x27;filewalker&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> jsonfile = <span class="built_in">require</span>(<span class="string">&#x27;jsonfile&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> modulesPath = &#123;</span><br><span class="line">    moduleSrc : <span class="string">&#x27;asset/src/js/&#x27;</span>,</span><br><span class="line">    moduleDist: <span class="string">&#x27;asset/dist/js&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">gulp.task(<span class="string">&#x27;jspm&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(modulesPath.moduleSrc+<span class="string">&#x27;**/*.js&#x27;</span>)</span><br><span class="line">        .pipe($.jspm(&#123; <span class="attr">minify</span>: <span class="literal">true</span>,<span class="attr">sourceMaps</span>: <span class="literal">false</span>,<span class="attr">arithmetic</span>: <span class="string">&#x27;- jquery - react - materialize&#x27;</span>&#125;))</span><br><span class="line">        .pipe(gulp.dest(modulesPath.moduleDist));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//inject 任务配资文件在config/injectJSON中</span></span><br><span class="line"><span class="comment">// var injectJSON = require(&quot;./conf/injectJSON.js&quot;);</span></span><br><span class="line">gulp.task(<span class="string">&quot;inject&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    jsonfile.readFile(<span class="string">&quot;conf/injectJSON.json&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,json</span>)</span>&#123;</span><br><span class="line">        inject(json.file);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">&quot;json&quot;</span>,jsonFac);</span><br><span class="line"></span><br><span class="line"><span class="comment">// helper</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [inject description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[array]&#125;</span> <span class="variable">fileList</span></span></span></span><br><span class="line"><span class="comment"> *  格式:</span></span><br><span class="line"><span class="comment"> // file:[</span></span><br><span class="line"><span class="comment"> //         &#123;</span></span><br><span class="line"><span class="comment">    //             &quot;html&quot;:&quot;html/index.html&quot;,</span></span><br><span class="line"><span class="comment">    //             &quot;basePath&quot;:&quot;_asset/scripts/dist/a/&quot;,</span></span><br><span class="line"><span class="comment">    //             &quot;dist&quot;:&quot;html&quot;,</span></span><br><span class="line"><span class="comment">    //             &quot;sources&quot;:&#123;</span></span><br><span class="line"><span class="comment">    //                     &quot;css&quot;:&quot;_asset/scripts/dist/a/*.css&quot;,</span></span><br><span class="line"><span class="comment">    //                     &quot;js&quot;:&quot;_asset/scripts/dist/a/*.js&quot;</span></span><br><span class="line"><span class="comment">    //             &#125;</span></span><br><span class="line"><span class="comment">    //         &#125;</span></span><br><span class="line"><span class="comment"> // ]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inject</span>(<span class="params">fileList</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> opts = &#123;</span><br><span class="line">        algorithm: <span class="string">&#x27;sha1&#x27;</span>,</span><br><span class="line">        hashLength: <span class="number">8</span>,</span><br><span class="line">        template: <span class="string">&#x27;&lt;%= name %&gt;&lt;%= ext %&gt;?v=&lt;%= hash %&gt;&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> a=<span class="number">0</span>,len=fileList.length;a&lt;len;a++)&#123;</span><br><span class="line">        <span class="comment">//searchPath css文件位置 接受一个数组 或者一个字符串</span></span><br><span class="line">        <span class="keyword">var</span> assets = $.useref.assets(&#123;<span class="attr">searchPath</span>: [<span class="string">&#x27;asset/**/*&#x27;</span>,<span class="string">&#x27;.&#x27;</span>]&#125;);</span><br><span class="line">        gulp.src(fileList[a].html)</span><br><span class="line">            .pipe($.<span class="keyword">if</span>(!!fileList[a].sources.js,$.inject(gulp.src(fileList[a].sources.js, &#123;<span class="attr">read</span>: <span class="literal">true</span>&#125;).pipe($.hash(opts)), &#123;<span class="attr">relative</span>: <span class="literal">true</span>,<span class="attr">removeTags</span>:<span class="literal">true</span>&#125;)))</span><br><span class="line">            .pipe(assets)</span><br><span class="line">            .pipe($.rev())</span><br><span class="line">            .pipe(assets.restore())</span><br><span class="line">            .pipe($.useref())</span><br><span class="line">            .pipe($.revReplace())</span><br><span class="line">            .pipe($.<span class="keyword">if</span>(<span class="string">&#x27;*.js&#x27;</span>, $.uglify()))</span><br><span class="line">            <span class="comment">//.pipe($.if(&#x27;*.html&#x27;,$.htmlmin(&#123;collapseWhitespace: true&#125;)))</span></span><br><span class="line">            .pipe(gulp.dest(fileList[a].dist));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonFac</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jsonData = &#123;</span><br><span class="line">        file:[]</span><br><span class="line">    &#125;</span><br><span class="line">    filewalker(<span class="string">&#x27;./html/src&#x27;</span>)</span><br><span class="line">      .on(<span class="string">&#x27;file&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">p, s</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//console.log(&#x27;file: %s, %d bytes&#x27;, p, s.size);</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/\.html$/</span>.test(p))&#123;</span><br><span class="line">            <span class="keyword">var</span> jsPath;</span><br><span class="line">                jsPath = <span class="string">&#x27;asset/dist/js/&#x27;</span>+p.replace(<span class="regexp">/\.html$/</span>,<span class="string">&#x27;.bundle.js&#x27;</span>)</span><br><span class="line">            jsonData.file.push(&#123;</span><br><span class="line">                html:<span class="string">&#x27;html/src/&#x27;</span>+p,</span><br><span class="line">                dist: path.dirname(<span class="string">&#x27;html/dist/&#x27;</span>+p),</span><br><span class="line">                sources:&#123;</span><br><span class="line">                    js:jsPath</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">&#x27;done&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> file = <span class="string">&#x27;conf/injectJSON.json&#x27;</span></span><br><span class="line">        jsonfile.writeFile(file, jsonData, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.error(err)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;%d dirs, %d files, %d bytes&#x27;</span>, <span class="built_in">this</span>.dirs, <span class="built_in">this</span>.files, <span class="built_in">this</span>.bytes);</span><br><span class="line">      &#125;)</span><br><span class="line">    .walk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用时候分成3步：</p>
<ol>
<li>gulp json生成配置文件</li>
<li>gulp jspm生成打包好的bundle文件</li>
<li>gulp inject负责将资源插入大html然后进行压缩</li>
</ol>
<p>实际上第三步骤里面包含的除了inject任务，还有css打包、压缩，私有前缀处理和强缓存处理。<br>当然，这并不是非常完善，但是处理SystemJS的应用确实是非常够用。</p>
<p>在这个流程中我们用到了npm的包，并非为gulp设计，但是配合npm的包，却在gulp当前没有合用插件情况下处理好了业务需求。这是一个非常有参考价值的实践。</p>
]]></content>
  </entry>
  <entry>
    <title>backbone初探(四)-数据流</title>
    <url>/2016/04/17/backbone-4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前一篇读源码主要是把逻辑清楚部分了，但是MVC之间数据数据的处理和相关细节，还是存在一定的隔膜，这篇就来试试各个多个实例，看看数据在MVC之间怎样进行流动和操作。</p>
<h1 id="step-1-View的简单使用"><a href="#step-1-View的简单使用" class="headerlink" title="step 1 View的简单使用"></a>step 1 View的简单使用</h1><p>第一步还是从View开始，由于前端的特性，MVC模式在前端的应用归根结底不管中间如何玩花样，到了最后还是要把数据渲染到浏览器来，这是最最根本的事情。而数据渲染这个环节，无论如何该有一个目标渲染的数据，这里model和collection都是可以。先试试最简单的用model配合view输出一个helloworld。</p>
<h2 id="纯View"><a href="#纯View" class="headerlink" title="纯View"></a>纯View</h2><p>我们先来看看View来渲染一个写死的数据(没有model和collection配合)是怎样的：</p>
<p><a class="jsbin-embed" href="http://jsbin.com/hizico/embed?html,js,output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.12"></script></p>
<p>在这个例子中，整个数据仅仅是直接传参进去人后通过render进行dom渲染。<br>最后出来的dom是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div data-index&#x3D;&quot;1&quot; data-test&#x3D;&quot;test&quot; id&#x3D;&quot;view&quot; class&#x3D;&quot;viewClass&quot;&gt;Hello World&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>这里需要说的是三个参数：id,className和attributes,这三个函数在没有指定el的情况下会自动生成DOM，然后将id，className作为id和class给其设置好(事实上还有一个tagName属性也可以设置)，然后attributes遍历也设置好。</p>
<p>这是其中一种用法，自动生成dom然后按逻辑渲染，但是除此以外我们还可以直接对已经有的DOM进行重绘：<br><a class="jsbin-embed" href="http://jsbin.com/zivucuq/embed?html,js,output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.12"></script></p>
<h2 id="View-amp-Model"><a href="#View-amp-Model" class="headerlink" title="View&amp;Model"></a>View&amp;Model</h2><p>这里先随便标记一下。回头再来看这个细节。我们先找个model配合view来渲染下页面:<br><a class="jsbin-embed" href="http://jsbin.com/bifehiw/embed?html,js,output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.12"></script><br>这个例子和之前变化不大，只是实例化了一个model，然后使用get的方法取出了值进行渲染</p>
<h2 id="View-amp-Collection"><a href="#View-amp-Collection" class="headerlink" title="View&amp;Collection"></a>View&amp;Collection</h2><p>Collection往往是诸多数据的集合，常用的场景往往就是遍历输出。配合遍历输出的往往有复杂模板，但是这里仅仅输出纯文本好了。像下面的：<br><a class="jsbin-embed" href="http://jsbin.com/kazipa/embed?html,js,output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.12"></script></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>至此预想的step1实验到此就完毕了。我们来分析一下这些情况是如何产生的逻辑：</p>
<ul>
<li>设置el和不设置el时候View生成的dom</li>
<li>Model和Collection数据如何被View使用的。</li>
</ul>
<h3 id="el相关："><a href="#el相关：" class="headerlink" title="el相关："></a>el相关：</h3><p>先看View的构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> View = Backbone.View = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.cid = _.uniqueId(<span class="string">&#x27;view&#x27;</span>);</span><br><span class="line">  _.extend(<span class="built_in">this</span>, _.pick(options, viewOptions));</span><br><span class="line">  <span class="built_in">this</span>._ensureElement();</span><br><span class="line">  <span class="built_in">this</span>.initialize.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于el不同的处理方式就在 <code>_ensureElement</code>方法中:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_ensureElement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.el) &#123;</span><br><span class="line">    <span class="keyword">var</span> attrs = _.extend(&#123;&#125;, _.result(<span class="built_in">this</span>, <span class="string">&#x27;attributes&#x27;</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.id) attrs.id = _.result(<span class="built_in">this</span>, <span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.className) attrs[<span class="string">&#x27;class&#x27;</span>] = _.result(<span class="built_in">this</span>, <span class="string">&#x27;className&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.setElement(<span class="built_in">this</span>._createElement(_.result(<span class="built_in">this</span>, <span class="string">&#x27;tagName&#x27;</span>)));</span><br><span class="line">    <span class="built_in">this</span>._setAttributes(attrs);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setElement(_.result(<span class="built_in">this</span>, <span class="string">&#x27;el&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">_createElement: <span class="function"><span class="keyword">function</span>(<span class="params">tagName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createElement(tagName);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">_setElement: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$el = el <span class="keyword">instanceof</span> Backbone.$ ? el : Backbone.$(el);</span><br><span class="line">  <span class="built_in">this</span>.el = <span class="built_in">this</span>.$el[<span class="number">0</span>];</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码很容易，似乎无需说什么了，只有两个很简单的分支,顺便把用到的方法也贴出来。存在el还是不存在el情况下目标元素的设置和选定。<br>唯一需要说明下的<a href="http://www.css88.com/doc/underscore/#result">_.result</a>可以点击下进去查看细节，这里不详解。</p>
<h3 id="Model和Collection数据如何被View使用"><a href="#Model和Collection数据如何被View使用" class="headerlink" title="Model和Collection数据如何被View使用"></a>Model和Collection数据如何被View使用</h3><p>构造函数已经被贴过了，关于model和collection的设置其实还在el被设置之前。这里只贴关键代码行，整体看前面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.extend(<span class="built_in">this</span>, _.pick(options, viewOptions));</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> viewOptions = [<span class="string">&#x27;model&#x27;</span>, <span class="string">&#x27;collection&#x27;</span>, <span class="string">&#x27;el&#x27;</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;attributes&#x27;</span>, <span class="string">&#x27;className&#x27;</span>, <span class="string">&#x27;tagName&#x27;</span>, <span class="string">&#x27;events&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>很简单的玩意儿，哈哈，但是不看用法时候还真不知道用来为何这样写。<br>这里顺便贴下<a href="http://www.css88.com/doc/underscore/#pick">_.pick</a>的用法,我认为相当于一个过滤方法。<br>不过还是简单说一句吧。这段代码的意思，从options中取出数组中指定的属性，使用extend加到this上。而这个this一般使用时候指向new出来的实例。</p>
<h2 id="View初始化"><a href="#View初始化" class="headerlink" title="View初始化"></a>View初始化</h2><p>View还是存在一个初始化的接口的，这是因为很多代码需要一实例化立即进行渲染之类的操作，上面我们使用自己的设置的render来处理这个，这里我们换个方式来做:<br><a class="jsbin-embed" href="http://jsbin.com/giyuyo/embed?html,js,output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.12"></script><br>只是非常简单的换了下上面demo的写法，加了一个initialize属性，调用render方法初始化，这样后面就无需手动view.render()了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.initialize.apply(this, arguments);</span><br></pre></td></tr></table></figure>
<p>这是这段代码的功劳了。但是需要注意的是initialize比自定义的render时机要早,很多情况下可能使用它来初始化this.template这个属性，也就是设置模板。</p>
<h2 id="View的事件绑定-非View-amp-Event"><a href="#View的事件绑定-非View-amp-Event" class="headerlink" title="View的事件绑定(非View&amp;Event)"></a>View的事件绑定(非View&amp;Event)</h2><p>现代WEB应用，几乎没有那个应用没有进行事件绑定了。这是一个刚需的功能性需求。<br>我们来看看如何在View中进行事件绑定。<br>先看个demo:<br><a class="jsbin-embed" href="http://jsbin.com/ferofo/embed?js,console,output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.12"></script></p>
<p>这个demo上绑定了两个很简单的事件 click和mouseover<br>事件的绑定，写在了setElement方法中，这个方法在View的构造函数里面有调用。看看这个方法的细节：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set callbacks, where `this.events` is a hash of</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// *&#123;&quot;event selector&quot;: &quot;callback&quot;&#125;*</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       &#x27;mousedown .title&#x27;:  &#x27;edit&#x27;,</span></span><br><span class="line"><span class="comment">//       &#x27;click .button&#x27;:     &#x27;save&#x27;,</span></span><br><span class="line"><span class="comment">//       &#x27;click .open&#x27;:       function(e) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// pairs. Callbacks will be bound to the view, with `this` set properly.</span></span><br><span class="line"><span class="comment">// Uses event delegation for efficiency.</span></span><br><span class="line"><span class="comment">// Omitting the selector binds the event to `this.el`.</span></span><br><span class="line">delegateEvents: <span class="function"><span class="keyword">function</span>(<span class="params">events</span>) </span>&#123;</span><br><span class="line">  events || (events = _.result(<span class="built_in">this</span>, <span class="string">&#x27;events&#x27;</span>));</span><br><span class="line">  <span class="keyword">if</span> (!events) <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  <span class="built_in">this</span>.undelegateEvents();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> events) &#123;</span><br><span class="line">    <span class="keyword">var</span> method = events[key];</span><br><span class="line">    <span class="keyword">if</span> (!_.isFunction(method)) method = <span class="built_in">this</span>[method];</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">var</span> match = key.match(delegateEventSplitter);</span><br><span class="line">    <span class="built_in">this</span>.delegate(match[<span class="number">1</span>], match[<span class="number">2</span>], _.bind(method, <span class="built_in">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a single event listener to the view&#x27;s element (or a child element</span></span><br><span class="line"><span class="comment">// using `selector`). This only works for delegate-able events: not `focus`,</span></span><br><span class="line"><span class="comment">// `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.</span></span><br><span class="line">delegate: <span class="function"><span class="keyword">function</span>(<span class="params">eventName, selector, listener</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$el.on(eventName + <span class="string">&#x27;.delegateEvents&#x27;</span> + <span class="built_in">this</span>.cid, selector, listener);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>事件绑定关键的代码在line22-23，我们聚焦这一块。</p>
<ol>
<li>它首先将events属性名切割成事件名称和选择器两个，作为属性传入delegate，随之传入的还有method,这里使用_bind将method事件方法的上下文绑定到当前视图对象, 因此在事件被触发后, 事件方法中的this始终指向视图对象本身.</li>
<li>然后看delegate:看完有些sb的感觉了。。。它使用jQuery等库的on函数来处理的事件绑定，并没有自己实现一下,<a href="http://www.css88.com/jqapi-1.9/on/">jQuery的on</a>可以去看看语法。唯一的问题是 <code>eventName + '.delegateEvents' + this.cid</code>运算的结果类似这样:keypress.delegateEventsview1,多了后面一截命名空间,何故呢？看看undelegateEvents内部通过’.delegateEvents’ + this.cid参数进行off解绑就明白了！</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Backbone.View的分析就此告落了。最后一段事件的分析，让我们可以联想到之前对事件机制的猜想，之前读源码时候还以为全部是Pub/Sub模式感到不解，现在可以得出最终结论了：Backbone确实是使用Pub/Sub模式，但是在View上它巧妙运用了第三方库来实现事件处理。实质上是混合了二者。</p>
<h1 id="step2-Model"><a href="#step2-Model" class="headerlink" title="step2 Model"></a>step2 Model</h1><p>Model基本属于数据表里面代表一行的数据，这个类型的数据基本没有太多可以多说的数据流问题。<br>在Model的实例中,实例的数据存放在attributes这个对象中，诸多方法，也都是依托CURD这个对象来实现。这个事情也只能这样做。因为数据最终需要有个地方存放，即使不叫attributes,那么也可能叫做attrs或者data之流。</p>
<p>这里仅仅简要说明一下Model里面常用到的一些功能。并没有太多新意。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># get获取数据</span><br><span class="line"><span class="keyword">var</span> bird = Backbone.Model.extent(&#123;</span><br><span class="line">        defaults:&#123;</span><br><span class="line">            color:<span class="string">&quot;&quot;</span>,</span><br><span class="line">            name:<span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> maque = <span class="keyword">new</span> bird(&#123;</span><br><span class="line">    name:<span class="string">&quot;麻雀&quot;</span>,</span><br><span class="line">    color:<span class="string">&quot;灰不啦叽&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(maque.get(<span class="string">&quot;name&quot;</span>)+<span class="string">&quot;颜色是:&quot;</span>+maque.color);</span><br><span class="line"></span><br><span class="line"># 设置属性</span><br><span class="line">maque.set(&#123;</span><br><span class="line">    color:<span class="string">&quot;灰色&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"># 删除属性</span><br><span class="line">maque.unset(<span class="string">&quot;color&quot;</span>);   <span class="comment">//删除一个</span></span><br><span class="line">maque.clear()           <span class="comment">//清除整个数据</span></span><br><span class="line"></span><br><span class="line"># 数据回滚</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;before&quot;</span>,maque.previousAttributes());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;after&quot;</span>,maque.attribuites);</span><br><span class="line"></span><br><span class="line"># 数据持久化</span><br><span class="line"><span class="keyword">var</span> bird = Backbone.Model.extent(&#123;</span><br><span class="line">        defaults:&#123;</span><br><span class="line">            color:<span class="string">&quot;&quot;</span>,</span><br><span class="line">            name:<span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        url:<span class="string">&quot;test/update&quot;</span>,</span><br><span class="line">        initilize:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//XXXXX</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mq = <span class="keyword">new</span> bird(&#123;</span><br><span class="line">    name:<span class="string">&quot;麻雀1&quot;</span>,</span><br><span class="line">    color:<span class="string">&quot;灰色&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line">mq.save(<span class="literal">null</span>,&#123;</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">model,data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(modal,data);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="step3-Collection"><a href="#step3-Collection" class="headerlink" title="step3 Collection"></a>step3 Collection</h1><p>如果说Model是一个row,那么collection就是一个table。Collection的方法应该是偏向集化操作的。<br>Collection是Model的Collection,明确这一点非常重要。这是数据集合的统一性质要求，是Sql数据表的存储要求，也是ORM这一原则的要求。<br>我们来看看如何设置一个简单的Collecion：</p>
<p><a class="jsbin-embed" href="http://jsbin.com/rihipur/embed?js,console">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.12"></script></p>
<p>大致就是专业的一个东西，这里简单的使用了一下Collection上的API,从思路上来说，一切都是对实例上models属性的操作。这个操作，非常大程度上参考了Array的api，有pop，push，shift，unshift，slice等等操作，细节上可能会有不同，但是都是对models属性的操作。</p>
<p>细节就不表了，感觉数组用了这么久，不需要。</p>
<h1 id="不是总结的总结"><a href="#不是总结的总结" class="headerlink" title="不是总结的总结"></a>不是总结的总结</h1><p>本来以为要浪费N多少时间在Modle和Colletion上，后来发现其实真的不需要，反而是View占用了大多数篇幅。</p>
<p>有朋友说Backbone写起来很随意，看了这么多，发现真的是很随意。除了改了N年的细节和兼容，Backbone是一个你理解架构就可以自己去山寨的一个不算库的库,虽然不会比它好。</p>
<p>MVC是backbone的核心，到现在基本是理清了。虽然很多细节没有提及，但是感觉不需要了。</p>
<p>Model就像是对闭包内数据的读写操作，而Collecion则相当于对闭包内数组的读写。</p>
<p>而View算是Backbone整体架构的最新展现者，但是它功能和API也真的是太简单,差不多一个巴掌可以数过来的API,也就涵盖了DOM生成选定，模板渲染和数据绑定三个环节的东西，没有一丝累赘。</p>
<p>有一句实话是,backbone虽然设计精巧，但是看下来确实有些失望。因为此番收获的确实不太多。或许没有精熟各个细节是大原因。下一篇有空打算把Sync和Router整理一番。做个收尾。</p>
<p>最后贴个链接在这里,算是自己的读源码历程的一个反思: <a href="https://www.zhihu.com/question/29765945">程序员阅读源码是一种什么心态？源码对编程意义何在？如何才能更好阅读代码？</a></p>
<p>深以为：debug能力是程序员生涯中最重要的能力之一，源码不是小说没有情节，也记不住细节，读源码的意义，除了在文档缺乏情况下可以找到使用方法，也是熟悉各种编程思想的最佳位置之一。</p>
]]></content>
  </entry>
  <entry>
    <title>backbone初探(三)-整体结构</title>
    <url>/2016/04/17/backbone-3/</url>
    <content><![CDATA[<h1 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h1><h2 id="Backbone的整体Structure"><a href="#Backbone的整体Structure" class="headerlink" title="Backbone的整体Structure"></a>Backbone的整体Structure</h2><p>webStorm的Structure是个很不错的功能。只是很多源码确实不是仅仅看这个就可以有相对清晰的脉络。但是这里似乎并不包括Backbone。<br><img style="width:40%" src="/images/backbone-all.png" alt=""><br>很清晰的结构，而且最重要的几个工具函数在上一篇已经有了相对深入的解读。<br>所以接下来我们对Backbone的若干个构造器来个相对粗略的了解。</p>
<h2 id="Event结构"><a href="#Event结构" class="headerlink" title="Event结构"></a>Event结构</h2><p><img src="/images/Backbone-Event.png"></p>
<p>Event是个很重要的部分,不管是Model，Collection还是View，均在原型上继承了它的各种方法。<br>但是Event如果不论细节，它的实现原理还是非常简单的。<br>如果上图所示，Event有两个基础方法：evnetApi和trigerApi，其中eventApi在AOP编程思想基础上，构建了4个方法，internalOn,onApi,offApi和onceApi，这里internalOn是队opApi的进一步封装用于设置_listeners和_event以便进行跟踪,本篇主要侧重于结构分析，细节将下一篇开始分解。然后在看trigerApi，在它基础上还有一个triggerEvents。</p>
<p>在这两个基础方法基础上，Event封装如果暴露出来的方法。<br>eventApi:</p>
<ul>
<li>on</li>
<li>off</li>
<li>once</li>
<li>listenToOnce</li>
<li>stopListening</li>
<li>ListenTo</li>
</ul>
<p>onceApi</p>
<ul>
<li>trigger</li>
</ul>
<h2 id="Model结构"><a href="#Model结构" class="headerlink" title="Model结构"></a>Model结构</h2><p><img src="/images/Backbone-Model.png"></p>
<p>首先要声明一点，Backbone.Model.extend()返回的是一个构造器。extend整个细节在上一篇已经深入讲过了。child.prototype.constructor被更改返回child以后，整个新的构造器已经被切断了和Backbone.Model的关联。Backbone.Model其实已经可以视为一个生产构造器工厂。</p>
<p>不独是Model，其他的View、Collection其实也是一样。extend使用了闭包将内部变量返回，当Backbone.Model.extend()执行完毕之后，返回值其实同Backbone.Model没有任何关联(除了特别设置的_<em>super_</em>)</p>
<p>这里看看Model生成新的构造器时候干了什么</p>
<p>回顾extend一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">child = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> parent.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); &#125;;</span><br></pre></td></tr></table></figure>
<p>这里this指向的是Model，Collection和View之类，以Model为例，它实质上将构造函数copy一个赋值给child了而已。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Todo &#x3D; Backbone.Model.extend(&#123;</span><br><span class="line">  &#x2F;&#x2F; Default attributes for the todo item.</span><br><span class="line">  defaults: function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title: &quot;empty todo...&quot;,</span><br><span class="line">      done: false</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Toggle the &#96;done&#96; state of this todo item.</span><br><span class="line">  toggle: function() &#123;</span><br><span class="line">    this.save(&#123;done: !this.get(&quot;done&quot;)&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">var test &#x3D; new Todo();</span><br></pre></td></tr></table></figure>
<p>console.log(test)的结果是：<br><img src="/images/console1.png"><br>这里attributes是存放数据的对象，代表的是，一个实例的数据。但是，toggle在原型上了，似乎忽略了一些细节。<br>回看extend代码，是这里运行导致的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">child.prototype = _.create(parent.prototype, protoProps);</span><br></pre></td></tr></table></figure>



<h2 id="Collection结构"><a href="#Collection结构" class="headerlink" title="Collection结构"></a>Collection结构</h2><p><img src="/images/Backbone-Collection.png"><br>实际上Collection同Model的构造环节几乎一模一样，只是构造函数有所不同。<br>看看构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> Collection = Backbone.Collection = <span class="function"><span class="keyword">function</span>(<span class="params">models, options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//options如果没有传入将初始化为一个空对象</span></span><br><span class="line">    options || (options = &#123;&#125;);</span><br><span class="line">    <span class="comment">//options.model若指定则设置实例的model属性为该值</span></span><br><span class="line">    <span class="keyword">if</span> (options.model) <span class="built_in">this</span>.model = options.model;</span><br><span class="line">    <span class="comment">//options.comparator若指定则设置实例的comparator属性为该值</span></span><br><span class="line">    <span class="keyword">if</span> (options.comparator !== <span class="keyword">void</span> <span class="number">0</span>) <span class="built_in">this</span>.comparator = options.comparator;</span><br><span class="line">    <span class="comment">//初始化实例的length，models和_byId属性</span></span><br><span class="line">    <span class="built_in">this</span>._reset();</span><br><span class="line">    <span class="comment">//this.initialize(arguments) 使用initialize来初始化实例</span></span><br><span class="line">    <span class="built_in">this</span>.initialize.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 如果models存在</span></span><br><span class="line">    <span class="keyword">if</span> (models) <span class="built_in">this</span>.reset(models, _.extend(&#123;<span class="attr">silent</span>: <span class="literal">true</span>&#125;, options));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很明晰的构造函数，大致是分成三步</p>
<ol>
<li>如果options传入且存在model或者comparator，那么将他们挂到实例属性上，否则设置为空对象。</li>
<li>然后使用先后使用_reset()和initialize来初始化实例属性。</li>
<li>最后一步，如果models传入了，那么调用reset来将models加入到实例的内部数据属性上。</li>
</ol>
<p>这里稍微有点问题的是第二步和第三步：</p>
<h3 id="reset"><a href="#reset" class="headerlink" title="_reset()"></a>_reset()</h3><p>_reset是原型上自带的一个初始化函数，而initialize默认是空函数，但是可以通过extend中以下代码来设置一个，也就是说是可以配置的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">child.prototype = _.create(parent.prototype, protoProps);</span><br></pre></td></tr></table></figure>

<h3 id="reset-1"><a href="#reset-1" class="headerlink" title="reset"></a>reset</h3><p>reset是另外一个初始化函数，这里贴一下细节：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// When you have more items than you want to add or remove individually,</span></span><br><span class="line"><span class="comment">// 当你有更多数据要逐个添加或者删除</span></span><br><span class="line"><span class="comment">// you can reset the entire set with a new list of models, without firing</span></span><br><span class="line"><span class="comment">// 你可以重置这个实例设置一个新的models列表，不用触发任何add和remove的事件</span></span><br><span class="line"><span class="comment">// any granular `add` or `remove` events. Fires `reset` when finished.</span></span><br><span class="line"><span class="comment">// 添加删除完毕后触发reset事件</span></span><br><span class="line"><span class="comment">// Useful for bulk operations and optimizations.</span></span><br><span class="line"><span class="comment">// 对批量操作和优化来说非常有用</span></span><br><span class="line">reset: <span class="function"><span class="keyword">function</span>(<span class="params">models, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//options存在则深拷贝一份，或设置为&#123;&#125;</span></span><br><span class="line">  options = options ? _.clone(options) : &#123;&#125;;</span><br><span class="line">  <span class="comment">//遍历models，切断模型和某个集合的关系。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.models.length; i++) &#123;</span><br><span class="line">    <span class="built_in">this</span>._removeReference(<span class="built_in">this</span>.models[i], options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将options的previousModels指向这个models</span></span><br><span class="line">  options.previousModels = <span class="built_in">this</span>.models;</span><br><span class="line">  <span class="comment">//初始化实例的length，models和_byId属性 -&gt;此时this.models=[];</span></span><br><span class="line">  <span class="built_in">this</span>._reset();</span><br><span class="line">  <span class="comment">//调用add方法添加models到Collection</span></span><br><span class="line">  models = <span class="built_in">this</span>.add(models, _.extend(&#123;<span class="attr">silent</span>: <span class="literal">true</span>&#125;, options));</span><br><span class="line">  <span class="comment">//如果options设置了silent=false,手动触发reset事件进行重置</span></span><br><span class="line">  <span class="keyword">if</span> (!options.silent) <span class="built_in">this</span>.trigger(<span class="string">&#x27;reset&#x27;</span>, <span class="built_in">this</span>, options);</span><br><span class="line">  <span class="keyword">return</span> models;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>代码已经注释了每一步的逻辑，这里有个需要说的是reset方法本身并不处理数据的增删，而是依赖add方法，add又依赖set方法，基本上set方法可以说是Collection最基础的方法之一了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add: function(models, options) &#123;</span><br><span class="line">  return this.set(models, _.extend(&#123;merge: false&#125;, options, addOptions));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; Update a collection by &#96;set&#96;-ing a new list of models, adding new ones,</span><br><span class="line">&#x2F;&#x2F; removing models that are no longer present, and merging models that</span><br><span class="line">&#x2F;&#x2F; already exist in the collection, as necessary. Similar to **Model#set**,</span><br><span class="line">&#x2F;&#x2F; the core operation for updating the data contained by the collection.</span><br><span class="line">set: function(models, options) &#123;</span><br><span class="line">      &#x2F;&#x2F;models为空直接返回false跳出函数</span><br><span class="line">      if (models &#x3D;&#x3D; null) return;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 合并setOptions和options赋值给options</span><br><span class="line">      options &#x3D; _.extend(&#123;&#125;, setOptions, options);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 分支1：如果options设置了parse且models不是一个Model实例，那么使用parse方法来解析一下models</span><br><span class="line">      if (options.parse &amp;&amp; !this._isModel(models)) &#123;</span><br><span class="line">        models &#x3D; this.parse(models, options) || [];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 分支2：判断一下models是否是数组,如果是数组，返回一个副本，</span><br><span class="line">      &#x2F;&#x2F; 否则放到一个空素组作为元素并返回数组-&gt;统一转换成数组处理</span><br><span class="line">      var singular &#x3D; !_.isArray(models);</span><br><span class="line">      models &#x3D; singular ? [models] : models.slice();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 设置at 如果指定了at，那么排序就无意义</span><br><span class="line">      &#x2F;&#x2F; 如果at不为空强制转为数字(正常范围内)</span><br><span class="line">      &#x2F;&#x2F; 如果at大于数组长度: 设为数组长度</span><br><span class="line">      &#x2F;&#x2F; 如果at小余0：反向设置索引</span><br><span class="line">      var at &#x3D; options.at;</span><br><span class="line">      if (at !&#x3D; null) at &#x3D; +at;</span><br><span class="line">      if (at &gt; this.length) at &#x3D; this.length;</span><br><span class="line">      if (at &lt; 0) at +&#x3D; this.length + 1;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 准备要放数据的设置，添加，合并，移除和modelMap的空数组</span><br><span class="line">      var set &#x3D; [];</span><br><span class="line">      var toAdd &#x3D; [];</span><br><span class="line">      var toMerge &#x3D; [];</span><br><span class="line">      var toRemove &#x3D; [];</span><br><span class="line">      var modelMap &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 为各个数据设置引用</span><br><span class="line">      var add &#x3D; options.add;</span><br><span class="line">      var merge &#x3D; options.merge;</span><br><span class="line">      var remove &#x3D; options.remove;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 设置排序状态，是否可以排序和排序属性</span><br><span class="line">      var sort &#x3D; false;</span><br><span class="line">      var sortable &#x3D; this.comparator &amp;&amp; at &#x3D;&#x3D; null &amp;&amp; options.sort !&#x3D;&#x3D; false;</span><br><span class="line">      var sortAttr &#x3D; _.isString(this.comparator) ? this.comparator : null;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Turn bare objects into model references, and prevent invalid models</span><br><span class="line">      &#x2F;&#x2F; from being added.</span><br><span class="line">      &#x2F;&#x2F; 将纯对象变成model引用，防止无效的models被加进来。</span><br><span class="line">      var model, i;</span><br><span class="line">      for (i &#x3D; 0; i &lt; models.length; i++) &#123;</span><br><span class="line">        model &#x3D; models[i];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If a duplicate is found, prevent it from being added and</span><br><span class="line">        &#x2F;&#x2F; optionally merge it into the existing model.</span><br><span class="line">        &#x2F;&#x2F; 如果一个副本已存在，防止被加进来，可选是否合并它到已存在的model</span><br><span class="line">        var existing &#x3D; this.get(model); &#x2F;&#x2F;获取已经存在的model数组</span><br><span class="line">        if (existing) &#123;</span><br><span class="line">          &#x2F;&#x2F; 如果存在，判断options.merge是否存在&amp;&amp;option的merge是否没有加入过</span><br><span class="line">            &#x2F;&#x2F; 如果是 处理数据压入到toMerge</span><br><span class="line">          if (merge &amp;&amp; model !&#x3D;&#x3D; existing) &#123;</span><br><span class="line">            var attrs &#x3D; this._isModel(model) ? model.attributes : model;</span><br><span class="line">            if (options.parse) attrs &#x3D; existing.parse(attrs, options);</span><br><span class="line">            existing.set(attrs, options);</span><br><span class="line">            toMerge.push(existing);</span><br><span class="line">            if (sortable &amp;&amp; !sort) sort &#x3D; existing.hasChanged(sortAttr);</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 如果存在且modelMap中没有这个cid</span><br><span class="line">            &#x2F;&#x2F; 那么设置modelMap对应的cid属性值为true，压入existing到set数组</span><br><span class="line">          if (!modelMap[existing.cid]) &#123;</span><br><span class="line">            modelMap[existing.cid] &#x3D; true;</span><br><span class="line">            set.push(existing);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; models[i]设为处理后的existing</span><br><span class="line">          models[i] &#x3D; existing;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If this is a new, valid model, push it to the &#96;toAdd&#96; list.</span><br><span class="line">        &#x2F;&#x2F; 如果是一个新的有效的model，将它压入到toAdd数组</span><br><span class="line">        &#125; else if (add) &#123;</span><br><span class="line">          model &#x3D; models[i] &#x3D; this._prepareModel(model, options);</span><br><span class="line">          if (model) &#123;</span><br><span class="line">            toAdd.push(model);</span><br><span class="line">            this._addReference(model, options);</span><br><span class="line">            modelMap[model.cid] &#x3D; true;</span><br><span class="line">            set.push(model);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Remove stale models.</span><br><span class="line">      &#x2F;&#x2F; 移除过期的models</span><br><span class="line">      if (remove) &#123;</span><br><span class="line">        for (i &#x3D; 0; i &lt; this.length; i++) &#123;</span><br><span class="line">          model &#x3D; this.models[i];</span><br><span class="line">          if (!modelMap[model.cid]) toRemove.push(model);</span><br><span class="line">        &#125;</span><br><span class="line">        if (toRemove.length) this._removeModels(toRemove, options);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; See if sorting is needed, update &#96;length&#96; and splice in new models.</span><br><span class="line">      &#x2F;&#x2F; 判断是否需要排序，更新length并切片到新的models列表</span><br><span class="line">      var orderChanged &#x3D; false;</span><br><span class="line">      var replace &#x3D; !sortable &amp;&amp; add &amp;&amp; remove;</span><br><span class="line">      if (set.length &amp;&amp; replace) &#123;</span><br><span class="line">        orderChanged &#x3D; this.length !&#x3D;&#x3D; set.length || _.some(this.models, function(m, index) &#123;</span><br><span class="line">          return m !&#x3D;&#x3D; set[index];</span><br><span class="line">        &#125;);</span><br><span class="line">        this.models.length &#x3D; 0;</span><br><span class="line">        splice(this.models, set, 0);</span><br><span class="line">        this.length &#x3D; this.models.length;</span><br><span class="line">      &#125; else if (toAdd.length) &#123;</span><br><span class="line">        if (sortable) sort &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F;如果at存在插入到at后面 不然插入到最后</span><br><span class="line">        splice(this.models, toAdd, at &#x3D;&#x3D; null ? this.length : at);</span><br><span class="line">        this.length &#x3D; this.models.length;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Silently sort the collection if appropriate.</span><br><span class="line">      &#x2F;&#x2F; 静默排序</span><br><span class="line">      if (sort) this.sort(&#123;silent: true&#125;);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Unless silenced, it&#39;s time to fire all appropriate add&#x2F;sort&#x2F;update events.</span><br><span class="line">      &#x2F;&#x2F; 除非设置了sliencd,是时候去触发所有的添加删除排序更新操作</span><br><span class="line">      if (!options.silent) &#123;</span><br><span class="line">        for (i &#x3D; 0; i &lt; toAdd.length; i++) &#123;</span><br><span class="line">          if (at !&#x3D; null) options.index &#x3D; at + i;</span><br><span class="line">          model &#x3D; toAdd[i];</span><br><span class="line">          model.trigger(&#39;add&#39;, model, this, options);</span><br><span class="line">        &#125;</span><br><span class="line">        if (sort || orderChanged) this.trigger(&#39;sort&#39;, this, options);</span><br><span class="line">        if (toAdd.length || toRemove.length || toMerge.length) &#123;</span><br><span class="line">          options.changes &#x3D; &#123;</span><br><span class="line">            added: toAdd,</span><br><span class="line">            removed: toRemove,</span><br><span class="line">            merged: toMerge</span><br><span class="line">          &#125;;</span><br><span class="line">          this.trigger(&#39;update&#39;, this, options);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Return the added (or merged) model (or models).</span><br><span class="line">      return singular ? models[0] : models;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p>set方法实在是个很重量级的方法了，逻辑很长，考虑到的东西非常多。<br>我们重点说说这个set方法，他的用途是什么呢？我们先翻译一遍这个注释</p>
<blockquote>
<p>更新一个集合，通过set一个新的集合列表。添加一个新集合，或者删除不再存在的集合，<br>同时，合并已经存在的集合——如果需要的话。类似Model的set方法，是collection更新数据的<br>核心方法。</p>
</blockquote>
<p>set方法如果全部记住的话实在太复杂了，一个函数长度达到一百行实际项目中也见到的不多。还是那句，先宏观到微观，步步为营深入它。</p>
<ol>
<li>准备后面函数需要用到的数据:</li>
</ol>
<ul>
<li>line11-23:设置options，然后设置model：</li>
</ul>
<p>  – parse存在且不为模型时,用parse处理model；<br>  – 判断是否是数组,如果是数组返回副本，否则放到一个空素组作为元素并返回数组</p>
<ul>
<li>line26-50:设置at索引,临时容器数组，和排序属性(状态,能力,属性)</li>
</ul>
<ol start="2">
<li>数据操作流程：</li>
</ol>
<ul>
<li>将纯对象变成model引用，方式是遍历数组，取出每个属性到以下流程</li>
</ul>
<p>  – 判断是否已有这个数据<br>  — 是-&gt;如果设置了合并相关选项，那么进行相关事宜<br>  — 否-&gt;进入添加流程</p>
<ul>
<li>移除过期的models</li>
<li>更新lenght&amp;排序</li>
<li>触发绑定的事件</li>
</ul>
<p>这样就够了。里面更多细节我认为已经不需要去深究了。阅读代码更多是在读架构。这里如果没有以后发现有补充必要，暂时先跳过了。实际上注释已经加的不少了。</p>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>view的结构和上面都一样，但是相比上列，它的构造函数实在简洁的不行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> View = Backbone.View = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.cid = _.uniqueId(<span class="string">&#x27;view&#x27;</span>);</span><br><span class="line">  _.extend(<span class="built_in">this</span>, _.pick(options, viewOptions));</span><br><span class="line">  <span class="built_in">this</span>._ensureElement();</span><br><span class="line">  <span class="built_in">this</span>.initialize.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>加起来一共也就4行,第一行设置cid；第二行从options中过滤出[‘model’, ‘collectgition’, ‘el’, ‘id’, ‘attributes’, ‘className’, ‘tagName’, ‘events’]数组中的属性；第三行用到了_ensureElement方法，用来确保获取dom(class,id或者选择器字符串),同时这个函数里面还对事件进行了绑定；第四行用来初始化，默认是个空函数，可以自定义。</p>
<p>除此以外View几乎没有其他的API被暴露出来。View的主要的API只有渲染、绑定事件和移除3种。但是简单不代表View不重要，后面文章再深入尝试使用。</p>
<h2 id="History-amp-amp-Route"><a href="#History-amp-amp-Route" class="headerlink" title="History&amp;&amp;Route"></a>History&amp;&amp;Route</h2><p>说实话History这个模块确实没有想到，可能是因为过去项目尚没有这方面的苛刻要求。<br>至于在html5的pushState和hashchange事件的基础上进行简单前进后退的实践却确实有不少，但是Histroy这个环节里面的处理方式确实让我始料未及。</p>
<p>这里随便列举一下里面包含的没有想过的：</p>
<ul>
<li>getSearch:在更多时候个人往往使用location.query来获取这个，但是没想过ie6会存在bug，这里使用正则获取</li>
<li>getHash:个人用的location.hash来获取，没遇到过firefox这个bug过</li>
<li>decodeFragment解码location.pathname这个<code>%25</code>的例外也不知道</li>
</ul>
<p>至于细节暂时搁置一下。毕竟Backbone我更想看看MVC三个模块之间的数据是怎样的。收拾一下，准备开始实例看数据。</p>
<p>就这样吧。此篇暂结。</p>
]]></content>
  </entry>
  <entry>
    <title>backbone初探(二)-辅助函数</title>
    <url>/2016/04/16/backbone-2/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这篇文章开始动笔之前抽了一周的晚上看源码，对Backbone的源码结构也算是有了整体认识。在宏观已经有了大体了解和有过大体猜测基础上，有了这篇文章，依赖是梳理学习脉络，二来强化记忆便于进一步整理代码。</p>
<h1 id="Backbone的基础公用函数"><a href="#Backbone的基础公用函数" class="headerlink" title="Backbone的基础公用函数"></a>Backbone的基础公用函数</h1><p>Backbone代码经过好多年的整理和重构代码变得非常复用，以至于很多基础函数代码很难一下子整理完毕。这里先看看它的基础函数。</p>
<h2 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h2><p>backbone很多代码都从underscore里面继承过来，并且对underscrore函数进行了高度的复用。但是它本身的extend函数确实根据自身的需要量身定制的。我们先看看TODO实例里面的几段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> Todo = Backbone.Model.extend(&#123;</span><br><span class="line">...</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">var</span> TodoList = Backbone.Collection.extend(&#123;</span><br><span class="line">...</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">var</span> Todos = <span class="keyword">new</span> TodoList;</span><br><span class="line"> <span class="keyword">var</span> TodoView = Backbone.View.extend(&#123;</span><br><span class="line">...</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">var</span> App = <span class="keyword">new</span> AppView;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了精简和明晰，主干代码已经被精简掉了。具体可以查看<a href="http://backbonejs.org/examples/todos/todos.js">这里</a>查看更多。<br>这三段代码就是Todo的DEMO的主题逻辑代码，可以看到backbone并没有像以往很多库和框架一样使用new的方式来实例化构造器。<br>然后把源码拖到最后几行，可以看到这一段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;</span><br></pre></td></tr></table></figure>
<p>很显然，不管是M、V还是C，他们的extend都指向了extend函数，我们来看细节：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Helper function to correctly set up the prototype chain for subclasses.</span></span><br><span class="line"><span class="comment">// 辅助函数-&gt;用于正确设置子类的原型链。</span></span><br><span class="line"><span class="comment">// Similar to `goog.inherits`, but uses a hash of prototype properties and</span></span><br><span class="line"><span class="comment">// 类似于`goog.inherits`，但是使用一个原型的hash属性并继承原型。</span></span><br><span class="line"><span class="comment">// class properties to be extended.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数protoProps对象中的属性是所有child实例的公用方法</span></span><br><span class="line"><span class="comment">// 参数staticProps对象中的属性是child类的静态属性</span></span><br><span class="line"><span class="keyword">var</span> extend = <span class="function"><span class="keyword">function</span>(<span class="params">protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//=&gt;this指向谁？当作为方法调用 指向调用对象本身，也就是说可能会指向Model,View,Events&amp;Collection之一</span></span><br><span class="line">  <span class="keyword">var</span> parent = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> child;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The constructor function for the new subclass is either defined by you</span></span><br><span class="line">  <span class="comment">// (the &quot;constructor&quot; property in your `extend` definition), or defaulted</span></span><br><span class="line">  <span class="comment">// by us to simply call the parent constructor.</span></span><br><span class="line">  <span class="comment">// 如果定义了protoProps，且protoProps有constructor属性</span></span><br><span class="line">  <span class="comment">// 那么protoProps.constructor将作为子类的构造器</span></span><br><span class="line">  <span class="comment">// 否则，会定义一个构造器，且构造器里调用了父类的构造函数</span></span><br><span class="line">  <span class="keyword">if</span> (protoProps &amp;&amp; _.has(protoProps, <span class="string">&#x27;constructor&#x27;</span>)) &#123;</span><br><span class="line">    child = protoProps.constructor;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 借用parent的构造函数初始化自身</span></span><br><span class="line">    child = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> parent.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Add static properties to the constructor function, if supplied.</span></span><br><span class="line">  <span class="comment">// 将静态属性staticProps以及parent上的类属性添加到child上作为类属性</span></span><br><span class="line">  _.extend(child, parent, staticProps);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the prototype chain to inherit from `parent`, without calling</span></span><br><span class="line">  <span class="comment">// 设置继承自parent的原型链 而不调用parent的构造器函数(实际上在上面已经调用过了)</span></span><br><span class="line">  <span class="comment">// `parent`&#x27;s constructor function and add the prototype properties.</span></span><br><span class="line">  <span class="comment">// 并添加原型属性</span></span><br><span class="line">  child.prototype = _.create(parent.prototype, protoProps);</span><br><span class="line">  child.prototype.constructor = child;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set a convenience property in case the parent&#x27;s prototype is needed</span></span><br><span class="line">  <span class="comment">// later.</span></span><br><span class="line">  child.__super__ = parent.prototype;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>前面几段还算好理解，主要麻烦的是原型prototype和constructor还有__super__这三个玩意儿之间的关系了。这里尽量用几句话说完：<br>众所周知，在面向对象继承这个概念有两个非常基础的概念:类&amp;实例。<br>但是在Javascript这门语言中，还存在一个叫做原型(prototype)的东西,js依赖它实现继承。<br>这里做个场景模拟：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="comment">//构造函数</span></span><br><span class="line">A.prototype.a=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="comment">//构造函数的原型</span></span><br><span class="line"><span class="keyword">var</span> b = A.prototype.constructor;</span><br><span class="line"><span class="keyword">var</span> B = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">var</span> c = B.__proto__;</span><br><span class="line"><span class="keyword">var</span> d = B.constructor;</span><br></pre></td></tr></table></figure>
<p>这里首先说明一下，构造器(A)通常会分为两个部分组成：构造函数(line1)+构造函数的原型(line2);<br>然后指出这里存在的三个对应关系：</p>
<ul>
<li>b === A =&gt;构造器的原型上的constructor会指向构造器的构造函数</li>
<li>c === A.prototype =&gt; 实例的__proto__属性会指向构造器的原型链</li>
<li>d === A =&gt;实例的constructor会指向构造器的原型链</li>
</ul>
<p>最后，需要补充的是：</p>
<ol>
<li>constructor属性在实例化时候动态生成,覆盖原来prototype的值</li>
<li>__proto__和__super__其实是不同的引用,__proto__是个别浏览器对原型的内部实现，而__super__仅仅是backbone的内部属性名称而已。</li>
</ol>
<p>最后来说下代码的意图：<br><code>child.prototype = <em>.create(parent.prototype, protoProps)</code>:这里设置了child.prototype为parent和protoProps的混合体；<br><code>child.prototype.constructor = child</code>:这里将prototype.constructor指向了本身<br><code>child._<em>super\</em></em> = parent.prototype</code>这里将__super__指向了parent.prototype；</p>
<p>——打住！看到这里是不是有似曾相识的感觉？没错，上面代码干了这两件事：</p>
<ul>
<li>设置原型然后将原型的constructor指向自身构造函数，这里它可以当做一个构造器使用了！</li>
<li>然后它把自己的__super__又给指向了parent.prototype……</li>
</ul>
<p>有点眼熟了吧，我们离题一下，假设_<em>super_<em>就是__proto\</em></em>,那么会发生什么奇妙的事情呢？</p>
<p>废话不说了，眼见为实：<br><a class="jsbin-embed" href="http://jsbin.com/jebaweciki/embed?js,console">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.12"></script></p>
<p>很奇妙的，如果这样写，那么此时这个child会既可以做构造器也可以作为实例来使用原型上的值。<br>然而__proto__毕竟是个属于浏览器内部实现的属性，所以不管基于什么原因也不该如此写。所以很遗憾的说，以上行为其实在backbone里面并不存在，__super__，其实也就是一个__proto__的替代性的引用。</p>
<p>扯淡了那么多，言归正传，这里说说extend干了什么：</p>
<p>三句话说：</p>
<ol>
<li>设置自身的构造函数</li>
<li>设置自身的原型，并把原型的constructor指向自身以作为构造器使用</li>
<li>添加一个__super__，用来保持对Model、Collection等这些超类原型的引用。以此为基础可以访问到这些超类的构造器和原型。防止设置了自身的属性后覆盖超类的方法要用时候获取不到.类似es6的super，仅此而已…</li>
</ol>
<p>一句话说：</p>
<ol>
<li>返回一个继承了指定类函数原型和构造器属性并带有一个指向指定类的原型引用的构造函数。</li>
</ol>
<p>这样，当需要时候，设置好构造器的构造函数，直接像上面代码一样，new一下就ok了。</p>
<h2 id="addUnderscoreMethods"><a href="#addUnderscoreMethods" class="headerlink" title="addUnderscoreMethods"></a>addUnderscoreMethods</h2><p>addUnderscoreMethods也是一个可以和extend具有同等地位的函数：<br>不管是Model还是Collection还是View，通通都用到了这个方法。不同的是extend主要用于暴露给用户使用，而addUnderscoreMethods是用于在内部构建原型使用。<br>相对于extend来说，addUnderscoreMethods要复杂许多。这里看源码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 addMethod方法 添加方法到Class原型上 attribute可能是&quot;attributes&quot;也可能是&quot;models&quot;</span></span><br><span class="line"><span class="keyword">var</span> addUnderscoreMethods = <span class="function"><span class="keyword">function</span>(<span class="params">Class, methods, attribute</span>) </span>&#123;</span><br><span class="line">  _.each(methods, <span class="function"><span class="keyword">function</span>(<span class="params">length, method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_[method]) Class.prototype[method] = addMethod(length, method, attribute);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里来简单解析一下：_.each方法用来遍历方法数组执行回调。在回调内部，执行这样的逻辑：</p>
<blockquote>
<p>如果method这个方法在Underscore下有同名的方法，那么为第一个参数的的原型下添加一个同名方法。这个方法的定义调用addMethod来生成。<br>追溯一下addMethod：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Proxy Backbone class methods to Underscore functions, wrapping the model&#x27;s</span></span><br><span class="line"><span class="comment">// 将Backbone类方法代理到Underscore的函数上，包装model的attributes或者</span></span><br><span class="line"><span class="comment">// `attributes` object or collection&#x27;s `models` array behind the scenes.</span></span><br><span class="line"><span class="comment">// attributes对象或者collection的models数组到该场景后</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// collection.filter(function(model) &#123; return model.get(&#x27;age&#x27;) &gt; 10 &#125;);</span></span><br><span class="line"><span class="comment">// collection.each(this.addView);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// `Function#apply` can be slow so we use the method&#x27;s arg count, if we know it.</span></span><br><span class="line"><span class="comment">// `Function#apply`会变慢，所以我们使用方法的参数数量来判定执行方案</span></span><br><span class="line"><span class="keyword">var</span> addMethod = <span class="function"><span class="keyword">function</span>(<span class="params">length, method, attribute</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (length) &#123;</span><br><span class="line">    <span class="comment">// 1个参数:返回函数-&gt;使用method方法处理window的attribute</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _[method](<span class="built_in">this</span>[attribute]);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 2个参数:返回函数,同上,只是可以多接受一个参数</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _[method](<span class="built_in">this</span>[attribute], value);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 3个参数:返回函数,同上,多接受两个参数:过滤条件和上下文</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">iteratee, context</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _[method](<span class="built_in">this</span>[attribute], cb(iteratee, <span class="built_in">this</span>), context);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 4个参数:返回函数,同上,多接受三个参数,过滤条件、默认值和上下文</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">iteratee, defaultVal, context</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _[method](<span class="built_in">this</span>[attribute], cb(iteratee, <span class="built_in">this</span>), defaultVal, context);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 默认不为以上值时候(0个)，返回一个函数:将this的attribute数组中顶部元素压入，返回 _[method].apply(_, args)</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">      args.unshift(<span class="built_in">this</span>[attribute]);</span><br><span class="line">      <span class="keyword">return</span> _[method].apply(_, args);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>addMethod的是个非常公用的方法，基本上是为添加underscore到MVC上而存在。这个函数存在的意义主要是为了优化apply性能而生，它转为参数数量进行了分支处理。<br>当参数数量不同时候，进行了类似重载的功能。需要注意的是：这里this，刚开始初始化Backbone时候this指向了Window，再之后this指向Model、View和Collection。这个如果太抽象的话，那么来个有点实际的情况：当length=1，而attribute为”models”,这时候addMethod实际上就是使用undercore的method方法来处理models指向的数组。<br>当然，这是最简单的情况，实际上，当lenght为3和4时候，这时候就有个cb函数要处理，我们继续追溯：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Support `collection.sortBy(&#x27;attr&#x27;)` and `collection.findWhere(&#123;id: 1&#125;)`.</span></span><br><span class="line"><span class="comment">// 支持`collection.sortBy(&#x27;attr&#x27;)` 和 `collection.findWhere(&#123;id: 1&#125;)`</span></span><br><span class="line"><span class="comment">// 函数作用：过滤多余对象属性&amp;根据属性查找数组中对象</span></span><br><span class="line"><span class="keyword">var</span> cb = <span class="function"><span class="keyword">function</span>(<span class="params">iteratee, instance</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//如果iteratee是函数，直接把函数原样返回</span></span><br><span class="line">  <span class="keyword">if</span> (_.isFunction(iteratee)) <span class="keyword">return</span> iteratee;</span><br><span class="line">  <span class="comment">//如果iteratee是Oject同时也是Model，返回modelMatcher过滤的对象</span></span><br><span class="line">  <span class="keyword">if</span> (_.isObject(iteratee) &amp;&amp; !instance._isModel(iteratee)) <span class="keyword">return</span> modelMatcher(iteratee);</span><br><span class="line">  <span class="comment">//如果iteratee是字符串，返回model.get(iteratee)</span></span><br><span class="line">  <span class="keyword">if</span> (_.isString(iteratee)) <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">model</span>) </span>&#123; <span class="keyword">return</span> model.get(iteratee); &#125;;</span><br><span class="line">  <span class="keyword">return</span> iteratee;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 模型匹配函数，使用_的matches来生成闭包，过滤model中指定的属性</span></span><br><span class="line"><span class="keyword">var</span> modelMatcher = <span class="function"><span class="keyword">function</span>(<span class="params">attrs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> matcher = _.matches(attrs);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">model</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> matcher(model.attributes);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>cb本身还依赖了modelMatcher，这里顺便一起贴出来，具体实现已经有了，简单说下它的作用:用来过滤多余属性，比如有个对象A:{a:1,b:1},使用modelMatcher(“a”)后会返回{a:1},b被过滤掉了。<br>简单整理下cb逻辑:</p>
<ol>
<li>如果是函数，直接返回函数</li>
<li>如果是对象且是Model封装。那么返回过滤属性后的Model</li>
<li>如果是字符串，那么使用model的get方法获取指定属性然后返回。</li>
</ol>
<p>简而言之，这个cb，就是个属性过滤函数。用来过滤多余的属性。</p>
<h3 id="来个小总结"><a href="#来个小总结" class="headerlink" title="来个小总结"></a>来个小总结</h3><p>addUnderscoreMethods方法的总体作用其实如他的名字一样好理解。这里顺了一遍逻辑发现确实如此，如果非要说这个代码细节阅读一次之后的收获，那么应该是从这个对参数处理分支的角度可以发现，不同的underscore方法传参时候参数是存在规律的。这里顺便归纳一下：</p>
<ol>
<li>1个参数的:一个参数的接受的数据类型不确定，但是共同点是都是逻辑运行需要的数据</li>
<li>2个参数的:如_.pluck(list, propertyName) </li>
<li>3个参数的:参考_.sortBy(list, iteratee, [context]) </li>
<li>4个参数的:参考:_.reduce(list, iteratee, [memo], [context]) </li>
</ol>
<p>这里需要注意的是！<br>backbone根据自身逻辑来进行了部分设计，所以backbone在对underscore分配length长度时候有时候并没有完全根据underscore实际接受数据来，比如reduce实际上接受4个参数，但是分派的lenght却是0，这样可以直接apply来引用。除了如此，实际上方法参数长度===2的，也并不存在。</p>
<blockquote>
<p>实际设计过程中存在的有3种：0，1和3.</p>
</blockquote>
<h2 id="eventsApi"><a href="#eventsApi" class="headerlink" title="eventsApi"></a>eventsApi</h2><p>如果说上面2个方法是各个大模块都会用到，那么eventsApi这个应用范围就会变少很多，它只是在Event这个上面用到，应用范围变小很多，但是它本身是设计精巧，高度复用，应该是AOP的完美实例。</p>
<blockquote>
<p>PS:AOP:AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来,这些 跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后, 再通过“动态织入”的方式掺入业务逻辑模块中。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Iterates over the standard `event, callback` (as well as the fancy multiple</span></span><br><span class="line"><span class="comment">// 迭代 兼容标准的`event, callback` 同时支持空格分隔多事件`&quot;change blur&quot;, callback`</span></span><br><span class="line"><span class="comment">// space-separated events `&quot;change blur&quot;, callback` and jQuery-style event</span></span><br><span class="line"><span class="comment">// 以及jquery的对象式的&#123;event: callback&#125;映射</span></span><br><span class="line"><span class="comment">// maps `&#123;event: callback&#125;`).</span></span><br><span class="line"><span class="comment">// eventsApi实质上是利用iteratee来实现操作events对象并返回，eventsApi</span></span><br><span class="line"><span class="comment">// 实际上只是处理了不同参数类型的问题，这里iteratee是onApi或者offApi</span></span><br><span class="line"><span class="keyword">var</span> eventsApi = <span class="function"><span class="keyword">function</span>(<span class="params">iteratee, events, name, callback, opts</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>, names;</span><br><span class="line">  <span class="keyword">if</span> (name &amp;&amp; <span class="keyword">typeof</span> name === <span class="string">&#x27;object&#x27;</span>) &#123;<span class="comment">//jQuery-style event map</span></span><br><span class="line">    <span class="comment">// Handle event maps.</span></span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="keyword">void</span> <span class="number">0</span> &amp;&amp; <span class="string">&#x27;context&#x27;</span> <span class="keyword">in</span> opts &amp;&amp; opts.context === <span class="keyword">void</span> <span class="number">0</span>) opts.context = callback;</span><br><span class="line">    <span class="comment">//_.keys获取对象的键名，返回一个包含键名的数组</span></span><br><span class="line">    <span class="keyword">for</span> (names = _.keys(name); i &lt; names.length ; i++) &#123;</span><br><span class="line">      <span class="comment">//将对象转换为单个字符串式，然后循环调用自身</span></span><br><span class="line">      events = eventsApi(iteratee, events, names[i], name[names[i]], opts);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name &amp;&amp; eventSplitter.test(name)) &#123;</span><br><span class="line">    <span class="comment">// Handle space-separated event names by delegating them individually.</span></span><br><span class="line">    <span class="comment">//判断name存在并由空格分隔</span></span><br><span class="line">    <span class="comment">//切割成数组循环传入函数自身进入下一分支环节</span></span><br><span class="line">    <span class="keyword">for</span> (names = name.split(eventSplitter); i &lt; names.length; i++) &#123;</span><br><span class="line">      events = iteratee(events, names[i], callback, opts);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Finally, standard events.</span></span><br><span class="line">    events = iteratee(events, name, callback, opts);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> events;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  这段代码有三个分支，一共接受3种类型的值已完善使用体验，它接受 <b>对象</b>、<b>空格分隔的字符串如”click change”</b>和 <b>字符串</b>三种。实际上真正处理业务逻辑的只有第三种逻辑，逻辑是这样的：</p>
<ol>
<li>如果是对象，将对象的键名全部取出来组成数组作为参数传入自身(步骤1)，将数组遍历作为参数传入自身进入分支3(步骤2)</li>
<li>如果是空格分隔的字符串，那么split变成数组，执行步骤2</li>
<li>如果是字符串，直接进入分支3</li>
</ol>
<p>eventsApi作为AOP编程方法的实践，它处理的是公共的逻辑。</p>
<p>而eventsApi除了使用了AOP的的思想很值得称赞外，它还在自身内部实现了递归，这种递归在AOP的情景下发挥了很重要的作用:</p>
<p>几乎所有最重要的逻辑都交由分支3处理，这样保持了传入参数的一致性，只需要维护分支3的参数传递即可，其他的分支只需要对参数类型进行转换然后递归调用自身进入分支3即可，防止了3个分支各自维护自己的参数顺序造成可能的混乱。</p>
<p>而且相对来说，降低了源码阅读的难度，这里我们看看eventsApi有哪些iteratee传入：onApi、offApi、onceMap、triggerApi。函数很明晰了，这些iteratee涵盖了绑定、解绑、一次性绑定和事件触发4个方案的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The reducing API that adds a callback to the `events` object.</span></span><br><span class="line"><span class="comment">// 增加了一个回调到`events`对象。</span></span><br><span class="line"><span class="comment">// 这个函数用来处理events对象，为events内部指定监听的事件对应的数组添加一个回调函数，同时将options的linstening数量+1</span></span><br><span class="line"><span class="comment">// 返回一个events对象(实际上已经实质性操作了，返回是为了方便操作)</span></span><br><span class="line"><span class="keyword">var</span> onApi = <span class="function"><span class="keyword">function</span>(<span class="params">events, name, callback, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    <span class="keyword">var</span> handlers = events[name] || (events[name] = []);</span><br><span class="line">    <span class="keyword">var</span> context = options.context, ctx = options.ctx, listening = options.listening;</span><br><span class="line">    <span class="keyword">if</span> (listening) listening.count++;</span><br><span class="line"></span><br><span class="line">    handlers.push(&#123;<span class="attr">callback</span>: callback, <span class="attr">context</span>: context, <span class="attr">ctx</span>: context || ctx, <span class="attr">listening</span>: listening&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> events;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>贴一下onApi的源码，这个事件绑定的内部细节可以实证一下第一篇的想法，使用Pub/Sub即订阅发布模式来处理事件。同时也排除了可能使用Dom方式如AddEventListener来绑定事件的猜测。<br>backbone Event内部完全使用了Pub/Sub模式，这样的操作的最大好处是：DOM无关，那么与DOM相关的兼容性在backbone Event这个模块内部也就不再存在。当然还有一个好处是容易维护和扩展。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇暂时就写这三个辅助函数或者也能叫做公用方法了。Backbone内部大面积使用了这些，如果不对其做深入的研究，那么下一步也相当困难也无法继续深入。本文对其进行了相对深入的了解和探索。到此也就告落一段。从下一篇就要开始整理Model、Event、View和Collection了。</p>
<p>先收工！</p>
]]></content>
  </entry>
  <entry>
    <title>backbone初探(一)-猜想和API</title>
    <url>/2016/04/05/backbone-1/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前几天在前端群里面闲聊时候，有好多年的老同行感叹说，08年出来的那帮人那时候很少用框架，jQuery在那时候还没有多少人用，不像现在有N多框架可以选，现在的新人着实幸福。我回答说，08年其实也是幸福的时代，可以专心研究javascript基础，而不像现在这样，被漫天的框架潮流拖着走。群友总结说，跟着时代的走的好处是，后来者，要重走一次历史线路，是一件很艰难的事情。 </p>
<p>那么，此刻，刻意来学backbone和其中思想，便应当是后来人对历史的其中一次回首，目标真的是进一步提升对MVC的理解.</p>
<p>《论前端工程师的修养》里面说，前端的价值，20%是知识，这里包含诸多框架经验，80%则是能力，这能力包括编程能力、架构能力和工程能力。想想觉得总结得真的很好。</p>
<p>不在乎前进的路难，而在乎浮云遮眼不知何将往。</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>文章写之前，我必须声明一次，这不是一番深思熟虑改之又改的文章，而仅仅是一个学习笔记，我想将backbone整理过程中，一路的想法细细展示出来。聊做以后再回首的记忆。</p>
<p>大抵最美好的青春岁月，都给编程了，留个印记也好。。。</p>
<h1 id="预计的学习线路"><a href="#预计的学习线路" class="headerlink" title="预计的学习线路"></a>预计的学习线路</h1><p>目标是先浏览一次API，然后熟悉API，做一些小项目，然后开始根据API来对源码进行原理猜测，最后进行源码架构整理阅读进行印证。<br>简单说的话，就是一句，看api，实践一下，然后猜测实现细节，然后看源码。</p>
<h1 id="API熟悉环节"><a href="#API熟悉环节" class="headerlink" title="API熟悉环节"></a>API熟悉环节</h1><p>先找个<a href="http://123.56.156.13/api/backbone/">中文的API</a>看，这样进度会快点。文档是1.12的翻译，我认为不是太落后当前其实也够学习用了。</p>
<p>先整理一下Backbone的API大类，以一直以来源码阅读经验来看，从宏观向微观读，理解架构再理解细节才是唯一的了解和阅读源码的路径：</p>
<ul>
<li>Backbone.Events</li>
<li>Backbone.Model</li>
<li>Backbone.Collection</li>
<li>Backbone.Router</li>
<li>Backbone.history</li>
<li>Backbone.sync</li>
<li>Backbone.View</li>
<li>Utility<ul>
<li>Backbone.noConflict</li>
<li>Backbone.$</li>
</ul>
</li>
</ul>
<p>简单的看了下这几部分的构成，从命名来看，很显然里面有事件、模型、集合，路由、历史、同步、视图、辅助工具这几个大类的东西，其他细节应该都是依附在这几个对象下作为方法使用。</p>
<p>这里猜测一下可能的库的延伸发展路径：</p>
<ol>
<li>Backbone作为以MVC(Model-View-Collection)主导的思想的框架，最主要的，那么也只可能是MVC三个角色了，Model-View-Collection这三个对象，应当就是BackBone编写开始最先写下三个的词汇。</li>
<li>现代网页程序对交互的处理必须依托事件来触发，所以需要一个Events来对时间进行统筹处理，API的说明是，一些事件对Model也有作用，那么这里面应该有一个订阅-发布模式的处理方案。</li>
<li>Router是路由处理，这个应当是考虑到当前页面复杂的结构设计，所以产生的一个模块，对路由统筹处理，以达到归并路由逻辑，防止到处横生节蔓的方案。</li>
<li>history这个应当是html5的hashchange事件的封装，依托hashchange事件，来处理单页面路由刷新页面后导致状态丢失和无法前进后退的处理方案。</li>
<li>sync这个模块应当是所有前端数据同后端服务器进行ajax交互的统一封装。</li>
<li>关于Model和Collection的关系，猜测应当是：Model(对象数据，也可能被封装)既是Collection(数组数据，也可能被封装)中的一个个对象，也是内部每个对象的整体数据结构骨架,所有Model都保持统一的结构，以便实现ORM。</li>
<li>Utility这个貌似不用说了，大家都知道。</li>
</ol>
<h1 id="API细节整理"><a href="#API细节整理" class="headerlink" title="API细节整理"></a>API细节整理</h1><p>这里简单整理一下，不过也可能变成一份简略版本的API…<br>不过这里一切整理从简</p>
<h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><h3 id="Event的方法和简单整理"><a href="#Event的方法和简单整理" class="headerlink" title="Event的方法和简单整理"></a>Event的方法和简单整理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Events</span><br><span class="line">  on            语法:object.on(event, callback, [context])</span><br><span class="line">  off           语法:object.off([event], [callback], [context])</span><br><span class="line">  trigger       语法:object.trigger(event, [*args]) </span><br><span class="line">  once          语法:object.once(event, callback, [context]) </span><br><span class="line">  listenTo      语法:object.listenTo(other, event, callback) </span><br><span class="line">  stopListening 语法:object.stopListening([other], [event], [callback]) </span><br><span class="line">  listenToOnce  语法:object.listenToOnce(other, event, callback) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>事件这里定义的方法不多简单整理：</p>
<ol>
<li>on对off一个绑定一个解绑，listenTo对stopListening一个订阅一个取消订阅(猜测！)</li>
<li>once对应on，一个是触发一次，一个是一直触发</li>
<li>listenToOnce和listenTo对应类似once对应on，一个订阅一次，一个订阅N次。</li>
</ol>
<h3 id="Event定义的事件："><a href="#Event定义的事件：" class="headerlink" title="Event定义的事件："></a>Event定义的事件：</h3><ul>
<li>“add” (model, collection, options) — 当一个model（模型）被添加到一个collection（集合）时触发。</li>
<li>“remove” (model, collection, options) — 当一个model（模型）从一个collection（集合）中被删除时触发。</li>
<li>“reset” (collection, options) — 当该collection（集合）的全部内容已被替换时触发。</li>
<li>“sort” (collection, options) — 当该collection（集合）已被重新排序时触发。</li>
<li>“change” (model, options) — 当一个model（模型）的属性改变时触发。</li>
<li>“change:[attribute]” (model, value, options) — 当一个model（模型）的某个特定属性被更新时触发。</li>
<li>“destroy” (model, collection, options) —当一个model（模型）被destroyed（销毁）时触发。</li>
<li>“request” (model_or_collection, xhr, options) — 当一个model（模型）或collection（集合）开始发送请求到服务器时触发。</li>
<li>“sync” (model_or_collection, resp, options) — 当一个model（模型）或collection（集合）成功同步到服务器时触发。</li>
<li>“error” (model_or_collection, resp, options) — 当一个model（模型）或collection（集合）的请求远程服务器失败时触发。</li>
<li>“invalid” (model, error, options) — 当model（模型）在客户端 validation（验证）失败时触发。</li>
<li>“route:[name]” (params) —  当一个特定route（路由）相匹配时通过路由器触发。</li>
<li>“route” (route, params) — 当任何一个route（路由）相匹配时通过路由器触发。</li>
<li>“route” (router, route, params) — 当任何一个route（路由）相匹配时通过history（历史记录）触发。</li>
<li>“all” — 所有事件发生都能触发这个特别的事件，第一个参数是触发事件的名称。</li>
</ul>
<h2 id="Model-模型和单个数据操作"><a href="#Model-模型和单个数据操作" class="headerlink" title="Model 模型和单个数据操作"></a>Model 模型和单个数据操作</h2><p>写到这里，不禁仰天长叹：Model的方法真的很多啊啊啊啊…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Model</span><br><span class="line">  extend 语法：Backbone.Model.extend(properties, [classProperties])用途不说了，应该同jquery的extend</span><br><span class="line">  constructor&#x2F;initialize 语法：new Model([attributes], [options]) ，用来创建初始属性</span><br><span class="line">  get 语法:model.get(attribute),获取属性值</span><br><span class="line">  set 语法:model.set(attributes, [options])  设置属性值</span><br><span class="line">  escape 语法:model.escape(attribute)，转义版get</span><br><span class="line">  has 语法:model.has(attribute), 属性值为非 null 或非 undefined 时返回 true。</span><br><span class="line">  unset 语法: model.unset(attribute, [options]) 从内部属性散列表中删除指定属性(attribute)。</span><br><span class="line">  clear 语法: model.clear([options]) 从model中删除所有属性， 包括id属性。</span><br><span class="line">  id 语法: model.id id是model的特殊属性，可以是任意字符串</span><br><span class="line">  idAttribute 语法: model.idAttribute 一个model的唯一标示符，被储存在 id 属性下</span><br><span class="line">  cid 语法: model.cid model的特殊属性，cid 或客户 id 是当所有model创建时自动产生的唯一标识符。</span><br><span class="line">  attributes 语法: model.attributes attributes 属性是包含模型状态的内部散列表</span><br><span class="line">  changed 语法: model.changed changed属性是一个包含所有属性的内部散列，自最后 set 已改变。</span><br><span class="line">  defaults 语法: model.defaults or 语法: model.defaults() defaults 散列（或函数）用于为模型指定默认属性。</span><br><span class="line">  toJSON 语法: model.toJSON([options]) 返回一个模型的 attributes 浅拷贝副本的 JSON 字符串化形式。</span><br><span class="line">  sync 语法: model.sync(method, model, [options]) 使用 Backbone.sync 可以将一个模型的状态持续发送到服务器。 </span><br><span class="line">  fetch 语法: model.fetch([options]) 通过委托给Backbone.sync从服务器重置模型的状态。</span><br><span class="line">  save 语法: model.save([attributes], [options]) 通过委托给Backbone.sync，保存模型到数据库</span><br><span class="line">  destroy 语法: model.destroy([options]) 通过委托给Backbone.sync，保存模型到数据库</span><br><span class="line">  validate 语法: model.validate(attributes, options) 自定义验证逻辑</span><br><span class="line">  validationError 语法: model.validationError 用validate最后验证失败时返回的值。</span><br><span class="line">  isValid 语法: model.isValid() 运行validate来检查模型状态。</span><br><span class="line">  url 语法: model.url() 返回模型资源在服务器上位置的相对 URL </span><br><span class="line">  urlRoot 语法: model.urlRoot or 语法: model.urlRoot() 设置生成基于模型 id 的 URLs 的默认 url 函数</span><br><span class="line">  parse 语法: model.parse(response, options) parse 会在通过 fetch 从服务器返回模型数据，以及 save 时执行</span><br><span class="line">  clone 语法: model.clone() 返回该模型的具有相同属性的新实例。</span><br><span class="line">  isNew 语法: model.isNew() 模型是否已经保存到服务器。</span><br><span class="line">  hasChanged 语法: model.hasChanged([attribute]) 标识模型从上次 set 事件发生后是否改变过。</span><br><span class="line">  changedAttributes 语法: model.changedAttributes([attributes]) 只从最后一次set开始检索已改变的模型属性散列</span><br><span class="line">  previous 语法: model.previous(attribute) 在 &quot;change&quot; 事件发生的过程中，本方法可被用于获取已改变属性的旧值</span><br><span class="line">  previousAttributes 语法: model.previousAttributes() 返回模型的上一个属性的副本。</span><br></pre></td></tr></table></figure>

<p>姑且开始尝试分类一下：</p>
<ol>
<li>数据持久化:sync，save，fetch，destroy</li>
<li>数据读写相关:get，set，escape，unset，clear，toJSON，validate，validationError，isValid，parse,clone</li>
<li>Model属性相关:id，cid，attributes，changed，defaults，url，urlRoot，isNew，changedAttributes，previous，previousAttributes</li>
</ol>
<p>大概猜测下这些玩意儿的用途和场景：</p>
<ol>
<li>数据持久化:</li>
</ol>
<ul>
<li>sync 数据双向同步</li>
<li>save 本地数据同步到服务器</li>
<li>fetch 获取服务器数据</li>
<li>destroy 销毁指定数据</li>
</ul>
<ol start="2">
<li>数据读写相关:</li>
</ol>
<ul>
<li>get 获取数据</li>
<li>set 设置数据</li>
<li>escape 转义get的值</li>
<li>unset 删除单个属性</li>
<li>clear 清除整个单个条目</li>
<li>toJSON 数据转换为json</li>
<li>validate 验证</li>
<li>validationError</li>
<li>isValid 判断验证通过否</li>
<li>parse 序列化json数据</li>
<li>clone 深拷贝数据</li>
</ul>
<ol start="3">
<li>Model属性相关:这个猜不到先放放</li>
</ol>
<h2 id="Collection-集合操作"><a href="#Collection-集合操作" class="headerlink" title="Collection 集合操作"></a>Collection 集合操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collection</span><br><span class="line">  extend     语法Backbone.Collection.extend(properties, [classProperties]) </span><br><span class="line">  model      语法:collection.model </span><br><span class="line">  constructor &#x2F; initialize</span><br><span class="line">  models     语法:collection.models </span><br><span class="line">  toJSON     语法:collection.toJSON([options]) </span><br><span class="line">  sync       语法:collection.sync(method, 语法:collection, [options]) </span><br><span class="line">  add        语法:collection.add(models, [options]) </span><br><span class="line">  remove     语法:collection.remove(models, [options]) </span><br><span class="line">  reset      语法:collection.reset([models], [options]) </span><br><span class="line">  set        语法:collection.set(models, [options]) </span><br><span class="line">  get        语法:collection.get(id) </span><br><span class="line">  at         语法:collection.at(index) </span><br><span class="line">  push       语法:collection.push(model, [options]) </span><br><span class="line">  pop        语法:collection.pop([options]) </span><br><span class="line">  unshift    语法:collection.unshift(model, [options]) </span><br><span class="line">  shift      语法:collection.shift([options]) </span><br><span class="line">  slice      语法:collection.slice(begin, end) </span><br><span class="line">  length     语法:collection.length </span><br><span class="line">  comparator 语法:collection.comparator </span><br><span class="line">  sort       语法:collection.sort([options]) </span><br><span class="line">  pluck      语法:collection.pluck(attribute) </span><br><span class="line">  where      语法:collection.where(attributes) </span><br><span class="line">  findWhere  语法:collection.findWhere(attributes) </span><br><span class="line">  url        语法:collection.url or 语法:collection.url() </span><br><span class="line">  parse      语法:collection.parse(response, options) </span><br><span class="line">  clone      语法:collection.clone() </span><br><span class="line">  fetch      语法:collection.fetch([options]) </span><br><span class="line">  create     语法:collection.create(attributes, [options]) </span><br></pre></td></tr></table></figure>

<p>尝试分类一下：</p>
<ol>
<li>持久化 sync,fetch</li>
<li>Collection对象读写相关：extend，model,models,remove,reset,get,set,findWhere,create,toJSON</li>
<li>集合(数组)操作：push,pop,unshift,shift,slice,sort,comparator,pluck,at</li>
</ol>
<p>貌似差不多了,API里面方法最多了都整理完了，送了一口气，我继续整理。。。</p>
<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router</span><br><span class="line">  extend                   语法:Backbone.Router.extend(properties, [classProperties]) </span><br><span class="line">  routes                   语法:router.routes </span><br><span class="line">  constructor &#x2F; initialize 语法:new Router([options]) </span><br><span class="line">  route                    语法:router.route(route, name, [callback]) </span><br><span class="line">  navigate                 语法:outer.navigate(fragment, [options]) </span><br><span class="line">  execute                  语法:executerouter.execute(callback, args) </span><br></pre></td></tr></table></figure>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">history</span><br><span class="line">  start 语法:Backbone.history.start([options]) 启动hashchange事件监控</span><br></pre></td></tr></table></figure>

<h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sync</span><br><span class="line">  Backbone.sync 语法:sync(method, model, [options])</span><br><span class="line">	- method – CRUD 方法 (&quot;create&quot;, &quot;read&quot;, &quot;update&quot;, or &quot;delete&quot;)</span><br><span class="line">	- model – 要被保存的模型（或要被读取的集合）</span><br><span class="line">	- options – 成功和失败的回调函数，以及所有 jQuery 请求支持的选项</span><br><span class="line">  Backbone.ajax 语法:Backbone.ajax &#x3D; function(request) &#123; ... &#125;; </span><br><span class="line">  Backbone.emulateHTTP 语法:属性值 设置为true可以用POST模拟put等http方法</span><br><span class="line">  Backbone.emulateJSON 语法:属性值 设置为true序列化JSON为formData</span><br></pre></td></tr></table></figure>

<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">View</span><br><span class="line">  extend 语法:Backbone.View.extend(properties, [classProperties]) 开始创建自定义的视图类。</span><br><span class="line">  constructor &#x2F; initialize</span><br><span class="line">  el 语法：属性值，设置view的元素</span><br><span class="line">  $el 语法: 属性值，一个视图元素的缓存jQuery对象。</span><br><span class="line">  setElement 语法：view.setElement(element) 如果你想应用一个Backbone视图到不同的DOM元素</span><br><span class="line">  attributes 语法:属性 接受对象 或者返回对象的函数 属性的键值对,将被设置为视图el上的HTML DOM元素的属性</span><br><span class="line">  $ (jQuery)</span><br><span class="line">  template 语法:view.template([data]) </span><br><span class="line">  render 语法：view.render()   重载本函数可以实现从模型数据渲染视图模板</span><br><span class="line">  remove 语法：view.remove() 从 DOM 中移除一个视图，并解绑所有事件</span><br><span class="line">  delegateEvents 语法：delegateEvents([events])  事件委托 很多时候不需要手动运行</span><br><span class="line">  undelegateEvents 语法:undelegateEvents() 上例的相反的操作</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>来一个Demo上的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var DocumentView &#x3D; Backbone.View.extend(&#123;</span><br><span class="line">  events: &#123;</span><br><span class="line">    &quot;dblclick&quot;                : &quot;open&quot;,</span><br><span class="line">    &quot;click .icon.doc&quot;         : &quot;select&quot;,</span><br><span class="line">    &quot;contextmenu .icon.doc&quot;   : &quot;showMenu&quot;,</span><br><span class="line">    &quot;click .show_notes&quot;       : &quot;toggleNotes&quot;,</span><br><span class="line">    &quot;click .title .lock&quot;      : &quot;editAccessLevel&quot;,</span><br><span class="line">    &quot;mouseover .title .date&quot;  : &quot;showTooltip&quot;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: function() &#123;</span><br><span class="line">    this.$el.html(this.template(this.model.attributes));</span><br><span class="line">    return this;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  open: function() &#123;</span><br><span class="line">    window.open(this.model.get(&quot;viewer_url&quot;));</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  select: function() &#123;</span><br><span class="line">    this.model.set(&#123;selected: true&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>集合例子来看，View的操作远比想象的要简单：</p>
<ol>
<li>设定模板</li>
<li>渲染模板到指定el</li>
<li>设定委托事件</li>
</ol>
<p>就这么三步了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大致结构我猜测就是这样了，先来个简单的总结：<br>上图：<br><img src="/images/Backbone.png" alt="backbone"></p>
]]></content>
  </entry>
  <entry>
    <title>HTTP笔记(一)</title>
    <url>/2016/04/02/http-1/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>开始学习HTTP了，清明望乡不能回，其实也是好惆怅。言归正传吧，之前对HTTP有过一些学习，主要是HTTP状态码和缓存这块的需要，这次试试深入学习一下，如果只是这样浅浅了解难免一叶障目，所以这次翻出《图解HTTP》，深入学一学，聊做笔记了。</p>
<h1 id="HTTP相关基础"><a href="#HTTP相关基础" class="headerlink" title="HTTP相关基础"></a>HTTP相关基础</h1><blockquote>
<p>“网络基础 TCP/IP”</p>
</blockquote>
<p>HTTP是TCP/IP的一个子集，它是TCP/IP四级分层顶部应用层协议，与HTTP类似的位于应用层的协议还有FTP&amp;NDNS等等。</p>
<p>TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。</p>
<h2 id="TCP-IP-协议族分层"><a href="#TCP-IP-协议族分层" class="headerlink" title="TCP/IP 协议族分层"></a>TCP/IP 协议族分层</h2><ul>
<li>应用层</li>
</ul>
<p>应用层决定了向用户提供应用服务时通信的活动。</p>
<p>TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。</p>
<p>HTTP 协议也处于该层。</p>
<ul>
<li>传输层</li>
</ul>
<p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。</p>
<p>在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。</p>
<ul>
<li>网络层（又名网络互连层）</li>
</ul>
<p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</p>
<p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p>
<ul>
<li>链路层（又名数据链路层，网络接口层）</li>
</ul>
<p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</p>
<p>两台计算机交互时候各层之间数据流动：<br><img src="/images/http-1.png?imageView/2/w/500/q/100" alt="http1"></p>
<p>一次HTTP沟通背后的数据封装：<br><img src="/images/http-2.png?imageView/2/w/500/q/100" alt="http2"></p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。<br>这种把数据信息包装起来的做法称为封装（encapsulate)</p>
<p>PS：以上摘自《图解HTTP》</p>
<h2 id="HTTP和TCP-IP-DNS不得不说的故事"><a href="#HTTP和TCP-IP-DNS不得不说的故事" class="headerlink" title="HTTP和TCP,IP,DNS不得不说的故事"></a>HTTP和TCP,IP,DNS不得不说的故事</h2><p>实际上本文第一副图已经说明了HTTP和TCP,IP之间密不可分的关系了：<br>HTTP作为应用层是依赖于TCP和IP层的：</p>
<ol>
<li>TCP作为传输层负责将数据打上MAC地址发给网络层IP，开始进行三次握手准备</li>
<li>IP作为网络层负责将数据打包成报文段进行编号，发送给链路层进行传送</li>
</ol>
<h3 id="确保数据到达的TCP"><a href="#确保数据到达的TCP" class="headerlink" title="确保数据到达的TCP"></a>确保数据到达的TCP</h3><p>TCP在将数据通过IP层下发时候将会打上SYN标记，请求端接受到数据时候，完成第一次握手，返回一个标记有SYN/ACK的数据包，TCP层接受到之后，完成第二次握手，最后发送一个标记有ACK的包给请求端完成第三次握手。</p>
<p><img src="/images/http-3.png?imageView/2/w/500/q/100" alt="http2"></p>
<p>这里呢，看到这里有个问题了：<br>第一次握手失败请求端没响应会间隔一个时间后重复发送<br>第二次握手请求失败之后请求端会重复发送包完成握手<br>那么第三次握手没有反馈，如果第三次握手失败以后会发生什么呢？这样不是和TCP保证送达的说法有冲突吗？</p>
<p>然后重复看了资料，这里需要注意到：通讯的两头都是四个分层的，客户端和服务端都有对应的TCP层，按照上图的三个箭头路径可以看到：</p>
<ol>
<li>每个TCP端都有三个端点(即三次握手)</li>
<li>当服务器端发送ACK(服务器端进行第三次握手但尚未完成)而客户端尚未接受到时候，此时客户端完成第二次握手等待第三次握手</li>
<li>如果服务端的发送ACK发送后但是客户端没有请求到，那么客户端第二次握手失败了，将会继续返回一个SYN/ACK，等待ACK包，这样思路就通顺了。</li>
</ol>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP属于网络层，《图解HTTP》对IP数据的传输有些语焉不详，说了IP传输需要IP地址和MAC地址两个最重要的数据，但是如何进行传输，中转按照什么规则进行，都没有说到，这里找了其他资料补充一下。</p>
<p>IP大致可以分为三个作用模块：</p>
<ol>
<li>IP寻址</li>
<li>路由</li>
<li>分包和组包</li>
</ol>
<p>这样，大致就可以理清为什么IP可以一站一站转发了，每个转发服务都会有一个路由表，通过这个路由表来将数据转发到到下一台服务器。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS貌似没啥好说的，简单说，计算机队数据敏感，但是并不能理解单词，不能理解类似aaa.com到底代表什么，所以需要一个协议，将aaa.com这种域名转换成数字ip，使得计算机可以识别。<br>而DNS，就是负责从域名到ip的转换的协议，就这么简单，对电脑熟悉点的人都知道。</p>
<h1 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h1><p>HTTP作为一个协议，如果非要给它说个特点，我觉得，它的的特点就是它足够简单。</p>
<h1 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h1><p>这里总结下HTTP：</p>
<ol>
<li>服务器与客户端之间的通信协议</li>
<li>通过请求和响应完成通信</li>
<li>HTTP协议不保存状态，即通信时候不做持久化，发完请求就忘了发给谁，发了什么，收到了什么</li>
<li>通过URI来定位访问资源</li>
</ol>
<h1 id="HTTP方法-mehthon"><a href="#HTTP方法-mehthon" class="headerlink" title="HTTP方法(mehthon)"></a>HTTP方法(mehthon)</h1><p>HTTP的请求方法有：</p>
<ul>
<li>PUT</li>
<li>POST</li>
<li>PUT</li>
<li>HEAD</li>
<li>DELETE</li>
<li>OPTIONS</li>
<li>TRACE</li>
<li>CONNECT</li>
</ul>
<p>这里最常用的应该是GET和POST了。<br>GET用来获取资源，而POST一般是用来传输实体(最常见的是传输表格数据)</p>
]]></content>
  </entry>
  <entry>
    <title>SystemJS Multi-Page多页面实践&amp;总结</title>
    <url>/2016/03/31/systemJS/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自从webpack三番五次因为工具链太重在公司内部推不起来也看不到推起来的希望以后，从此绝了在项目中使用webpack的念头，唯一使用了webpack的项目仅剩微信端的一个单人独奏项目。</p>
<p>然后开始寻找webpack的替代品。目标是：</p>
<ul>
<li>支持UMD规范</li>
<li>有合用的打包的工具并且可以整合gulp</li>
<li>不需要工具链就可以运行起来</li>
</ul>
<p>然后，我找到了SystemJS这个新玩具，记得当时看到5K+的star，感觉好激动，写本文时候我又去看了下，5355，然后又看到自己居然没有star一下，遂star之，恩，现在是5356。</p>
<p>本文是一个记录，记录自己在项目实践中的诸多总结，总体项目背景如下：<code>传统的多页面应用，不需要兼容旧浏览器，总体页面逻辑是顶部和右侧菜单不变，点击栏目链接不刷新更新中间区域，具体的业务逻辑这里不提，不是重点</code>。</p>
<h1 id="SystemJS介绍"><a href="#SystemJS介绍" class="headerlink" title="SystemJS介绍"></a>SystemJS介绍</h1><p>写之前简单介绍下SystemJs是什么。<br>Github上的介绍是：</p>
<blockquote>
<p><em>Universal dynamic module loader</em><br>Universal dynamic module loader - loads ES6 modules, AMD, CommonJS and global scripts in the browser and NodeJS. Works with both Traceur and Babel.</p>
</blockquote>
<blockquote>
<ul>
<li>Loads any module format with exact circular reference and binding support.</li>
<li>Loads ES6 modules compiled into the System.register bundle format for production, maintaining circular references support.</li>
<li>Supports RequireJS-style map, paths, bundles and global shims.</li>
<li>Loader plugins allow loading assets through the module naming system such as CSS, JSON or images.</li>
</ul>
</blockquote>
<p>翻译一下：</p>
<blockquote>
<p><em><a href="https://github.com/umdjs/umd">UMD</a>规范加载器</em><br><em><a href="https://github.com/umdjs/umd">UMD</a>规范加载器</em> - 加载ES6、AMD、CommonJS模块和全局脚本,可以运行在浏览器和NodeJS环境，可以与Traceur和Babel一起协作。</p>
</blockquote>
<blockquote>
<ul>
<li>各种规范的模块之间的循环引用功能和绑定支持</li>
<li>ES6模块在实际生产环境编译为System.register的bundle格式，维持循环引用</li>
<li>支持RequireJS式map, paths, bundles和全局垫片技术(global shims).</li>
<li>支持通过各种模块加载CSS, JSON or images等资源</li>
</ul>
</blockquote>
<p>貌似功能都写的很具体了，但是好像不需要这么多的列表，这里简单说下自己认为的重点，那就是：</p>
<blockquote>
<p><em>各种规范的模块之间的循环引用功能</em></p>
</blockquote>
<p>是的，就一个就足够说服我自己用起来了，尤其是，它不需要工具链支持就可以运行起来！当然，到了产品发布阶段，还是需要打包才能达到性能优化目标。</p>
<h1 id="SystemJS专属包管理工具"><a href="#SystemJS专属包管理工具" class="headerlink" title="SystemJS专属包管理工具"></a>SystemJS专属包管理工具</h1><p><a href="http://jspm.io/">jspm</a>官网的介绍感觉有些抓不住重点。</p>
<p>我这里就自己实践，简单说下jspm的功能</p>
<ul>
<li>初始化SystemJS项目，下载system依赖，生成config.js等配置文件</li>
<li>安装各种npm和github上的包和组件，并自动化配置config.js的map映射，并可以设置自己的类似npm这样的源</li>
<li>打包模块</li>
</ul>
<p>这里简单说下jspm日常使用：</p>
<h2 id="安装jspm"><a href="#安装jspm" class="headerlink" title="安装jspm"></a>安装jspm</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g jspm</span><br></pre></td></tr></table></figure>

<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jspm init</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Package.json file does not exist, create it? [yes]: </span><br><span class="line">Would you like jspm to prefix the jspm package.json properties under jspm? [yes]: </span><br><span class="line">Enter server baseURL (public folder path) [.]: </span><br><span class="line">Enter jspm packages folder [.&#x2F;jspm_packages]: </span><br><span class="line">Enter config file path [.&#x2F;config.js]: </span><br><span class="line">Configuration file config.js doesn&#39;t exist, create it? [yes]:</span><br><span class="line">Enter client baseURL (public folder URL) [&#x2F;]: </span><br><span class="line">Which ES6 transpiler would you like to use, Traceur or Babel? [babel]:</span><br></pre></td></tr></table></figure>

<h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">从npm</span></span><br><span class="line">jspm install npm:jquery</span><br><span class="line"><span class="meta">#</span><span class="bash">从github</span></span><br><span class="line">jsom install github:lodash/lodash</span><br><span class="line"><span class="meta">#</span><span class="bash">设置map,这样可以直接require(<span class="string">&#x27;jq&#x27;</span>)</span></span><br><span class="line">jspm install jq=npm:jquery</span><br></pre></td></tr></table></figure>

<h2 id="构建自己的git源"><a href="#构建自己的git源" class="headerlink" title="构建自己的git源"></a>构建自己的git源</h2><p>构建自己的git源可以用来处理维护问题，新项目git clone以后直接jspm install一遍就可以直接运行。<br>这里使用<a href="https://github.com/Orbs/jspm-git">jspm-git</a>来做自己的私有registries。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line">npm install --save-dev jspm-git</span><br><span class="line"><span class="meta">#</span><span class="bash">创建</span></span><br><span class="line">jspm registry create &lt;registryName&gt; jspm-git</span><br><span class="line">jspm registry config &lt;registryName&gt;</span><br></pre></td></tr></table></figure>
<p>这样处理之后，就要输入git的位置了，建议企业项目要用自己的私有git，不要使用公有仓库<br>处理完毕以后，配置文件位置在 <code>~/.jspm/config</code>，以后可以按需更改，需要注意的重点是：</p>
<ul>
<li>私有仓库需要添加ssh key，不然包的这个安装过程是很折腾人的，具体如何添加ssh key，不在本文范围内。</li>
<li>可以设置内网的Git公开库，这样可以在安全和便捷上达到平衡。</li>
</ul>
<h1 id="SystemJS基本用法"><a href="#SystemJS基本用法" class="headerlink" title="SystemJS基本用法"></a>SystemJS基本用法</h1><h2 id="jQuery插件使用："><a href="#jQuery插件使用：" class="headerlink" title="jQuery插件使用："></a>jQuery插件使用：</h2><p>jQuery插件需要先加载jQuery,然后加载插件,如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">System.import(<span class="string">&#x27;jquery&#x27;</span>)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">jQuery</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</span><br><span class="line">            <span class="keyword">return</span> System.import(<span class="string">&quot;xdan/datetimepicker&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            $(<span class="string">&#x27;#datetimepicker&#x27;</span>).datetimepicker(&#123;</span><br><span class="line">                lang:<span class="string">&#x27;zh&#x27;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="多依赖处理："><a href="#多依赖处理：" class="headerlink" title="多依赖处理："></a>多依赖处理：</h2><p>假设a.js依赖b.js和c.js,只有两个加载完成后a.js才能正常运行:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([<span class="string">&quot;b.js&quot;</span>,<span class="string">&quot;c.js&quot;</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;        <span class="comment">//先加载b.js和c.js</span></span><br><span class="line">    <span class="keyword">return</span> System.import(x)</span><br><span class="line">&#125;)).then(<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = m[<span class="number">0</span>],c = m[<span class="number">1</span>];                          <span class="comment">//为b和c设置别名以便调用</span></span><br><span class="line">    <span class="keyword">return</span> System.import(<span class="string">&#x27;a.js&#x27;</span>)                    <span class="comment">//加载a.js</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    a();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="如何编写业务代码"><a href="#如何编写业务代码" class="headerlink" title="如何编写业务代码:"></a>如何编写业务代码:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入jQuery</span></span><br><span class="line">   System.import(<span class="string">&#x27;jquery&#x27;</span>)                             </span><br><span class="line">           .then(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">               <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = $;</span><br><span class="line">               <span class="comment">//这是业务代码</span></span><br><span class="line">               <span class="keyword">return</span> System.import(<span class="string">&quot;modules/custom/test.js&quot;</span>); </span><br><span class="line">           &#125;)</span><br><span class="line">           <span class="comment">//app是业务代码的别名</span></span><br><span class="line">           .then(<span class="function"><span class="keyword">function</span>(<span class="params">app</span>)</span>&#123;</span><br><span class="line">               app();                                          </span><br><span class="line">           &#125;)</span><br></pre></td></tr></table></figure>
<p>test.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.exports是暴露出来的对接口</span></span><br><span class="line">   <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;                                </span><br><span class="line">       $(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;just a test&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>PS：如果你并不想每次都执行一次app(),也不想使用函数式编程,那么test.js是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;just a test&quot;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>但是这里有个地方需要注意，这样的代码仅仅在js加载时候有效果，当js使用缓存时候，js将不被再次执行。<br>引用时候这样就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入jQuery</span></span><br><span class="line">      System.import(<span class="string">&#x27;jquery&#x27;</span>)                             </span><br><span class="line">              .then(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">                  <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = $;</span><br><span class="line">                  <span class="comment">//这是业务代码</span></span><br><span class="line">                  <span class="keyword">return</span> System.import(<span class="string">&quot;modules/custom/test.js&quot;</span>); </span><br><span class="line">              &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="不改代码，全局暴露"><a href="#不改代码，全局暴露" class="headerlink" title="不改代码，全局暴露"></a>不改代码，全局暴露</h2><p>类似这样的一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test.js</span><br><span class="line">    $(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;just a test&quot;</span>);</span><br><span class="line">    alert(<span class="string">&quot;test1234&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>可以这样引用:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入jQuery</span></span><br><span class="line">System.import(<span class="string">&#x27;jquery&#x27;</span>)                             </span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = $;</span><br><span class="line">        <span class="comment">//这是业务代码</span></span><br><span class="line">        <span class="keyword">return</span> System.import(<span class="string">&quot;modules/custom/test.js&quot;</span>); </span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="在JS中引用模块"><a href="#在JS中引用模块" class="headerlink" title="在JS中引用模块"></a>在JS中引用模块</h2><p>最简引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">System.import(<span class="string">&quot;modules/custom/test.js&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这就够了，但是如果你在JS中用到了jQuey,test.js还是要处理一下：</p>
<p>test.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入jQuery</span></span><br><span class="line">      <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&quot;jquery&quot;</span>);                     </span><br><span class="line">      $(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;just a test&quot;</span>);</span><br><span class="line">      alert(<span class="string">&quot;test1234&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="AMD和CMD的循环引用"><a href="#AMD和CMD的循环引用" class="headerlink" title="AMD和CMD的循环引用"></a>AMD和CMD的循环引用</h2><p>上面提到的import实际上用到的CMD规范，遇到只支持AMD,并且依赖异常复杂库(如echarts)的如何处理？<br>SystemJS可以支持AMD和CMD规范,<br>如果使用CMD规范的模块,需要使用Promise来确保引入顺序,<br>如果使用AMD规范的话,声明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>=System.amdRequire;</span><br></pre></td></tr></table></figure>

<p>然后JS中这样处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">&#x27;jquery&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;echarts&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;echarts/src/config&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;echarts/src/chart/line&#x27;</span>, <span class="comment">// 使用柱状图就加载bar模块，按需加载</span></span><br><span class="line">        <span class="string">&#x27;echarts/src/chart/bar&#x27;</span>,</span><br><span class="line">        <span class="comment">//&#x27;echarts/src/chart/pie&#x27;</span></span><br><span class="line">    ],</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">$,ec,ecConfig</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>但是这样会导致无法使用cmd模块，无法使用多类型模块循环引用。所以有需求时候使用System.amdRequire来音容AMD是最完美的，require用来加载CMD好了。</p>
<h1 id="项目基本和手脚架设计"><a href="#项目基本和手脚架设计" class="headerlink" title="项目基本和手脚架设计"></a>项目基本和手脚架设计</h1><p>基本的情况文首说过一次，这里重复一下：<br><code>传统的多页面应用，不需要兼容旧浏览器，总体页面逻辑是顶部和右侧菜单不变，点击栏目链接不刷新更新中间区域，具体的业务逻辑这里不提，不是重点</code>。</p>
<p>这里提取和补充一下要点：</p>
<ul>
<li>左侧菜单和顶部菜单做成模块公用(不使用gulp来inject是因为涉及帐号权限问题)，点击这菜单这两块不刷新</li>
<li>中间区域通过jQuery的load使用ajax来载入进去，插入到内容区域，尽量减少全刷新。</li>
<li>CSS和JS在线和开发阶段使用不同版本，开发阶段方便调试不压缩合并，在线版本需要满足以下：<ul>
<li>压缩</li>
<li>合并</li>
<li>强缓存(即为资源添加版本号或者hash值，我个人喜欢hash)</li>
</ul>
</li>
</ul>
<h2 id="文件目录基础设计"><a href="#文件目录基础设计" class="headerlink" title="文件目录基础设计"></a>文件目录基础设计</h2><p>这里简单说下文件目录基础设计：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── asset</span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── fonts</span><br><span class="line">│   ├── images</span><br><span class="line">│   └── js</span><br><span class="line">├── config.js</span><br><span class="line">├── html</span><br><span class="line">│   ├── dist</span><br><span class="line">│   │   └── login</span><br><span class="line">│   │       ├── login.html</span><br><span class="line">│   │       ├── logout.html</span><br><span class="line">│   │       └── resetPwd.html</span><br><span class="line">│   └── src</span><br><span class="line">│       └── login</span><br><span class="line">│           ├── login.html</span><br><span class="line">│           ├── logout.html</span><br><span class="line">│           └── resetPwd.html</span><br><span class="line">└── modules</span><br><span class="line">    ├── business</span><br><span class="line">    │   └── login</span><br><span class="line">    │       ├── login.js</span><br><span class="line">    │       ├── logout.js</span><br><span class="line">    │       └── resetPwd.js</span><br><span class="line">    ├── github</span><br><span class="line">    ├── npm</span><br><span class="line">    └── privateregistr</span><br></pre></td></tr></table></figure>
<p>根据约定重于配置原则，这里说下设计和约定：</p>
<ol>
<li>开发阶段使用html下src目录放置html文件，modules下business放置业务js和css代码，privateregistr这个随意命名的，用来放置公用模块，使用submodule维护。</li>
<li>发布阶段使用gulp对business下js和css进行打包，统一发布到asset/js和asset/css</li>
<li>每个html/dist下的文件夹为一个大栏目，里面每个html对应一个业务页面，每个页面的js名称结构要同modules/business下结构对应，举例来说：<ul>
<li>html/dist/login/login.html这个文件的对应的js是modules/business/login/login.js</li>
<li>每个页面只接受一个js作为业务入口，意思是如果上文login.js分解为step1.js&amp;step2.js&amp;step3.js是可以的，但是最终将只引入login.js一个，其他将require方式引用进去，不提供单独的script标签给它们。</li>
</ul>
</li>
<li>modules文件夹是jspm packages folder，里面的github和npm分别是github和npm下载的包，privateregistr则是使用jspm-git构建的私有包目标源。config.js是system.js的配置文件。</li>
</ol>
<h2 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h2><p>上面写了那么多，到底其实到底只是为了workflow服务。</p>
<p>这里简单说下这个流程下开发过程的展开：</p>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><ol>
<li>安装一个包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装一个做好模块化处理的jqueyr版本</span><br><span class="line">jspm install jquery&#x3D;github:components&#x2F;jquery</span><br></pre></td></tr></table></figure></li>
<li>进入开发环节，假设要做个搜索页面，放在search大类目录下：</li>
</ol>
<ul>
<li>新建文件：html/dist/search/search.html</li>
<li>新建文件：modules/business/search/search.js</li>
<li>开始编码环节：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//js</span><br><span class="line">...</span><br><span class="line">module.exports = function()&#123;</span><br><span class="line">	var $ = require(&quot;jquery&quot;)</span><br><span class="line">	$.get(&quot;XXXXX&quot;,&#123;</span><br><span class="line">		query:&quot;XXXX&quot;</span><br><span class="line">	&#125;,function(data)&#123;</span><br><span class="line">		//coding here</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">//html</span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!--build asset/css/search.css--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style1.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style2.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--build--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;system.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;config.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--inject:js--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--endinject--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">System.import(<span class="string">&quot;modules/business/search/search&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">app</span>)</span>&#123;</span></span><br><span class="line">	app();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="打包环节："><a href="#打包环节：" class="headerlink" title="打包环节："></a>打包环节：</h3><p>个人设计的打包环节主要是几个个主要部分组成：</p>
<ol>
<li>处理 <code>inject:js</code>这个注释标签的，这里插入打包&amp;压缩&amp;强缓存处理后的js</li>
<li>处理 <code>build</code>这个注释标签，将内部css进行合并、压缩、强缓存的css并插入</li>
<li>第3个是第1个任务的依赖，它生成配置文件，用来设置好inject这个任务哪个html需要插入哪个js(这就是为什么要做html和js文件名和层级约定)</li>
<li>第4个也是第一个任务的依赖，它将所有js文件从business，进行打包压缩后放到asset/js目录下，并保持相应的目录层级</li>
</ol>
<h3 id="发布环节"><a href="#发布环节" class="headerlink" title="发布环节"></a>发布环节</h3><p>将dist这类版本直接放到服务器即可。src这类目录为了安全还是不放上去的好</p>
<h2 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h2><p>这里为打包环节做个简单摘要，说下自己的task设计流程：</p>
<ol>
<li>生成配置json文件——gulp json,主要用到了jsonfile和filewalker</li>
<li>进行模块打包，压缩——gulp jspm，主要用到了gulp-jspm</li>
<li>进行inject操作，处理css和js——gulp inject,主要用到了gulp-inject，gulp-hash，gulp-rev，gulp-rev-replace和gulp-usermin</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>得益于前端变革般的发展，以及类似yeoman这类手脚架模板工具的普及和众多社区的贡献，优秀的手脚架貌似变得越来越多，有越来越廉价的感觉。但是这类手脚架一来往往都是基于SPA的设计，并不适合MPA来使用;二来是这类手脚架一般都是使用简单的requireJs这个加载器而非现在文章提及的可以支持UMD规范并有命令行工具支持的加载器，因此，并不能满足项目和业务快速迭代的需求，因此，有了这篇文章。</p>
<p>每一个被星星点亮手脚架其实都是无数经验积累的产物，愿大家可以在巨人的肩膀上更近一步。</p>
<p>本文只是一篇基于SystemJS工作流的总结。尚不敢妄称手脚架模板。</p>
<p>恩，文章对自己的这个流程已经有了非常丰富的记载，而gulp这个，限于篇幅，我决定单开一篇来介绍它。</p>
<div style="text-align:center;">-------------------------The End-------------------------</div>






]]></content>
  </entry>
  <entry>
    <title>Git笔记-续</title>
    <url>/2016/03/27/git-plus/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>早之前在使用Git也做过一些浅浅的笔记，但是随着后来对层次和节奏的更高追求，也对Git工作流有了更高的要求。只是简单的add和commit很难满足这项要求，实质上，缺乏了对分支功能的深入挖掘，Git其实和svn相比优势也不大，毕竟如果只是比较速度，svn在局域网下速度并不慢。</p>
<h1 id="Git简单操作-amp-简单流程"><a href="#Git简单操作-amp-简单流程" class="headerlink" title="Git简单操作&amp;简单流程"></a>Git简单操作&amp;简单流程</h1><h2 id="初始化和添加远程仓库"><a href="#初始化和添加远程仓库" class="headerlink" title="初始化和添加远程仓库"></a>初始化和添加远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">初始化</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash">添加远程仓库</span></span><br><span class="line">git remote add origin &lt;url&gt;</span><br></pre></td></tr></table></figure>
<h2 id="常用的git操作"><a href="#常用的git操作" class="headerlink" title="常用的git操作"></a>常用的git操作</h2><h3 id="添加数据到暂存区"><a href="#添加数据到暂存区" class="headerlink" title="添加数据到暂存区"></a>添加数据到暂存区</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add &lt;fileName&gt; //指定文件添加</span><br><span class="line">git add . //添加所有修改文件到暂存区</span><br></pre></td></tr></table></figure>

<h3 id="从暂存区撤回"><a href="#从暂存区撤回" class="headerlink" title="从暂存区撤回"></a>从暂存区撤回</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout &lt;fileName&gt;</span><br></pre></td></tr></table></figure>

<h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><p>提交文件分为两种</p>
<ul>
<li>提交到本地版本库<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;提交说明&quot;</span><br></pre></td></tr></table></figure></li>
<li>提交到中央仓库<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">提交本地master分支到远程仓库origin</span></span><br><span class="line">git push origin master</span><br><span class="line"><span class="meta">#</span><span class="bash">提交本地master分支到远程仓库t</span></span><br><span class="line">git push test master</span><br></pre></td></tr></table></figure>
所以提交到远程仓库的语法是： git push &lt;远程仓库&gt; &lt;本地仓库&gt;</li>
</ul>
<h3 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h3><p>所有操作中我觉得最重要的是比较操作了，这是一个，非常常用且非常重要的操作。<br>对比操作根据对比对象的不同，分为以下几种：</p>
<ol>
<li>工作目录同暂存区对比</li>
<li>工作目录同版本库对比</li>
<li>暂存区同版本库对比</li>
<li>同分支不同提交之间对比</li>
<li>不同分支之间文件对比</li>
</ol>
<ul>
<li><p>工作目录同暂存区对比</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">指定对比文件</span></span><br><span class="line">git diff &lt;fileName&gt;	</span><br><span class="line"><span class="meta">#</span><span class="bash">对比全部</span></span><br><span class="line">git diff	</span><br></pre></td></tr></table></figure></li>
<li><p>工作目录同版本库对比</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">对比工作区和最近提交版本库1.txt文件变化</span></span><br><span class="line">git diff HEAD -- 1.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">对比工作区和最近提交版本库a文件夹变化</span></span><br><span class="line">git diff HEAD -- ./a</span><br><span class="line"><span class="meta">#</span><span class="bash">对比全部变化</span></span><br><span class="line">git diff HEAD </span><br></pre></td></tr></table></figure></li>
<li><p>暂存区同版本库对比</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">对比暂存区和最近提交版本库1.txt文件变化</span></span><br><span class="line">git diff --cache HEAD -- 1.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">对比暂存区和最近提交版本库a文件夹变化</span></span><br><span class="line">git diff --cache HEAD -- ./a</span><br><span class="line"><span class="meta">#</span><span class="bash">对比全部变化</span></span><br><span class="line">git diff --cache HEAD </span><br></pre></td></tr></table></figure>
</li>
<li><p>同分支不同提交之间对比</p>
</li>
<li><p>不同分支之间文件对比</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">比较master分支和foo分支文件差异</span></span><br><span class="line">git diff master..test</span><br><span class="line"><span class="meta">#</span><span class="bash">比较master分支和<span class="built_in">test</span>分支上1.txt不同</span></span><br><span class="line">git diff master test 1.txt</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;git branch&#39; [--color[&#x3D;&lt;when&gt;] | --no-color] [-r | -a]</span><br><span class="line">	[--list] [-v [--abbrev&#x3D;&lt;length&gt; | --no-abbrev]]</span><br><span class="line">	[--column[&#x3D;&lt;options&gt;] | --no-column]</span><br><span class="line">	[(--merged | --no-merged | --contains) [&lt;commit&gt;]] [&lt;pattern&gt;...]</span><br><span class="line">&#39;git branch&#39; [--set-upstream | --track | --no-track] [-l] [-f] &lt;branchname&gt; [&lt;start-point&gt;]</span><br><span class="line">&#39;git branch&#39; (--set-upstream-to&#x3D;&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;]</span><br><span class="line">&#39;git branch&#39; --unset-upstream [&lt;branchname&gt;]</span><br><span class="line">&#39;git branch&#39; (-m | -M) [&lt;oldbranch&gt;] &lt;newbranch&gt;</span><br><span class="line">&#39;git branch&#39; (-d | -D) [-r] &lt;branchname&gt;...</span><br><span class="line">&#39;git branch&#39; --edit-description [&lt;branchname&gt;]</span><br></pre></td></tr></table></figure>

<p>查看分支，查看分支有几种方式：</p>
<ul>
<li>只看本地 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li>
<li>只看远程 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure></li>
<li>查看全部<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其他常见的的分支操作：</p>
<ul>
<li><p>添加新分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建test分支</span><br><span class="line">git branch test</span><br></pre></td></tr></table></figure></li>
<li><p>切换分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#切换到test分支</span><br><span class="line">git checkout test</span><br></pre></td></tr></table></figure></li>
<li><p>删除分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#删除test分支</span><br><span class="line">git checkout -d test</span><br></pre></td></tr></table></figure></li>
<li><p>复合操作：新建并切换过去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b foo</span><br></pre></td></tr></table></figure>
</li>
<li><p>分支映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#设置abc分支提交到远程test分支</span><br><span class="line">git branch --set-upstream abc origin&#x2F;test</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="改变历史"><a href="#改变历史" class="headerlink" title="改变历史"></a>改变历史</h3><p>最常见的改变历史情况是：当提交完一个修改之后让同事更新去看结果，然后瞬间发现有个文件没有提交<br>这种修改相对简单，使用 <code>--amend</code>命令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;这是一个有遗漏的提交&quot;</span><br><span class="line">git add -u</span><br><span class="line">git commit --amend -m &quot;修正刚才的错误&quot;</span><br></pre></td></tr></table></figure>

<p>除了这种最常见的，还有两种非常常用的改变历史：</p>
<ol>
<li>删除提交历史中的某次提交记录</li>
<li>融合过去若干次提交的变为一个</li>
</ol>
<h4 id="删除体检提交历史中的某次提交记录"><a href="#删除体检提交历史中的某次提交记录" class="headerlink" title="删除体检提交历史中的某次提交记录"></a>删除体检提交历史中的某次提交记录</h4><h5 id="第一种方式-拣选-："><a href="#第一种方式-拣选-：" class="headerlink" title="第一种方式(拣选)："></a>第一种方式(拣选)：</h5><p>做个简单例子，假如有一下提交记录：A-B-C-D,其中，A,B,C,D都指代对应提交的tag，假设我们需要改变历史，使其变成A-B-D,也就是从提交历史中删除C：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#首先，跑到B位置去,使用checkout</span><br><span class="line">git checkout B</span><br><span class="line">#使用git cherry-pick命令，这个是干嘛用的呢：help有写:</span><br><span class="line">#Apply the changes introduced by some existing commits 应用改变到已存在提交</span><br><span class="line">#此时：D为master，C为master^,B为mster^^,我们执行一次git cherry-pick即可：</span><br><span class="line">git cherry-pick master</span><br><span class="line">#这里再假设要删除B，这样操作：</span><br><span class="line">git checkout A</span><br><span class="line">git cherry-pick master^</span><br><span class="line">git chery-pick master</span><br></pre></td></tr></table></figure>
<h5 id="第二种方式-变基"><a href="#第二种方式-变基" class="headerlink" title="第二种方式(变基)"></a>第二种方式(变基)</h5><p>变基(rebase)是个相对高级的命令，执行之前需要知道发生了什么：<br>语法： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --onto &lt;newbase&gt; &lt;since&gt; &lt;till&gt;</span><br></pre></td></tr></table></figure>
<p>这里声明一下 since不含since，而till包含till(这个不说了，懂的自然会懂…)</p>
<p>执行细节：</p>
<ol>
<li>执行git checkout <till></li>
<li>产生临时文件，存放版本范围</li>
<li>git reset –hard <newbase></li>
<li>根据临时文件中版本范围，逐一提交到<newbase></li>
<li>1 如果该提交已经包含，跳过</li>
<li>2 如果文件冲突，变基暂停</li>
<li>3 冲突解决后执行git rebase –continue继续或者git rebase –skip跳过此提交</li>
<li>3 执行git rebase –abort可以终止变基并返回变基前位置</li>
</ol>
<p>因此，第二种方法更快：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --onto B C D</span><br><span class="line">#开始重置master指向 这是一个很常用的操作，需要记下来</span><br><span class="line">git checkout master</span><br><span class="line">git reset --hard master@&#123;1&#125;</span><br></pre></td></tr></table></figure>




<h4 id="融合过去若干次提交的变为一个"><a href="#融合过去若干次提交的变为一个" class="headerlink" title="融合过去若干次提交的变为一个"></a>融合过去若干次提交的变为一个</h4><p>融合也可以使用git cherry-pick,不同的是不用checkout,而使用reset来操作，reset和checkout不同的地方在于它会更改HEAD指向<br>例子：假如有一下提交记录：A-B-C-D,其中，A,B,C,D都指代对应提交的tag，我们要将BC两个融合到一起</p>
<h5 id="第一种方式-拣选-：-1"><a href="#第一种方式-拣选-：-1" class="headerlink" title="第一种方式(拣选)："></a>第一种方式(拣选)：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --soft C&#x2F;&#x2F;不对暂存和工作区做操作，仅变更HEAD，为C</span><br><span class="line"># 此时A为HEAD，而D为HEAD@&#123;1&#125;</span><br><span class="line"># 然后使用git commit -C ,这个是什么呢，看help：Take an existing commit object, and reuse the log </span><br><span class="line"># message and the authorship information (including the timestamp) when creating the commit.</span><br><span class="line"># 这里使用这个-C来使用B的提交对象，提交到C上</span><br><span class="line">git commmit -C B</span><br><span class="line"># 拣选D的变化</span><br><span class="line">git cherry-pick D</span><br><span class="line">#开始重置master指向 这是一个很常用的操作，需要记下来</span><br><span class="line">git checkout master</span><br><span class="line">git reset --hard master@&#123;1&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第二种方式-变基-："><a href="#第二种方式-变基-：" class="headerlink" title="第二种方式(变基)："></a>第二种方式(变基)：</h5><p>第二种方式实际上仅仅是省略了可能的若干git cherry-pick，实际上步骤依然是三步走：</p>
<ol>
<li>git commit -C</li>
<li>git rebase</li>
<li>重置master</li>
</ol>
<p>具体步骤不再重复了。</p>
<h1 id="git工作流-amp-git-flow"><a href="#git工作流-amp-git-flow" class="headerlink" title="git工作流&amp;git-flow"></a>git工作流&amp;git-flow</h1><p>更加详细的git-flow我就不献丑了，这里是中文翻译地址：<a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">传送门</a><br>这里仅仅介绍一下工作流程：</p>
<ol>
<li>develop作为常用分支，所有开发流程都在develop上进行操作</li>
<li><code>git flow feature start MYFEATURE</code>开始一项功能开发，<code>git flow feature finish MYFEATURE</code>结束一项功能开发</li>
<li><code>git flow release start MYFEATURE</code>创建一个发型版本，finish用法同2结束版本</li>
<li><code>git flow hotfix start VERSION [BASENAME]</code>紧急修复，跳过release</li>
</ol>
<p>这个过程中的分支变化：</p>
<ul>
<li>git flow feature start MYFEATURE</li>
</ul>
<p> –新建分支develop/MYFEATURE</p>
<ul>
<li>git flow feature finish MYFEATURE</li>
</ul>
<p> –mergedevelop/MYFEATURE到develop分支</p>
<ul>
<li>git flow release start MYFEATURE</li>
</ul>
<p> – 创建release/MYFEATURE分支<br> – 从develop当前位置记录发型版本起点</p>
<ul>
<li>git flow release finish MYFEATURE</li>
</ul>
<p> –从develop当前位置记录发型版本结尾<br> –归并到develop&amp;master分支<br> –删除release/MYFEATURE分支</p>
<ul>
<li>git flow hotfix start VERSION</li>
</ul>
<p> –创建hotfix/VERSION分支</p>
<ul>
<li>git flow hotfix finish VERSION</li>
</ul>
<p> –merge hotfix/VERSION分支到master和develop<br> –删除hotfix/VERSION</p>
<h1 id="git和svn的合奏"><a href="#git和svn的合奏" class="headerlink" title="git和svn的合奏"></a>git和svn的合奏</h1><p>不管怎么说，svn还是在更多的企业环境发挥着重要的作用，这种状况作为打工仔其实也无力去改变它。<br>但是这并不意味这不能拥抱git的魅力，因为，我们还有一个工具叫做git-svn</p>
<h2 id="安装碎碎念"><a href="#安装碎碎念" class="headerlink" title="安装碎碎念"></a>安装碎碎念</h2><p>window平台安装时候要安装两个软件，一个是git，另一个往往就是乌龟svn了,这里安装乌龟svn时候要自定义一下安装选项，将command line选起来<br>mac平台的话， <code>brew install git svn</code>搞定一切<br>ubuntu平台的话， <code>sudo apt-get install git git-svn subversion</code></p>
<h2 id="git和svn的合并使用："><a href="#git和svn的合并使用：" class="headerlink" title="git和svn的合并使用："></a>git和svn的合并使用：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#先检出svn库</span><br><span class="line">git svn clone &lt;svn-url&gt; --username&#x3D;&lt;youname&gt;</span><br><span class="line">cd repoDir</span><br><span class="line">#git-flow 初始化，一路enter</span><br><span class="line">git flow init</span><br><span class="line">#更新数据(仅仅到git-svn分支)</span><br><span class="line">git svn fetch</span><br><span class="line">#提交数据(从master)</span><br><span class="line">git svn dcommit</span><br><span class="line">#svn数据更新到master</span><br><span class="line">git svn fetch</span><br><span class="line">git checktout master</span><br><span class="line">git svn rebase</span><br></pre></td></tr></table></figure>

<p>恩，这就是这段时间用到的全部了，收尾！</p>
]]></content>
  </entry>
  <entry>
    <title>mongoDB笔记(三)</title>
    <url>/2016/03/24/mongodb3/</url>
    <content><![CDATA[<h1 id="mongoose续"><a href="#mongoose续" class="headerlink" title="mongoose续"></a>mongoose续</h1><p>前一篇笔记只是非常简单的说了下mongoose下怎样对collection进行增删查改，所以这里做做笔记说说别的开发过程中可能遇到的琐碎。</p>
<h2 id="关于查询"><a href="#关于查询" class="headerlink" title="关于查询"></a>关于查询</h2><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>闲话不说，直接看图：<br><img src="/images/find2.png"><br>这个图在第二篇笔记里面见过。它有什么问题吗？没有，但是也许可以有：比如说，那个”_id”就是不需要的数据，如果所有的数据都直接这样返回，那么必然会存在一些商业机密信息暴露——尤其是你的user collections里面包含用户手机号码和地址时候。<br>我们来优化一下流程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&#x27;/user&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  User.find().exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,users</span>)</span>&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      code:<span class="number">200</span>,</span><br><span class="line">      msg:<span class="string">&quot;success&quot;</span>,</span><br><span class="line">      data:&#123;</span><br><span class="line">        users:users.map(<span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;</span><br><span class="line">				name:o.name,</span><br><span class="line">				age:o.age</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当然，map可能不是非常优雅，但是，还有select可以做到限制字段输出，这里说map，是因为最初自己使用的这个办法处理问题。select具体后文有写到。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>很多时候状态作为数字存入数据库，做后端数据库的同学应该很熟悉，经常用前端模板渲染json到页面的前端ers也会非常熟悉。在mongoose里面也定义了这样一类方法。我们做个简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> db = mongoose.connection;</span><br><span class="line"><span class="keyword">var</span> conn = mongoose.connect(<span class="string">&#x27;mongodb://que01:&lt;youhost&gt;:&lt;youport&gt;/learn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123; <span class="attr">name</span>: <span class="string">&#x27;string&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;number&#x27;</span> &#125;);</span><br><span class="line">schema.methods.isAdults = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//一个很简单的辅助函数，返回是否成年人</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.age&gt;<span class="number">18</span>?<span class="string">&quot;成年人&quot;</span>:<span class="string">&quot;未成年人&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> User = mongoose.model(<span class="string">&#x27;user&#x27;</span>, schema);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">	name:o.name,</span><br><span class="line">	age:<span class="number">0.</span>age,</span><br><span class="line">	isAdults:o.isAdults()</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>除了这种最简单的静态方法，在静态方法中还可以调用model进行查询：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">schema.methods.sex = <span class="function"><span class="keyword">function</span>(<span class="params">user</span>)</span>&#123;<span class="comment">//假装数据里面已经有age属性了吧...这是一个获取相同性别人集合的一个方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.model.find(&#123;<span class="attr">sex</span>:<span class="built_in">this</span>.sex&#125;,user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于限制性查询"><a href="#关于限制性查询" class="headerlink" title="关于限制性查询"></a>关于限制性查询</h3><p>『SELECT * FROM table ORDER BY id』,想起这类查询，我就想起曾经学过的mysql和php，很熟悉的感觉，哈哈哈。<br>在mongoose里面当然不是这样查询了，作为一个框架，它必然也会提供类似这种Order By的排序方法。<br>我在网上找了个相对全的代码片段,就懒得自己写了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person</span><br><span class="line">     .find(&#123; <span class="attr">occupation</span>: <span class="regexp">/host/</span> &#125;)</span><br><span class="line">     .where(<span class="string">&#x27;name.last&#x27;</span>).equals(<span class="string">&#x27;Ghost&#x27;</span>)</span><br><span class="line">     .where(<span class="string">&#x27;age&#x27;</span>).gt(<span class="number">17</span>).lt(<span class="number">66</span>)</span><br><span class="line">     .where(<span class="string">&#x27;likes&#x27;</span>).in([<span class="string">&#x27;vaporizing&#x27;</span>, <span class="string">&#x27;talking&#x27;</span>])</span><br><span class="line">     .limit(<span class="number">10</span>)</span><br><span class="line">     .sort(<span class="string">&#x27;-occupation&#x27;</span>)</span><br><span class="line">     .select(<span class="string">&#x27;name occupation&#x27;</span>)</span><br><span class="line">     .exec(callback);</span><br></pre></td></tr></table></figure>
<p>这里总结一下在查询过程中会遇到的情形：</p>
<ul>
<li>属性值是确定的字符串，而不是一个区间时候，直接在find环节传递参数进去</li>
<li>第二个环节对有区间的数字这种进行限制,如代码中的gt和lt，代表意思是大于17小余66</li>
<li>限制查询条目用limit传入数字进行限制</li>
<li>最后，限制字段使用select传入使用空格分隔的字符串作为需要的字段</li>
</ul>
<p>当然，如果是非常简单的查询，只是需要限制字段的话，可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&#x27;/user&#x27;</span>,<span class="string">&quot;name age&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  User.find().exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,users</span>)</span>&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      code:<span class="number">200</span>,</span><br><span class="line">      msg:<span class="string">&quot;success&quot;</span>,</span><br><span class="line">      data:&#123;</span><br><span class="line">        users:users</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>恩，这就是最开始的代码片段除了select的另外的一种解决办法。</p>
<h3 id="查询的静态方法"><a href="#查询的静态方法" class="headerlink" title="查询的静态方法"></a>查询的静态方法</h3><p>最后说下查询的方法，查询可以使用的方法有三个</p>
<ol>
<li>find(query)</li>
<li>findOne(query)</li>
<li>findById(ObjectID)</li>
</ol>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find这个应该无需多说了，在前面已经有了太多例子了。</p>
<h4 id="findOne"><a href="#findOne" class="headerlink" title="findOne"></a>findOne</h4><p>接受一个查询条件，返回单个数据，这个方法，在一些限制性的collection中非常有用，例如很多保存操作会在进行保存之前判断是否用重复，这个最常见的是管理员帐号collection限制用户名不能相同和用户注册collection限制手机和邮件不能相同。</p>
<h4 id="findById-ObjectID"><a href="#findById-ObjectID" class="headerlink" title="findById(ObjectID)"></a>findById(ObjectID)</h4><p>应该来说这个性能最高。如果能获取ObjectID，使用它替代findOne，无需进行任何query查询直接获取结果。</p>
<h2 id="关于增加"><a href="#关于增加" class="headerlink" title="关于增加"></a>关于增加</h2><p>在mysql这类sql数据库里面，数据是强制限制的，如果不符合会被拒绝写入，但是mongoDB作为NoSql数据库是不限制类型的，这意味着当将mongoDB作为关系型数据库时候需要自己承担这个验证的过程，mongoose里面已经为我们做了这个接口：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> conn = mongoose.connect(<span class="string">&#x27;mongodb://que01:&lt;youhost&gt;:&lt;youport&gt;/learn&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123; </span><br><span class="line">	  name:&#123;</span><br><span class="line">        type:<span class="string">&#x27;String&#x27;</span>,</span><br><span class="line">        required:<span class="literal">true</span> <span class="comment">//姓名非空</span></span><br><span class="line">      &#125;,</span><br><span class="line">      age:&#123;</span><br><span class="line">        type:<span class="string">&#x27;Nunmer&#x27;</span>,</span><br><span class="line">        min:<span class="number">18</span>,       <span class="comment">//年龄最小18</span></span><br><span class="line">        max:<span class="number">120</span>     <span class="comment">//年龄最大120</span></span><br><span class="line">      &#125;,</span><br><span class="line">      city:&#123;</span><br><span class="line">        type:<span class="string">&#x27;String&#x27;</span>,</span><br><span class="line">        enum:[<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>]  <span class="comment">//只能是北京、上海</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> User = mongoose.model(<span class="string">&#x27;user&#x27;</span>, schema);</span><br></pre></td></tr></table></figure>

<h2 id="关于更新"><a href="#关于更新" class="headerlink" title="关于更新"></a>关于更新</h2><h3 id="用关数据更新的Model辅助方法"><a href="#用关数据更新的Model辅助方法" class="headerlink" title="用关数据更新的Model辅助方法"></a>用关数据更新的Model辅助方法</h3><ol>
<li>update()</li>
<li>findOneAndUpdate() 这个之前有过演示</li>
<li>findByIdAndUpdate()</li>
</ol>
<p>这三个方法都接受相同的四个参数：</p>
<ol>
<li>conditions 查询条件</li>
<li>update       一个对象，里面放想要设置的键值对</li>
<li>options      一个对象，里面设置一些特殊的操作</li>
<li>callback   回调函数，执行更新之后的回调</li>
</ol>
<p>这里简单说下options这个选项，在三个方法中，它有所不同</p>
<h4 id="options在update-中"><a href="#options在update-中" class="headerlink" title="options在update()中"></a>options在update()中</h4><ul>
<li><code>safa</code> 布尔值，是否抛出错误给callback,默认值是schema中设置的。如果没有设置，缺省值是true</li>
<li><code>upsert</code> 布尔值，当没有匹配document是否新建一个，缺省值为false</li>
<li><code>multi</code> 布尔值，是否多个文档可以一起更新，默认为false</li>
<li><code>strict</code> 是否只有schema已定义的数据才能被保存，默认值是true</li>
</ul>
<h4 id="findOneAndUpdate-amp-findByIdAndUpdate中"><a href="#findOneAndUpdate-amp-findByIdAndUpdate中" class="headerlink" title="findOneAndUpdate()&amp;findByIdAndUpdate中"></a>findOneAndUpdate()&amp;findByIdAndUpdate中</h4><ul>
<li><code>new</code> 布尔值，是否返回最初被修改过的document，默认为true</li>
<li><code>upsert</code> 布尔值，如果查询文档不存在则新建一个，默认为false</li>
<li><code>sort</code> 接受一个object，对查到的数据排序</li>
<li><code>select</code> string，空格分隔的字段组成的字符串</li>
</ul>
<h3 id="更新步骤"><a href="#更新步骤" class="headerlink" title="更新步骤"></a>更新步骤</h3><p>更新数据是个复合动作，包括三个动作：查、改、存。所以说，即使不实用update方法，使用find，手动实现修改后，save()之，也是一个完整的更新过程。<br>但是这里我们来使用update更新数据会更快，更方便(其实更方便我觉得是最重要的)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">User.update(</span><br><span class="line">	&#123;<span class="attr">_id</span>:user.id&#125;,</span><br><span class="line">	&#123;<span class="attr">$set</span>:&#123;<span class="attr">lastLogin</span>:<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//code here...</span></span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>是不是很简单？update将读、改、保存合为一体了，这就是它的『快』，但是除了这个快之外，还有一个更方便地方：<br><b>它只是更新了lastLogin值，而别的值秋毫无犯，这是和save非常显著的区别，save()时候如果不传入完整数据，那么没有传入的数据就会被schema中默认值替代！ </b></p>
<p>恩，关于更新，就是这么多了，更多例子就不补充了。继续删除。</p>
<h3 id="关于删除"><a href="#关于删除" class="headerlink" title="关于删除"></a>关于删除</h3><p>类似更新，它有很类似的方法：</p>
<ol>
<li>remove()</li>
<li>findOneRemove()</li>
<li>findByIdAndRemove()</li>
</ol>
<p>remove貌似不用再作介绍了，在之前笔记有过若干例子。<br>这里说说后面两个方法，他们接受相同的参数：</p>
<ul>
<li>Query Object 查询对象 输入对象进行匹配和删除</li>
<li>Options 一个对象，接受两个属性： <code>sort</code>(对匹配文档排序)和 <code>select</code>(设置返回给callback的对象的属性)</li>
<li>Callback 一个回调函数，好像无需说更多</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>就这样吧，虽然还是不是很详细，但是作为一份笔记和总结来说，这已经足够。mongoose的中文资料不多，深入的更少，这里就仅仅就CURD进了相对深入的记录，聊做记忆强化和备忘。</p>
<div style="text-align:center;">--This is All--tks</div>






]]></content>
  </entry>
  <entry>
    <title>mongoDB笔记(二)</title>
    <url>/2016/03/20/mongodb2/</url>
    <content><![CDATA[<h1 id="关于mongoose"><a href="#关于mongoose" class="headerlink" title="关于mongoose"></a>关于mongoose</h1><h2 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Schema  ：  一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力，他的存在相当于Mysql里面的表的字段设计。</span><br><span class="line">Model   ：  由Schema发布生成的模型，具有抽象属性和行为的数据库操作对，相当于对表的操作</span><br><span class="line">Entity  ：  由Model创建的实体，他的操作也会影响数据库，相当于对查询出的结果组成的数据集合。</span><br></pre></td></tr></table></figure>

<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>Schema生成Model，Model创造Entity，Model和Entity都可对数据库操作造成影响，但Model比Entity更具操作性。</p>
<h1 id="mongoose初步使用"><a href="#mongoose初步使用" class="headerlink" title="mongoose初步使用"></a>mongoose初步使用</h1><h2 id="用mongoose连接数据库"><a href="#用mongoose连接数据库" class="headerlink" title="用mongoose连接数据库"></a>用mongoose连接数据库</h2><p>连接用的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> db = mongoose.connection;</span><br><span class="line"><span class="keyword">var</span> conn = mongoose.connect(<span class="string">&#x27;mongodb://que01:&lt;youhost&gt;:&lt;youport&gt;/learn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123; <span class="attr">name</span>: <span class="string">&#x27;string&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;number&#x27;</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> User = mongoose.model(<span class="string">&#x27;user&#x27;</span>, schema);</span><br></pre></td></tr></table></figure>
<p>这里需要说明的是，schema规定了数据的类型，实际上它也可以规定数据的范围。但是这里需要注意的这里不需要指定数据字的字段大小(field sizes),mongoDB设定的最大大小是16MB,基本上够你放下几部长篇小说了。</p>
<h2 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h2><p>在express里面实践一番，设定一个路由：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&#x27;/user&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  User.find().exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,users</span>)</span>&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      code:<span class="number">200</span>,</span><br><span class="line">      msg:<span class="string">&quot;success&quot;</span>,</span><br><span class="line">      data:&#123;</span><br><span class="line">        users:users</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结果如图：<br><img src="/images/find.png" alt="find"></p>
<h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><p>同上，设定路由和相关逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&#x27;/saveUser&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> user = &#123;</span><br><span class="line">    name:req.query.name,</span><br><span class="line">    age:req.query.age</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> User(user).save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">      user = &#123;</span><br><span class="line">        code:<span class="number">200</span>,</span><br><span class="line">        msg:<span class="string">&quot;success&quot;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      user=&#123;</span><br><span class="line">        code:<span class="number">200</span>,</span><br><span class="line">        msg:<span class="string">&quot;fail&quot;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    res.json(user);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>  如图：<br>  <img src="/images/save.png" alt="save"><br>  重新访问 <code>/user</code>,结果添加了一条，保存成功：<br>   <img src="/images/savesuccess.png" alt="savesuccess">；</p>
<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>这里就不写详细逻辑了，仅仅用get请求传个age数字回来，更改wangwu的age值：<br>这里用到了findOneAndUpdate方法，其实也就是对 <code>Entity</code>进行操作————因为毕竟改动的是一条数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&#x27;/updateUser&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> user = &#123;</span><br><span class="line">    age:req.query.age</span><br><span class="line">  &#125;;</span><br><span class="line">  User.findOneAndUpdate(&#123;<span class="attr">name</span>:<span class="string">&quot;wangwu&quot;</span>&#125;, &#123;<span class="attr">age</span>:user.age&#125;, callback)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>恩，接下来开始传值，浏览器直接输入 <code><a href="http://localhost:3000/updateUser?age=25">http://localhost:3000/updateUser?age=25</a></code>,然后访问<code><a href="http://localhost:3000/user">http://localhost:3000/user</a></code>，结果如图：<br><img src="/images/find2.png"></p>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>删除操作使用remove：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&#x27;/deleteUser&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> user = &#123;</span><br><span class="line">    name:req.query.name</span><br><span class="line">  &#125;;</span><br><span class="line">  User.remove(&#123; <span class="attr">name</span>: user.name &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>访问<code><a href="http://localhost:3000/deleteUser?name=wangwu">http://localhost:3000/deleteUser?name=wangwu</a></code>,然后然后访问<code><a href="http://localhost:3000/user">http://localhost:3000/user</a></code>，如果不报错，可以看到wangwu的记录已经被删除了。</p>
]]></content>
  </entry>
  <entry>
    <title>mongoDB笔记(一)</title>
    <url>/2016/03/18/mongodb/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>mongodb在linux下安装不太复杂,这里仅仅说非常常见的ubuntu安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mongodb</span><br></pre></td></tr></table></figure>
<p>如果是OSX，那么使用brew：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install mongodb</span><br></pre></td></tr></table></figure>

<h1 id="运行服务端"><a href="#运行服务端" class="headerlink" title="运行服务端"></a>运行服务端</h1><p>运行命令 <code>mongod</code>即可将mongod服务端运行起来。这里有两个非常有用的参数需要注意：</p>
<p>1.认证参数： –auth<br>2.数据库参数：–dbpath</p>
<p>先来看看加上这两个参数后的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongod --auth --dbpath ~/workStation/mongodb/learnNode</span><br></pre></td></tr></table></figure>
<p>这里要说明两点：</p>
<ul>
<li><p>如果没有 <code>--auth</code>,那么数据库是不会认证用户，也就是说可以直接登录CURD而不验证操作者身份。通常本地开发会这样使用，但是个人建议，即使本地开发，最好也不要省略这个步骤，毕竟个人认为，贪图这点方便没有必要。</p>
</li>
<li><p>如果没有 <code>--dbpath</code>这个属性，那么mongoDB会使用默认的路径：<code>/data/db</code>。新安装的mongoDB第一次报错往往就是没有加上 <code>--dbpath</code>这个参数，导致在/data/db不存在和没有读写权限时候就会导致报错。</p>
</li>
</ul>
<p>如果确实不想指定数据库路径，那么解决办法是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/db </span><br><span class="line">chown &lt;youname&gt; /data/db</span><br></pre></td></tr></table></figure>

<h1 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h1><p>如果是本地直接通过 <code>mongod</code>跑起来的服务端，那么只需要运行 <code>mongo</code>即可连上数据库。<br>但是如果是需要认证的服务器，那么需要使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo &lt;dbhost&gt;:&lt;port&gt;/&lt;dbname&gt; -u &lt;username&gt; -p &lt;pwd&gt;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是 尖括号加字符代表是变量，使用时尖括号都是没有的</p>
<h1 id="Collection中数据的CURD"><a href="#Collection中数据的CURD" class="headerlink" title="Collection中数据的CURD"></a>Collection中数据的CURD</h1><p>这里应该是最重要的一部分了。CURD是最基础也是数据库操作最重要的一部分。</p>
<p>为了演示如何CURD，熟悉mysql等关系数据库的，你默认这里有一个user的表好了，其实它就是mongoDB里面的collection。同时这里默认你已经在mongoDB的shell里面了。</p>
<h2 id="C-Create-创建"><a href="#C-Create-创建" class="headerlink" title="C-Create 创建"></a>C-Create 创建</h2><p>先把万年龙套张三弄进来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zhangsan = &#123;name:&quot;张三&quot;,age:24&#125;;</span><br><span class="line">db.user.insert(zhangsan);</span><br></pre></td></tr></table></figure>
<p><img src="/images/mongoInsert.png" alt="insert"></p>
<h2 id="R-read-查询插入结果"><a href="#R-read-查询插入结果" class="headerlink" title="R-read 查询插入结果"></a>R-read 查询插入结果</h2><p>现在看看插入成功没有：<br>运行查询命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.user.find(&#123;name:&quot;张三&quot;&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="/images/mongoFind.png" alt="find"></p>
<h2 id="U-update-更新"><a href="#U-update-更新" class="headerlink" title="U-update 更新"></a>U-update 更新</h2><p>为了演示这个，那么我就假装写错了张三名字，改成18吧…</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zhangsan = &#123;name:&quot;张三&quot;,age:18&#125;;</span><br><span class="line">db.user.update(&#123;name:&quot;张三&quot;&#125;，zhangsan);</span><br></pre></td></tr></table></figure>
<p><img src="/images/mongoUpdate.png" alt="update"><br>恩，请忽略我打错逗号的报错。。。</p>
<h2 id="D-delete-删除"><a href="#D-delete-删除" class="headerlink" title="D-delete 删除"></a>D-delete 删除</h2><p>删除和插入类似，这里就不截图了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.user.remove(&#123;name:&quot;张三&quot;,age:24&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="管理数据库中Collection-CURD"><a href="#管理数据库中Collection-CURD" class="headerlink" title="管理数据库中Collection(CURD)"></a>管理数据库中Collection(CURD)</h1><p>每个Collection都类似SQL数据库中的一张表，所以除了表中的数据CURD，表本身的操作也非常重要。</p>
<h2 id="删除Collection-D"><a href="#删除Collection-D" class="headerlink" title="删除Collection(D)"></a>删除Collection(D)</h2><p>这里删除user</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.user.remove();	//删除user内部记录</span><br><span class="line">db.user.drop();		//这是删除collections 在内部数据很多时候 删除collection速度远远比删除文档速度快</span><br></pre></td></tr></table></figure>
<h2 id="新建Collection-C"><a href="#新建Collection-C" class="headerlink" title="新建Collection(C)"></a>新建Collection(C)</h2><p>新建一个，把删掉的重新建立回来…</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.createCollection(&quot;user&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="查看Collection列表-R"><a href="#查看Collection列表-R" class="headerlink" title="查看Collection列表(R)"></a>查看Collection列表(R)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show collections;</span><br></pre></td></tr></table></figure>

<h2 id="修改Collection-U"><a href="#修改Collection-U" class="headerlink" title="修改Collection(U)"></a>修改Collection(U)</h2><p>把user改成复数形式好了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.user.renameCollection(&quot;users&quot;)</span><br></pre></td></tr></table></figure>
<p>这里需要说明的是，在mySQL里面的修改表还涉及到修改表结构这个修改，但是NoSQL数据库不存在这个说法，因为『NoSQL』;</p>
]]></content>
  </entry>
  <entry>
    <title>Window环境下搭建相对完美的前端开发环境</title>
    <url>/2016/02/25/evn_for_webfrontend_3/</url>
    <content><![CDATA[<h2 id="回首"><a href="#回首" class="headerlink" title="回首"></a>回首</h2><p>一年前其实也写过一两篇博文记录自己的前端的环境。但是随着前端的飞速发展,以及协同开发的逐渐扩大，早些时候的环境就不太适用，最近又折腾了一下vagrant镜像，这里谨作记录.</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司目前对电脑安装了加密软件，仅运行在win平台，因此更多情况我就不得不使用win平台进行开发。但是win下npm install诸多包的时候会用到gcc等编译工具链，而win下安装vs后仍然有很多包搞不定。另外来说，作为命令行重度用户，vim热爱人士(youcompleteme在win下安装麻烦得感人),等等，基于这么多的考虑，最后我不得不在虚拟机里面运行相关命令，并依托sabma来进行linux和win的文件交互。</p>
<p>但是随着前端小组有扩大的倾向，公司没法变更的win平台（boss不让用个人电脑）,直接使用虚拟机渐渐变得很不优雅。</p>
<p>最后，考虑到vagrant在开发过程中的优势，加之npm3随之而来的平坦化特性(更早时候npm2时代node_modules目录无线嵌套导致win平台存不下去那么长文件路径导致读写失败),最终我又用vagrant开始配置环境了。</p>
<p>感谢vagrant 和 npm3，给工作带来诸多方便。</p>
<h2 id="第一步是安装"><a href="#第一步是安装" class="headerlink" title="第一步是安装"></a>第一步是安装</h2><p>安装其实本来想省掉的，但是后来win下使用碰到了一点坑，所以也记录一下</p>
<ol>
<li>在MacOS下安装vbox和vagrant没有什么好说的，直接下载最新版，先安装vbox再安装vagrant.</li>
<li>Win平台下有个地方需要注意，最新的vbox版本下，使用npm在同步目录npm install时候有时候会遇到syslink之类的错误，我预计这个是属于linux系统下ln -s命令这种执行失败。查了下资料，使用virtualBox 4.3.10这个老版本没这个现象,于是降到这个版本了(vagrant也换了1.7.4)，果然就没有这个问题了。但是比较奇葩的是我一个同事新装系统和我用同样的box就不行,所以这里我还要进一步找个电脑看看。</li>
</ol>
<h2 id="第二步是vagrant的base-box配置"><a href="#第二步是vagrant的base-box配置" class="headerlink" title="第二步是vagrant的base box配置"></a>第二步是vagrant的base box配置</h2><p>base box配置是件挺麻烦的事情,所以我们直接用他人打包好的干净的base box就可以了。<br>这里我是在github上找到的archlinux为发行版的box,作者刚刚更新了这个box，所以我就用上了,地址在这里 <a href="https://viget.com/extend/create-a-github-repo-from-the-command-line">传送门</a>.<br>选择archlinux做基础环境的原因主要是以下几个：</p>
<ul>
<li>archlinux使用滚动升级，可以跨版本升级，方便以后进行进一步维护更新</li>
<li>archlinux的包相对其他来说更加干净的同事也更加省内存(正常空闲运行时占用不到80M)</li>
</ul>
<p>好了，闲话就说到这里，下面开始贴代码写步骤。</p>
<ol>
<li>下载好box，并cd进入目录，设下载好的box叫做box.box</li>
<li>添加box,命令是 <code>vagrant box add archlinux box.box</code>,这里archlinux是box名字，可以自己随意设置</li>
<li>创建一个新目录，将环境初始化在这里： <code>mkdir archlinux&&cd archlinux&&vagrant init archlinux</code>,这里archlinux是步骤2设置好的</li>
<li>启动虚拟机， <code>vagrant up</code></li>
<li>登陆进入linux环境,如果是在具有ssh命令的环境，比如安装了cygwin(我推荐用babun替代他),可以直接使用vagrant ssh进入,如果没有，使用putty、xshell(可以记住密码)之流,使用预定义帐号登录(帐号密码都是vagrant，可以用root登录，密码仍是vagrant)</li>
</ol>
<h2 id="第三步开始配置环境了"><a href="#第三步开始配置环境了" class="headerlink" title="第三步开始配置环境了"></a>第三步开始配置环境了</h2><p>前端工作流需要安装的各种东西都安装起来。<br>环境这个就要分成两种了.</p>
<ul>
<li><p>一种是工作必须,主要是npm下的各种包，诸如gulp,grunt,puer,bower,yeoman,webpack之类。<br>这里一口气安好就完事了：npm i -g gulp grunt bower yo webpack</p>
</li>
<li><p>一种则是用得舒服需要的：比如oh-my-zsh，比如常用的vim配置，比如配个登录消息(screenfetch)之类,如果习惯shell下工作，怎么也要安装一个tmux。。。<br>这里安装的东西主要列一下，有些记不起了：</p>
</li>
</ul>
<ol>
<li>oh-my-zsh</li>
<li>vim常用配置 基于github上星星最多的项目改过来的 配好YoucompleteMe</li>
<li>tmux</li>
<li>git&amp;git flow&amp;<a href="https://github.com/joeblau/gitignore.io">gitignore.io</a>&amp;<a href="https://github.com/jonas/tig">tig</a></li>
<li>一些没有安装的命令tree,<a href="https://github.com/hut/ranger">ranger</a></li>
<li>其他(暂时忘了，有机会再补充)</li>
</ol>
<h2 id="第四步-打包自己的box"><a href="#第四步-打包自己的box" class="headerlink" title="第四步 打包自己的box"></a>第四步 打包自己的box</h2><p>就一条命令：<br>vagrant package</p>
<h2 id="暂结"><a href="#暂结" class="headerlink" title="暂结"></a>暂结</h2><p>到这里，此时我已经可以在win下非常完美进行相关开发了，npm install再也没有碰到乱七八糟的问题，vim的youCompleteMe插件也可以完美运行了，另外box还可以分享给其他人快速构建环境，我自己的工作电脑和私人的MacbookPro也可以保持统一的环境，算是了解我一桩心事，期望就这样一直下去吧。</p>
<p>本文暂时就这样了，配好是过去几天的事情，具体安装哪些有些不是记得很清楚了，稍后我把相关文件打包一下，如果有人急需的话，可以留下邮箱找我要.</p>
<p>—-已经上传 <a href="http://pan.baidu.com/s/1c12E5IK">点此前往</a>—-</p>
]]></content>
  </entry>
  <entry>
    <title>React实践系列一 组件生命周期</title>
    <url>/2015/12/15/react_cycle/</url>
    <content><![CDATA[<h2 id="React组件周期"><a href="#React组件周期" class="headerlink" title="React组件周期"></a>React组件周期</h2><p>React的组件拥有自身的生命周期。这是一个通过精心设计过的，通过钩子函数来进行对组件进行渲染的过程。<br>React的组件有以下的生命周期：</p>
<ul>
<li>实例化</li>
<li>存在期</li>
<li>销毁&amp;清理期</li>
</ul>
<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>实例化过程中视情况调用的方法会有不同：初次实例化，和后续实例化过程中存在差异。</p>
<h3 id="初次实例化调用"><a href="#初次实例化调用" class="headerlink" title="初次实例化调用"></a>初次实例化调用</h3><ul>
<li>getDefaultProps</li>
<li>getInitialState</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<h3 id="后续实例化"><a href="#后续实例化" class="headerlink" title="后续实例化"></a>后续实例化</h3><ul>
<li>getInitialState</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<h3 id="初次实例化和后续实例化的差异"><a href="#初次实例化和后续实例化的差异" class="headerlink" title="初次实例化和后续实例化的差异"></a>初次实例化和后续实例化的差异</h3><p>getDefaultProps在后续实例化过程中不会被调用.</p>
<h2 id="存在期"><a href="#存在期" class="headerlink" title="存在期"></a>存在期</h2><p>存在期不像实例化存在情景不同，它是持续不变的，它依次调用以下方法：</p>
<ul>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ul>
<h2 id="销毁期"><a href="#销毁期" class="headerlink" title="销毁期"></a>销毁期</h2><p>销毁期仅有一个钩子函数：</p>
<ul>
<li>compoentWillUnmount</li>
</ul>
<h2 id="各个方法的简单说明"><a href="#各个方法的简单说明" class="headerlink" title="各个方法的简单说明"></a>各个方法的简单说明</h2><h3 id="getDefaultProps"><a href="#getDefaultProps" class="headerlink" title="getDefaultProps"></a>getDefaultProps</h3><p>这个方法仅会被调用一次。对那些在父元素上没有设置props的<b>新建</b>组件来说，这是唯一的设定默认值机会。</p>
<h3 id="getInitialState"><a href="#getInitialState" class="headerlink" title="getInitialState"></a>getInitialState</h3><p>这个方法和getDefaultPorps不同，它会在每个实例创建时都调用一次。这这里有个地方要注意:</p>
<ul>
<li>这里已经可以访问到this.props</li>
<li>这是一个初始化state的机会</li>
</ul>
<h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h3><p>组件即将进行渲染前调用一个方法，这是组件渲染前最后一次进行state修改的机会。</p>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>这个方法是必须有的，也是大家用到的最常见最频繁的方法。它会创建一个虚拟DOM，而不是一个真实的DOM。这里有几个地方要注意：</p>
<ul>
<li>通过且之能通过this.props和this.state来访问数据</li>
<li>返回null,false或者react组件</li>
<li>只能出现一个顶级组件</li>
<li>纯净，只做渲染，绝不修改state和dom的输出</li>
</ul>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><p>DOM被渲染到浏览器以后调用的方法。这是一个非常有用的方法，尤其是当你打算把诸多现有组件、插件之类和React一起混用时。他相当于<b>DOMReady</b>。</p>
<p><b>如果你还是不懂的话，我只好祭出杀招:你的各种jQuery插件调用可以放到这里。</b></p>
<h3 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h3><p>当组件处于存在期时候，任何时候都可以通过改变父元素来更改组件的props。当父元素进行这种改变时候，这个方法会被调用，在这里我们可以对props和state进行修改。</p>
<h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><h3 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h3><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><h3 id="compoentWillUnmount"><a href="#compoentWillUnmount" class="headerlink" title="compoentWillUnmount"></a>compoentWillUnmount</h3>]]></content>
  </entry>
  <entry>
    <title>React实践系列一 JSX</title>
    <url>/2015/12/12/react_jsx/</url>
    <content><![CDATA[<h2 id="关于React"><a href="#关于React" class="headerlink" title="关于React"></a>关于React</h2><p>React最近很火。一来一直以来DOM操作都是性能瓶颈,二来从另一个角度来诠释模块化。虽然说它按传统MVC的概念来分的话智仅仅能算V层面,同AngularJS这类MVVM框架在广度有较大距离。但是呢，一件事物不能一味求大求全，何况并不是一味大就可以解决EveryThing————比如YUI。</p>
<p>React之所以成功，我以为，它是击中了前端从业人员的痛点：</p>
<ol>
<li>多个文章和书籍都无数次在说，DOM是性能后腿。然而避无可避。</li>
<li>模块化说来容易做起来永远是一项业界痛点。太多代码写了一年又一年，也许下一年还会重复写。 </li>
</ol>
<p>React根据这两个痛点做了两件事：</p>
<ol>
<li>shadow DOM   ==&gt;  减少不必要的DOM操作</li>
<li>JSX          ==&gt;  将模块相关的HTML,CSS,JS放到一起，这也许是一项前端领域的“逆生长”。</li>
</ol>
<p><span style="color:red">——本文只说JSX</span></p>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>JSX有什么好处呢：</p>
<ul>
<li>允许使用熟悉的语法来定义HTML元素树</li>
<li>提供更加语义化且易懂的标签</li>
<li>程序结构更加直观</li>
<li>抽象了React.Element的创建过程</li>
<li>随时掌控HTML标签以及生成这些标签的代码</li>
<li>原生的Javascript</li>
</ul>
<p>当然，上面说了那么多只是文科考试一般的答案，实际工作中，没人会背诵下来。实际上，JSX仅仅是发明出来方便将html，css，js杂糅到一起做成模块用的工具，用不用可以看喜好。简单来对比下用和不用的区别(当然，用不用JSX，React依然是React)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不使用JSX</span></span><br><span class="line">React.createElement(<span class="string">&#x27;h1&#x27;</span>,&#123;<span class="attr">className</span>:<span class="string">&quot;aaa&quot;</span>&#125;,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="comment">//使用JSX</span></span><br><span class="line">&lt;h1 <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;aaa&quot;</span>&gt;hello world&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>两者在最后运行时候是等效的，但是很显然，JSX抹平了HTML在js中的转换问题，做到了将html标签转换js可识别的DOM对象的自动化——大家都干过用N个”+”来拼接HTML字符串并innerHTML到dom元素中的活儿，一旦字符串庞大，这个拼接就会很费神，然而这仅仅是字符串，手动来操作一个复杂的html字符串转换js认识的DOM，这将会更加复杂。所幸JSX为我们做好了这项工作。</p>
<h2 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h2><p>首先让我们先来个Hello World！第一步就老实从Hello组件做起好了。来个半官方的demo，我仅仅改了标签而已。注意这里JSX浏览器端编译工具体积达到1.3M，这里再次说明了，这个转换是一件相当复杂的事情。</p>
<p><a class="jsbin-embed" href="http://jsbin.com/gayuca/3/embed?html,output">JS Bin on jsbin.com</a></p>
<h2 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h2><p>hello world到此为止就可以运行了，但是这个demo仅仅是一个写死的，不可以复用的html——事实上复制粘贴比它快多了，对吧？<br>第二步，来构建一个简单的组件。这里我抄个demo过来，就不写了。</p>
<pre>
组件的层级：
- CommentBox
  - CommentList
    - Comment
  - CommentForm
</pre>
<p>代码如下：</p>
<p><a class="jsbin-embed" href="http://jsbin.com/winohi/embed?html,output">JS Bin on jsbin.com</a></p>
<p>这里定义一个评论组件，他包含一个评论列表和一个提交评论的表单，我们用React.createClass分别构造了这三个小模块，然后在CommentBox中引用了CommentList和CommentForm，这样，一个包含列表和表单的评论组件就做好了——当然，它只是随便填充了点文字意思了那么一下。。。</p>
<h2 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h2><p>到此为止，这个组件可以实现复用了，但是，<b>它的数据还是写死的</b>。CommentList里面也没有Comment，完善一下：<br><a class="jsbin-embed" href="http://jsbin.com/dazisu/embed?html,output">JS Bin on jsbin.com</a></p>
<p>说一下这里有哪些需要注意的，它做了什么</p>
<ul>
<li>添加了一个Comment组件，并改变了CommentList</li>
<li>传入了data对象</li>
<li>在CommentList中根据传入的data遍历输出了Comment</li>
</ul>
<h2 id="写在step4之前"><a href="#写在step4之前" class="headerlink" title="写在step4之前"></a>写在step4之前</h2><p>写到step3，步子跨越的有些大了。这里补充一下关于JSX的一些基础，和语法相关常识。</p>
<h3 id="JSX的注释"><a href="#JSX的注释" class="headerlink" title="JSX的注释"></a>JSX的注释</h3><p>JSX本质上是js，即使当它是JSX时候可以不太遵循JS语法，但是一旦编译成JS，它就必须遵循JS的语法。</p>
<p>这里简单说一下常见的两种情况：</p>
<ul>
<li><p>注释在JS中</p>
</li>
<li><p>注释在HTML中</p>
</li>
</ul>
<h5 id="注释在JS中"><a href="#注释在JS中" class="headerlink" title="注释在JS中"></a>注释在JS中</h5><p>注释在JS中其实没有太多好说的，和常规的JS一样</p>
<h5 id="注释在HTML中"><a href="#注释在HTML中" class="headerlink" title="注释在HTML中"></a>注释在HTML中</h5><p>注释在HTML中的话，有两种情况：</p>
<ol>
<li>作为子节点</li>
<li>作为内联属性</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作为子节点</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这是一个注释</span></span><br><span class="line">    &#125;</span><br><span class="line">   &lt;h1&gt;helloWorld&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为内联属性</span></span><br><span class="line">&lt;input </span><br><span class="line">    <span class="comment">//这是一个注释</span></span><br><span class="line">type=<span class="string">&quot;text&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这里的注释，可以使用 “//“&amp;”/* */“</p>
<h3 id="JSX模板替代性相关"><a href="#JSX模板替代性相关" class="headerlink" title="JSX模板替代性相关"></a>JSX模板替代性相关</h3><p>模板的作用众所周知，它至少起到以下作用：</p>
<ol>
<li>在标记中输出变量</li>
<li>选择性输出HTML</li>
<li>遍历输出固定HTML标记</li>
<li>分支支持(if else之流)</li>
</ol>
<p>这里就根据上面4个，一一说到JSX中的替代解决方案</p>
<h5 id="在标记中输出变量-–-gt"><a href="#在标记中输出变量-–-gt" class="headerlink" title="在标记中输出变量 –&gt; {}"></a>在标记中输出变量 –&gt; {}</h5><p>在JSX中，花括号{}中间的内容会被渲染为动态值，在{}中放入的任何东西都会被求值，实际上每个{}之间，都会放入一个context(上下文)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析变量</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">&quot;helloWorld&quot;</span>;</span><br><span class="line">&lt;h2&gt;&#123;test&#125;&lt;<span class="regexp">/h2&gt; /</span><span class="regexp">/==&gt;&lt;h2&gt;helloWorld&lt;/</span>h2&gt;</span><br><span class="line"><span class="comment">//执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(a)+<span class="built_in">String</span>(b);</span><br><span class="line">&#125;</span><br><span class="line">&lt;h2&gt;&#123;hello(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;World&quot;</span>)&#125;&lt;<span class="regexp">/h2&gt; /</span><span class="regexp">/==&gt;&lt;h2&gt;helloWorld&lt;/</span>h2&gt;</span><br><span class="line"><span class="comment">//解析数组</span></span><br><span class="line"><span class="keyword">var</span> test = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&lt;h2&gt;&#123;test&#125;&lt;<span class="regexp">/h2&gt; /</span><span class="regexp">/==&gt;&lt;h2&gt;123&lt;/</span>h2&gt;</span><br></pre></td></tr></table></figure>

<h5 id="选择性输出HTML-–-gt-dangerouslySetInnerHTML"><a href="#选择性输出HTML-–-gt-dangerouslySetInnerHTML" class="headerlink" title="选择性输出HTML  –&gt;  dangerouslySetInnerHTML"></a>选择性输出HTML  –&gt;  dangerouslySetInnerHTML</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMarkup</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">            __html: <span class="string">&#x27;&lt;span&gt;Hello World&lt;/span&gt;&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">...</span><br><span class="line">render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;createMarkup()&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h5 id="遍历输出固定HTML标记-–-gt-this-props-data-map"><a href="#遍历输出固定HTML标记-–-gt-this-props-data-map" class="headerlink" title="遍历输出固定HTML标记  –&gt; this.props.data.map"></a>遍历输出固定HTML标记  –&gt; this.props.data.map</h5><p>关于遍历输出固定html标记，在上文的例子中有一个已经运行起来的demo，把它提取出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> commentNodes = <span class="built_in">this</span>.props.data.map(<span class="function"><span class="keyword">function</span> (<span class="params">comment</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Comment author=&#123;comment.author&#125;&gt;</span><br><span class="line">          &#123;comment.text&#125;</span><br><span class="line">        &lt;/Comment&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;commentList&quot;</span>&gt;</span><br><span class="line">        &#123;commentNodes&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> Comment = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;comment&quot;</span>&gt;</span><br><span class="line">        &lt;h2 className=<span class="string">&quot;commentAuthor&quot;</span>&gt;</span><br><span class="line">          &#123;<span class="built_in">this</span>.props.author&#125;</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.props.children&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>大致说一下这里出现的各种变量：<br>首先要说的是 {this.props.children} ，这是一个非常关键的变量。它指向哪个变量呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在CommentList中调用</span></span><br><span class="line">&lt;Comment author=张三&gt;</span><br><span class="line">  测试变量</span><br><span class="line">&lt;/Comment&gt;</span><br><span class="line"><span class="comment">//最后在编译成的：</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;comment&quot;</span>&gt;</span><br><span class="line">&lt;h2 <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;commentAuthor&quot;</span>&gt;</span><br><span class="line">  张三</span><br><span class="line">&lt;/h2&gt;</span><br><span class="line">    测试变量</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>对比上面两个code片段，可以看到：{this.props.children}的地方，出现了”测试变量”。</p>
<p>——{this.props.children}实际上就是指向了Comment标记开始到结尾过程中的子元素</p>
<p>这里解释了JSX中如何生成遍历过程中输出不同变量的，但是还没有说明如何进行遍历过程，这里就是this.props.data.map的作用了。熟悉JS的话就不需要再解释了，map对数组每个元素操作后返回了新的变量组成的数据，最后放到{}中去解析去了：数组是会被当做字符串加起来innerHTML到目标位置的。</p>
<p>最后整理下实现的路径：</p>
<ol>
<li>定义Comment组件，把Comment标记中的文本作为变量放到内容区，以备遍历过程中输出不同变量之需</li>
<li>使用map方法生成一个包含多个Comment组件的数组，把逻辑放到CommentList定义语句中</li>
<li>将返回的数组放到{}中去解析生成，从而遍历生成子节点</li>
</ol>
<h5 id="分支支持-if-else之流"><a href="#分支支持-if-else之流" class="headerlink" title="分支支持(if else之流)"></a>分支支持(if else之流)</h5><p>分支这个最后决定一笔略过了——前面说过了，{}中会有个context，所以，if/else在js中怎么用，这里就可以怎么用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JSX应该算是是React的语法糖，它是React的语法更加简洁，好写和好认。用好JSX是React实现实用意义的第一步。<br>本文简单解释了必要的概念，从step1到step4，实现了一个非常简单评论组件——虽然它很简单，但是一旦封装好却可以重复使用。<br>在step1到step4，实践了复用子组件的同时，实现了模板在实用意义中至关重要的3点：</p>
<ol>
<li>在标记中输出变量</li>
<li>选择性输出HTML</li>
<li>分支支持(if else之流)</li>
</ol>
<p>本文将就此终止，但是本文仍不完善，比如没有讲到this.props，但是这部重要，最重要的是，如何把JSX当成模板用一回，是将JSX作为实用工具最初的一步。关于this.props和组件中数据传递，下一篇再说。</p>
<p>this end</p>
<script src="http://static.jsbin.com/js/embed.min.js?3.35.5"></script>

]]></content>
  </entry>
  <entry>
    <title>Javascript闭包“浅”析</title>
    <url>/2015/11/30/closure2/</url>
    <content><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>3月时候其实浅显的说过一次闭包的概念。然而随着实践和了解的加深,尤其是最近阅读了一些书籍，有了现在这篇文章。此文谨献给过去那些日子的自己，顺便作为笔记。</p>
<h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2><p>现在认为，闭包是一个作用域。它有以下关键词:  </p>
<ol>
<li>它(作为闭包的作用域)是函数创建时建立的——这个作用域在执行后可能已经消失(函数执行完毕后作用域被推出)，也可能没有(window全局作用域)。</li>
<li>这个作用域允许函数的自身函数访问和操作函数之外的变量。</li>
<li>闭包就像一个保护壳,保护着闭包内部变量不被回收。</li>
</ol>
<p>这些关键词可以帮助我们理解一些概念。</p>
<p>权威指南对闭包的定义: 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献内称为“闭包”[This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature.]</p>
<p>中文部分是中文版的权威指南翻译。但是不得不承认，相对于英文的清晰描述，中文的翻译实在是很误导人。英文的原意是：<strong>这种函数对象和其绑定的作用域(作用域是函数内部变量保存的地方)的 **结合体</strong>，在计算机科学中称之为闭包。**</p>
<p>不过原文说这句话时候有很长的一段上下文，这里引用一下。</p>
<blockquote>
<p>Like most modern programming languages, JavaScript uses lexical scoping. This means that functions are executed using the variable scope that was in effect when they were defined, not the variable scope that is in effect when they are invoked. In order to implement lexical scoping, the internal state of a JavaScript function object must include not only the code of the function but also a reference to the current scope chain. (Before reading the rest of this section, you may want to review the material on variable scope and the scope chain in §3.10 and §3.10.3.) This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature.</p>
</blockquote>
<p>这段话里面有几个关键的地方：</p>
<ul>
<li>Javacript使用词法作用域(常见的作用域有两种模型，一种是词法作用域Lexical Scope，一种是动态作用域Dynamic Scope)。</li>
<li>词法作用域有一个特性: 函数执行时候使用的作用域，是在函数定义时候决定,而不是执行的时候决定的(而这是动态作用域的特性)</li>
<li><strong>函数和作用域的结合体才是闭包的真正所指</strong>。</li>
</ul>
<h3 id="最简单的一个例子"><a href="#最简单的一个例子" class="headerlink" title="最简单的一个例子"></a>最简单的一个例子</h3><p>从技术的角度来讲，按照这个内涵，任何的Javascript的函数对象其实都可以称之为闭包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br><span class="line">add();</span><br></pre></td></tr></table></figure>

<p>实际上，前端从业人员大概每天都在写类似这样的代码，而且写过无数次。然而直到最近，才明白，其实它也算是一个闭包。在这个例子中呢，函数对象和全局作用域绑定在一起了，他们组合一起就可以称之为闭包。</p>
<p>但是这个例子呢，因为绑定了全局作用域，但是全局作用域变量本身存在一个特性，那就是全局作用域里面的变量的生命周期是伴随全局作用域的存在，贯穿整个程序的始终的，如果你不去改变它，它就不会消失。</p>
<p>但是更多的情况下，我们的函数使用的是函数作用域，函数作用域的生命周期是这样的：函数开始执行时创建，函数执行完后局部变量会自动销毁。它伴随函数的执行而生灭，是会消失的。</p>
<h3 id="来个稍微复杂的"><a href="#来个稍微复杂的" class="headerlink" title="来个稍微复杂的"></a>来个稍微复杂的</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> out = <span class="string">&quot;outValue&quot;</span>,middle;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closuer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inner = <span class="string">&quot;innerValue&quot;</span>;</span><br><span class="line">    middle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">closuer();</span><br><span class="line"><span class="built_in">console</span>.log(middle());</span><br></pre></td></tr></table></figure>

<p>相对上一个闭包来说，这个例子就可以说明闭包的一些好处。首先这里需要注意到的要点：</p>
<ol>
<li><del>closuer执行完毕以后,作用域已经从作用域链中推出了(生命周期走完)，也就是说middle()执行时候，这个作用域已经不存在</del>。按照正常的流程这个作用域应该被推出了，但是它没有。</li>
<li>middle可以访问到<del>已经不存在的</del>作用域内的变量–&gt;闭包将它们「保护」起来了。</li>
</ol>
<p>在这里, 保护这个词我个人认为不是很恰当，它毕竟只是一个比喻。在这个例子中，存在的是两个闭包。</p>
<ul>
<li>当closuer函数定义的时候，它和全局形成了一个闭包。</li>
<li>当middle函数定义的时候，它和inner所在的作用域形成了一个闭包(当然，它同时是closuer的函数作用域)。</li>
</ul>
<p>当closuer执行时候，closuer改变了全局作用域的变量使其指向了closuer内部的middle函数。而middle函数在定义的时候就绑定了inner所在的作用域形成了闭包。所以当middle函数执行的时候，它只是访问到了自己作用域的变量。而并非一种特殊的保护。<strong>如果非要说有，那么就是middle强行改变了该函数的生命周期，使函数始终被引用了，最终导致与其绑定的作用域无法被释放。</strong></p>
<p>在这里基本上可以给出一个闭包应用的套路了:</p>
<ol>
<li>第一步，函数嵌套，函数A包含函数B，此时函数B作为闭包(参考前文，任何Javacript的函数其实都是闭包)会绑定到函数A的函数作用域。</li>
<li>第二部，函数A最终会讲函数B作为返回值</li>
<li>设定一个全局变量(生命周期决定它不会被回收)然后讲它赋值为函数A的执行结果。But，理论如果你定一个生命周期有限的变量(只要它的生命周期收起大于A便可)，也可以在它的生命周期里面享有这个闭包——但你如何实现它？函数的执行应该是快速而果断的，人为制造一个类似下列的耗时的函数，其实用处不大。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = b()()</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于闭包一些特性"><a href="#关于闭包一些特性" class="headerlink" title="关于闭包一些特性"></a>关于闭包一些特性</h2><ul>
<li>内部函数的参数是包含在闭包中的，关于这个例子 参见 <a href="/2015/03/30/closure.html" target=“_blank”>Javascript闭包作用</a>场景二</li>
<li>闭包作用域内的其他变量(指处于定义时作用域之外的变量)，即使是在闭包产生后定义，也可以被闭包访问到。</li>
</ul>
<p>最后一句话, 几年过去，对闭包的理解不断加深，到今天觉得应该是把握到了核心的地方了。闭包关键点在于2个:</p>
<ol>
<li>Javascript一切函数即闭包</li>
<li>闭包是函数对象和作用域的联合体,然而Javascript内不存在函数没有绑定作用域</li>
</ol>
<p>end</p>
]]></content>
  </entry>
  <entry>
    <title>Array整理二</title>
    <url>/2015/11/01/array2/</url>
    <content><![CDATA[<h2 id="JavaScript数组支持简况"><a href="#JavaScript数组支持简况" class="headerlink" title="JavaScript数组支持简况"></a>JavaScript数组支持简况</h2><p>简单回忆一下JavaScript原生对数组的支持，最常用的基本是，push，pop，shift，unshift这类。<br>实际上，我甚至相信很多写了很多年JavaScript的人，可能会pop,unshift和shift到底是栈还是队操作这种搞混——我以为这种事情并不奇怪，前端甚至很多后端，在具体业务中实际上也很少在数据堆栈结构中不停进栈(队)出栈(队)操作。</p>
<p>而且，相比后端对数组方法完善的方法集成，前端的数组操作，只能算是马马虎虎,这么多年过去,基本上还是堆和栈操作的老三样——不过很多前端确实也不需要复杂的处理方法。</p>
<h2 id="JavaScript数组的栈和队"><a href="#JavaScript数组的栈和队" class="headerlink" title="JavaScript数组的栈和队"></a>JavaScript数组的栈和队</h2><h3 id="栈操作-–-gt-LIFO-Last-in-first-out"><a href="#栈操作-–-gt-LIFO-Last-in-first-out" class="headerlink" title="栈操作 –&gt;LIFO(Last in first out)"></a>栈操作 –&gt;LIFO(Last in first out)</h3><p>栈操作的特点就四个字：<b>后进先出</b></p>
<ul>
<li>pop 出栈操作，删除并返回最后一个数组元素</li>
<li>push 入栈操作，返回添加后的数组长度(直接操作数组)</li>
</ul>
<h3 id="队操作-–-gt-FIFO-First-in-first-out"><a href="#队操作-–-gt-FIFO-First-in-first-out" class="headerlink" title="队操作 –&gt; FIFO(First in first out)"></a>队操作 –&gt; FIFO(First in first out)</h3><p>队操作的特点是<b>先进先出</b>：</p>
<ul>
<li>unshift 入队操作，在数组头部添加一个元素，返回添加后数组长度</li>
<li>shift 出队操作，在数组头部删除一个元素并将其返回</li>
</ul>
<h3 id="栈操作和队操作的简单对比总结"><a href="#栈操作和队操作的简单对比总结" class="headerlink" title="栈操作和队操作的简单对比总结"></a>栈操作和队操作的简单对比总结</h3><p>首先说下相同的地方：</p>
<ul>
<li>出栈操作(pop)和出队操作(shift)都是将特定删除的元素直接从数组中删除并返回</li>
<li>入栈操作(push)和入队操作(unshift)都是将特定元素直接放到数组中，并返回新数组的长度</li>
</ul>
<p>不同的地方：<br>一个是FIFO一个是LIFO，这里有个很粗鄙但是很形象的比喻是：</p>
<blockquote>
<p>栈操作是吃多了吃不下吐出去，而队则是吃多了拉出去。</p>
</blockquote>
<h2 id="数组其他一些方法"><a href="#数组其他一些方法" class="headerlink" title="数组其他一些方法"></a>数组其他一些方法</h2><p>除了栈和队操作以外，常见的数组操作方式还有：</p>
<ul>
<li><p>slice和splice数组切片操作。在切片操作中，它们都可以接受两个参数,一个是数组索引(从0开始)，一个要切片的数量。但是slice和splice的不同之处是slice将切片后的数组返回并不会影响原来数组，而splice则直接操作原来数组将切出来的从原来数组删除。</p>
</li>
<li><p>join操作，可以将数组指定分隔符号拼接成字符串(响应的，字符串有个split操作，类似join反向操作)，缺省分隔符号是”,”。join的作为Array2String的使用场景很多，使用它可以替代”+”来拼字符串和厂商队字符串处理效率的优化，效率要高一些(得益疯狂优化的浏览器内核，这个结论正在被挑战)。</p>
</li>
<li><p>concat.这个比较简单，合并数组用的。</p>
</li>
<li><p>forEach和map。感觉这两个方法有些容易搞混。</p>
<ul>
<li>forEach(迭代),forEach类似将原料(数组内每个元素)扔进扔进生产机器，扔完以后就不是forEach的活儿了</li>
<li>map(收集),map则不同，他不但要挨个扔进原料，还要负责把原料生产出来的产品放进新的盒子里面(不影响原来数组)</li>
</ul>
</li>
<li><p>filter过滤数组，filter是一个非常好用也非常常用的方法，它负责根据条件来过滤符合条件的数组元素并返回。</p>
</li>
<li><p>some和every，个人倾向这两个方法是是”验货方法”，some管的比较松，只要有一个能用(符合判断条件)就让过(返回true)，而every则管的很严格(符合判断条件)，必须全部能用才给过(返回true)。</p>
</li>
<li><p>reverse，将数组反转———这个方法说实话项目从来没用到过。</p>
</li>
<li><p>sort，排序。</p>
</li>
</ul>
<p>总体来说，原生的数组方法就是这些，这里简单回顾对比一下，具体的使用代码，可以参见以前的文章：<a href="/2015/04/01/array.html">Array整理</a>，这里不在赘述。</p>
<h2 id="数组方法分类"><a href="#数组方法分类" class="headerlink" title="数组方法分类"></a>数组方法分类</h2><p>这里本来是打算找一找增强数组方法分类，结果找到了原生支持的，实际上前一篇已经有了累死的分类结论，但是没这个好,所以copy一下这个分类，原文载于<a href="http://segmentfault.com/a/1190000003738483">《js 你不知道的 Array》</a> (鉴于国内比较混乱的环境，如果这个不是最初原文出处，请联系我修正)</p>
<ol>
<li><p>Mutator方法 这些方法可以改变数组自身</p>
<ul>
<li>pop : 移除数组的最后一个元素，返回值是被删除的元素。</li>
<li>push : 在数组的末尾添加一个或者多个元素，返回值是新的数组的长度。</li>
<li>reverse : 颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在的第一个，也就是数组的索引发生了变化。</li>
<li>shift : 删除数组的第一个元素，返回值是删除的元素</li>
<li>sort : 对数组中的元素进行排序</li>
<li>plice : 添加或删除数组中的一个或多个元素。</li>
<li>unshift : （将废弃）添加一个或者多个元素在数组的开头，返回值是新的数组的长度。</li>
</ul>
</li>
<li><p>Accessor方法 这些方法不改变数组自身</p>
<ul>
<li>concat : 返回一个包含此数组和其他数组和/或值的结合的新数组</li>
<li>indexOf : 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1</li>
<li>join : 将所有的数组元素连接成一个字符串</li>
<li>lastIndexOf : 返回在数组中搜索到的与给定参数相等的元素的最后（最大）索引</li>
<li>slice : 返回数组中的一段。</li>
<li>toString : 返回代表该数组及其元素的字符,重写Object.toString 过程.</li>
<li>valueOf : 重写Object.valueOf过程。</li>
</ul>
</li>
<li><p>循环（迭代） 方法</p>
<ul>
<li>filter : 对数组中的每一个元素调用参数中指定的过滤函数，并将对于过滤函数返回值为true的那些数组元素集合为新的数组返回。</li>
<li>forEach : 对数组的每一个元素依次调用参数中指定的函数。</li>
<li>every : 如果数组中每一个元素都满足参数中提供的测试函数，则返回真</li>
<li>map : 创建一个新数组，新数组中含有，分别对于原来数组的每一个元素调用一个给定函数的结果</li>
<li>some : 如果数组中至少有一个元素满足参数函数的测试，则返回true。</li>
</ul>
</li>
</ol>
<h2 id="数组的增强"><a href="#数组的增强" class="headerlink" title="数组的增强"></a>数组的增强</h2><p>说完JavaScript原生数组支持，这里来说一说数组方法的扩展和增强。<br>常见的数组增强在各个辅助库里面其实都会包含，这里仅仅贴一段之前的练习代码。聊做参考：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * desc:判断指定元素存在于指定数组中</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns <span class="type">&#123;boolean&#125;</span> </span>返回是否含有</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">src,target</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> target.indexOf(src)&gt;-<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * desc:移除特定index的元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">index</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns <span class="type">&#123;boolean&#125;</span> </span>返回操作是否成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">removeAt</span>(<span class="params">arr,index</span>)</span>&#123;</span><br><span class="line">       <span class="comment">//splice直接操作数组</span></span><br><span class="line">       <span class="keyword">return</span> !!arr.splice(index,<span class="number">1</span>).length;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * desc:移除数组中元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">array</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>ele  移除元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">array,ele</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ele != e;</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * desc:对数组进行乱序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> tmp = [],len = array.length;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> a= <span class="number">0</span>;a&lt;len;a++)&#123;</span><br><span class="line">           <span class="keyword">var</span> r = <span class="built_in">this</span>.random(array); <span class="comment">//随机选一个出来</span></span><br><span class="line">           tmp.push(r);                <span class="comment">//压入目标数组</span></span><br><span class="line">           array = <span class="built_in">this</span>.remove(array,r);<span class="comment">//从数组中删除元素</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tmp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * desc:随机选出数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">array</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> array[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*array.length)];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * desc:平坦化处理,将内部二维数组转为一维数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * desc:对数组元素进行去重</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">array</span></span></span></span><br><span class="line"><span class="comment">    * 相关参考 http://www.cnblogs.com/wteam-xq/p/4732351.html</span></span><br><span class="line"><span class="comment">    * 1.遍历数组法 2.对象键值对法 3.数组下标判断法 4.排序后相邻去除法 5.优化遍历数组法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0</span>); <span class="comment">//结果数组</span></span><br><span class="line">       n.push(array[<span class="number">0</span>]); <span class="comment">//先添加第一个元素进去</span></span><br><span class="line">       <span class="comment">//从第二项开始遍历</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">           <span class="comment">//如果当前数组的第i项在当前数组中第一次出现的位置不是i，</span></span><br><span class="line">           <span class="comment">//那么表示第i项是重复的，忽略掉。否则存入结果数组</span></span><br><span class="line">           <span class="keyword">if</span> (array.indexOf(array[i]) === i) n.push(array[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> n;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 过滤null&amp;undefined</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">array</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">compact</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> e != <span class="literal">undefined</span></span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * desc 获取数组中对象的特定值组成的数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">array</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">name</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">fluck</span>(<span class="params">array,name</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> len = array.length,</span><br><span class="line">           i = <span class="number">0</span>,</span><br><span class="line">           tmp=[];</span><br><span class="line">       <span class="keyword">for</span>(;i&lt;len;i++)&#123;</span><br><span class="line">           tmp.push(array[i][name])</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tmp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * desc 返回数组最大值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">array</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,array)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * desc 返回数组最小值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">array</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span>  <span class="title">min</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,array)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>Array整理</title>
    <url>/2015/04/01/array/</url>
    <content><![CDATA[<h2 id="Javascript数组"><a href="#Javascript数组" class="headerlink" title="Javascript数组"></a>Javascript数组</h2><p>据了解，在严格类型语言中，数组是不能随意增加元素的，但是个人来说，后端基础仅限PHP，但是PHP中，数组长度其实也是可以增加的。数组的在弱类型语言中的这种特性，其实也确实方便了太多。</p>
<h2 id="数组的增删"><a href="#数组的增删" class="headerlink" title="数组的增删"></a>数组的增删</h2><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>数组的增加有3个方法：</p>
<pre><code>-push       添加到尾部
-unshift    添加到头部
-splice     添加到任意位置(也可以删除）</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">Arr.push(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Arr);<span class="comment">//[1,2,3,4,5,6]</span></span><br><span class="line">Arr.unshift(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Arr);<span class="comment">//[0,1,2,3,4,5,6]</span></span><br><span class="line">Arr.splice(<span class="number">3</span>,<span class="number">0</span>,<span class="number">33</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Arr);<span class="comment">//[0,1,2,33,3,4,5,6]</span></span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>对应增加，删除也是三个方法：</p>
<pre><code>-pop        从尾部删除
-shift      从头部删除
-splice     指定位置删除</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">Arr.pop();<span class="comment">//[1,2,3,4]</span></span><br><span class="line">Arr.shift();<span class="comment">//[2,3,4]</span></span><br><span class="line">Arr.splice(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//[2,4]</span></span><br></pre></td></tr></table></figure>

<h2 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h2><p>数组的排序有两个方法</p>
<pre><code>-reverse    倒序排列
-sort       按字典排列(元素视为字符)</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">Arr.reverse();<span class="comment">//[5,4,3,2,1]</span></span><br><span class="line">Arr.sort();<span class="comment">//[1,2,3,4,5];</span></span><br><span class="line"><span class="keyword">var</span> Arr2=[a,f,g,e];</span><br><span class="line">Arr2.sort();<span class="comment">//[a,e,f,g];</span></span><br><span class="line"><span class="keyword">var</span> Arr3=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>];</span><br><span class="line">Arr3.sort()<span class="comment">//[1,10,2,3];</span></span><br></pre></td></tr></table></figure>

<p>从上面例子可以知道，sort这个方法，如果不传入参数，排序字符串元素的效果尚可，但是排序数字元素的效果就达不到预期。但是可以通过传入方法来纠正：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Arr3&#x3D;[1,10,2,3];</span><br><span class="line">Arr3.sort(function(num1,num2)&#123;</span><br><span class="line">    return num1-num2    </span><br><span class="line">&#125;);&#x2F;&#x2F;[1,2,3,10]</span><br></pre></td></tr></table></figure>

<h2 id="迭代-遍历"><a href="#迭代-遍历" class="headerlink" title="迭代(遍历)"></a>迭代(遍历)</h2><h3 id="不产生新数组"><a href="#不产生新数组" class="headerlink" title="不产生新数组"></a>不产生新数组</h3><pre><code>-forEach    对数组每个元素进行相关操作
-every      如果所有元素都符合判断，返回true
-some       只要有一个符合就返回true</code></pre>
<h3 id="产生新数组"><a href="#产生新数组" class="headerlink" title="产生新数组"></a>产生新数组</h3><pre><code>-map        基本等同forEach,不同的是返回一个数组副本，而不修改原数组
-filter     筛选出符合的元素，作为数组返回</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;<span class="built_in">console</span>.log(num*num)&#125;);<span class="comment">//1,4,9,16,25</span></span><br><span class="line"><span class="built_in">console</span>.log(a.every(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;<span class="keyword">return</span> num&gt;<span class="number">0</span>&#125;);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.some(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;<span class="keyword">return</span> num&gt;<span class="number">4</span>&#125;);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;<span class="keyword">return</span> num&gt;<span class="number">4</span>&#125;;<span class="comment">//[5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.map(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;<span class="keyword">return</span> num*num&#125;))<span class="comment">//[1,4,9,16,25]</span></span><br><span class="line"><span class="comment">//PS:空数组不会输出</span></span><br><span class="line"><span class="keyword">var</span> b=[<span class="number">1</span>,<span class="number">2</span>,,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">b.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;<span class="built_in">console</span>.log(num*num)&#125;);<span class="comment">//1,4,16,25</span></span><br></pre></td></tr></table></figure>


<h2 id="数组的增强"><a href="#数组的增强" class="headerlink" title="数组的增强"></a>数组的增强</h2><h3 id="contains-包含"><a href="#contains-包含" class="headerlink" title="contains    包含"></a>contains    包含</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">target,item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target.indexOf(item)&gt;-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="max-amp-amp-min"><a href="#max-amp-amp-min" class="headerlink" title="max&amp;&amp;min"></a>max&amp;&amp;min</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max.apply(<span class="number">0</span>,arr);        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">min</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min.apply(<span class="number">0</span>,arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="removeAt-amp-amp-remove"><a href="#removeAt-amp-amp-remove" class="headerlink" title="removeAt&amp;&amp;remove"></a>removeAt&amp;&amp;remove</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeAt</span>(<span class="params">arr,index</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !!arr.splice(index,<span class="number">1</span>).length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">target,item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = target.indexOf(item);</span><br><span class="line">    <span class="keyword">return</span> !!arr.splice(index,<span class="number">1</span>).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Javascript闭包作用</title>
    <url>/2015/03/30/closure/</url>
    <content><![CDATA[<h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2><p>个人觉得闭包其实是一个很抽象的概念，因为很难用一个词语特别清晰的表达这个概念。从当前个人知识体系讲，我以为闭包是Javascript特殊的变量作用域造成的一个特殊现象，它使得Javacript的函数内部可以访问到外部变量，但是外部变量却无法访问函数内部私有变量（使用var声明的变量）,而闭包则是将内外部变量结合起来的一座桥梁。<br>MDN的定义是：闭包是指函数有自由独立的变量。换句话说，定义在闭包中的函数可以“记忆”它创建时候的环境。</p>
<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>闭包有两个作用：</p>
<pre><code>1. 使得在函数外部可以访问到原本访问不到的变量。
2. 闭包始终被存在内存中可以用来存储变量。</code></pre>
<h2 id="闭包场景"><a href="#闭包场景" class="headerlink" title="闭包场景"></a>闭包场景</h2><h3 id="场景一-访问函数内部变量"><a href="#场景一-访问函数内部变量" class="headerlink" title="场景一 访问函数内部变量"></a>场景一 访问函数内部变量</h3><p>code:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMyName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">returnMyName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myName;</span><br><span class="line">    &#125;</span><br><span class="line">    returnMyName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getMyName()) <span class="comment">//&quot;Tom&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这个场景下，由于子作用域可以访问到上级作用域，所以getMyName函数作为其内部函数returnMyName的上级作用域，其属性myName可以被returnMyName访问到。因此，虽然在getMyName外部虽然无法直接获取myName的值，但是通过闭包，却可以获取到其内部的属性。</p>
<h3 id="场景二-存储变量"><a href="#场景二-存储变量" class="headerlink" title="场景二 存储变量"></a>场景二 存储变量</h3><p>code:<br>JS:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeBg</span>(<span class="params">color</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">color</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.body.style.background = color;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> red = changeBg(red);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;red&quot;</span>).onclick = red;</span><br></pre></td></tr></table></figure>
<p>HTML:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&amp;lt;a href=<span class="string">&quot;&quot;</span> id=<span class="string">&quot;red&quot;</span>&amp;gt;&amp;lt;/a&amp;gt;</span><br></pre></td></tr></table></figure>

<p>这里仅仅是一个改变背景为红色的按钮，但是也可以添加更多为其他颜色的按钮,这样，存储变量的目的就达到了。</p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>闭包是javascript特殊的变量作用域行为导致的，由此，javascript可以有更丰富的特性。<br>它本质上，是对函数作用域的深入应用。而这，就是编程基础的重要之所在。</p>
]]></content>
  </entry>
  <entry>
    <title>Mocha测试框架笔记(二)</title>
    <url>/2015/02/02/mocha_test_2/</url>
    <content><![CDATA[<h2 id="先总结下昨天的笔记"><a href="#先总结下昨天的笔记" class="headerlink" title="先总结下昨天的笔记"></a>先总结下昨天的笔记</h2><p> 昨天一共总结了mocha中的四种测试案例：</p>
<pre><code>1.同步测试
2.异步测试
3.排他性测试
4.包容性测试</code></pre>
<p>用过的API包括：</p>
<pre><code>describe(&quot;name&quot;,callback) 
it 
beforeEach(),afterEach(),before(),after() 
only() &amp;  skip()</code></pre>
<h2 id="继续第二篇笔记"><a href="#继续第二篇笔记" class="headerlink" title="继续第二篇笔记"></a>继续第二篇笔记</h2><hr>
<h2 id="Mocha命令行用法"><a href="#Mocha命令行用法" class="headerlink" title="Mocha命令行用法"></a>Mocha命令行用法</h2><pre><code>mocha 

    Usage: mocha [debug] [options] [files]

    Commands:

      init &lt;path&gt;                     在指定 &lt;path&gt; 位置初始化一个 mocha 客户端

    Options:

      -h, --help                      输出帮助信息
      -V, --version                   输出版本号
      -r, --require &lt;name&gt;            必须的给定模块
      -R, --reporter &lt;name&gt;           指定测试报告工具
      -u, --ui &lt;name&gt;                 指定编写的测试用例使用的接口 (bdd|tdd|exports)
      -g, --grep &lt;pattern&gt;            仅运行匹配 &lt;pattern&gt; 的测试
      -i, --invert                    反转 --grep 的匹配
      -t, --timeout &lt;ms&gt;              设置测试用例的超时时间，默认为 [2000] 毫秒
      -s, --slow &lt;ms&gt;                 设置运行得 &quot;慢&quot; 的测试的阈值，默认为 [75] 毫秒
      -w, --watch                     实时监控文件修改
      -c, --colors                    启用彩色显示
      -C, --no-colors                 禁用彩色显示
      -G, --growl                     启用 growl 消息通知
      -d, --debug                     启用 node 的调试功能, 和 node --debug 一样
      -b, --bail                      bail after first test failure
      --recursive                     包括所有子目录
      --debug-brk                     在第一行启用 node 的断点调试
      --globals &lt;names&gt;               允许的全局变量，多个用逗号分隔
      --ignore-leaks                  忽略全局变量泄露
      --interfaces                    显示可用的接口
      --reporters                     显示可用的报告器
      --compilers &lt;ext&gt;:&lt;module&gt;,...  使用给定的模块来编译文件</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Mocha测试框架笔记(一)</title>
    <url>/2015/02/01/mocha_test_1/</url>
    <content><![CDATA[<p>想写写Javascript测试很久，但是一直没有有过实践，今天花了点实践从官网看了下资料，做一下笔记。实践一下javascript的单元测试.半翻译半笔记。</p>
<p>如果还不知道Mocha是什么，可以看看官网的介绍<a href="http://mochajs.org/">mocha</a><br>简而言之，它是一个测试框架，在yeoman的generator里面很多都用到了macha，它作为一个测试框架，可以和不少断言库一起使用，官网的信息是这些断言库包括：should.js|expect.js|chai|better-asssert<br>个人这里只听说过chai，而且本文仅仅对mocha做笔记，chai将另外撰文。</p>
<h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><pre><code>   sudo npm install -g mocha </code></pre>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>姑且用官网的第一个例子做学习的Hello World:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">&quot;assert&quot;</span>)</span><br><span class="line">describe(<span class="string">&#x27;Array&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  describe(<span class="string">&#x27;#indexOf()&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    it(<span class="string">&#x27;should return -1 when the value is not present&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      assert.equal(-<span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">5</span>));</span><br><span class="line">        assert.equal(-<span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">0</span>));</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> 命令行mocha运行之：</p>
<p><img src="/images/2015-02/mocha1.png" alt="mocha"></p>
<p> 这里总结一下最简单的一个测试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">&quot;测试名目&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    it(<span class="string">&quot;测试项目说明&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//断言函数    </span></span><br><span class="line">        <span class="comment">//assert.equal 即是一个相等关系断言</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="异步测试"><a href="#异步测试" class="headerlink" title="异步测试"></a>异步测试</h2><p> 官网的说法是:Testing asynchronous code with Mocha could not be simpler!(用Mocha做异步测试已经不能再简单!)<br> 官方的例子是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> describe(<span class="string">&#x27;User&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   describe(<span class="string">&#x27;#save()&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     it(<span class="string">&#x27;should save without error&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> user = <span class="keyword">new</span> User(<span class="string">&#x27;Luna&#x27;</span>);</span><br><span class="line">       user.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">            done();</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
<p>PS:这里为了更方便一点,done()回调函数甚至可以接受一个err作为参数，我们可以直接使用，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">&#x27;User&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  describe(<span class="string">&#x27;#save()&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    it(<span class="string">&#x27;should save without error&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> user = <span class="keyword">new</span> User(<span class="string">&#x27;Luna&#x27;</span>);</span><br><span class="line">      user.save(done);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>值得说明的是所有的API(原文是Hooks)：before(),after(),beforeEach(),afterEach()均可在同步异步环境下友好运行，就像仅仅是一个常规测试用例一样：<br>Example：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">&#x27;Connection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="comment">//连接数据库并本地创建3个User</span></span><br><span class="line">  <span class="keyword">var</span> db = <span class="keyword">new</span> Connection</span><br><span class="line">    , tobi = <span class="keyword">new</span> User(<span class="string">&#x27;tobi&#x27;</span>)</span><br><span class="line">    , loki = <span class="keyword">new</span> User(<span class="string">&#x27;loki&#x27;</span>)</span><br><span class="line">    , jane = <span class="keyword">new</span> User(<span class="string">&#x27;jane&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//清空数据库后在数据库创建新建的3个User ---&gt;异步</span></span><br><span class="line">    db.clear(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> done(err);</span><br><span class="line">      db.save([tobi, loki, jane], done);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  describe(<span class="string">&#x27;#find()&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//查询数据库确认结果为3                 ---&gt;异步</span></span><br><span class="line">    it(<span class="string">&#x27;respond with matching records&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">      db.find(&#123; <span class="attr">type</span>: <span class="string">&#x27;User&#x27;</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> done(err);</span><br><span class="line">        res.should.have.length(<span class="number">3</span>);</span><br><span class="line">        done();</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<b>
这里注意到：
it的回调里面必须能够返回err才可以确保测试无误，否则回调函数执行done()之前务必使用断言测试确保额可以抛出err
</b>

<p>接下来使用chai断言库做Promised <a href="https://github.com/domenic/chai-as-promised/">chai promised</a><br>这里仅仅贴上官网的链接 chai在另外的文章总结</p>
<h2 id="API-Hooks"><a href="#API-Hooks" class="headerlink" title="API(Hooks)"></a>API(Hooks)</h2><p> 四个：before(),after(),beforeEach(),afterEach()</p>
<p> 作用：设定测试前提条件，简化测试用例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">&#x27;hooks&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// runs before all tests in this block</span></span><br><span class="line">            &#125;)</span><br><span class="line">    after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// runs after all tests in this block</span></span><br><span class="line">            &#125;)</span><br><span class="line">    beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// runs before each test in this block</span></span><br><span class="line">            &#125;)</span><br><span class="line">    afterEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// runs after each test in this block</span></span><br><span class="line">            &#125;)</span><br><span class="line">    <span class="comment">// test cases</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="Exclusive-tests-独立测试，排他测试…不知道准确术语"><a href="#Exclusive-tests-独立测试，排他测试…不知道准确术语" class="headerlink" title="Exclusive tests(独立测试，排他测试…不知道准确术语)"></a>Exclusive tests(独立测试，排他测试…不知道准确术语)</h2><p>简单Demo:<br>仅仅在describe后用only()引用一个回调</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">&#x27;Array&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  describe.only(<span class="string">&#x27;#indexOf()&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>一个简单的包含Exclusive Test的测试案例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">&#x27;Array&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  describe(<span class="string">&#x27;#indexOf()&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    it.only(<span class="string">&#x27;should return -1 unless present&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//code here </span></span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line">    it(<span class="string">&#x27;should return the index when present&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//code here </span></span><br><span class="line">     &#125;)</span><br><span class="line">              </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Inclusive-tests-与上文对应，包容性测试"><a href="#Inclusive-tests-与上文对应，包容性测试" class="headerlink" title="Inclusive tests(与上文对应，包容性测试)"></a>Inclusive tests(与上文对应，包容性测试)</h2><p>同only()用法完全一致，不过这里使用skip()来跳过测试案例里面的通用测试</p>
<p>Example:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">&#x27;Array&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  describe(<span class="string">&#x27;#indexOf()&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    it.skip(<span class="string">&#x27;should return -1 unless present&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">&#x27;should return the index when present&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>……….未完待续…………..</p>
<p><a href="/2015/02/02/mocha-test-2.html">Mocha测试框架笔记(二) </a></p>
]]></content>
  </entry>
  <entry>
    <title>Javascript的元素运动(二)</title>
    <url>/2014/04/10/animate2/</url>
    <content><![CDATA[<h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><p>这篇的重点是处理一下<b>曲线运动</b>相关的知识，自己之前没有做过相关的研究，这里一边写一边总结。写的不好的话请见谅。<br>我个人见过觉得比较有实用价值的运动有三种：</p>
<ol>
<li>圆周运动</li>
<li>抛物线运动</li>
<li>贝塞尔曲线运动</li>
</ol>
<p>所以暂时就研究这几种曲线运动，如果以后有比较值得研究的再补充一下。</p>
<h2 id="圆周运动"><a href="#圆周运动" class="headerlink" title="圆周运动"></a>圆周运动</h2><p>先贴个图来找下感觉</p>
<p>![圆在坐标系中](/images/animate/1.jpg =200x200)</p>
<p>很熟悉的感觉。。。大抵高三就是这一生智商巅峰了。。。<br>言归正传，找到这张图才想起原点不一定都是在(0,0)的位置。另外把圆的方程找到了，挺简单的：</p>
<pre style="margin-bottom:20px">
        (x－a)²+(y－b)²=r²
</pre>


<p>其中(a,b)是圆心所在点。这里我们主要的需求是：<b>已知半径,根据角度不同来计算当前角度下坐标</b><br>网上搜索一下，感谢google，这里是计算的公式：</p>
<p>设A(x,y)是所求点,(a,b)是圆心,r为半径，PI为圆周率,A为当前角度</p>
<pre style="margin-bottom:20px">
    x = a + r * cos(A * PI/180) 
    y = b + r * sin(A * PI/180) 
</pre>

<p>这样一来其实就很好算了,这里就根据JavaScript来写个function来获取坐标：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取圆的上一个点的坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span> </span>a     [圆心横坐标]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span> </span>b     [圆心纵坐标]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span> </span>x     [圆上一点的横坐标]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span> </span>y     [圆上一点的纵坐标]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span> </span>r     [圆的半径]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span> </span>angle [目标点所在角度]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;[object]&#125;</span>       </span>[目标点的坐标]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCoordinate</span>(<span class="params">a,b,x,y,r,angle</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> r = <span class="built_in">Math</span>.sqrt((a-x)*(a-x) + (b-y)*(b-y))</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		x : a + r * <span class="built_in">Math</span>.cos(angle * <span class="built_in">Math</span>.PI/<span class="number">180</span>),</span><br><span class="line">		y : b + r * <span class="built_in">Math</span>.sin(angle * <span class="built_in">Math</span>.PI/<span class="number">180</span>) </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来基本就可以使用了，给出圆心坐标、圆上一点加上角度值就可以开始获取圆周运动中的点的坐标了。</p>
<p>我们现在来处理动画要素——计时器和贯穿运动的角度问题。<br>角度这个不能一直加下去，它需要可以从一个数(&lt;=360)加到360，过了360又重置成1.因为可能有很多个计时器，所以需要一个计数器的构造函数，考虑到每个构造函数都有自己的角度，因此我们需要一个闭包来保存它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AngleFac</span>(<span class="params">init</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">initNum</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> angle = <span class="number">1</span>,</span><br><span class="line">			initAngle = initNum;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(initAngle)&#123;</span><br><span class="line">			angle = initAngle;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			add:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				angle = (angle==<span class="number">360</span>)?<span class="number">1</span>:angle+<span class="number">1</span>;</span><br><span class="line">			&#125;,</span><br><span class="line">			get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> angle;</span><br><span class="line">			&#125;,</span><br><span class="line">			set:<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(a&gt;<span class="number">360</span>)&#123;</span><br><span class="line">					<span class="built_in">console</span>.log(<span class="string">&quot;最大只能设置360&quot;</span>)</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					angle = a;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			reset:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(initAngle)&#123;</span><br><span class="line">					<span class="built_in">this</span>.set(initAngle);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="built_in">console</span>.log(<span class="string">&quot;没有设置初始值！&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;)(init)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们有一个功能相对完备的构造函数,可以读、写、设置和重置角度。</p>
<p>好吧，上个demo，超级简单的，然而很是简陋啊。。。我不折腾圆周了，实际上可以给出半径而不需要圆上一点的。</p>
<p><a class="jsbin-embed" href="http://jsbin.com/melexaj/embed?js,output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.9"></script></p>
]]></content>
  </entry>
  <entry>
    <title>javasript事件类型整理</title>
    <url>/2014/04/01/javascript_event/</url>
    <content><![CDATA[<pre><code>##鼠标键盘事件
onclick             鼠标点击时触发此事件
ondblclick          鼠标双击时触发此事件
onmousedown         按下鼠标时触发此事件
onmouseup             按下鼠标后松开鼠标触发此事件
onmousemove         当鼠标移动时触发此事件
onmouseover         当鼠标移动到某对象范围的上方时触发此事件
onmouseout             当鼠标离开某对象范围时触发此事件
onkeypress             当键盘上某个键被敲下并释放时触发此事件
onkeydown             当键盘上某个键被敲下时触发此事件
onkeyup             当键盘上某个键被释放时触发此事件

##HTML事件
onabort             图片在下载时被用户中断
onbeforeunload         当前页面的内容将要被改变时触发此事件
onerror             出现错误时触发此事件
onload                 页面内容完成时触发此事件
onresize             当浏览器的出口大小被改变时触发此事件
onscroll             当浏览器的滚动条位置发生变化时触发此事件
onstop 当            浏览器的停止按钮被按下时或这在下载的文件被中断时触发此事件
onunload             当前页面将被改动时触发此事件


##表单相关事件
onblur                 当前元素失去焦点时触发此事件
onchange             当前元素失去焦点并且被改变时触发此事件
onfocus             当某个元素获得焦点时触发此事件
onreset             当表单中reset的属性被激发时触发的事件
onsubmit             当表单被提交时触发的事件

##编辑事件
onbeforecopy         页面当前的被选择内容将要复制到浏览者系统的剪切板前触发此事件
onbeforecut         当页面中的一部分或者全部的内容将被移离当前页面并移动到浏览者的系统剪切板时触发此事件
onbeforeeditfocus    当前元素将要进入编辑状态时触发此事件
onbeforepaste        内容将要从浏览者的系统剪切板粘贴到页面中时触发此事件
onbeforeupdate         当浏览者粘贴系统剪切板中的内容时通知目标对象
oncontextmenu         当浏览者按下鼠标右键出现菜单时或者通过键盘的按键触发页面菜单时触发的事件
oncopy                 当页面当前的被选择内容被复制时触发此事件
oncut                 当页面当前的被选择内容被剪切时触发此事件
ondrag                 当某个对象被拖动时触发此事件
ondragdrop             一个外部对象被鼠标拖入当前窗口时触发此事件
ondragend             当鼠标拖动结束时触发此事件
ondragenter         当对象被鼠标拖动的对象进入其容器范围内时触发此事件
ondragleave         当对象被鼠标拖动的对象离开其容器范围内时触发此事件
ondragover             当某被拖动的对象在另一对象容器范围内拖动时触发此事件</code></pre>
<p>以上部分摘录<a href="http://www.cnblogs.com/sosoft/p/3541160.html">此处</a>,有删改.</p>
<p>ps:记得在&lt;&lt;javascript核心技术&gt;&gt;上面看到的是javascript可以分为三类,所以这篇文章权作暂时性摘录.待编辑.</p>
<p>经过资料查阅,分类如下:<br>##UI事件<br>    load 页面完全加载后出发<br>    unload 页面完全卸载后触发<br>    abort 当用户停止下载过程如果嵌入内容未加载完成时触发<br>    error 发生js错误是在window是上出发<br>    select input和texterea中一个多个字符被选择时触发<br>    resize 窗口大小变化时候触发<br>    scroll    页面滚动时触发</p>
<p>##焦点事件<br>    blur 元素失去焦点时候触发<br>    focus 元素捕获焦点时候触发 该事件不冒泡<br>    focusin 是fucus的冒泡版<br>    focusout blue等价事件</p>
<p>##鼠标和滚轮事件<br>    click    单击<br>    dbclick 双击<br>    mousedown 鼠标任意按键落下<br>    mouseenter 鼠标首次从元素外移动到元素内触发 不冒泡<br>    mouseleave mouseenter的相反事件<br>    mouseover 处于元素内部时候始终触发(或者说重复触发) 不能通过键盘触发<br>    mouseout 元素从一个元素上方移动到另一个元素时候触发<br>    mouseup 在用户释放鼠标按键时候触发 不能通过鼠标触发这个事件<br>    mousewheel    滚轮事件</p>
]]></content>
  </entry>
  <entry>
    <title>Javascript的元素运动(一)</title>
    <url>/2014/03/31/animate/</url>
    <content><![CDATA[<h2 id="开始写之前的话"><a href="#开始写之前的话" class="headerlink" title="开始写之前的话"></a>开始写之前的话</h2><p>其实在这篇文章之前写过一次animate,但是再回首时候它几经不堪入目。有些看小时候作文的感觉。那时候把事情想的太复杂。</p>
<p>JS的运动,如果说复杂呢，js运动涉及运动设计到的算法真的是很复杂，然而说简单，其实它在运行机制上，真的很简单很简单。</p>
<h2 id="动画的生成"><a href="#动画的生成" class="headerlink" title="动画的生成"></a>动画的生成</h2><p>想了好久，怎样构成一个动画呢？动画有两种,直线运动和曲线，这里仅仅说直线运动的分类</p>
<ul>
<li>匀速运动</li>
<li>变速运动</li>
</ul>
<p>匀速的运动很好模拟，使用setInterval来模拟，每隔一段时间对物体的位置累加一个相同的单位即可，那么问题来了,变速匀速怎样处理呢？匀速可以累加，而变速运动类型很多，怎样去处理这个加法的变量？</p>
<p>参考了一下开源方案，最后发现其实处理过程中简单归纳起来其实也不外如是，其实和上面的思路是一样的，它使用函数(内部封装Tween算法)来计算这个变量。具体流程是这样的：</p>
<ol>
<li>通过算法计算变量</li>
<li>通过一个postion封装来处理物体位置</li>
<li>通过setInterval来每个一段时间调用postion(传入算法执行后的变量)来更新物体位置</li>
</ol>
<p>在这个过程中,时间是维系和贯穿这个过程的唯一要素，3个过程中都不能缺少它。<br>为了下次不再为物理动画头疼，这里直接用Tween的算法了，即是总结，也是一个加深和记录。</p>
<p>这里先贴一份Tween算法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Tween = &#123;</span><br><span class="line">	linear: <span class="function"><span class="keyword">function</span> (<span class="params">t, b, c, d</span>)</span>&#123;  <span class="comment">//匀速</span></span><br><span class="line">		<span class="keyword">return</span> c*t/d + b; </span><br><span class="line">	&#125;,</span><br><span class="line">	easeIn: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>)</span>&#123;  <span class="comment">//加速曲线</span></span><br><span class="line">		<span class="keyword">return</span> c*(t/=d)*t + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	easeOut: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>)</span>&#123;  <span class="comment">//减速曲线</span></span><br><span class="line">		<span class="keyword">return</span> -c *(t/=d)*(t-<span class="number">2</span>) + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	easeBoth: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>)</span>&#123;  <span class="comment">//加速减速曲线</span></span><br><span class="line">		<span class="keyword">if</span> ((t/=d/<span class="number">2</span>) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> c/<span class="number">2</span>*t*t + b;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -c/<span class="number">2</span> * ((--t)*(t-<span class="number">2</span>) - <span class="number">1</span>) + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	easeInStrong: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>)</span>&#123;  <span class="comment">//加加速曲线</span></span><br><span class="line">		<span class="keyword">return</span> c*(t/=d)*t*t*t + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	easeOutStrong: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>)</span>&#123;  <span class="comment">//减减速曲线</span></span><br><span class="line">		<span class="keyword">return</span> -c * ((t=t/d-<span class="number">1</span>)*t*t*t - <span class="number">1</span>) + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	easeBothStrong: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>)</span>&#123;  <span class="comment">//加加速减减速曲线</span></span><br><span class="line">		<span class="keyword">if</span> ((t/=d/<span class="number">2</span>) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> c/<span class="number">2</span>*t*t*t*t + b;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -c/<span class="number">2</span> * ((t-=<span class="number">2</span>)*t*t*t - <span class="number">2</span>) + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	elasticIn: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d, a, p</span>)</span>&#123;  <span class="comment">//正弦衰减曲线（弹动渐入）</span></span><br><span class="line">		<span class="keyword">if</span> (t === <span class="number">0</span>) &#123; </span><br><span class="line">			<span class="keyword">return</span> b; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ( (t /= d) == <span class="number">1</span> ) &#123;</span><br><span class="line">			<span class="keyword">return</span> b+c; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">			p=d*<span class="number">0.3</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!a || a &lt; <span class="built_in">Math</span>.abs(c)) &#123;</span><br><span class="line">			a = c; </span><br><span class="line">			<span class="keyword">var</span> s = p/<span class="number">4</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> s = p/(<span class="number">2</span>*<span class="built_in">Math</span>.PI) * <span class="built_in">Math</span>.asin (c/a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -(a*<span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">10</span>*(t-=<span class="number">1</span>)) * <span class="built_in">Math</span>.sin( (t*d-s)*(<span class="number">2</span>*<span class="built_in">Math</span>.PI)/p )) + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	elasticOut: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d, a, p</span>)</span>&#123;    <span class="comment">//正弦增强曲线（弹动渐出）</span></span><br><span class="line">		<span class="keyword">if</span> (t === <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> b;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ( (t /= d) == <span class="number">1</span> ) &#123;</span><br><span class="line">			<span class="keyword">return</span> b+c;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">			p=d*<span class="number">0.3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!a || a &lt; <span class="built_in">Math</span>.abs(c)) &#123;</span><br><span class="line">			a = c;</span><br><span class="line">			<span class="keyword">var</span> s = p / <span class="number">4</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> s = p/(<span class="number">2</span>*<span class="built_in">Math</span>.PI) * <span class="built_in">Math</span>.asin (c/a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a*<span class="built_in">Math</span>.pow(<span class="number">2</span>,-<span class="number">10</span>*t) * <span class="built_in">Math</span>.sin( (t*d-s)*(<span class="number">2</span>*<span class="built_in">Math</span>.PI)/p ) + c + b;</span><br><span class="line">	&#125;,    </span><br><span class="line">	elasticBoth: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d, a, p</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (t === <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> b;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ( (t /= d/<span class="number">2</span>) == <span class="number">2</span> ) &#123;</span><br><span class="line">			<span class="keyword">return</span> b+c;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">			p = d*(<span class="number">0.3</span>*<span class="number">1.5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ( !a || a &lt; <span class="built_in">Math</span>.abs(c) ) &#123;</span><br><span class="line">			a = c; </span><br><span class="line">			<span class="keyword">var</span> s = p/<span class="number">4</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> s = p/(<span class="number">2</span>*<span class="built_in">Math</span>.PI) * <span class="built_in">Math</span>.asin (c/a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (t &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> - <span class="number">0.5</span>*(a*<span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">10</span>*(t-=<span class="number">1</span>)) * </span><br><span class="line">					<span class="built_in">Math</span>.sin( (t*d-s)*(<span class="number">2</span>*<span class="built_in">Math</span>.PI)/p )) + b;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a*<span class="built_in">Math</span>.pow(<span class="number">2</span>,-<span class="number">10</span>*(t-=<span class="number">1</span>)) * </span><br><span class="line">				<span class="built_in">Math</span>.sin( (t*d-s)*(<span class="number">2</span>*<span class="built_in">Math</span>.PI)/p )*<span class="number">0.5</span> + c + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	backIn: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d, s</span>)</span>&#123;     <span class="comment">//回退加速（回退渐入）</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> s == <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">		   s = <span class="number">1.70158</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c*(t/=d)*t*((s+<span class="number">1</span>)*t - s) + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	backOut: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d, s</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> s == <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">			s = <span class="number">3.70158</span>;  <span class="comment">//回缩的距离</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c*((t=t/d-<span class="number">1</span>)*t*((s+<span class="number">1</span>)*t + s) + <span class="number">1</span>) + b;</span><br><span class="line">	&#125;, </span><br><span class="line">	backBoth: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d, s</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> s == <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">			s = <span class="number">1.70158</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((t /= d/<span class="number">2</span> ) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> c/<span class="number">2</span>*(t*t*(((s*=(<span class="number">1.525</span>))+<span class="number">1</span>)*t - s)) + b;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c/<span class="number">2</span>*((t-=<span class="number">2</span>)*t*(((s*=(<span class="number">1.525</span>))+<span class="number">1</span>)*t + s) + <span class="number">2</span>) + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	bounceIn: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>)</span>&#123;    <span class="comment">//弹球减振（弹球渐出）</span></span><br><span class="line">		<span class="keyword">return</span> c - Tween[<span class="string">&#x27;bounceOut&#x27;</span>](d-t, <span class="number">0</span>, c, d) + b;</span><br><span class="line">	&#125;,       </span><br><span class="line">	bounceOut: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ((t/=d) &lt; (<span class="number">1</span>/<span class="number">2.75</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> c*(<span class="number">7.5625</span>*t*t) + b;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &lt; (<span class="number">2</span>/<span class="number">2.75</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> c*(<span class="number">7.5625</span>*(t-=(<span class="number">1.5</span>/<span class="number">2.75</span>))*t + <span class="number">0.75</span>) + b;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &lt; (<span class="number">2.5</span>/<span class="number">2.75</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> c*(<span class="number">7.5625</span>*(t-=(<span class="number">2.25</span>/<span class="number">2.75</span>))*t + <span class="number">0.9375</span>) + b;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c*(<span class="number">7.5625</span>*(t-=(<span class="number">2.625</span>/<span class="number">2.75</span>))*t + <span class="number">0.984375</span>) + b;</span><br><span class="line">	&#125;,      </span><br><span class="line">	bounceBoth: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (t &lt; d/<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> Tween[<span class="string">&#x27;bounceIn&#x27;</span>](t*<span class="number">2</span>, <span class="number">0</span>, c, d) * <span class="number">0.5</span> + b;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Tween[<span class="string">&#x27;bounceOut&#x27;</span>](t*<span class="number">2</span>-d, <span class="number">0</span>, c, d) * <span class="number">0.5</span> + c*<span class="number">0.5</span> + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里说下参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">t: current time（当前时间）</span><br><span class="line">b: beginning value（初始值）</span><br><span class="line">c: change <span class="keyword">in</span> value（变化量）</span><br><span class="line">d: duration（持续时间）</span><br><span class="line">个别算法有其他参数，这里仅就共通处做总结	</span><br></pre></td></tr></table></figure>

<p>这个不太好理解到底怎么用了，我们来个场景：<br>现在div#ABC中有个div#move,ABC我相对定位，move为绝对定位且top和left均为0；现在要开始一次运动：<br>move要在1s内从left:0运行到left:500px的位置。<br>那么现在t、b、c、d到底是多少呢？t=0，b=0，c=500-0=500，d=1000(ms)</p>
<p><a class="jsbin-embed" href="http://jsbin.com/wonowu/embed?js,output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.5"></script></p>
<p>可以看到这个DEMO中的例子,这里基本仅仅是用的命令式编程没考虑什么复用性，但是整个过程中还是分成了上面说到的三个步骤：算法计算位置，postion函数处理css定位,setIntereval处理按帧刷新。</p>
<p>这作为第一篇就这样了，这一篇仅仅作为<b>变速运动</b>的上手,虽然没法理解Tween算法的意义，但是数学作为科学的基础，交给专业的人处理就好了，我目前仅仅打算做个安静的FrontEnder用全部精力来紧跟前端潮流。</p>
<p>下一篇有时间再总结一下关于运动的其他知识点，这里列一下：</p>
<ol>
<li>动画基础理论：刷新率&amp;setTimeout和setInterval精度</li>
<li>曲线运动和算法整理</li>
<li>结合闭包做一个可以复用的动画封装</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>github学习笔记</title>
    <url>/2014/03/22/github_learn/</url>
    <content><![CDATA[<h1 id="创建一个git库"><a href="#创建一个git库" class="headerlink" title="创建一个git库"></a>创建一个git库</h1><pre><code>1.进入目录clone
cd dir
git clone https://github.com/que01/github

2.直接clone到目录
git clone https://github.com/que01/github dir</code></pre>
<h1 id="初始化一个git库"><a href="#初始化一个git库" class="headerlink" title="初始化一个git库"></a>初始化一个git库</h1><pre><code>git init</code></pre>
<h1 id="初始化空repo后push前需要设置云端url"><a href="#初始化空repo后push前需要设置云端url" class="headerlink" title="初始化空repo后push前需要设置云端url#"></a>初始化空repo后push前需要设置云端url#</h1><pre><code>git remote set-url origin ssh://newhost.com/usr/local/gitroot/myproject.git`</code></pre>
<blockquote>
<p>或者更改.gitconfig</p>
</blockquote>
<pre><code>[remote &quot;origin&quot;]
fetch = +refs/heads/*:refs/remotes/origin/*
url = ssh://xxxxxxxxxxxx/xxxxxxxx.git</code></pre>
<h1 id="本地库修改提交"><a href="#本地库修改提交" class="headerlink" title="本地库修改提交"></a>本地库修改提交</h1><p>文件修改直接修改即可</p>
<p>#快照(暂存区修改)#</p>
<pre><code>git add             //添加文件到缓存区
git add .             //添加所有改变文件,ps:任何未改变文件都不会被包含
git add new.html     //添加nesw.html到缓存</code></pre>
<hr>
<p>#状态#</p>
<pre><code> git status            //详细状态 
 git status -s        //简单状态</code></pre>
<p>#改动#</p>
<pre><code>git diff            //尚未add的改动
git diff --cached     //查看已缓存的改动(暂存区同最近一次提交对比)
git diff HEAD       //工作区同最近一次提交对比(仅仅文件改动对比,工作区新加文件不会进行对比)</code></pre>
<p>#提交#</p>
<pre><code>git commit -a         //自动将在提交前将已记录、修改的文件放入缓存区,跳过add修改文件，但新文件仍然需要add
git commit -am &#39;the changes in this&#39;    //修改的备注</code></pre>
<h1 id="云端建立分支"><a href="#云端建立分支" class="headerlink" title="云端建立分支"></a>云端建立分支</h1><pre><code>git remote add origin https://github.com/user_name/repository_name.git</code></pre>
<p>#”时空穿梭”#<br>这里用到两个命令： git reset&amp;git reflog<br>git reset –head + 哈希散列数值(前几位即可)可以进行穿梭 —&gt; 这里可以向前也可以向后,但是向前以后无法在git log看到以前的哈希散列值</p>
<p>这时候就轮到git relog出场了,他可以记录HEAD位置移动,这里可以看到移动前后的哈希值</p>
<p>所以向前之后找不到向后的散列值可以通过它查询到向后的散列值.拿到散列值以后有两个方式来进行向后</p>
<pre><code>git reset --hard 哈希值
git reset --hard HEAD@&#123;n&#125;  //这里的n代表向前几次</code></pre>
]]></content>
  </entry>
  <entry>
    <title>前端开发环境探析-补充</title>
    <url>/2014/03/20/evn_for_webfrontend_2/</url>
    <content><![CDATA[<p>###补充一下昨天的开发环境<br>昨天说到的开发环境是从宏观上进行的配置，涉及到的都是大方向的设置，如平台选择，软件运行在哪个平台选择(跨平台软件未必体验一致)<br></p>
<p>###编辑器选择<br>这个大家应该有很多选择了，我不多说，个人是vim拥护者，现在sublime也在用，主要看它插件比较多<br></p>
<p>###实时刷新方案<br>昨天博文说的是，grunt和服务器环境设置到linux，这样对没有这样做的人，就目前实时刷新方案来说未免陌生。我说下个人解决方案。<br></p>
<pre><code>1.samba 
    通过samba来实现linux文件交互
2.bat批处理&lt;br&gt;
    之所以如此，是因为可以每次开机在浏览器栏输入“\\192.XXX.XXX.XXX”
    但毕竟不便&lt;br&gt;
    因此找了一个批处理文件，如下
    net use Z: \\192.168.128.128\d &quot;samba密码&quot; /user:&quot;samba用户名&quot;
    使用时候保存到txt文档，然后改后缀至bat即可
3.F5免刷新
    这个大家可能用的比较多了，通过批处理可以把samba映射到磁盘，这样就和原来一样用了</code></pre>
<p>###结语<br>好了，这篇博文算碎碎念，是个补充，不赘述。希望对看到的人是个参考</p>
]]></content>
  </entry>
  <entry>
    <title>前端开发环境探析</title>
    <url>/2014/03/19/evn_for_webfrontend/</url>
    <content><![CDATA[<p>###前端开发环境要求<br>前端是一个复杂工种，这一点已经无需我重复了。前端的工作其实说简单也简单，无非处理页面表现而已；然而说复杂也复杂，因为页面表现的实现和可复用性都是前端需要考虑的，通通纳入其中。我写这篇博文时，就是立足于这个复杂的前段开发背景。<br /><br>这里简单说一下前端对开发环境的需求：<br /></p>
<pre><code>    1.web页面浏览调试需求&lt;br /&gt;
    2.IDE需求&lt;br /&gt;
    3.Ajax异步通信需求&lt;br /&gt;
    4.自动化处理工具的需求&lt;br /&gt;
    5.轻量级需求&lt;br /&gt;</code></pre>
<p>当然，这不是业内公论，仅仅是自己在web前端工程中的体悟。<br /></p>
<p>###web调试需求<br>这个不用多说ie，ff，chrome等等。。。一入前端，便是进入了N个版本浏览器的海洋,不如此不能写出更具有可用性的web页面。<br /><br>所以ms系的系统不可或缺。</p>
<p>###IDE需求<br>这个仅仅简单提一下，因为个人不用发言权不高，目前各种IDE支持首选的还是MS系系统。</p>
<p>###Ajax异步通信需求<br>这个对环境要求不高，ms和linux系系统都能完美胜任之，方案很多，LAMP，iis+php，apache+php都可以，加上mysql数据库也很容易，系统占用也不算高。</p>
<p>###自动化处理工具<br>随着NodeJs的出现和渐渐流行，自动化处理工具入Grunt因为其符合人的懒惰特性也渐渐流行起来，但是这些工具多数依赖NodeJs或者ruby，众所周知，Nodejs和ruby在linux系系统上才能发挥到最佳状态，在MS下安装了NodeJs和ruby，它们分别有自己的控制台，操作殊为不便。而且控制台很多时候不能复制粘贴。。。这是要一个字符一个字符敲的节奏。。。所以，自动化处理工具首选linux系。</p>
<p>###轻量级需求<br>恩，我所说的轻量级，是指系统必须跑得飞快，如我，对等待这种效率浪费的事情往往是不能忍的。综上文，前端开发过程中MS系统必须有，这个是硬性需求，Linux系统也最好有，这个便利性的需求，而且LAMP也的确是跑服务器环境的好选择。<br /><br>这种情况下，只能一个宿主机，然后一个虚拟机了，不过谁宿主谁虚拟，这个有待商榷。不过按照我个人经验来说，宿主MS加linxu虚拟(CLI命令行环境)是最符合轻量级理念的环境。Linux下虚拟机跑MS系统实在太卡（个人NOTEBOOK上I3+4G DDR3 1333）。</p>
<p>###个人最终环境<br>1.宿主和虚拟选择 <br /></p>
<pre><code>win7 64bit 作为宿主
Centos 6.5 mini 64bit 作为虚拟</code></pre>
<p>###最后说下GitHub<br>虽然GitHub现在有了Win版本，但是相对来说，那个GUI显然没有CLI功能全面，我在win下都是用的GitHub Shell。linux下则可直接使用git命令行，这个很方便。</p>
<p>2.宿主和虚拟环境配置<br /></p>
<pre><code>win7 64bit
    PS|sublime-text|GVim|IE6-IE10/IETest|GitHub|Putty|winscp
centos 64bit &lt;br /&gt;
    Samba|LAMP|Nodejs|ruby|Grunt </code></pre>
<p>简单说下这个配置，win下的配置大家应该都明白，需要说明的大概就winscp了，这个是win下使用sftp连接linux的软件，可以直接root访问linux处理文件,单文件修改可以直接编辑，保存后直接提交到服务器。<br /><br>Linux下Samba是为了可以直接在资源管理通过ip来访问linux数据，这个很多时候还是很要紧的，Cli处理文件有时候真的是很捉急。。。LAMP这个不多说，linux下PHP环境的首选，当然LNMP最近也很流行。至于NodeJs|ruby|Grunt工具我前文已经说过，再次不赘述。<br /></p>
<p>###结语<br>目前来说，个人的配置就是这样，纵览互联网，暂时也没听说其他更好方案来解决WebFrontEnder的开发环境困惑，当初学前端时候，前辈说一个现代一点的文本编辑器如notepad++便可，但是到如今，这个已经很难处理WebFrontEnder的业务流了，他们要处理图片要处理css布局要hach Css要ajax数据交互要N个版本调试页面，更高要求的公司甚至可能要求建设自己的前端框架。。。<br /><br>所以，应该需要一个好用一点的开发环境的了。它应该功能全面满足硬性需求，应该先进满足便利性和性能要求，应该轻量考虑开发人员心情。因此,我写了这篇文章。<br /><br>谨以此文献给奋战在前端一线的筒子们。。。</p>
]]></content>
  </entry>
</search>
