<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Microsoft YaHei, Verdana, sans-serif:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.que01.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"AL4M83H31B","apiKey":"d30226bc78f2b15b834d9fc9993e3c42","indexName":"hexo","hits":{"per_page":10}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"bounceDownIn","post_body":"bounceDownIn","coll_header":"slideLeftIn","sidebar":"fadeInUp"}},"path":"search.xml"};
  </script>

  <meta name="description" content="react Event笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="react Event">
<meta property="og:url" content="http://www.que01.top/2018/06/10/react-event/index.html">
<meta property="og:site_name" content="Que&#39;s Blog">
<meta property="og:description" content="react Event笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.que01.top/images/20180906111656.png">
<meta property="og:image" content="http://www.que01.top/images/react-event-save.png">
<meta property="og:image" content="http://www.que01.top/images/react-event-dispatch.png">
<meta property="og:image" content="http://www.que01.top/images/react-event-system.png">
<meta property="article:published_time" content="2018-06-09T16:00:00.000Z">
<meta property="article:modified_time" content="2020-12-17T13:21:55.000Z">
<meta property="article:author" content="que01">
<meta property="article:tag" content="react">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.que01.top/images/20180906111656.png">

<link rel="canonical" href="http://www.que01.top/2018/06/10/react-event/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>react Event | Que's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Que's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">WebFrontEnd Development</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.que01.top/2018/06/10/react-event/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="que01">
      <meta itemprop="description" content="自己的学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Que's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          react Event
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-10 00:00:00" itemprop="dateCreated datePublished" datetime="2018-06-10T00:00:00+08:00">2018-06-10</time>
            </span>

          
            <span id="/2018/06/10/react-event/" class="post-meta-item leancloud_visitors" data-flag-title="react Event" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <div class="post-description">react Event笔记</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h1><p>这里暂时不做高屋建瓴式的解读直接给出关键文件。而是从之前已有的分析开始，尝试自己蛛丝马迹找出来。</p>
<p>既然是事件绑定，那么必然在<code>ReactDom.render</code>的环节里面有处理。所以这里简单回顾然后把它挖出来。</p>
<p>我们知道React在浏览器的运行时里面的渲染存在两种情况，一种是第一次的初次渲染，一种是props更新带来的更新。</p>
<p>当我们说事件的时候，我们是在说谁的事件？之前分析已经提到了调度函数ReactReconciler返回的几种实例：<code>ReactDOMEmptyComponent</code>、<code>ReactDOMComponent</code>实例、<code>ReactCompositeComponentWrapper</code>实例。</p>
<p>那么回想一下，当我们绑定事件的时候第一次渲染里面必然会有，props和state更新时候我们的React事务也会这样做(清场和现场还原)。</p>
<p>这个操作呢，第一次渲染时候大抵在<code>ReactCompositeComponentWrapper.mountComponent</code>里面，它可能是这个组件上绑定，再不济也应该是在其children中绑定，后面的渲染，则大抵在<code>ReactUpdates.js</code>的<code>ReactUpdatesFlushTransaction</code>中。</p>
<p>不过整体按React抽象至死的尿性，显然最后都会殊途同归。不过这里还是尝试整理一下两条路线下的调用路径。</p>
<h2 id="mountComponent路径"><a href="#mountComponent路径" class="headerlink" title="mountComponent路径"></a>mountComponent路径</h2><p>这里不再重复贴代码,如果读到这里的时候没有看过之前的分析,也没有自己打开IDE debug过，其实这篇文章读与不读，本质上区别不大。</p>
<p>这个函数代码不多，配合这个函数的注释简直确认了我自己猜测的注释:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes the component, renders markup, and registers event listeners.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ReactReconcileTransaction|ReactServerRenderingTransaction&#125;</span> <span class="variable">transaction</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;?object&#125;</span> <span class="variable">hostParent</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;?object&#125;</span> <span class="variable">hostContainerInfo</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;?object&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;?string&#125;</span> </span>Rendered markup to be inserted into the DOM.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@final</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>简单分析<code>ReactCompositeComponent.mountComponent</code>可以很容易知道这里的事件绑定,下一步路径是<code>ReactCompositeComponentWrapper.performInitialMount</code>。</p>
<p>在这个函数内</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">this</span>._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY <span class="comment">/* shouldHaveDebugID */</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">this</span>._renderedComponent = child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, <span class="built_in">this</span>._processChildContext(context), debugID);</span><br></pre></td></tr></table></figure>

<p>child是自定义函数里面的render里面的子组件，他的type是一个string，这样调度模块使用ReactDOMComponent.mountComponent来定义这块。</p>
<p>回顾一下<code>ReactDOMComponent._updateDOMProperties</code> 里面提到的<code>enqueuePutListener</code>，这里是事件注册的关注点。这个函数里面进行绑定的关键代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listenTo(registrationName, doc);</span><br><span class="line">transaction.getReactMountReady().enqueue(putListener, &#123;</span><br><span class="line">  inst: inst,</span><br><span class="line">  registrationName: registrationName,</span><br><span class="line">  listener: listener,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里事件绑定到document上，然后使用putListener来进行事件绑定。</p>
<p>其中<code>listenTo</code>指向<code>ReactBrowserEventEmitter.listenTo</code>，<code>putListener</code>指向<code>EventPluginHub.putListener</code>。</p>
<h2 id="props更新路径"><a href="#props更新路径" class="headerlink" title="props更新路径"></a>props更新路径</h2><p>参考之前lifecycle里面props更新环节的render分析和<code>ReactCompositeComponent._updateRenderedComponent</code>分析。这里的定位分析点是起始点<code>ReactCompositeComponent._updateRenderedComponent</code>。</p>
<p>这里有替换和更新两个分支 我们这里只谈更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReactReconciler.receiveComponent(</span><br><span class="line">  prevComponentInstance,</span><br><span class="line">  nextRenderedElement,</span><br><span class="line">  transaction,</span><br><span class="line">  <span class="built_in">this</span>._processChildContext(context),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>和之前同样的道理，定位到<code>ReactDOMComponent.receiveComponent</code>。一路顺着</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOMComponent.receiveComponent</span><br><span class="line">	-&gt; ReactDOMComponent.updateComponent</span><br><span class="line">		-&gt; ReactDOMComponent._updateDOMProperties</span><br></pre></td></tr></table></figure>

<p>的路径，显然，最初的猜测一点没错。</p>
<h2 id="补充-amp-旁白"><a href="#补充-amp-旁白" class="headerlink" title="补充 &amp; 旁白"></a>补充 &amp; 旁白</h2><p>这里两个路径的探索，说白了还是从断点角度的摸索，属于从下往上的摸索。虽然可以摸清楚这些，但是实际上不是最好的办法。</p>
<p>但是如果可以对虚拟DOM节点、render、和Diff路径有相对清晰的了解和认知，那么当可以从顶层设计上对这个<code>ReactDOMComponent._updateDOMProperties</code>函数进行定位。</p>
<p>如果非要一个思路，这里可以这样思考:</p>
<ul>
<li>Diff算法实质上除了’移动’，不存在实质意义上的’更新’，这个更新本质是删除旧的+替换新的。</li>
<li>不管是初始render还是替换，都需要对一个新的ReactDomCompositeComponent进行实例化备用。</li>
<li>这个过程中终究会伴随<code>_updateDOMProperties</code>函数调用。</li>
<li>这个<code>_updateDOMProperties</code>函数，是自定义组件渲染为ReactDOMComponent的核心调用。</li>
</ul>
<h1 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h1><h2 id="事件保存-amp-amp-绑定"><a href="#事件保存-amp-amp-绑定" class="headerlink" title="事件保存 &amp;&amp; 绑定"></a>事件保存 &amp;&amp; 绑定</h2><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>事件保存主要是走的<code>EventPluginHub.putListener</code>,将putListener保存到了listenerBank。具体一点来说，是将事件放到了<code>listenerBank[registrationName][getDictionaryKey(inst)]</code>。这里<code>getDictionaryKey</code>的返回值是<code>&#39;.&#39; + inst._rootNodeID</code>。</p>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>来自ReacDomComponent.js文件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueuePutListener</span>(<span class="params">inst, registrationName, listener, transaction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (transaction <span class="keyword">instanceof</span> ReactServerRenderingTransaction) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> containerInfo = inst._hostContainerInfo;</span><br><span class="line">  <span class="keyword">var</span> isDocumentFragment =</span><br><span class="line">    containerInfo._node &amp;&amp; containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;</span><br><span class="line">  <span class="keyword">var</span> doc = isDocumentFragment</span><br><span class="line">    ? containerInfo._node</span><br><span class="line">    : containerInfo._ownerDocument;</span><br><span class="line">  listenTo(registrationName, doc);</span><br><span class="line">  transaction.getReactMountReady().enqueue(putListener, &#123;</span><br><span class="line">    inst: inst,</span><br><span class="line">    registrationName: registrationName,</span><br><span class="line">    listener: listener,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个绑定是由<code>listenTo(registrationName, doc)</code>处理的，直接把事件绑定到document，利用事件冒泡性质来进行事件委托处理。这个listenTo实际上就是<code>ReactBrowserEventEmitter.listenTo</code>。</p>
<h2 id="事件触发-amp-amp-分发"><a href="#事件触发-amp-amp-分发" class="headerlink" title="事件触发 &amp;&amp; 分发"></a>事件触发 &amp;&amp; 分发</h2><p><strong>事件触发</strong>这个实际上在上一小结就提到了，当事件在某个元素上触发，会冒泡到document，然后document开始触发相关逻辑。</p>
<p><strong>事件分发</strong>主要是通过<code>ReactBrowserEventEmitter.listenTo</code>处理。这里关于浏览器兼容有点多，不过这里管住核心代码就好。这里的<code>listenTo</code>有两个核心调用, 都在<code>ReactBrowserEventEmitter.ReactEventListener</code>上。</p>
<h3 id="ReactEventListener"><a href="#ReactEventListener" class="headerlink" title="ReactEventListener"></a>ReactEventListener</h3><ul>
<li>trapBubbledEvent</li>
<li>trapCapturedEvent</li>
</ul>
<p>看看它们引用到的listen和capture中的listen(React 15.6是支持冒泡+捕获两种事件传播的,具体参考traverseTwoPhase函数，但是这仅仅是传播的支持，并没有具体实现这个捕获事件触发)。这里就是我们熟悉的原生API了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">listen: <span class="function"><span class="keyword">function</span> (<span class="params">target, eventType, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target.addEventListener) &#123;</span><br><span class="line">    target.addEventListener(eventType, callback, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      remove: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        target.removeEventListener(eventType, callback, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target.attachEvent) &#123;</span><br><span class="line">    target.attachEvent(<span class="string">&#x27;on&#x27;</span> + eventType, callback);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      remove: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        target.detachEvent(<span class="string">&#x27;on&#x27;</span> + eventType, callback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意的是我们这里的addEventListener是在DOM层级上触发的，当我们触发了这个事件，接下来需要找到我们保存的回调函数，不然这个触发就毫无意义。</p>
<p>以<code>trapBubbledEvent</code>为例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">trapBubbledEvent: <span class="function"><span class="keyword">function</span>(<span class="params">topLevelType, handlerBaseName, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!element) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EventListener.listen(</span><br><span class="line">    element,</span><br><span class="line">    handlerBaseName,</span><br><span class="line">    ReactEventListener.dispatchEvent.bind(<span class="literal">null</span>, topLevelType),</span><br><span class="line">  );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这里传入到listen中的事件回调是<code>ReactEventListener.dispatchEvent.bind(null, topLevelType)</code></p>
<p><strong>首先，这里有个十分重要的地方需要注意，那就是这个<code>element</code>变量。这个element常规情况下直接指向的document对象。也就是说，事件绑定在document上了</strong>。这可以方便整体的事件管理，原理同大家用过的Jquery事件委托。</p>
<p>其次，这里进一步看看<code>ReactEventListener.dispatchEvent</code>的基础定义:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatchEvent: <span class="function"><span class="keyword">function</span> (<span class="params">topLevelType, nativeEvent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ReactEventListener._enabled) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    TopLevelCallbackBookKeeping.release(bookKeeping);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>EventListener.listen</code>本质上还是<code>addEventListener</code>的封装,所以作为回调的函数<code>ReactEventListener.dispatchEvent.bind(null, topLevelType)</code>它会被传入一个event事件对象 ,这个对象会被作为nativeEvent参数传入到<code>TopLevelCallbackBookKeeping</code>。<strong>然后就是重点了</strong>: <code>event</code>对象中有触发的DOM node节点引用，这点非常重要，只有如此，我们才可以进一步在虚拟DOM树中获取到需要触发冒泡捕获的所有节点，这点同样非常重要。</p>
<p>PS: 除了这里常规的事件委托，关于<code>SimpleEventPlugin.putListener</code>可以了解一下。</p>
<h4 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a>dispatchEvent</h4><p><code>ReactEventListener.dispatchEvent</code>这里做的事情显然是触发我们定义好的回调，我们所有的事件绑定的回调函数都被储存在一个集中的地方，那么我们现在看看它如何从这个集合中正确找出我们需要的事件回调。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatchEvent: <span class="function"><span class="keyword">function</span>(<span class="params">topLevelType, nativeEvent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ReactEventListener._enabled) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> bookKeeping = TopLevelCallbackBookKeeping.getPooled(</span><br><span class="line">    topLevelType,</span><br><span class="line">    nativeEvent,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Event queue being processed in the same cycle allows</span></span><br><span class="line">    <span class="comment">// `preventDefault`.</span></span><br><span class="line">    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    TopLevelCallbackBookKeeping.release(bookKeeping);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>关于<code>ReactUpdates.batchedUpdates</code>之前在render相关文章里面有分析，这里不做更多分析，这里的关键是<code>handleTopLevelImpl</code></p>
<h4 id="handleTopLevelImpl"><a href="#handleTopLevelImpl" class="headerlink" title="handleTopLevelImpl"></a>handleTopLevelImpl</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleTopLevelImpl</span>(<span class="params">bookKeeping</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);</span><br><span class="line">  <span class="comment">// 关于这个函数 用于从原生元素上获取最近的上级ReactNode实例</span></span><br><span class="line">  <span class="keyword">var</span> targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(</span><br><span class="line">    nativeEventTarget,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Loop through the hierarchy, in case there&#x27;s any nested components.</span></span><br><span class="line">  <span class="comment">// It&#x27;s important that we build the array of ancestors before calling any</span></span><br><span class="line">  <span class="comment">// event handlers, because event handlers can modify the DOM, leading to</span></span><br><span class="line">  <span class="comment">// inconsistencies with ReactMount&#x27;s node cache. See #1105.</span></span><br><span class="line">  <span class="comment">// 提前缓存祖先组件，因为事件回调可能会中途修改它，导致无法找对正确对应ReactNode实例</span></span><br><span class="line">  <span class="keyword">var</span> ancestor = targetInst;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    bookKeeping.ancestors.push(ancestor);</span><br><span class="line">    ancestor = ancestor &amp;&amp; findParent(ancestor);</span><br><span class="line">  &#125; <span class="keyword">while</span> (ancestor);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookKeeping.ancestors.length; i++) &#123;</span><br><span class="line">    targetInst = bookKeeping.ancestors[i];</span><br><span class="line">    ReactEventListener._handleTopLevel(</span><br><span class="line">      bookKeeping.topLevelType,</span><br><span class="line">      targetInst,</span><br><span class="line">      bookKeeping.nativeEvent,</span><br><span class="line">      getEventTarget(bookKeeping.nativeEvent),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>do~while</code>先缓存target触发事件那一瞬的所有父组件，这是一个数组，从左到右，右边的是左边的父组件。<strong>这里i从0起，其实也就是事实上走了从子到父的路径，也就是说，只有冒泡被实现了</strong>。这里<code>_handleTopLevel</code>指向<code>ReactEventEmitterMixin.handleTopLevel</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">handleTopLevel: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  topLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> events = EventPluginHub.extractEvents(</span><br><span class="line">    topLevelType,</span><br><span class="line">    targetInst,</span><br><span class="line">    nativeEvent,</span><br><span class="line">    nativeEventTarget,</span><br><span class="line">  );</span><br><span class="line">  runEventQueueInBatch(events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有<code>extractEvents</code>从注册的事件里面将目标事件取出，然后调用<code>runEventQueueInBatch</code>批量执行回调。其内容仍旧是<code>EventPluginHub</code>上的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventPluginHub.enqueueEvents(events);</span><br><span class="line">EventPluginHub.processEventQueue(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>接下来看看这两个函数细节。enqueueEvents作用相对简单，维护<code>EventPluginHub.eventQueue</code>变量确保其是一个事件组成的一维数组(也可能是null)。</p>
<p>processEventQueue函数则是触发所有事件，将事件清空，并抛出其运行时的错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">processEventQueue: <span class="function"><span class="keyword">function</span>(<span class="params">simulated</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> processingEventQueue = eventQueue;</span><br><span class="line">  eventQueue = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (simulated) &#123;</span><br><span class="line">    forEachAccumulated(</span><br><span class="line">      processingEventQueue,</span><br><span class="line">      executeDispatchesAndReleaseSimulated,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    forEachAccumulated(</span><br><span class="line">      processingEventQueue,</span><br><span class="line">      executeDispatchesAndReleaseTopLevel,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  ReactErrorUtils.rethrowCaughtError();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这里<code>executeDispatchesAndReleaseSimulated</code>、<code>executeDispatchesAndReleaseTopLevel</code>都是调用的<code>executeDispatchesAndRelease</code>只不过一个传入了true参数，一个传入了false参数。</p>
<p>一路深入这个函数的调用栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">executeDispatchesAndRelease</span><br><span class="line">-&gt;EventPluginUtils.executeDispatchesInOrder</span><br><span class="line">--&gt;executeDispatch</span><br><span class="line">---&gt;invokeGuardedCallback</span><br></pre></td></tr></table></figure>

<p>其实他们最终调用到的都是同一个函数<code>invokeGuardedCallback</code>。这个函数作用就是直接执行eventHandle,并捕获错误，没别的作用了。</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>前面分析的都是具体的路径，不过总归对触发还是需要一个原理上的总结。</p>
<p>我们知道事件在DOM中的传播是先从外层逐层捕获，然后从里层逐层冒泡。这个过程涉及到的DOM层实际上就是触发事件的target node,和其上级的各个父祖元素。这是其一。</p>
<p>其二，当冒泡捕获发生以后，会在各个父祖元素上也触发对应的事件回调。</p>
<p>其三，当我们在document上触发事件时候，事件回调会被传入一个event对象，这个event对象里面会有触发事件的target node(HTMLElement)的引用，配合ReactDOMComponentTree的API或者其他，总之精确获取到要触发冒泡的目标组件集合就可以做到顺手拈来。</p>
<p>最后，触发的那瞬间在储存的事件集合里面找到对应<code>inst._rootNodeID</code>的事件并触发即可。当然，这里的触发也会进行批处理优化(runEventQueueInBatch)。</p>
<p>这就是整体的原理。至于细节，可以慢慢从上面的分析上思考。</p>
<h1 id="源码细节"><a href="#源码细节" class="headerlink" title="源码细节"></a>源码细节</h1><h2 id="EventPluginHub"><a href="#EventPluginHub" class="headerlink" title="EventPluginHub"></a>EventPluginHub</h2><table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>putListener</td>
<td>保存listener到集合</td>
</tr>
<tr>
<td>getListener</td>
<td>从集合中获取listener</td>
</tr>
<tr>
<td>deleteListener</td>
<td>从集合删除这个listener</td>
</tr>
<tr>
<td>deleteAllListeners</td>
<td>移除集合里面所有listener</td>
</tr>
<tr>
<td>extractEvents</td>
<td>允许已注册插件从浏览器原生事件获取已注册事件</td>
</tr>
<tr>
<td>enqueueEvents</td>
<td>将事件排队推入一个合成事件中，在processEventQueue执行时触发</td>
</tr>
<tr>
<td>processEventQueue</td>
<td>执行事件队列上的所有合成事件</td>
</tr>
</tbody></table>
<h3 id="extractEvents"><a href="#extractEvents" class="headerlink" title="extractEvents"></a>extractEvents</h3><p>extractEvents方法可能是整个流程中比较影响深入理解的，这里简单分析一下。</p>
<p>这个函数实质上遍历<code>EventPluginRegistry.plugins</code>,然后通过根据其内部的plugin自身的<code>extractEvents</code>方法来获取事件。以<code>SimpleEventPlugin</code>为例。这里假设<code>TopLevelTypes === ‘topError’ </code>。此时这个代码的逻辑就相当于:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = SyntheticEvent(</span><br><span class="line">	dispatchConfig,</span><br><span class="line">  targetInst,</span><br><span class="line">  nativeEvent,</span><br><span class="line">  nativeEventTarget</span><br><span class="line">)</span><br><span class="line">EventPropagators.accumulateTwoPhaseDispatches(event);</span><br><span class="line"><span class="keyword">return</span> event;</span><br></pre></td></tr></table></figure>

<p>此时event的数据结构是这样的</p>
<p><img src="/images/20180906111656.png"></p>
<p><code>EventPropagators.accumulateTwoPhaseDispatches(event)</code>顺藤摸瓜则指向了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventPluginUtils.traverseTwoPhase(</span><br><span class="line">  event._targetInst,</span><br><span class="line">  accumulateDirectionalDispatches,</span><br><span class="line">  event,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其最终的指向则是<code>ReactDOMTreeTraversal.traverseTwoPhase</code>,这个函数模拟冒泡/捕获环节的事件分发的遍历行为，实质上它是获取所有父元素得到数组(索引升序对应更上层的父元素)，先降序遍历触发捕获回调，然后升序遍历触发冒泡回调的过程。而这个回调则指向了<code>accumulateDirectionalDispatches</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accumulateDirectionalDispatches</span>(<span class="params">inst, phase, event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> listener = listenerAtPhase(inst, event, phase);</span><br><span class="line">  <span class="keyword">if</span> (listener) &#123;</span><br><span class="line">    event._dispatchListeners = accumulateInto(</span><br><span class="line">      event._dispatchListeners,</span><br><span class="line">      listener,</span><br><span class="line">    );</span><br><span class="line">    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数整体来说做了两件事就是操作<code>event._dispatchListeners &amp;&amp; event._dispatchInstances</code>。</p>
<p>在之前我们提到<code>traverseTwoPhase</code>是冒泡捕获的遍历过程的模拟，对应的说这里的<code>phase</code>参数就是这个过程的标志，<code>captured</code>和<code>bubbled</code>是其可选值。之所以有这个参数 就是因为在不同阶段对应的listener并不一样。**<code>listenerAtPhase</code>实质上调用<code>EventPluginHub.getListener</code>来获取这个listener**。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除了这些，这里还有一个injection方法，通过<code>EventPluginRegistry</code>上的方法来进行一些依赖注入。</p>
<p>这个注入还是在之前见过很多次的<code>ReactDefaultInjection.js</code>里面。这里整体代码是这样的，为了方便阅读有简单修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ReactInjection.EventPluginHub.injectEventPluginOrder([</span><br><span class="line">  <span class="string">&#x27;ResponderEventPlugin&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;SimpleEventPlugin&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;TapEventPlugin&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;EnterLeaveEventPlugin&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;ChangeEventPlugin&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;SelectEventPlugin&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;BeforeInputEventPlugin&#x27;</span>,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">ReactInjection.EventPluginHub.injectEventPluginsByName(&#123;</span><br><span class="line">  SimpleEventPlugin: SimpleEventPlugin,</span><br><span class="line">  EnterLeaveEventPlugin: EnterLeaveEventPlugin,</span><br><span class="line">  ChangeEventPlugin: ChangeEventPlugin,</span><br><span class="line">  SelectEventPlugin: SelectEventPlugin,</span><br><span class="line">  BeforeInputEventPlugin: BeforeInputEventPlugin,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="EventPluginRegistry"><a href="#EventPluginRegistry" class="headerlink" title="EventPluginRegistry"></a>EventPluginRegistry</h2><p>EventPluginHub是一个Hub，更多时候它只是一个调度。而EventPluginRegistry，是EventPlugin实际上的数据源，上面提到的注入实际上还是注入到这里，所以还是看看里面东西。</p>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>injectEventPluginOrder</td>
<td>注入 插件排序的次序表 这里仅仅是插件名称(Array)</td>
</tr>
<tr>
<td>injectEventPluginsByName</td>
<td>注入 插件本体 这个必须在次序表中</td>
</tr>
<tr>
<td>getPluginModuleForEvent</td>
<td>查找提供的事件的plugin</td>
</tr>
<tr>
<td>_resetEventPlugins</td>
<td>单元测试专用API</td>
</tr>
</tbody></table>
<h1 id="总结-amp-思考"><a href="#总结-amp-思考" class="headerlink" title="总结&amp;思考"></a>总结&amp;思考</h1><p>关于React的事件系统实际上源码里面(<code>ReactBrowserEventEmitter</code>)有注释，并且还有一个流程图示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Summary of `ReactBrowserEventEmitter` event handling:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - Top-level delegation is used to trap most native browser events. This</span></span><br><span class="line"><span class="comment"> *    may only occur in the main thread and is the responsibility of</span></span><br><span class="line"><span class="comment"> *    ReactEventListener, which is injected and can therefore support pluggable</span></span><br><span class="line"><span class="comment"> *    event sources. This is the only work that occurs in the main thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - 顶级委派用于捕获大多数本机浏览器事件。 </span></span><br><span class="line"><span class="comment"> *	  这可能只发生在主线程中 并且这是ReactEventListener的主要职责。</span></span><br><span class="line"><span class="comment"> *    ReactEventListener是注入的，因此可以支持可插入的事件源。 这是浏览器主线程中发生的唯一工作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - We normalize and de-duplicate events to account for browser quirks. This</span></span><br><span class="line"><span class="comment"> *    may be done in the worker thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    我们对事件进行规范化和去重处理 以解决浏览器怪癖问题。这可以在工作线程中完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - Forward these native events (with the associated top-level type used to</span></span><br><span class="line"><span class="comment"> *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want</span></span><br><span class="line"><span class="comment"> *    to extract any synthetic events.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - 将这些浏览器原生事件（以及用于捕获它的相关顶级类型）转发给`EventPluginHub`</span></span><br><span class="line"><span class="comment"> *    它会询问`EventPluginHub`是否保存有它所需要提取的合成事件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - The `EventPluginHub` will then process each event by annotating them with</span></span><br><span class="line"><span class="comment"> *    &quot;dispatches&quot;, a sequence of listeners and IDs that care about that event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - 然后，`EventPluginHub`将通过使用“dispatches”来处理每个事件</span></span><br><span class="line"><span class="comment"> *    一系列侦听器和IDs 关联到这些事件。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - The `EventPluginHub` then dispatches the events.</span></span><br><span class="line"><span class="comment"> *  - 最后 `EventPluginHub` 会分发/触发这些事件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Overview of React and the event system:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * +------------+    .</span></span><br><span class="line"><span class="comment"> * |    DOM     |    .</span></span><br><span class="line"><span class="comment"> * +------------+    .</span></span><br><span class="line"><span class="comment"> *       |           .</span></span><br><span class="line"><span class="comment"> *       v           .</span></span><br><span class="line"><span class="comment"> * +------------+    .</span></span><br><span class="line"><span class="comment"> * | ReactEvent |    .</span></span><br><span class="line"><span class="comment"> * |  Listener  |    .</span></span><br><span class="line"><span class="comment"> * +------------+    .                         +-----------+</span></span><br><span class="line"><span class="comment"> *       |           .               +--------+|SimpleEvent|</span></span><br><span class="line"><span class="comment"> *       |           .               |         |Plugin     |</span></span><br><span class="line"><span class="comment"> * +-----|------+    .               v         +-----------+</span></span><br><span class="line"><span class="comment"> * |     |      |    .    +--------------+                    +------------+</span></span><br><span class="line"><span class="comment"> * |     +-----------.---&gt;|EventPluginHub|                    |    Event   |</span></span><br><span class="line"><span class="comment"> * |            |    .    |              |     +-----------+  | Propagators|</span></span><br><span class="line"><span class="comment"> * | ReactEvent |    .    |              |     |TapEvent   |  |------------|</span></span><br><span class="line"><span class="comment"> * |  Emitter   |    .    |              |&lt;---+|Plugin     |  |other plugin|</span></span><br><span class="line"><span class="comment"> * |            |    .    |              |     +-----------+  |  utilities |</span></span><br><span class="line"><span class="comment"> * |     +-----------.---&gt;|              |                    +------------+</span></span><br><span class="line"><span class="comment"> * |     |      |    .    +--------------+</span></span><br><span class="line"><span class="comment"> * +-----|------+    .                ^        +-----------+</span></span><br><span class="line"><span class="comment"> *       |           .                |        |Enter/Leave|</span></span><br><span class="line"><span class="comment"> *       +           .                +-------+|Plugin     |</span></span><br><span class="line"><span class="comment"> * +-------------+   .                         +-----------+</span></span><br><span class="line"><span class="comment"> * | application |   .</span></span><br><span class="line"><span class="comment"> * |-------------|   .</span></span><br><span class="line"><span class="comment"> * |             |   .</span></span><br><span class="line"><span class="comment"> * |             |   .</span></span><br><span class="line"><span class="comment"> * +-------------+   .</span></span><br><span class="line"><span class="comment"> *                   .</span></span><br><span class="line"><span class="comment"> *    React Core     .  General Purpose Event Plugin System</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>这里暂时还有很多细节没有被理解：</p>
<ul>
<li>合成事件概念 &amp;&amp; 事件定义的数据结构</li>
<li>EventPluginHub &amp;&amp; EventPluginRegistry 联系 </li>
</ul>
<h2 id="合成事件-amp-amp-其数据结构"><a href="#合成事件-amp-amp-其数据结构" class="headerlink" title="合成事件 &amp;&amp; 其数据结构"></a>合成事件 &amp;&amp; 其数据结构</h2><p>React定义了合成事件，它在顶层API上，对不同浏览器进行了兼容处理。它里面和原生事件一样有<code>preventDefault &amp;&amp; preventDefault</code>。</p>
<p>这里仅就最简单的<code>SyntheticEvent</code>做分析，其他的鼠标、滚动、拖曳之类的合成事件都是对它的拓展、继承。</p>
<p>这个合成事件的定义主要是三个地方。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventInterface = &#123;</span><br><span class="line">  type: <span class="literal">null</span>,</span><br><span class="line">  target: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// currentTarget is set when dispatching; no use in copying it here</span></span><br><span class="line">  currentTarget: emptyFunction.thatReturnsNull,</span><br><span class="line">  eventPhase: <span class="literal">null</span>,</span><br><span class="line">  bubbles: <span class="literal">null</span>,</span><br><span class="line">  cancelable: <span class="literal">null</span>,</span><br><span class="line">  timeStamp: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.timeStamp || <span class="built_in">Date</span>.now();</span><br><span class="line">  &#125;,</span><br><span class="line">  defaultPrevented: <span class="literal">null</span>,</span><br><span class="line">  isTrusted: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SyntheticEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  dispatchConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义位置一</span></span><br><span class="line">  <span class="built_in">this</span>.dispatchConfig = dispatchConfig;</span><br><span class="line">  <span class="built_in">this</span>._targetInst = targetInst;</span><br><span class="line">  <span class="built_in">this</span>.nativeEvent = nativeEvent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Interface = <span class="built_in">this</span>.constructor.Interface;</span><br><span class="line">  <span class="comment">// 定义位置二 配合EventInterface看</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> Interface) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Interface.hasOwnProperty(propName)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> normalize = Interface[propName];</span><br><span class="line">    <span class="keyword">if</span> (normalize) &#123;</span><br><span class="line">      <span class="built_in">this</span>[propName] = normalize(nativeEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (propName === <span class="string">&#x27;target&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = nativeEventTarget;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>[propName] = nativeEvent[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义位置三</span></span><br><span class="line"><span class="built_in">Object</span>.assign(SyntheticEvent.prototype, &#123;</span><br><span class="line">  preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  persist: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  isPersistent: emptyFunction.thatReturnsFalse,</span><br><span class="line">  destructor: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>整体的属性、方法如下表。<strong>最有可能影响理解的可能是对原生event对象属性的基础上</strong>。仔细看看可以看到合成事件大部分都是在模拟原生Event对象的属性和方法。</p>
<table>
<thead>
<tr>
<th>属性、方法名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>dispatchConfig</td>
<td></td>
<td></td>
</tr>
<tr>
<td>_targetInst</td>
<td>ReactDomComponent实例或其他实例</td>
<td>ReactNode实例</td>
</tr>
<tr>
<td>nativeEvent</td>
<td>DOMEvent</td>
<td>原生event对象</td>
</tr>
<tr>
<td>type</td>
<td>string</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/type">type</a></td>
</tr>
<tr>
<td>target</td>
<td>DOMEventTarget</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/target">target</a></td>
</tr>
<tr>
<td>currentTarget</td>
<td>DOMEventTarget</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/currentTarget">currentTarget</a></td>
</tr>
<tr>
<td>eventPhase</td>
<td>number</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/eventPhase">event.eventPhase</a></td>
</tr>
<tr>
<td>bubbles</td>
<td>boolean</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/bubbles">bubbles</a></td>
</tr>
<tr>
<td>cancelable</td>
<td>boolean</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/cancelable">cancelable</a></td>
</tr>
<tr>
<td>timeStamp</td>
<td>number</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/timeStamp">timeStamp</a></td>
</tr>
<tr>
<td>defaultPrevented</td>
<td>boolean</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/defaultPrevented">defaultPrevented</a></td>
</tr>
<tr>
<td>isTrusted</td>
<td>boolean</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/isTrusted">isTrusted</a></td>
</tr>
<tr>
<td>preventDefault</td>
<td>Function</td>
<td>阻止浏览器默认行为</td>
</tr>
<tr>
<td>stopPropagation</td>
<td>Function</td>
<td>停止冒泡</td>
</tr>
<tr>
<td>persist</td>
<td>Function</td>
<td>阻止将其放入对象池 保持其引用</td>
</tr>
<tr>
<td>isPersistent</td>
<td>boolean</td>
<td>检查是否应将此事件释放回对象池中</td>
</tr>
<tr>
<td>destructor</td>
<td>Function</td>
<td>PooledClass会用到它</td>
</tr>
</tbody></table>
<p>这里dispatchConfig的大致结构如下, 关于这个数据结构<code>SimpleEventPlugin.js</code>中<code>eventTypes</code>变量有注释和代码定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  phasedRegistrationNames: &#123;</span><br><span class="line">    bubbled: <span class="string">&#x27;onClick&#x27;</span>,</span><br><span class="line">    captured: <span class="string">&#x27;onClickCapture&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  dependencies: [<span class="string">&#x27;topClick&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说，onClick注册的事件会在冒泡环节触发，如果要在捕获环节触发，那么使用onClickCapture进行注册。这里<code>phasedRegistrationNames</code>还是很容易理解。而<code>dependencies</code>则是被依赖的top事件组成的数组，在冒泡捕获触发环节所有的事件诸如提到的<code>onClick、onClickCapture</code>最后都会被转换为<code>topClick</code>这样的形式进行触发。</p>
<h2 id="EventPluginHub-amp-amp-EventPluginRegistry-联系"><a href="#EventPluginHub-amp-amp-EventPluginRegistry-联系" class="headerlink" title="EventPluginHub &amp;&amp; EventPluginRegistry 联系"></a>EventPluginHub &amp;&amp; EventPluginRegistry 联系</h2><p>这里EventPluginHub是建立在EventPluginRegistry上的，从理解上，个人认为EventPluginRegistry实际上是处理的依赖注入的事情。他将plugin名称和本体保存起来，以供EventPluginHub方便调用。</p>
<h1 id="三张图"><a href="#三张图" class="headerlink" title="三张图"></a>三张图</h1><p>想了一下，虽然自己最后分析了这么多，但是太过于重视细枝末节其实很难把握宏观上的处理方式。这源码就算读破了天，最终如果没有建立起体系其实没有什么卵用，所以这里画张图。</p>
<p>不过合成事件的各种继承，其实应该也值得很好研究一下，这里暂时不去细读这一块了。</p>
<p><img src="/images/react-event-save.png" alt="reac 事件保存"></p>
<p><img src="/images/react-event-dispatch.png" alt="react事件分发"></p>
<p><img src="/images/react-event-system.png" alt="react-event-system"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/react/" rel="tag"># react</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/05/01/react-domComponent/" rel="prev" title="react ReactDOMComponent分析">
      <i class="fa fa-chevron-left"></i> react ReactDOMComponent分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/11/05/2018-11-5-typescript-redux-starter/" rel="next" title="typescript在redux-react项目中的应用">
      typescript在redux-react项目中的应用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D"><span class="nav-number">1.</span> <span class="nav-text">写在最前</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#mountComponent%E8%B7%AF%E5%BE%84"><span class="nav-number">1.1.</span> <span class="nav-text">mountComponent路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#props%E6%9B%B4%E6%96%B0%E8%B7%AF%E5%BE%84"><span class="nav-number">1.2.</span> <span class="nav-text">props更新路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-amp-%E6%97%81%E7%99%BD"><span class="nav-number">1.3.</span> <span class="nav-text">补充 &amp; 旁白</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%A7%8B"><span class="nav-number">2.</span> <span class="nav-text">正式开始</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E4%BF%9D%E5%AD%98-amp-amp-%E7%BB%91%E5%AE%9A"><span class="nav-number">2.1.</span> <span class="nav-text">事件保存 &amp;&amp; 绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98"><span class="nav-number">2.1.1.</span> <span class="nav-text">保存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A"><span class="nav-number">2.1.2.</span> <span class="nav-text">绑定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91-amp-amp-%E5%88%86%E5%8F%91"><span class="nav-number">2.2.</span> <span class="nav-text">事件触发 &amp;&amp; 分发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ReactEventListener"><span class="nav-number">2.2.1.</span> <span class="nav-text">ReactEventListener</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatchEvent"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">dispatchEvent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#handleTopLevelImpl"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">handleTopLevelImpl</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="nav-number">2.2.2.</span> <span class="nav-text">小总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E7%BB%86%E8%8A%82"><span class="nav-number">3.</span> <span class="nav-text">源码细节</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#EventPluginHub"><span class="nav-number">3.1.</span> <span class="nav-text">EventPluginHub</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#extractEvents"><span class="nav-number">3.1.1.</span> <span class="nav-text">extractEvents</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">3.1.2.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EventPluginRegistry"><span class="nav-number">3.2.</span> <span class="nav-text">EventPluginRegistry</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-amp-%E6%80%9D%E8%80%83"><span class="nav-number">4.</span> <span class="nav-text">总结&amp;思考</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6-amp-amp-%E5%85%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">合成事件 &amp;&amp; 其数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EventPluginHub-amp-amp-EventPluginRegistry-%E8%81%94%E7%B3%BB"><span class="nav-number">4.2.</span> <span class="nav-text">EventPluginHub &amp;&amp; EventPluginRegistry 联系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E5%BC%A0%E5%9B%BE"><span class="nav-number">5.</span> <span class="nav-text">三张图</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">que01</p>
  <div class="site-description" itemprop="description">自己的学习记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">77</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">que01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"TXWIywcTsrMfVKtclog3CxDl-gzGzoHsz","app_key":"987dqIR4vvX2mQJjmAV86Qp0","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
