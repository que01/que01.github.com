<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Microsoft YaHei, Verdana, sans-serif:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.que01.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"AL4M83H31B","apiKey":"d30226bc78f2b15b834d9fc9993e3c42","indexName":"hexo","hits":{"per_page":10}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"bounceDownIn","post_body":"bounceDownIn","coll_header":"slideLeftIn","sidebar":"fadeInUp"}},"path":"search.xml"};
  </script>

  <meta name="description" content="上一篇文章主要写了下mvvm实现的底层原理，这篇文章打算自己试着做一做、研究研究一番mvvm，究竟该怎样去实现。写模板过程中加深了自己对正则、Function&#x2F;eval的了解。这篇希望同样也有收获。">
<meta property="og:type" content="article">
<meta property="og:title" content="MVVM的简单实现-脏检测">
<meta property="og:url" content="http://www.que01.top/2016/05/07/a-simple-mvvm-framwork-1/index.html">
<meta property="og:site_name" content="Que&#39;s Blog">
<meta property="og:description" content="上一篇文章主要写了下mvvm实现的底层原理，这篇文章打算自己试着做一做、研究研究一番mvvm，究竟该怎样去实现。写模板过程中加深了自己对正则、Function&#x2F;eval的了解。这篇希望同样也有收获。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-05-07T07:29:25.000Z">
<meta property="article:modified_time" content="2020-12-17T13:21:55.591Z">
<meta property="article:author" content="que01">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="双向绑定原理">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.que01.top/2016/05/07/a-simple-mvvm-framwork-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MVVM的简单实现-脏检测 | Que's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Que's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">WebFrontEnd Development</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.que01.top/2016/05/07/a-simple-mvvm-framwork-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="que01">
      <meta itemprop="description" content="自己的学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Que's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MVVM的简单实现-脏检测
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-05-07 15:29:25" itemprop="dateCreated datePublished" datetime="2016-05-07T15:29:25+08:00">2016-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-17 21:21:55" itemprop="dateModified" datetime="2020-12-17T21:21:55+08:00">2020-12-17</time>
              </span>

          
            <span id="/2016/05/07/a-simple-mvvm-framwork-1/" class="post-meta-item leancloud_visitors" data-flag-title="MVVM的简单实现-脏检测" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <div class="post-description">上一篇文章主要写了下mvvm实现的底层原理，这篇文章打算自己试着做一做、研究研究一番mvvm，究竟该怎样去实现。写模板过程中加深了自己对正则、Function/eval的了解。这篇希望同样也有收获。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>敲下这几个时候心里其实有些犹豫。但是很多事有了开始就行了。遇到的困难主要是第一步难，走过去了就会很平坦。</p>
<p>决定研究一下MVVM，前一篇文章主要讲了MVVM数据绑定的两种实现方式：观察者模式和脏检查模式。最后决定用脏检查来试试。原因上有若干:</p>
<ol>
<li>观察者模式这个在触发上可以理解而且比较直观，但是脏检查模式还是对触发机制有些模糊不清</li>
<li>脏检测据说实现起来相对容易</li>
<li>脏检测这个过程里面的细节个人非常感兴趣</li>
<li>Angular资料比较多 书籍也很多可以参考供参考，mvvm框架这种复杂东西并不适合闭门造车了</li>
</ol>
<blockquote class="blockquote-center"><p>良好的开端，成功的一半。——贺瑞斯 《书简集》</p>
</blockquote>

<h1 id="写在前面-1"><a href="#写在前面-1" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将基于《Build You Own AngularJS》展开。这里自己试试按照《Build You Own AngularJS》步骤来构建。</p>
<h2 id="从Scope开始"><a href="#从Scope开始" class="headerlink" title="从Scope开始"></a>从Scope开始</h2><p>书中的原话是：<br>Scopes are used for many different purposes:</p>
<ul>
<li>Sharing data between controllers and views</li>
<li>Sharing data between different parts of the application </li>
<li>Broadcasting and listening for events</li>
<li>Watching for changes in data</li>
</ul>
<p>这里就不翻译了，都是常见的单词。</p>
<p>当然，虽然这样，但是我认为Scope作为数据双向绑定，才是最大的兴趣点。</p>
<p>我们遵循宏观再微观的顺序，先整整这部分覆盖的内容点。</p>
<ol>
<li>digest cycle和脏检测本身, 包括:$watch,$digest,$apply.</li>
<li>Scope继承 – 这个机制使得不同等级Scope之间的数据和事件继承成为可能.</li>
<li>高效率的面向集合数据的脏检测</li>
<li>事件体系：$on, $emit, and $broadcast.</li>
</ol>
<h2 id="环境设定篇"><a href="#环境设定篇" class="headerlink" title="环境设定篇"></a>环境设定篇</h2><p>开始之前先扯一扯环境安装</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建目录并npm init,一路回车</span></span><br><span class="line">mkdir youownangularjs &amp;&amp; cd youownangularjs &amp;&amp; npm init </span><br><span class="line"><span class="comment">//安装grunt插件</span></span><br><span class="line">npm i -g grunt-cli <span class="comment">//如果有跳过</span></span><br><span class="line">npm i grunt grunt-contrib-jshit grunt-contrib-testem sinon --save-dev</span><br><span class="line">npm install -g phantomjs</span><br><span class="line"><span class="comment">//测试需要用到的库 lodash和jquery</span></span><br><span class="line">npm i jquery lodash --save</span><br></pre></td></tr></table></figure>

<p>然后是Gruntfile.js，这个是grunt任务的配置文件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        jshint: &#123;</span><br><span class="line">             all: [<span class="string">&#x27;src/**/*.js&#x27;</span>, <span class="string">&#x27;test/**/*.js&#x27;</span>],</span><br><span class="line">             options: &#123;</span><br><span class="line">             globals: &#123;</span><br><span class="line">                 _: <span class="literal">false</span>,</span><br><span class="line">                 $: <span class="literal">false</span>, </span><br><span class="line">                 jasmine: <span class="literal">false</span>,</span><br><span class="line">                 describe: <span class="literal">false</span>, </span><br><span class="line">                 it: <span class="literal">false</span>,</span><br><span class="line">                 expect: <span class="literal">false</span>, </span><br><span class="line">                 beforeEach: <span class="literal">false</span>, </span><br><span class="line">                 afterEach: <span class="literal">false</span>, </span><br><span class="line">                 sinon: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">             &#125;,</span><br><span class="line">             browser: <span class="literal">true</span>, <span class="attr">devel</span>: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">             &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        testem: &#123;</span><br><span class="line">            unit: &#123;</span><br><span class="line">                options: &#123;</span><br><span class="line">                  framework: <span class="string">&#x27;jasmine2&#x27;</span>,</span><br><span class="line">                  launch_in_dev: [<span class="string">&#x27;PhantomJS&#x27;</span>],</span><br><span class="line">                  before_tests: <span class="string">&#x27;grunt jshint&#x27;</span>,</span><br><span class="line">                  serve_files: [</span><br><span class="line">                              <span class="string">&#x27;node_modules/lodash/lodash.js&#x27;</span>,<span class="comment">//原书是index.js貌似版本更新后变化了</span></span><br><span class="line">                              <span class="string">&#x27;node_modules/jquery/dist/jquery.js&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;node_modules/sinon/pkg/sinon.js&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;src/**/*.js&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;test/**/*.js&#x27;</span></span><br><span class="line">                  ],</span><br><span class="line">                  watch_files: [</span><br><span class="line">                              <span class="string">&#x27;src/**/*.js&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;test/**/*.js&#x27;</span></span><br><span class="line">                  ] </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;);</span><br><span class="line">    grunt.loadNpmTasks(<span class="string">&#x27;grunt-contrib-jshint&#x27;</span>);</span><br><span class="line">    grunt.loadNpmTasks(<span class="string">&#x27;grunt-contrib-testem&#x27;</span>);</span><br><span class="line">    grunt.registerTask(<span class="string">&#x27;default&#x27;</span>, [<span class="string">&#x27;testem:run:unit&#x27;</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>项目结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── Gruntfile.js</span><br><span class="line">├── index.js</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   ├── hello.js</span><br><span class="line">│   └── scope.js</span><br><span class="line">└── test</span><br><span class="line">    ├── hello_spec.js</span><br><span class="line">    └── scope.spec.js</span><br></pre></td></tr></table></figure>

<h2 id="watch-amp-digest"><a href="#watch-amp-digest" class="headerlink" title="$watch&amp;$digest"></a>$watch&amp;$digest</h2><p>想了一下，如果按部就班顺书而就，那么这篇文章也就成为了一个翻译，而且顺着别人思路来也得不到什么相对深层次的思考，所以这里反其道而来，分析测试，来踹度作者思路，还是走了捷径，但是相比顺思路来还是有其思考过程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line">describe(<span class="string">&quot;Scope&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">&quot;可以用来做构造器,也可以作为一个对象使用|can be constructed and used as an object&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">var</span> scope = <span class="keyword">new</span> Scope();</span><br><span class="line">        scope.aProperty = <span class="number">1</span>;</span><br><span class="line">        expect(scope.aProperty).toBe(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    describe(<span class="string">&quot;digest&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> scope;</span><br><span class="line">        beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; scope = <span class="keyword">new</span> Scope();</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&#x27;第一次$digest时候调用监视器的监听函数|calls the listener function of a watch on first $digest&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> watchFn    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;wat&#x27;</span>; &#125;;</span><br><span class="line">            <span class="keyword">var</span> listenerFn = jasmine.createSpy();</span><br><span class="line">            scope.$watch(watchFn, listenerFn);</span><br><span class="line"></span><br><span class="line">            scope.$digest();</span><br><span class="line"></span><br><span class="line">            expect(listenerFn).toHaveBeenCalled();</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&quot;调用监视器的监听函数时候将scope作为参数传入|calls the watch function with the scope as the argument&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> watchFn = jasmine.createSpy();</span><br><span class="line">            <span class="keyword">var</span> listenerFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">            scope.$watch(watchFn, listenerFn);</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(watchFn).toHaveBeenCalledWith(scope);</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&quot;当监听的值改变时候调用监视器的监听函数|calls the listener function when the watched value changes&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; scope.someValue = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            scope.counter = <span class="number">0</span>;</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.someValue; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123; scope.counter++; &#125;</span><br><span class="line">            );</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">0</span>);</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">            scope.someValue = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        it(<span class="string">&quot;当监视值开始是undefined时候调用监视函数|calls listener when watch value is first undefined&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            scope.counter = <span class="number">0</span>;</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.someValue; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123; scope.counter++; &#125;</span><br><span class="line">            );</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        it(<span class="string">&quot;may have watchers that omit the listener function&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> watchFn = jasmine.createSpy().and.returnValue(<span class="string">&#x27;something&#x27;</span>);</span><br><span class="line">            scope.$watch(watchFn);</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(watchFn).toHaveBeenCalled();</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&quot;相同digest里面监视器循环调用|triggers chained watchers in the same digest&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//先监视nameUpper，然后再监视name(监听函数里面修改nameUpper)，最后改变name以期循环调用</span></span><br><span class="line">            scope.name = <span class="string">&#x27;Jane&#x27;</span>;</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.nameUpper; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (newValue) &#123;</span><br><span class="line">                        scope.initial = newValue.substring(<span class="number">0</span>, <span class="number">1</span>) + <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125; &#125;</span><br><span class="line">            );</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.name; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (newValue) &#123;</span><br><span class="line">                        scope.nameUpper = newValue.toUpperCase();</span><br><span class="line">                    &#125; &#125;</span><br><span class="line">            );</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.initial).toBe(<span class="string">&#x27;J.&#x27;</span>);</span><br><span class="line">            scope.name = <span class="string">&#x27;vob&#x27;</span>;</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.initial).toBe(<span class="string">&#x27;V.&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&quot;终止一个迭代10次的监视器|gives up on the watches after 10 iterations&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            scope.counterA = <span class="number">0</span>;</span><br><span class="line">            scope.counterB = <span class="number">0</span>;</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.counterA; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                    scope.counterB++;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.counterB; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                    scope.counterA++;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">            expect((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; scope.$digest(); &#125;)).toThrow();</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&quot;结束digest，当最后的监视器是干净的|ends the digest when the last watch is clean&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            scope.array = _.range(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">var</span> watchExecutions = <span class="number">0</span>;</span><br><span class="line">            _.times(<span class="number">100</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123; scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123;</span><br><span class="line">                    watchExecutions++;</span><br><span class="line">                    <span class="keyword">return</span> scope.array[i];</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123; &#125;</span><br><span class="line">            ); &#125;);</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(watchExecutions).toBe(<span class="number">200</span>);</span><br><span class="line">            scope.array[<span class="number">0</span>] = <span class="number">420</span>;</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(watchExecutions).toBe(<span class="number">301</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        it(<span class="string">&quot;does not end digest so that new watches are not run&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            scope.aValue = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">            scope.counter = <span class="number">0</span>;</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.aValue; &#125;,</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                    scope.$watch(</span><br><span class="line">                        <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.aValue; &#125;,</span><br><span class="line">                        <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                            scope.counter++;</span><br><span class="line">                        &#125; </span><br><span class="line">                    );</span><br><span class="line">                &#125; );</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&quot;基于值的对比，如果可以的话|compares based on value if enabled&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            scope.aValue = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">            scope.counter = <span class="number">0</span>;</span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.aValue; &#125;,</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                    scope.counter++;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="literal">true</span></span><br><span class="line">            );</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">            scope.aValue.push(<span class="number">4</span>);</span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        it(<span class="string">&#x27;正确的处理NaN|correctly handles NaNs&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            scope.number = <span class="number">0</span>/<span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line">            scope.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            scope.$watch(</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.number; &#125;,</span><br><span class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">                    scope.counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            scope.$digest();</span><br><span class="line">            expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>列下主要的标题:</p>
<ol>
<li>Scope 对象</li>
<li>监视对象属性：$watch和$digest</li>
<li>检查Dirty值</li>
<li>初始化监视值</li>
<li>获得Digest的通知</li>
<li>在dirty的时候保持digesting</li>
<li>终止不稳定的Digest</li>
<li>短路digest进程，如果最后一个污点被清除</li>
<li>基于值的脏检测</li>
</ol>
<p>主要的逻辑如下图：</p>
<iframe id="embed_dom" name="embed_dom" frameborder="0" style="border:1px solid #000;display:block;width:100%; height:500px;" src="https://www.processon.com/embed/573339a7e4b0c102ad1e17b5"></iframe>

<p>这是Scope部分主要包含watch和digest的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* jshint globalstrict: true */</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$$watchers = [];</span><br><span class="line">    <span class="built_in">this</span>.$$lastDirtyWatch = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatchVal</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Scope.prototype.$watch = <span class="function"><span class="keyword">function</span>(<span class="params">watchFn, listenerFn, valueEq</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> watcher = &#123;</span><br><span class="line">	        watchFn: watchFn,</span><br><span class="line">	        listenerFn: listenerFn || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">	        valueEq: !!valueEq,</span><br><span class="line">	        last: initWatchVal</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.$$watchers.push(watcher);</span><br><span class="line">    <span class="built_in">this</span>.$$lastDirtyWatch = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scope.prototype.$$digestOnce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> newValue, oldValue, dirty; </span><br><span class="line">    _.forEach(<span class="built_in">this</span>.$$watchers, <span class="function"><span class="keyword">function</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">        newValue = watcher.watchFn(self);</span><br><span class="line">        oldValue = watcher.last;</span><br><span class="line">        <span class="keyword">if</span> (!self.$$areEqual(newValue, oldValue, watcher.valueEq)) &#123;</span><br><span class="line">            self.$$lastDirtyWatch = watcher;</span><br><span class="line">            watcher.last = (watcher.valueEq ? _.cloneDeep(newValue) : newValue);</span><br><span class="line">            watcher.listenerFn(newValue,(oldValue === initWatchVal ? newValue : oldValue), self);</span><br><span class="line">            dirty = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.$$lastDirtyWatch === watcher) &#123; </span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; &#125;);</span><br><span class="line">    <span class="keyword">return</span> dirty;</span><br><span class="line">&#125;;</span><br><span class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ttl = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> dirty;</span><br><span class="line">    <span class="built_in">this</span>.$$lastDirtyWatch = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        dirty = <span class="built_in">this</span>.$$digestOnce();</span><br><span class="line">        <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;10 digest iterations reached&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (dirty);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Scope.prototype.$$areEqual = <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, valueEq</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (valueEq) &#123;</span><br><span class="line">        <span class="keyword">return</span> _.isEqual(newValue, oldValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newValue === oldValue ||</span><br><span class="line">            (<span class="keyword">typeof</span> newValue === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> oldValue === <span class="string">&#x27;number&#x27;</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">isNaN</span>(newValue) &amp;&amp; <span class="built_in">isNaN</span>(oldValue));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码不多，但是可以通过上面的测试用例。</p>
<p>这里我们来根据测试和标题整理相关知识点——不得不说，这些都是基础的东西，但是组合在一起就变得很考验开发者的功底。废话不说，开始干活。</p>
<h3 id="step1-watchFn传参"><a href="#step1-watchFn传参" class="headerlink" title="step1-watchFn传参"></a>step1-watchFn传参</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;第一次$digest时候调用监视器的监听函数|calls the listener function of a watch on first $digest&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> watchFn    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;wat&#x27;</span>; &#125;;</span><br><span class="line">    <span class="keyword">var</span> listenerFn = jasmine.createSpy();</span><br><span class="line">    scope.$watch(watchFn, listenerFn);</span><br><span class="line"></span><br><span class="line">    scope.$digest();</span><br><span class="line"></span><br><span class="line">    expect(listenerFn).toHaveBeenCalled();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>先看这个测试,这个测试意图是，当scope.$watch(watchFn, listenerFn);开始监控变化后，一旦运行了$digest，就会触发listenerFn这个回调。<br>这个测试是基于怎样的目的呢？这是确保$digest的功能设置初衷:确保遍历watchers数组，然后遍历它执行里面的监视函数。</p>
<h3 id="step2-digest初次运行"><a href="#step2-digest初次运行" class="headerlink" title="step2-$digest初次运行"></a>step2-$digest初次运行</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&quot;调用监视器的监听函数时候将scope作为参数传入|calls the watch function with the scope as the argument&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> watchFn = jasmine.createSpy();</span><br><span class="line">    <span class="keyword">var</span> listenerFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    scope.$watch(watchFn, listenerFn);</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(watchFn).toHaveBeenCalledWith(scope);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个测试其实两个测试了。<code>expect(watchFn).toHaveBeenCalledWith(scope);</code>，一个是显式的，scope被作为参数传入watchFn，二是隐式的，watchFn被<code>scope.$digest()</code>触发了。这里，在代码中的 <code>newValue = watcher.watchFn(self);</code>使得代码得以通过。</p>
<h3 id="step3-检查Dirty值"><a href="#step3-检查Dirty值" class="headerlink" title="step3-检查Dirty值"></a>step3-检查Dirty值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  it(<span class="string">&quot;当监听的值改变时候调用监视器的监听函数|calls the listener function when the watched value changes&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"></span><br><span class="line">scope.someValue = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      scope.counter = <span class="number">0</span>;</span><br><span class="line">      scope.$watch(</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; </span><br><span class="line">          	<span class="keyword">return</span> scope.someValue; </span><br><span class="line">          &#125;, </span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123; </span><br><span class="line">          	scope.counter++; </span><br><span class="line">          &#125;</span><br><span class="line">      );</span><br><span class="line">      expect(scope.counter).toBe(<span class="number">0</span>);</span><br><span class="line">      scope.$digest();</span><br><span class="line">      expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">      scope.$digest();</span><br><span class="line">      expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">      scope.someValue = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">      expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">      scope.$digest();</span><br><span class="line">      expect(scope.counter).toBe(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>监听值改变以后进行触发。这是脏检测的一个测试，如果被监视的值改变了，那么进行检测，然后调用对应的监听函数。<br>这里测试意图中有几点需要注意一下：</p>
<ol>
<li>第一次$digest时候没有改变值就触发了监听函数</li>
<li>第二次再次直接$digest没有触发</li>
<li>第三次改变scope.someValue没有执行$digest没有触发监听函数</li>
<li>第四次在someValue改变前提下执行$digest，监听函数执行了</li>
</ol>
<p>这里新旧值进行脏检测主要是通过这块代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newValue, oldValue; _.forEach(<span class="built_in">this</span>.$$watchers, <span class="function"><span class="keyword">function</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">newValue = watcher.watchFn(self); oldValue = watcher.last;</span><br><span class="line"><span class="keyword">if</span> (newValue !== oldValue) &#123;</span><br><span class="line">      watcher.last = newValue;</span><br><span class="line">      watcher.listenerFn(newValue, oldValue, self);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="step4-初始化监视值"><a href="#step4-初始化监视值" class="headerlink" title="step4-初始化监视值"></a>step4-初始化监视值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&quot;当监视值开始是undefined时候调用监视函数|calls listener when watch value is first undefined&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    scope.counter = <span class="number">0</span>;</span><br><span class="line">    scope.$watch(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.someValue; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123; scope.counter++; &#125;</span><br><span class="line">    );</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当执行$watch时候scope.someValue是undefined，也就是说，这段测试代码期待即使要监视的属性是undefined也要可以顺利通过。这是一个fixbug性质的测试。<br>目标是为了测试初始化监视值。<br>这里有一些地方值得关注:</p>
<ol>
<li>last即使使得undefined合法也无法使得程序正常运行(undefined===undefined = true,当已有这个监视器会重复)</li>
<li>而我们需要一个不会重复的值.javascript中函数是引用值，除了自身不会和谁相等。可以利用到这里。此时它同监视器函数可能返回的任何值都不会相同。</li>
</ol>
<h3 id="step5-获得Digest的通知"><a href="#step5-获得Digest的通知" class="headerlink" title="step5-获得Digest的通知"></a>step5-获得Digest的通知</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&quot;may have watchers that omit the listener function&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> watchFn = jasmine.createSpy().and.returnValue(<span class="string">&#x27;something&#x27;</span>);</span><br><span class="line">       scope.$watch(watchFn);</span><br><span class="line">       scope.$digest();</span><br><span class="line">       expect(watchFn).toHaveBeenCalled();</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>这里焦点是：</p>
<ol>
<li>这里的$watch仅仅传了一个参数，监听函数listenerFn是空的，这样当遍历过程中执行对应的监听函数必然报错，因为这个listenerFn不存在。所以代码里面有一句 <code>listenerFn: listenerFn || function() &#123; &#125;</code>，这是容错处理。</li>
<li>toHaveBeenCalled是确认是否调用，这里测试用来确保digest时候获取通知。</li>
</ol>
<h3 id="step6-在dirty的时候保持digesting"><a href="#step6-在dirty的时候保持digesting" class="headerlink" title="step6-在dirty的时候保持digesting"></a>step6-在dirty的时候保持digesting</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&quot;相同digest里面监视器链式调用|triggers chained watchers in the same digest&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//先监视nameUpper，然后再监视name(监听函数里面修改nameUpper)，最后改变name以期循环调用</span></span><br><span class="line">    scope.name = <span class="string">&#x27;Jane&#x27;</span>;</span><br><span class="line">    scope.$watch(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.nameUpper; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue) &#123;</span><br><span class="line">                scope.initial = newValue.substring(<span class="number">0</span>, <span class="number">1</span>) + <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125; &#125;</span><br><span class="line">    );</span><br><span class="line">    scope.$watch(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.name; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue) &#123;</span><br><span class="line">                scope.nameUpper = newValue.toUpperCase();</span><br><span class="line">            &#125; &#125;</span><br><span class="line">    );</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.initial).toBe(<span class="string">&#x27;J.&#x27;</span>);</span><br><span class="line">    scope.name = <span class="string">&#x27;vob&#x27;</span>;</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.initial).toBe(<span class="string">&#x27;V.&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里测试主要逻辑是先监视nameUpper，再监视name,name的监听函数里面修改nameUpper以便改了name之后能把变化蔓延到nameUpper，这样可以测试是否可以做到链式调用。</p>
<h3 id="step7-终止不稳定的Digest"><a href="#step7-终止不稳定的Digest" class="headerlink" title="step7-终止不稳定的Digest"></a>step7-终止不稳定的Digest</h3><p>链式调用存在一个问题是两个监视器对应的监听函数里面互相修改彼此的值，这样会无限循环处理脏数据，造成死循环，所以要防止这种情况,对应的代码是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ttl = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> dirty;</span><br><span class="line">    <span class="built_in">this</span>.$$lastDirtyWatch = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        dirty = <span class="built_in">this</span>.$$digestOnce();</span><br><span class="line">        <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;10 digest iterations reached&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (dirty);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里设置了ttl值，值为10。当ttl==10，此时会抛出错误。这样当脏检测机制遇到数据全部干净或者10次迭代循环后会结束digest过程。</p>
<h3 id="step8-短路digest进程"><a href="#step8-短路digest进程" class="headerlink" title="step8-短路digest进程"></a>step8-短路digest进程</h3><p>脏检测最大的问题是优化问题。按照原理来说，脏检测每次执行检测都需要遍历所有的监视属性，那么随着监视属性的数量不断增多，那么会导致脏检测过程变慢这个缺陷无限放大，如果达到一个理论的量，那么会存在内存溢出和应用卡顿到没法用的问题和风险，所以这里有必要进行下一步的优化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&quot;结束digest，当最后的监视器是干净的|ends the digest when the last watch is clean&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    scope.array = _.range(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">var</span> watchExecutions = <span class="number">0</span>;</span><br><span class="line">    _.times(<span class="number">100</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123; </span><br><span class="line">     scope.$watch(</span><br><span class="line">         <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123;</span><br><span class="line">             watchExecutions++;</span><br><span class="line">             <span class="keyword">return</span> scope.array[i];</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123; &#125;</span><br><span class="line">     ); </span><br><span class="line">    &#125;);</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(watchExecutions).toBe(<span class="number">200</span>);</span><br><span class="line">    scope.array[<span class="number">0</span>] = <span class="number">420</span>;</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(watchExecutions).toBe(<span class="number">301</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段测试的意图应该比较明显，_.range(100)创建一个包含100个从0递增到99的数字的数组，_.times则相当于Array的each方法，迭代器里面传入了index索引。<br>这个测试里面监视了从0到99。预期第一次执行$digest(),watchExecutions会等于200，也就是说watchFn被执行了200次。第二次在修改了其中一个值以后，再运行$digest()，会多运行101次watchFn。</p>
<p>这里有些地方需要关注，那就是200和101这两个数。<br>我们这里来算算这个数：</p>
<ol>
<li>首先$.watch操作将数据压入到watcher数组，完毕之后数组里面有100个元素</li>
<li>$digest运行时候会进行脏检测获取newValue，这里会调用1次watchFn，加起来有100次</li>
<li>do…while这断，因为原来没有数据，此时数据是脏的，导致运行了2次$$digestOnce，这样200就得到了</li>
<li>改变值以后再次执行$digest()，仍然会如同上一次，先do一次，然后判断是否脏数据，然后再运行一次do逻辑。</li>
</ol>
<p>优化的主要是第4步，这里整理了一下watch和digest逻辑。首先，digest是基于do…while执行，也就是说当dirty==true时候这个digest不会停止。默认想法下，这个digest是一轮一轮的来对脏数据进行处理，但是经过优化之后，可以跳过一些环节，因为脏数据在数组顶部一些位置，这样处理完了可以直接跳过后面的。</p>
<p>主要的标记在这里:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.$$lastDirtyWatch = watcher;</span><br><span class="line">watcher.last = (watcher.valueEq ? _.cloneDeep(newValue) : newValue);</span><br><span class="line">watcher.listenerFn(newValue,</span><br><span class="line">    (oldValue === initWatchVal ? newValue : oldValue),</span><br><span class="line">    self);</span><br><span class="line">dirty = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>具体来说，这个流程是这样的 ，当第一次进行watch时候，值不存在，所以digest过程do一次之后，触发dirty==true，又跑了一次do逻辑——跑了一次全部，因为$$lastDirtyWatch指向最后一个，当再次改变一个值以后，跑一次do逻辑，将$$lastDirtyWatch作为游标指向最后一个污点属性(此时$$lastDirtyWatch指向第一个)，然后进入触发dirty==true环节，此时因为$$lastDirtyWatch==watcher(第一个监视属性)为真，所以短路跳出了。这样就不需要再跑一次全部。</p>
<h3 id="step9-基于值的脏检测-gt-比较全部基于值"><a href="#step9-基于值的脏检测-gt-比较全部基于值" class="headerlink" title="step9-基于值的脏检测-&gt;比较全部基于值"></a>step9-基于值的脏检测-&gt;比较全部基于值</h3><p>脏检测对比过程中需要确定值类型，当对比的值是一个引用类型的话，即使改变了值，但是由于是一个引用，那么最终还是会相等，因为指向没有任何改变。所以在脏检测过程中需要对引用类型进行一次深拷贝再比较，也就是说，即使是引用值，也必须转换为基于值的比较。</p>
<p>测试用例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&quot;基于值的对比，如果可以的话|compares based on value if enabled&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    scope.aValue = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    scope.counter = <span class="number">0</span>;</span><br><span class="line">    scope.$watch(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.aValue; &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">            scope.counter++;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">    scope.aValue.push(<span class="number">4</span>);</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.counter).toBe(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里scope.counter==1而不是等于2，是由于$$lastDirtyWatch指向了第一个。其他地方没有什么值得注意的地方。</p>
<h3 id="step10-NaNs兼容"><a href="#step10-NaNs兼容" class="headerlink" title="step10-NaNs兼容"></a>step10-NaNs兼容</h3><p>为什么要有这个检测呢？一句代码的事情: <code>(NaN===NaN) === false</code><br>虽然奇怪但是确实如此，如果不对此做特殊处理，那么NaN在脏检测函数中将始终是脏数据。不过，lodash的isEqual方法已经对此做了兼容。所以我们不需要改什么代码了。<br>这里是测试:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;正确的处理NaN|correctly handles NaNs&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    scope.number = <span class="number">0</span>/<span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line">    scope.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    scope.$watch(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; </span><br><span class="line">        	<span class="keyword">return</span> scope.number; </span><br><span class="line">    	&#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">            scope.counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.counter).toBe(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这没什么奇怪的，但是如果没有isEqual大法加持，正常情况下$digest每执行一次，都会执行一次linstenFn的。。。也就是说scope.counter会被+1.</p>
<h2 id="eval、-apply和-evalAsync"><a href="#eval、-apply和-evalAsync" class="headerlink" title="$eval、$apply和$evalAsync"></a>$eval、$apply和$evalAsync</h2><h3 id="eval"><a href="#eval" class="headerlink" title="$eval"></a>$eval</h3><p>$eval的作用是在scope中执行给出的表达式。<br>$eval很容易实现，代码主要是这样，测试代码就不管了,因为简单的实在不想贴测试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$eval = <span class="function"><span class="keyword">function</span>(<span class="params">expr, locals</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">return</span> expr(<span class="built_in">this</span>, locals);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="apply"><a href="#apply" class="headerlink" title="$apply"></a>$apply</h3><p>$apply作用是将外部js代码引入到scope的digest环节来。这个方法可能是非常非常广为人知的一个方法。尤其是用jquery处理数据更新数据，ajax获取数据更新view什么的。<br>但是$.apply真的没有比$.eval复杂到哪儿去。他实际上调用了$.eval，然后手动触发了digest,代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$apply = <span class="function"><span class="keyword">function</span>(<span class="params">expr</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.$eval(expr); </span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.$digest(); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>try/catch用的比较多，但是try/finally估计很少见了.finally在try和catch代码执行完毕后执行，不管这两个环节结果如何。</p>
<h3 id="evalAsync"><a href="#evalAsync" class="headerlink" title="$evalAsync"></a>$evalAsync</h3><p>$evalAsync作用是代码延迟执行。setTimeout(function(){},0)是代码延迟执行其中一个办法。但是setTimeout的问题是一旦你使用了它，那么就等于完全放弃了对代码执行时机的控制——浏览器可能去渲染UI，可能去响应事件，直到很久以后才会执行指定的代码片段。$evalAsync更优于setTimeout，就是因为它在这个时机上控制得更好。</p>
<p>这里看测试代码，可以更加清晰了解设计意图：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&quot;executes $evalAsync&#x27;ed function later in the same cycle&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; scope.aValue = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">		scope.asyncEvaluated = <span class="literal">false</span>;</span><br><span class="line">		scope.asyncEvaluatedImmediately = <span class="literal">false</span>;</span><br><span class="line">		scope.$watch(</span><br><span class="line">			<span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; <span class="keyword">return</span> scope.aValue; &#125;, </span><br><span class="line">			<span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">				scope.$evalAsync(<span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123; </span><br><span class="line">				scope.asyncEvaluated = <span class="literal">true</span>;</span><br><span class="line">			&#125;);</span><br><span class="line">	        scope.asyncEvaluatedImmediately = scope.asyncEvaluated;</span><br><span class="line">	    &#125;);</span><br><span class="line">		scope.$digest(); </span><br><span class="line">		expect(scope.asyncEvaluated).toBe(<span class="literal">true</span>); </span><br><span class="line">		expect(scope.asyncEvaluatedImmediately).toBe(<span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>很显然，这里$evalAsync内部的函数在 <code>scope.asyncEvaluatedImmediately = scope.asyncEvaluated;</code>之前完成了。<br>实现这点不算难，找个地方保存这个函数，然后在digest过程中的do里面先执行一次就可以了。<br>修改后代码这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$$watchers = [];</span><br><span class="line">    <span class="built_in">this</span>.$$lastDirtyWatch = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.$$asyncQueue = [];<span class="comment">//add</span></span><br><span class="line">&#125;</span><br><span class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ttl = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> dirty;</span><br><span class="line">    <span class="built_in">this</span>.$$lastDirtyWatch = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">		&lt;!-- 添加start --&gt;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.$$asyncQueue.length) &#123;</span><br><span class="line">            <span class="keyword">var</span> asyncTask = <span class="built_in">this</span>.$$asyncQueue.shift();</span><br><span class="line">            asyncTask.scope.$eval(asyncTask.expression);</span><br><span class="line">        &#125;</span><br><span class="line">		&lt;!-- 添加end --&gt;</span><br><span class="line">        dirty = <span class="built_in">this</span>.$$digestOnce();</span><br><span class="line">        <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;10 digest iterations reached&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (dirty);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>继续看下一个测试:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&quot;executes $evalAsync&#x27;ed functions even when not dirty&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    scope.aValue = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    scope.asyncEvaluatedTimes = <span class="number">0</span>;</span><br><span class="line">    scope.$watch(<span class="function"><span class="keyword">function</span> (<span class="params">scope</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (scope.asyncEvaluatedTimes &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                scope.$evalAsync(<span class="function"><span class="keyword">function</span> (<span class="params">scope</span>) </span>&#123;</span><br><span class="line">                    scope.asyncEvaluatedTimes++;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> scope.aValue;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    scope.$digest();</span><br><span class="line">    expect(scope.asyncEvaluatedTimes).toBe(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>报错了。。。因为第二次运行时候数据不是脏的，因此没有进入do逻辑。。。改改:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$digest &#x3D; function() &#123; </span><br><span class="line">	...</span><br><span class="line">do &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; while (dirty || this.$$asyncQueue.length); &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样一来测试是通过了，但是问题是如果如果watcher里面一直$evalAsync导致不停执行do逻辑造成死循环怎么办？所以继续改，先上测试用例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&quot;eventually halts $evalAsyncs added by watches&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    scope.aValue = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    scope.$watch(<span class="function"><span class="keyword">function</span> (<span class="params">scope</span>) </span>&#123;</span><br><span class="line">            scope.$evalAsync(<span class="function"><span class="keyword">function</span> (<span class="params">scope</span>) </span>&#123;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> scope.aValue;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue, scope</span>) </span>&#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    expect(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        scope.$digest();</span><br><span class="line">    &#125;).toThrow();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>代码改造:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$digest &#x3D; function () &#123;</span><br><span class="line">    var ttl &#x3D; 10;</span><br><span class="line">    var dirty;</span><br><span class="line">    this.$$lastDirtyWatch &#x3D; null;</span><br><span class="line">    do &#123;</span><br><span class="line"></span><br><span class="line">        while (this.$$asyncQueue.length) &#123;</span><br><span class="line">            var asyncTask &#x3D; this.$$asyncQueue.shift();</span><br><span class="line">            asyncTask.scope.$eval(asyncTask.expression);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dirty &#x3D; this.$$digestOnce();</span><br><span class="line">        if ((dirty || this.$$asyncQueue.length) &amp;&amp; !(ttl--)) &#123; &#x2F;&#x2F;修改的代码</span><br><span class="line">            throw &quot;10 digest iterations reached&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (dirty || this.$$asyncQueue.length);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样，当 <code>(dirty || this.$$asyncQueue.length)</code>反复为true时候，就会tll累减，最后抛出错误终止。</p>
<h2 id="收个尾"><a href="#收个尾" class="headerlink" title="收个尾"></a>收个尾</h2><p>实际上写完$eval、$apply和$evalAsync这块时候突然发觉有些跑题了。文章初衷还是学习一下脏检测是如何运行的。所以就暂且打住了。不过考虑到往后还会继续深入下去，暂时就不做删除了。</p>
<p>这里再次回顾整理一下脏检测：<br>回顾一下文章标题，总结下脏检测实现思路。</p>
<ol>
<li>Scope 对象</li>
<li>监视对象属性：$watch和$digest</li>
<li>检查Dirty值</li>
<li>初始化监视值</li>
<li>获得Digest的通知</li>
<li>在dirty的时候保持digesting</li>
<li>终止不稳定的Digest</li>
<li>短路digest进程，如果最后一个污点被清除</li>
<li>基于值的脏检测</li>
</ol>
<p>个人总结：<br>基本上脏检测呢，说得有些术语化，其实整个过程真的和高深扯不上太多关系。主要的思路是这样的：</p>
<ol>
<li>实现Scope函数，在原型上挂载$watch和$digest和方法</li>
<li>digest过程返回Dirty值用来判断是否继续执行digest过程</li>
<li>$watch负责添加要监视的属性，而digest负责消灭污点</li>
<li>至于更多的初始值啊，基于值的比较啊，NaN啊，死循环啊，digest优化之类，都不过是细节补充</li>
<li>$apply实现真的说明了很多</li>
</ol>
<p>最后一句话总结就是digest是手动触发——真的没有太多深奥的东西。<br>当然，这里手动触发有不少值得注意的场景：</p>
<ol>
<li>Scope内部数组的splice，slice，push，pop等堆栈操作</li>
<li>View2Data环节过程中各种事件触发</li>
<li>$apply等等</li>
</ol>
<p>到这里这一篇就此暂结，本文主要整理了脏检测过程中细节的实现和测试。最后发现除了深入了实现机制，确实也没有什么特别耀眼的东西。但是整个过程，还是深入了解了脏检测实现过程中需要考虑的细节，收获还是不少。</p>
<p>Thanks For 《Build You Own AngularJS》</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/javascript/" rel="tag"># javascript</a>
              <a href="/tags/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/" rel="tag"># 双向绑定原理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/05/03/two-way-bind/" rel="prev" title="MVVM基础之双向绑定原理">
      <i class="fa fa-chevron-left"></i> MVVM基础之双向绑定原理
    </a></div>
      <div class="post-nav-item">
    <a href="/2016/06/08/react-starter-kit-1/" rel="next" title="React全家桶:react-starter-kit之一">
      React全家桶:react-starter-kit之一 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="nav-number">1.</span> <span class="nav-text">写在前面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2-1"><span class="nav-number">2.</span> <span class="nav-text">写在前面</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8EScope%E5%BC%80%E5%A7%8B"><span class="nav-number">2.1.</span> <span class="nav-text">从Scope开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E8%AE%BE%E5%AE%9A%E7%AF%87"><span class="nav-number">2.2.</span> <span class="nav-text">环境设定篇</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#watch-amp-digest"><span class="nav-number">2.3.</span> <span class="nav-text">$watch&amp;$digest</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#step1-watchFn%E4%BC%A0%E5%8F%82"><span class="nav-number">2.3.1.</span> <span class="nav-text">step1-watchFn传参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step2-digest%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C"><span class="nav-number">2.3.2.</span> <span class="nav-text">step2-$digest初次运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step3-%E6%A3%80%E6%9F%A5Dirty%E5%80%BC"><span class="nav-number">2.3.3.</span> <span class="nav-text">step3-检查Dirty值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step4-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9B%91%E8%A7%86%E5%80%BC"><span class="nav-number">2.3.4.</span> <span class="nav-text">step4-初始化监视值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step5-%E8%8E%B7%E5%BE%97Digest%E7%9A%84%E9%80%9A%E7%9F%A5"><span class="nav-number">2.3.5.</span> <span class="nav-text">step5-获得Digest的通知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step6-%E5%9C%A8dirty%E7%9A%84%E6%97%B6%E5%80%99%E4%BF%9D%E6%8C%81digesting"><span class="nav-number">2.3.6.</span> <span class="nav-text">step6-在dirty的时候保持digesting</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step7-%E7%BB%88%E6%AD%A2%E4%B8%8D%E7%A8%B3%E5%AE%9A%E7%9A%84Digest"><span class="nav-number">2.3.7.</span> <span class="nav-text">step7-终止不稳定的Digest</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step8-%E7%9F%AD%E8%B7%AFdigest%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.3.8.</span> <span class="nav-text">step8-短路digest进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step9-%E5%9F%BA%E4%BA%8E%E5%80%BC%E7%9A%84%E8%84%8F%E6%A3%80%E6%B5%8B-gt-%E6%AF%94%E8%BE%83%E5%85%A8%E9%83%A8%E5%9F%BA%E4%BA%8E%E5%80%BC"><span class="nav-number">2.3.9.</span> <span class="nav-text">step9-基于值的脏检测-&gt;比较全部基于值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step10-NaNs%E5%85%BC%E5%AE%B9"><span class="nav-number">2.3.10.</span> <span class="nav-text">step10-NaNs兼容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eval%E3%80%81-apply%E5%92%8C-evalAsync"><span class="nav-number">2.4.</span> <span class="nav-text">$eval、$apply和$evalAsync</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#eval"><span class="nav-number">2.4.1.</span> <span class="nav-text">$eval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apply"><span class="nav-number">2.4.2.</span> <span class="nav-text">$apply</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#evalAsync"><span class="nav-number">2.4.3.</span> <span class="nav-text">$evalAsync</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B6%E4%B8%AA%E5%B0%BE"><span class="nav-number">2.5.</span> <span class="nav-text">收个尾</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">que01</p>
  <div class="site-description" itemprop="description">自己的学习记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">77</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">que01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"TXWIywcTsrMfVKtclog3CxDl-gzGzoHsz","app_key":"987dqIR4vvX2mQJjmAV86Qp0","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
